"use strict";
(self.webpackChunkhackerrank_lib = self.webpackChunkhackerrank_lib || []).push([
    ["defaultVendors-node_modules_vscode_vscode_src_vs_base_common_diff_diffChange_js-node_modules_-0535b1"], {
        "0+aF": (e, t, n) => {
            n.d(t, {
                J: () => i
            });
            class i {
                constructor(e, t, n, i) {
                    this.originalStart = e, this.originalLength = t, this.modifiedStart = n, this.modifiedLength = i
                }
                getOriginalEnd() {
                    return this.originalStart + this.originalLength
                }
                getModifiedEnd() {
                    return this.modifiedStart + this.modifiedLength
                }
            }
        },
        "U+Fb": (e, t, n) => {
            n.d(t, {
                S: () => r
            });
            class i {
                static {
                    this.Undefined = new i(void 0)
                }
                constructor(e) {
                    this.element = e, this.next = i.Undefined, this.prev = i.Undefined
                }
            }
            class r {
                constructor() {
                    this._first = i.Undefined, this._last = i.Undefined, this._size = 0
                }
                get size() {
                    return this._size
                }
                isEmpty() {
                    return this._first === i.Undefined
                }
                clear() {
                    let e = this._first;
                    for (; e !== i.Undefined;) {
                        const t = e.next;
                        e.prev = i.Undefined, e.next = i.Undefined, e = t
                    }
                    this._first = i.Undefined, this._last = i.Undefined, this._size = 0
                }
                unshift(e) {
                    return this._insert(e, !1)
                }
                push(e) {
                    return this._insert(e, !0)
                }
                _insert(e, t) {
                    const n = new i(e);
                    if (this._first === i.Undefined) this._first = n, this._last = n;
                    else if (t) {
                        const e = this._last;
                        this._last = n, n.prev = e, e.next = n
                    } else {
                        const e = this._first;
                        this._first = n, n.next = e, e.prev = n
                    }
                    this._size += 1;
                    let r = !1;
                    return () => {
                        r || (r = !0, this._remove(n))
                    }
                }
                shift() {
                    if (this._first !== i.Undefined) {
                        const e = this._first.element;
                        return this._remove(this._first), e
                    }
                }
                pop() {
                    if (this._last !== i.Undefined) {
                        const e = this._last.element;
                        return this._remove(this._last), e
                    }
                }
                _remove(e) {
                    if (e.prev !== i.Undefined && e.next !== i.Undefined) {
                        const t = e.prev;
                        t.next = e.next, e.next.prev = t
                    } else e.prev === i.Undefined && e.next === i.Undefined ? (this._first = i.Undefined, this._last = i.Undefined) : e.next === i.Undefined ? (this._last = this._last.prev, this._last.next = i.Undefined) : e.prev === i.Undefined && (this._first = this._first.next, this._first.prev = i.Undefined);
                    this._size -= 1
                }*[Symbol.iterator]() {
                    let e = this._first;
                    for (; e !== i.Undefined;) yield e.element, e = e.next
                }
            }
        },
        MM2S: (e, t, n) => {
            var i;

            function r(e) {
                return e < 0 ? 0 : e > i.MAX_UINT_8 ? i.MAX_UINT_8 : 0 | e
            }

            function s(e) {
                return e < 0 ? 0 : e > i.MAX_UINT_32 ? i.MAX_UINT_32 : 0 | e
            }
            n.d(t, {
                    AE: () => s,
                    Ki: () => r,
                    gT: () => i
                }),
                function(e) {
                    e[e.MAX_SAFE_SMALL_INTEGER = 1073741824] = "MAX_SAFE_SMALL_INTEGER", e[e.MIN_SAFE_SMALL_INTEGER = -1073741824] = "MIN_SAFE_SMALL_INTEGER", e[e.MAX_UINT_8 = 255] = "MAX_UINT_8", e[e.MAX_UINT_16 = 65535] = "MAX_UINT_16", e[e.MAX_UINT_32 = 4294967295] = "MAX_UINT_32", e[e.UNICODE_SUPPLEMENTARY_PLANE_BEGIN = 65536] = "UNICODE_SUPPLEMENTARY_PLANE_BEGIN"
                }(i || (i = {}))
        },
        MAz2: (e, t, n) => {
            n.d(t, {
                i: () => l,
                z: () => a
            });
            var i = n("PUdK"),
                r = n("j4W2"),
                s = n("Aw1u"),
                o = n("W8Fm");
            class a {
                static fromRange(e) {
                    return new a(e.startLineNumber, e.endLineNumber)
                }
                static fromRangeInclusive(e) {
                    return new a(e.startLineNumber, e.endLineNumber + 1)
                }
                static subtract(e, t) {
                    return t ? e.startLineNumber < t.startLineNumber && t.endLineNumberExclusive < e.endLineNumberExclusive ? [new a(e.startLineNumber, t.startLineNumber), new a(t.endLineNumberExclusive, e.endLineNumberExclusive)] : t.startLineNumber <= e.startLineNumber && e.endLineNumberExclusive <= t.endLineNumberExclusive ? [] : t.endLineNumberExclusive < e.endLineNumberExclusive ? [new a(Math.max(t.endLineNumberExclusive, e.startLineNumber), e.endLineNumberExclusive)] : [new a(e.startLineNumber, Math.min(t.startLineNumber, e.endLineNumberExclusive))] : [e]
                }
                static joinMany(e) {
                    if (0 === e.length) return [];
                    let t = new l(e[0].slice());
                    for (let n = 1; n < e.length; n++) t = t.getUnion(new l(e[n].slice()));
                    return t.ranges
                }
                static join(e) {
                    if (0 === e.length) throw new i.he("lineRanges cannot be empty");
                    let t = e[0].startLineNumber,
                        n = e[0].endLineNumberExclusive;
                    for (let i = 1; i < e.length; i++) t = Math.min(t, e[i].startLineNumber), n = Math.max(n, e[i].endLineNumberExclusive);
                    return new a(t, n)
                }
                static ofLength(e, t) {
                    return new a(e, e + t)
                }
                static deserialize(e) {
                    return new a(e[0], e[1])
                }
                constructor(e, t) {
                    if (e > t) throw new i.he(`startLineNumber ${e} cannot be after endLineNumberExclusive ${t}`);
                    this.startLineNumber = e, this.endLineNumberExclusive = t
                }
                contains(e) {
                    return this.startLineNumber <= e && e < this.endLineNumberExclusive
                }
                get isEmpty() {
                    return this.startLineNumber === this.endLineNumberExclusive
                }
                delta(e) {
                    return new a(this.startLineNumber + e, this.endLineNumberExclusive + e)
                }
                deltaLength(e) {
                    return new a(this.startLineNumber, this.endLineNumberExclusive + e)
                }
                get length() {
                    return this.endLineNumberExclusive - this.startLineNumber
                }
                join(e) {
                    return new a(Math.min(this.startLineNumber, e.startLineNumber), Math.max(this.endLineNumberExclusive, e.endLineNumberExclusive))
                }
                toString() {
                    return `[${this.startLineNumber},${this.endLineNumberExclusive})`
                }
                intersect(e) {
                    const t = Math.max(this.startLineNumber, e.startLineNumber),
                        n = Math.min(this.endLineNumberExclusive, e.endLineNumberExclusive);
                    if (t <= n) return new a(t, n)
                }
                intersectsStrict(e) {
                    return this.startLineNumber < e.endLineNumberExclusive && e.startLineNumber < this.endLineNumberExclusive
                }
                overlapOrTouch(e) {
                    return this.startLineNumber <= e.endLineNumberExclusive && e.startLineNumber <= this.endLineNumberExclusive
                }
                equals(e) {
                    return this.startLineNumber === e.startLineNumber && this.endLineNumberExclusive === e.endLineNumberExclusive
                }
                toInclusiveRange() {
                    return this.isEmpty ? null : new s.e(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER)
                }
                toExclusiveRange() {
                    return new s.e(this.startLineNumber, 1, this.endLineNumberExclusive, 1)
                }
                mapToLineArray(e) {
                    const t = [];
                    for (let n = this.startLineNumber; n < this.endLineNumberExclusive; n++) t.push(e(n));
                    return t
                }
                forEach(e) {
                    for (let t = this.startLineNumber; t < this.endLineNumberExclusive; t++) e(t)
                }
                serialize() {
                    return [this.startLineNumber, this.endLineNumberExclusive]
                }
                includes(e) {
                    return this.startLineNumber <= e && e < this.endLineNumberExclusive
                }
                toOffsetRange() {
                    return new r.q(this.startLineNumber - 1, this.endLineNumberExclusive - 1)
                }
            }
            class l {
                constructor(e = []) {
                    this._normalizedRanges = e
                }
                get ranges() {
                    return this._normalizedRanges
                }
                addRange(e) {
                    if (0 === e.length) return;
                    const t = (0, o.J_)(this._normalizedRanges, (t => t.endLineNumberExclusive >= e.startLineNumber)),
                        n = (0, o.Jw)(this._normalizedRanges, (t => t.startLineNumber <= e.endLineNumberExclusive)) + 1;
                    if (t === n) this._normalizedRanges.splice(t, 0, e);
                    else if (t === n - 1) {
                        const n = this._normalizedRanges[t];
                        this._normalizedRanges[t] = n.join(e)
                    } else {
                        const i = this._normalizedRanges[t].join(this._normalizedRanges[n - 1]).join(e);
                        this._normalizedRanges.splice(t, n - t, i)
                    }
                }
                contains(e) {
                    const t = (0, o.ti)(this._normalizedRanges, (t => t.startLineNumber <= e));
                    return !!t && t.endLineNumberExclusive > e
                }
                intersects(e) {
                    const t = (0, o.ti)(this._normalizedRanges, (t => t.startLineNumber < e.endLineNumberExclusive));
                    return !!t && t.endLineNumberExclusive > e.startLineNumber
                }
                getUnion(e) {
                    if (0 === this._normalizedRanges.length) return e;
                    if (0 === e._normalizedRanges.length) return this;
                    const t = [];
                    let n = 0,
                        i = 0,
                        r = null;
                    for (; n < this._normalizedRanges.length || i < e._normalizedRanges.length;) {
                        let s = null;
                        if (n < this._normalizedRanges.length && i < e._normalizedRanges.length) {
                            const t = this._normalizedRanges[n],
                                r = e._normalizedRanges[i];
                            t.startLineNumber < r.startLineNumber ? (s = t, n++) : (s = r, i++)
                        } else n < this._normalizedRanges.length ? (s = this._normalizedRanges[n], n++) : (s = e._normalizedRanges[i], i++);
                        null === r ? r = s : r.endLineNumberExclusive >= s.startLineNumber ? r = new a(r.startLineNumber, Math.max(r.endLineNumberExclusive, s.endLineNumberExclusive)) : (t.push(r), r = s)
                    }
                    return null !== r && t.push(r), new l(t)
                }
                subtractFrom(e) {
                    const t = (0, o.J_)(this._normalizedRanges, (t => t.endLineNumberExclusive >= e.startLineNumber)),
                        n = (0, o.Jw)(this._normalizedRanges, (t => t.startLineNumber <= e.endLineNumberExclusive)) + 1;
                    if (t === n) return new l([e]);
                    const i = [];
                    let r = e.startLineNumber;
                    for (let e = t; e < n; e++) {
                        const t = this._normalizedRanges[e];
                        t.startLineNumber > r && i.push(new a(r, t.startLineNumber)), r = t.endLineNumberExclusive
                    }
                    return r < e.endLineNumberExclusive && i.push(new a(r, e.endLineNumberExclusive)), new l(i)
                }
                toString() {
                    return this._normalizedRanges.map((e => e.toString())).join(", ")
                }
                getIntersection(e) {
                    const t = [];
                    let n = 0,
                        i = 0;
                    for (; n < this._normalizedRanges.length && i < e._normalizedRanges.length;) {
                        const r = this._normalizedRanges[n],
                            s = e._normalizedRanges[i],
                            o = r.intersect(s);
                        o && !o.isEmpty && t.push(o), r.endLineNumberExclusive < s.endLineNumberExclusive ? n++ : i++
                    }
                    return new l(t)
                }
                getWithDelta(e) {
                    return new l(this._normalizedRanges.map((t => t.delta(e))))
                }
            }
        },
        eNI2: (e, t, n) => {
            n.d(t, {
                KU: () => o,
                NT: () => h,
                i8: () => a,
                n0: () => u,
                zl: () => l
            });
            var i = n("iDmX"),
                r = n("PUdK"),
                s = n("j4W2");
            class o {
                static trivial(e, t) {
                    return new o([new a(s.q.ofLength(e.length), s.q.ofLength(t.length))], !1)
                }
                static trivialTimedOut(e, t) {
                    return new o([new a(s.q.ofLength(e.length), s.q.ofLength(t.length))], !0)
                }
                constructor(e, t) {
                    this.diffs = e, this.hitTimeout = t
                }
            }
            class a {
                static invert(e, t) {
                    const n = [];
                    return (0, i.zy)(e, ((e, i) => {
                        n.push(a.fromOffsetPairs(e ? e.getEndExclusives() : l.zero, i ? i.getStarts() : new l(t, (e ? e.seq2Range.endExclusive - e.seq1Range.endExclusive : 0) + t)))
                    })), n
                }
                static fromOffsetPairs(e, t) {
                    return new a(new s.q(e.offset1, t.offset1), new s.q(e.offset2, t.offset2))
                }
                constructor(e, t) {
                    this.seq1Range = e, this.seq2Range = t
                }
                swap() {
                    return new a(this.seq2Range, this.seq1Range)
                }
                toString() {
                    return `${this.seq1Range} <-> ${this.seq2Range}`
                }
                join(e) {
                    return new a(this.seq1Range.join(e.seq1Range), this.seq2Range.join(e.seq2Range))
                }
                delta(e) {
                    return 0 === e ? this : new a(this.seq1Range.delta(e), this.seq2Range.delta(e))
                }
                deltaStart(e) {
                    return 0 === e ? this : new a(this.seq1Range.deltaStart(e), this.seq2Range.deltaStart(e))
                }
                deltaEnd(e) {
                    return 0 === e ? this : new a(this.seq1Range.deltaEnd(e), this.seq2Range.deltaEnd(e))
                }
                intersectsOrTouches(e) {
                    return this.seq1Range.intersectsOrTouches(e.seq1Range) || this.seq2Range.intersectsOrTouches(e.seq2Range)
                }
                intersect(e) {
                    const t = this.seq1Range.intersect(e.seq1Range),
                        n = this.seq2Range.intersect(e.seq2Range);
                    if (t && n) return new a(t, n)
                }
                getStarts() {
                    return new l(this.seq1Range.start, this.seq2Range.start)
                }
                getEndExclusives() {
                    return new l(this.seq1Range.endExclusive, this.seq2Range.endExclusive)
                }
            }
            class l {
                static {
                    this.zero = new l(0, 0)
                }
                static {
                    this.max = new l(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)
                }
                constructor(e, t) {
                    this.offset1 = e, this.offset2 = t
                }
                toString() {
                    return `${this.offset1} <-> ${this.offset2}`
                }
                delta(e) {
                    return 0 === e ? this : new l(this.offset1 + e, this.offset2 + e)
                }
                equals(e) {
                    return this.offset1 === e.offset1 && this.offset2 === e.offset2
                }
            }
            class u {
                static {
                    this.instance = new u
                }
                isValid() {
                    return !0
                }
            }
            class h {
                constructor(e) {
                    if (this.timeout = e, this.startTime = Date.now(), this.valid = !0, e <= 0) throw new r.he("timeout must be positive")
                }
                isValid() {
                    return !(Date.now() - this.startTime < this.timeout) && this.valid && (this.valid = !1), this.valid
                }
                disable() {
                    this.timeout = Number.MAX_SAFE_INTEGER, this.isValid = () => !0, this.valid = !0
                }
            }
        },
        qruf: (e, t, n) => {
            n.d(t, {
                DW: () => T
            });
            var i = n("iDmX"),
                r = n("/hu5"),
                s = n("MAz2"),
                o = n("j4W2"),
                a = n("Aw1u"),
                l = n("eNI2"),
                u = n("U7Xe");
            class h {
                constructor(e, t) {
                    this.width = e, this.height = t, this.array = [], this.array = new Array(e * t)
                }
                get(e, t) {
                    return this.array[e + t * this.width]
                }
                set(e, t, n) {
                    this.array[e + t * this.width] = n
                }
            }

            function g(e) {
                return e === u.m.Space || e === u.m.Tab
            }
            class m {
                static {
                    this.chrKeys = new Map
                }
                static getKey(e) {
                    let t = this.chrKeys.get(e);
                    return void 0 === t && (t = this.chrKeys.size, this.chrKeys.set(e, t)), t
                }
                constructor(e, t, n) {
                    this.range = e, this.lines = t, this.source = n, this.histogram = [];
                    let i = 0;
                    for (let n = e.startLineNumber - 1; n < e.endLineNumberExclusive - 1; n++) {
                        const e = t[n];
                        for (let t = 0; t < e.length; t++) {
                            i++;
                            const n = e[t],
                                r = m.getKey(n);
                            this.histogram[r] = (this.histogram[r] || 0) + 1
                        }
                        i++;
                        const r = m.getKey("\n");
                        this.histogram[r] = (this.histogram[r] || 0) + 1
                    }
                    this.totalCount = i
                }
                computeSimilarity(e) {
                    let t = 0;
                    const n = Math.max(this.histogram.length, e.histogram.length);
                    for (let i = 0; i < n; i++) t += Math.abs((this.histogram[i] ? ? 0) - (e.histogram[i] ? ? 0));
                    return 1 - t / (this.totalCount + e.totalCount)
                }
            }
            class d {
                compute(e, t, n = l.n0.instance, i) {
                    if (0 === e.length || 0 === t.length) return l.KU.trivial(e, t);
                    const r = new h(e.length, t.length),
                        s = new h(e.length, t.length),
                        a = new h(e.length, t.length);
                    for (let o = 0; o < e.length; o++)
                        for (let u = 0; u < t.length; u++) {
                            if (!n.isValid()) return l.KU.trivialTimedOut(e, t);
                            const h = 0 === o ? 0 : r.get(o - 1, u),
                                g = 0 === u ? 0 : r.get(o, u - 1);
                            let m;
                            e.getElement(o) === t.getElement(u) ? (m = 0 === o || 0 === u ? 0 : r.get(o - 1, u - 1), o > 0 && u > 0 && 3 === s.get(o - 1, u - 1) && (m += a.get(o - 1, u - 1)), m += i ? i(o, u) : 1) : m = -1;
                            const d = Math.max(h, g, m);
                            if (d === m) {
                                const e = o > 0 && u > 0 ? a.get(o - 1, u - 1) : 0;
                                a.set(o, u, e + 1), s.set(o, u, 3)
                            } else d === h ? (a.set(o, u, 0), s.set(o, u, 1)) : d === g && (a.set(o, u, 0), s.set(o, u, 2));
                            r.set(o, u, d)
                        }
                    const u = [];
                    let g = e.length,
                        m = t.length;

                    function d(e, t) {
                        e + 1 === g && t + 1 === m || u.push(new l.i8(new o.q(e + 1, g), new o.q(t + 1, m))), g = e, m = t
                    }
                    let c = e.length - 1,
                        f = t.length - 1;
                    for (; c >= 0 && f >= 0;) 3 === s.get(c, f) ? (d(c, f), c--, f--) : 1 === s.get(c, f) ? c-- : f--;
                    return d(-1, -1), u.reverse(), new l.KU(u, !1)
                }
            }
            class c {
                compute(e, t, n = l.n0.instance) {
                    if (0 === e.length || 0 === t.length) return l.KU.trivial(e, t);
                    const i = e,
                        r = t;

                    function s(e, t) {
                        for (; e < i.length && t < r.length && i.getElement(e) === r.getElement(t);) e++, t++;
                        return e
                    }
                    let a = 0;
                    const u = new L;
                    u.set(0, s(0, 0));
                    const h = new b;
                    h.set(0, 0 === u.get(0) ? null : new f(null, 0, 0, u.get(0)));
                    let g = 0;
                    e: for (;;) {
                        if (a++, !n.isValid()) return l.KU.trivialTimedOut(i, r);
                        const e = -Math.min(a, r.length + a % 2),
                            t = Math.min(a, i.length + a % 2);
                        for (g = e; g <= t; g += 2) {
                            const n = g === t ? -1 : u.get(g + 1),
                                o = g === e ? -1 : u.get(g - 1) + 1,
                                a = Math.min(Math.max(n, o), i.length),
                                l = a - g;
                            if (a > i.length || l > r.length) continue;
                            const m = s(a, l);
                            u.set(g, m);
                            const d = a === n ? h.get(g + 1) : h.get(g - 1);
                            if (h.set(g, m !== a ? new f(d, a, l, m - a) : d), u.get(g) === i.length && u.get(g) - g === r.length) break e
                        }
                    }
                    let m = h.get(g);
                    const d = [];
                    let c = i.length,
                        N = r.length;
                    for (;;) {
                        const e = m ? m.x + m.length : 0,
                            t = m ? m.y + m.length : 0;
                        if (e === c && t === N || d.push(new l.i8(new o.q(e, c), new o.q(t, N))), !m) break;
                        c = m.x, N = m.y, m = m.prev
                    }
                    return d.reverse(), new l.KU(d, !1)
                }
            }
            class f {
                constructor(e, t, n, i) {
                    this.prev = e, this.x = t, this.y = n, this.length = i
                }
            }
            class L {
                constructor() {
                    this.positiveArr = new Int32Array(10), this.negativeArr = new Int32Array(10)
                }
                get(e) {
                    return e < 0 ? (e = -e - 1, this.negativeArr[e]) : this.positiveArr[e]
                }
                set(e, t) {
                    if (e < 0) {
                        if ((e = -e - 1) >= this.negativeArr.length) {
                            const e = this.negativeArr;
                            this.negativeArr = new Int32Array(2 * e.length), this.negativeArr.set(e)
                        }
                        this.negativeArr[e] = t
                    } else {
                        if (e >= this.positiveArr.length) {
                            const e = this.positiveArr;
                            this.positiveArr = new Int32Array(2 * e.length), this.positiveArr.set(e)
                        }
                        this.positiveArr[e] = t
                    }
                }
            }
            class b {
                constructor() {
                    this.positiveArr = [], this.negativeArr = []
                }
                get(e) {
                    return e < 0 ? (e = -e - 1, this.negativeArr[e]) : this.positiveArr[e]
                }
                set(e, t) {
                    e < 0 ? (e = -e - 1, this.negativeArr[e] = t) : this.positiveArr[e] = t
                }
            }
            var N, p = n("z+Ny"),
                E = n("W8Fm"),
                R = n("Ef4y"),
                v = n("6PFX");
            class w {
                constructor(e, t, n) {
                    this.lines = e, this.considerWhitespaceChanges = n, this.elements = [], this.firstCharOffsetByLine = [], this.additionalOffsetByLine = [];
                    let i = !1;
                    t.start > 0 && t.endExclusive >= e.length && (t = new o.q(t.start - 1, t.endExclusive), i = !0), this.lineRange = t, this.firstCharOffsetByLine[0] = 0;
                    for (let t = this.lineRange.start; t < this.lineRange.endExclusive; t++) {
                        let r = e[t],
                            s = 0;
                        if (i) s = r.length, r = "", i = !1;
                        else if (!n) {
                            const e = r.trimStart();
                            s = r.length - e.length, r = e.trimEnd()
                        }
                        this.additionalOffsetByLine.push(s);
                        for (let e = 0; e < r.length; e++) this.elements.push(r.charCodeAt(e));
                        t < e.length - 1 && (this.elements.push("\n".charCodeAt(0)), this.firstCharOffsetByLine[t - this.lineRange.start + 1] = this.elements.length)
                    }
                    this.additionalOffsetByLine.push(0)
                }
                toString() {
                    return `Slice: "${this.text}"`
                }
                get text() {
                    return this.getText(new o.q(0, this.length))
                }
                getText(e) {
                    return this.elements.slice(e.start, e.endExclusive).map((e => String.fromCharCode(e))).join("")
                }
                getElement(e) {
                    return this.elements[e]
                }
                get length() {
                    return this.elements.length
                }
                getBoundaryScore(e) {
                    const t = S(e > 0 ? this.elements[e - 1] : -1),
                        n = S(e < this.elements.length ? this.elements[e] : -1);
                    if (t === N.LineBreakCR && n === N.LineBreakLF) return 0;
                    if (t === N.LineBreakLF) return 150;
                    let i = 0;
                    return t !== n && (i += 10, t === N.WordLower && n === N.WordUpper && (i += 1)), i += _(t), i += _(n), i
                }
                translateOffset(e) {
                    if (this.lineRange.isEmpty) return new v.L(this.lineRange.start + 1, 1);
                    const t = (0, E.Jw)(this.firstCharOffsetByLine, (t => t <= e));
                    return new v.L(this.lineRange.start + t + 1, e - this.firstCharOffsetByLine[t] + this.additionalOffsetByLine[t] + 1)
                }
                translateRange(e) {
                    return a.e.fromPositions(this.translateOffset(e.start), this.translateOffset(e.endExclusive))
                }
                findWordContaining(e) {
                    if (e < 0 || e >= this.elements.length) return;
                    if (!x(this.elements[e])) return;
                    let t = e;
                    for (; t > 0 && x(this.elements[t - 1]);) t--;
                    let n = e;
                    for (; n < this.elements.length && x(this.elements[n]);) n++;
                    return new o.q(t, n)
                }
                countLinesIn(e) {
                    return this.translateOffset(e.endExclusive).lineNumber - this.translateOffset(e.start).lineNumber
                }
                isStronglyEqual(e, t) {
                    return this.elements[e] === this.elements[t]
                }
                extendToFullLines(e) {
                    const t = (0, E.ti)(this.firstCharOffsetByLine, (t => t <= e.start)) ? ? 0,
                        n = (0, E.cn)(this.firstCharOffsetByLine, (t => e.endExclusive <= t)) ? ? this.elements.length;
                    return new o.q(t, n)
                }
            }

            function x(e) {
                return e >= u.m.a && e <= u.m.z || e >= u.m.A && e <= u.m.Z || e >= u.m.Digit0 && e <= u.m.Digit9
            }! function(e) {
                e[e.WordLower = 0] = "WordLower", e[e.WordUpper = 1] = "WordUpper", e[e.WordNumber = 2] = "WordNumber", e[e.End = 3] = "End", e[e.Other = 4] = "Other", e[e.Separator = 5] = "Separator", e[e.Space = 6] = "Space", e[e.LineBreakCR = 7] = "LineBreakCR", e[e.LineBreakLF = 8] = "LineBreakLF"
            }(N || (N = {}));
            const C = {
                [N.WordLower]: 0,
                [N.WordUpper]: 0,
                [N.WordNumber]: 0,
                [N.End]: 10,
                [N.Other]: 2,
                [N.Separator]: 30,
                [N.Space]: 3,
                [N.LineBreakCR]: 10,
                [N.LineBreakLF]: 10
            };

            function _(e) {
                return C[e]
            }

            function S(e) {
                return e === u.m.LineFeed ? N.LineBreakLF : e === u.m.CarriageReturn ? N.LineBreakCR : g(e) ? N.Space : e >= u.m.a && e <= u.m.z ? N.WordLower : e >= u.m.A && e <= u.m.Z ? N.WordUpper : e >= u.m.Digit0 && e <= u.m.Digit9 ? N.WordNumber : -1 === e ? N.End : e === u.m.Comma || e === u.m.Semicolon ? N.Separator : N.Other
            }

            function q(e, t, n) {
                if (e.trim() === t.trim()) return !0;
                if (e.length > 300 && t.length > 300) return !1;
                const i = (new c).compute(new w([e], new o.q(0, 1), !1), new w([t], new o.q(0, 1), !1), n);
                let r = 0;
                const s = l.i8.invert(i.diffs, e.length);
                for (const t of s) t.seq1Range.forEach((t => {
                    g(e.charCodeAt(t)) || r++
                }));
                const a = function(t) {
                    let n = 0;
                    for (let i = 0; i < e.length; i++) g(t.charCodeAt(i)) || n++;
                    return n
                }(e.length > t.length ? e : t);
                return r / a > .6 && a > 10
            }
            var M = n("SxIA");
            class y {
                constructor(e, t) {
                    this.trimmedHash = e, this.lines = t
                }
                getElement(e) {
                    return this.trimmedHash[e]
                }
                get length() {
                    return this.trimmedHash.length
                }
                getBoundaryScore(e) {
                    return 1e3 - ((0 === e ? 0 : A(this.lines[e - 1])) + (e === this.lines.length ? 0 : A(this.lines[e])))
                }
                getText(e) {
                    return this.lines.slice(e.start, e.endExclusive).join("\n")
                }
                isStronglyEqual(e, t) {
                    return this.lines[e] === this.lines[t]
                }
            }

            function A(e) {
                let t = 0;
                for (; t < e.length && (e.charCodeAt(t) === u.m.Space || e.charCodeAt(t) === u.m.Tab);) t++;
                return t
            }
            var z = n("6QcS");
            class T {
                constructor() {
                    this.dynamicProgrammingDiffing = new d, this.myersDiffingAlgorithm = new c
                }
                computeDiff(e, t, n) {
                    if (e.length <= 1 && (0, i.fS)(e, t, ((e, t) => e === t))) return new z.h([], [], !1);
                    if (1 === e.length && 0 === e[0].length || 1 === t.length && 0 === t[0].length) return new z.h([new p.gB(new s.z(1, e.length + 1), new s.z(1, t.length + 1), [new p.iy(new a.e(1, 1, e.length, e[e.length - 1].length + 1), new a.e(1, 1, t.length, t[t.length - 1].length + 1))])], [], !1);
                    const u = 0 === n.maxComputationTimeMs ? l.n0.instance : new l.NT(n.maxComputationTimeMs),
                        h = !n.ignoreTrimWhitespace,
                        g = new Map;

                    function m(e) {
                        let t = g.get(e);
                        return void 0 === t && (t = g.size, g.set(e, t)), t
                    }
                    const d = e.map((e => m(e.trim()))),
                        c = t.map((e => m(e.trim()))),
                        f = new y(d, e),
                        L = new y(c, t),
                        b = (() => f.length + L.length < 1700 ? this.dynamicProgrammingDiffing.compute(f, L, u, ((n, i) => e[n] === t[i] ? 0 === t[i].length ? .1 : 1 + Math.log(1 + t[i].length) : .99)) : this.myersDiffingAlgorithm.compute(f, L, u))();
                    let N = b.diffs,
                        E = b.hitTimeout;
                    N = (0, M.xG)(f, L, N), N = (0, M.rh)(f, L, N);
                    const R = [],
                        v = n => {
                            if (h)
                                for (let i = 0; i < n; i++) {
                                    const n = w + i,
                                        r = x + i;
                                    if (e[n] !== t[r]) {
                                        const i = this.refineDiff(e, t, new l.i8(new o.q(n, n + 1), new o.q(r, r + 1)), u, h);
                                        for (const e of i.mappings) R.push(e);
                                        i.hitTimeout && (E = !0)
                                    }
                                }
                        };
                    let w = 0,
                        x = 0;
                    for (const n of N) {
                        (0, r.eZ)((() => n.seq1Range.start - w == n.seq2Range.start - x)), v(n.seq1Range.start - w), w = n.seq1Range.endExclusive, x = n.seq2Range.endExclusive;
                        const i = this.refineDiff(e, t, n, u, h);
                        i.hitTimeout && (E = !0);
                        for (const e of i.mappings) R.push(e)
                    }
                    v(e.length - w);
                    const C = I(R, e, t);
                    let _ = [];
                    return n.computeMoves && (_ = this.computeMoves(C, e, t, d, c, u, h)), (0, r.eZ)((() => {
                        function n(e, t) {
                            if (e.lineNumber < 1 || e.lineNumber > t.length) return !1;
                            const n = t[e.lineNumber - 1];
                            return !(e.column < 1 || e.column > n.length + 1)
                        }

                        function i(e, t) {
                            return !(e.startLineNumber < 1 || e.startLineNumber > t.length + 1 || e.endLineNumberExclusive < 1 || e.endLineNumberExclusive > t.length + 1)
                        }
                        for (const r of C) {
                            if (!r.innerChanges) return !1;
                            for (const i of r.innerChanges)
                                if (!(n(i.modifiedRange.getStartPosition(), t) && n(i.modifiedRange.getEndPosition(), t) && n(i.originalRange.getStartPosition(), e) && n(i.originalRange.getEndPosition(), e))) return !1;
                            if (!i(r.modified, t) || !i(r.original, e)) return !1
                        }
                        return !0
                    })), new z.h(C, _, E)
                }
                computeMoves(e, t, n, r, o, a, u) {
                    return function(e, t, n, r, o, a) {
                        let {
                            moves: l,
                            excludedChanges: u
                        } = function(e, t, n, i) {
                            const r = [],
                                s = e.filter((e => e.modified.isEmpty && e.original.length >= 3)).map((e => new m(e.original, t, e))),
                                o = new Set(e.filter((e => e.original.isEmpty && e.modified.length >= 3)).map((e => new m(e.modified, n, e)))),
                                a = new Set;
                            for (const e of s) {
                                let t, n = -1;
                                for (const i of o) {
                                    const r = e.computeSimilarity(i);
                                    r > n && (n = r, t = i)
                                }
                                if (n > .9 && t && (o.delete(t), r.push(new p.f0(e.range, t.range)), a.add(e.source), a.add(t.source)), !i.isValid()) return {
                                    moves: r,
                                    excludedChanges: a
                                }
                            }
                            return {
                                moves: r,
                                excludedChanges: a
                            }
                        }(e, t, n, a);
                        if (!a.isValid()) return [];
                        const h = function(e, t, n, r, o, a) {
                            const l = [],
                                u = new R.ri;
                            for (const n of e)
                                for (let e = n.original.startLineNumber; e < n.original.endLineNumberExclusive - 2; e++) {
                                    const n = `${t[e-1]}:${t[e+1-1]}:${t[e+2-1]}`;
                                    u.add(n, {
                                        range: new s.z(e, e + 3)
                                    })
                                }
                            const h = [];
                            e.sort((0, i.tT)((e => e.modified.startLineNumber), i.fv));
                            for (const t of e) {
                                let e = [];
                                for (let i = t.modified.startLineNumber; i < t.modified.endLineNumberExclusive - 2; i++) {
                                    const t = `${n[i-1]}:${n[i+1-1]}:${n[i+2-1]}`,
                                        r = new s.z(i, i + 3),
                                        o = [];
                                    u.forEach(t, (({
                                        range: t
                                    }) => {
                                        for (const n of e)
                                            if (n.originalLineRange.endLineNumberExclusive + 1 === t.endLineNumberExclusive && n.modifiedLineRange.endLineNumberExclusive + 1 === r.endLineNumberExclusive) return n.originalLineRange = new s.z(n.originalLineRange.startLineNumber, t.endLineNumberExclusive), n.modifiedLineRange = new s.z(n.modifiedLineRange.startLineNumber, r.endLineNumberExclusive), void o.push(n);
                                        const n = {
                                            modifiedLineRange: r,
                                            originalLineRange: t
                                        };
                                        h.push(n), o.push(n)
                                    })), e = o
                                }
                                if (!a.isValid()) return []
                            }
                            h.sort((0, i.BV)((0, i.tT)((e => e.modifiedLineRange.length), i.fv)));
                            const g = new s.i,
                                m = new s.i;
                            for (const e of h) {
                                const t = e.modifiedLineRange.startLineNumber - e.originalLineRange.startLineNumber,
                                    n = g.subtractFrom(e.modifiedLineRange),
                                    i = m.subtractFrom(e.originalLineRange).getWithDelta(t),
                                    r = n.getIntersection(i);
                                for (const e of r.ranges) {
                                    if (e.length < 3) continue;
                                    const n = e,
                                        i = e.delta(-t);
                                    l.push(new p.f0(i, n)), g.addRange(n), m.addRange(i)
                                }
                            }
                            l.sort((0, i.tT)((e => e.original.startLineNumber), i.fv));
                            const d = new E.b1(e);
                            for (let t = 0; t < l.length; t++) {
                                const n = l[t],
                                    i = d.findLastMonotonous((e => e.original.startLineNumber <= n.original.startLineNumber)),
                                    u = (0, E.ti)(e, (e => e.modified.startLineNumber <= n.modified.startLineNumber)),
                                    h = Math.max(n.original.startLineNumber - i.original.startLineNumber, n.modified.startLineNumber - u.modified.startLineNumber),
                                    c = d.findLastMonotonous((e => e.original.startLineNumber < n.original.endLineNumberExclusive)),
                                    f = (0, E.ti)(e, (e => e.modified.startLineNumber < n.modified.endLineNumberExclusive)),
                                    L = Math.max(c.original.endLineNumberExclusive - n.original.endLineNumberExclusive, f.modified.endLineNumberExclusive - n.modified.endLineNumberExclusive);
                                let b, N;
                                for (b = 0; b < h; b++) {
                                    const e = n.original.startLineNumber - b - 1,
                                        t = n.modified.startLineNumber - b - 1;
                                    if (e > r.length || t > o.length) break;
                                    if (g.contains(t) || m.contains(e)) break;
                                    if (!q(r[e - 1], o[t - 1], a)) break
                                }
                                for (b > 0 && (m.addRange(new s.z(n.original.startLineNumber - b, n.original.startLineNumber)), g.addRange(new s.z(n.modified.startLineNumber - b, n.modified.startLineNumber))), N = 0; N < L; N++) {
                                    const e = n.original.endLineNumberExclusive + N,
                                        t = n.modified.endLineNumberExclusive + N;
                                    if (e > r.length || t > o.length) break;
                                    if (g.contains(t) || m.contains(e)) break;
                                    if (!q(r[e - 1], o[t - 1], a)) break
                                }
                                N > 0 && (m.addRange(new s.z(n.original.endLineNumberExclusive, n.original.endLineNumberExclusive + N)), g.addRange(new s.z(n.modified.endLineNumberExclusive, n.modified.endLineNumberExclusive + N))), (b > 0 || N > 0) && (l[t] = new p.f0(new s.z(n.original.startLineNumber - b, n.original.endLineNumberExclusive + N), new s.z(n.modified.startLineNumber - b, n.modified.endLineNumberExclusive + N)))
                            }
                            return l
                        }(e.filter((e => !u.has(e))), r, o, t, n, a);
                        return (0, i.vA)(l, h), l = function(e) {
                            if (0 === e.length) return e;
                            e.sort((0, i.tT)((e => e.original.startLineNumber), i.fv));
                            const t = [e[0]];
                            for (let n = 1; n < e.length; n++) {
                                const i = t[t.length - 1],
                                    r = e[n],
                                    s = r.original.startLineNumber - i.original.endLineNumberExclusive,
                                    o = r.modified.startLineNumber - i.modified.endLineNumberExclusive;
                                s >= 0 && o >= 0 && s + o <= 2 ? t[t.length - 1] = i.join(r) : t.push(r)
                            }
                            return t
                        }(l), l = l.filter((e => {
                            const n = e.original.toOffsetRange().slice(t).map((e => e.trim()));
                            return n.join("\n").length >= 15 && function(e, t) {
                                let n = 0;
                                for (const t of e) t.length >= 2 && n++;
                                return n
                            }(n) >= 2
                        })), l = function(e, t) {
                            const n = new E.b1(e);
                            return t.filter((t => (n.findLastMonotonous((e => e.original.startLineNumber < t.original.endLineNumberExclusive)) || new p.f0(new s.z(1, 1), new s.z(1, 1))) !== (0, E.ti)(e, (e => e.modified.startLineNumber < t.modified.endLineNumberExclusive))))
                        }(e, l), l
                    }(e, t, n, r, o, a).map((e => {
                        const i = I(this.refineDiff(t, n, new l.i8(e.original.toOffsetRange(), e.modified.toOffsetRange()), a, u).mappings, t, n, !0);
                        return new z.y(e, i)
                    }))
                }
                refineDiff(e, t, n, i, r) {
                    const s = new w(e, n.seq1Range, r),
                        o = new w(t, n.seq2Range, r),
                        a = s.length + o.length < 500 ? this.dynamicProgrammingDiffing.compute(s, o, i) : this.myersDiffingAlgorithm.compute(s, o, i);
                    let l = a.diffs;
                    return l = (0, M.xG)(s, o, l), l = (0, M.g0)(s, o, l), l = (0, M.oK)(s, o, l), l = (0, M.DI)(s, o, l), {
                        mappings: l.map((e => new p.iy(s.translateRange(e.seq1Range), o.translateRange(e.seq2Range)))),
                        hitTimeout: a.hitTimeout
                    }
                }
            }

            function I(e, t, n, o = !1) {
                const a = [];
                for (const r of (0, i.mw)(e.map((e => function(e, t, n) {
                        let i = 0,
                            r = 0;
                        1 === e.modifiedRange.endColumn && 1 === e.originalRange.endColumn && e.originalRange.startLineNumber + i <= e.originalRange.endLineNumber && e.modifiedRange.startLineNumber + i <= e.modifiedRange.endLineNumber && (r = -1), e.modifiedRange.startColumn - 1 >= n[e.modifiedRange.startLineNumber - 1].length && e.originalRange.startColumn - 1 >= t[e.originalRange.startLineNumber - 1].length && e.originalRange.startLineNumber <= e.originalRange.endLineNumber + r && e.modifiedRange.startLineNumber <= e.modifiedRange.endLineNumber + r && (i = 1);
                        const o = new s.z(e.originalRange.startLineNumber + i, e.originalRange.endLineNumber + 1 + r),
                            a = new s.z(e.modifiedRange.startLineNumber + i, e.modifiedRange.endLineNumber + 1 + r);
                        return new p.gB(o, a, [e])
                    }(e, t, n))), ((e, t) => e.original.overlapOrTouch(t.original) || e.modified.overlapOrTouch(t.modified)))) {
                    const e = r[0],
                        t = r[r.length - 1];
                    a.push(new p.gB(e.original.join(t.original), e.modified.join(t.modified), r.map((e => e.innerChanges[0]))))
                }
                return (0, r.eZ)((() => {
                    if (!o && a.length > 0) {
                        if (a[0].modified.startLineNumber !== a[0].original.startLineNumber) return !1;
                        if (n.length - a[a.length - 1].modified.endLineNumberExclusive != t.length - a[a.length - 1].original.endLineNumberExclusive) return !1
                    }
                    return (0, r.DM)(a, ((e, t) => t.original.startLineNumber - e.original.endLineNumberExclusive == t.modified.startLineNumber - e.modified.endLineNumberExclusive && e.original.endLineNumberExclusive < t.original.startLineNumber && e.modified.endLineNumberExclusive < t.modified.startLineNumber))
                })), a
            }
        },
        SxIA: (e, t, n) => {
            n.d(t, {
                DI: () => m,
                g0: () => h,
                oK: () => u,
                rh: () => g,
                xG: () => o
            });
            var i = n("iDmX"),
                r = n("j4W2"),
                s = n("eNI2");

            function o(e, t, n) {
                let i = n;
                return i = a(e, t, i), i = a(e, t, i), i = function(e, t, n) {
                    if (!e.getBoundaryScore || !t.getBoundaryScore) return n;
                    for (let i = 0; i < n.length; i++) {
                        const s = i > 0 ? n[i - 1] : void 0,
                            o = n[i],
                            a = i + 1 < n.length ? n[i + 1] : void 0,
                            u = new r.q(s ? s.seq1Range.endExclusive + 1 : 0, a ? a.seq1Range.start - 1 : e.length),
                            h = new r.q(s ? s.seq2Range.endExclusive + 1 : 0, a ? a.seq2Range.start - 1 : t.length);
                        o.seq1Range.isEmpty ? n[i] = l(o, e, t, u, h) : o.seq2Range.isEmpty && (n[i] = l(o.swap(), t, e, h, u).swap())
                    }
                    return n
                }(e, t, i), i
            }

            function a(e, t, n) {
                if (0 === n.length) return n;
                const i = [];
                i.push(n[0]);
                for (let o = 1; o < n.length; o++) {
                    const a = i[i.length - 1];
                    let l = n[o];
                    if (l.seq1Range.isEmpty || l.seq2Range.isEmpty) {
                        const n = l.seq1Range.start - a.seq1Range.endExclusive;
                        let o;
                        for (o = 1; o <= n && e.getElement(l.seq1Range.start - o) === e.getElement(l.seq1Range.endExclusive - o) && t.getElement(l.seq2Range.start - o) === t.getElement(l.seq2Range.endExclusive - o); o++);
                        if (o--, o === n) {
                            i[i.length - 1] = new s.i8(new r.q(a.seq1Range.start, l.seq1Range.endExclusive - n), new r.q(a.seq2Range.start, l.seq2Range.endExclusive - n));
                            continue
                        }
                        l = l.delta(-o)
                    }
                    i.push(l)
                }
                const o = [];
                for (let n = 0; n < i.length - 1; n++) {
                    const a = i[n + 1];
                    let l = i[n];
                    if (l.seq1Range.isEmpty || l.seq2Range.isEmpty) {
                        const o = a.seq1Range.start - l.seq1Range.endExclusive;
                        let u;
                        for (u = 0; u < o && e.isStronglyEqual(l.seq1Range.start + u, l.seq1Range.endExclusive + u) && t.isStronglyEqual(l.seq2Range.start + u, l.seq2Range.endExclusive + u); u++);
                        if (u === o) {
                            i[n + 1] = new s.i8(new r.q(l.seq1Range.start + o, a.seq1Range.endExclusive), new r.q(l.seq2Range.start + o, a.seq2Range.endExclusive));
                            continue
                        }
                        u > 0 && (l = l.delta(u))
                    }
                    o.push(l)
                }
                return i.length > 0 && o.push(i[i.length - 1]), o
            }

            function l(e, t, n, i, r) {
                let s = 1;
                for (; e.seq1Range.start - s >= i.start && e.seq2Range.start - s >= r.start && n.isStronglyEqual(e.seq2Range.start - s, e.seq2Range.endExclusive - s) && s < 100;) s++;
                s--;
                let o = 0;
                for (; e.seq1Range.start + o < i.endExclusive && e.seq2Range.endExclusive + o < r.endExclusive && n.isStronglyEqual(e.seq2Range.start + o, e.seq2Range.endExclusive + o) && o < 100;) o++;
                if (0 === s && 0 === o) return e;
                let a = 0,
                    l = -1;
                for (let i = -s; i <= o; i++) {
                    const r = e.seq2Range.start + i,
                        s = e.seq2Range.endExclusive + i,
                        o = e.seq1Range.start + i,
                        u = t.getBoundaryScore(o) + n.getBoundaryScore(r) + n.getBoundaryScore(s);
                    u > l && (l = u, a = i)
                }
                return e.delta(a)
            }

            function u(e, t, n) {
                const i = [];
                for (const e of n) {
                    const t = i[i.length - 1];
                    t && (e.seq1Range.start - t.seq1Range.endExclusive <= 2 || e.seq2Range.start - t.seq2Range.endExclusive <= 2) ? i[i.length - 1] = new s.i8(t.seq1Range.join(e.seq1Range), t.seq2Range.join(e.seq2Range)) : i.push(e)
                }
                return i
            }

            function h(e, t, n) {
                const i = s.i8.invert(n, e.length),
                    r = [];
                let o = new s.zl(0, 0);

                function a(n, a) {
                    if (n.offset1 < o.offset1 || n.offset2 < o.offset2) return;
                    const l = e.findWordContaining(n.offset1),
                        u = t.findWordContaining(n.offset2);
                    if (!l || !u) return;
                    let h = new s.i8(l, u);
                    const g = h.intersect(a);
                    let m = g.seq1Range.length,
                        d = g.seq2Range.length;
                    for (; i.length > 0;) {
                        const n = i[0];
                        if (!n.seq1Range.intersects(h.seq1Range) && !n.seq2Range.intersects(h.seq2Range)) break;
                        const r = e.findWordContaining(n.seq1Range.start),
                            o = t.findWordContaining(n.seq2Range.start),
                            a = new s.i8(r, o),
                            l = a.intersect(n);
                        if (m += l.seq1Range.length, d += l.seq2Range.length, h = h.join(a), !(h.seq1Range.endExclusive >= n.seq1Range.endExclusive)) break;
                        i.shift()
                    }
                    m + d < 2 * (h.seq1Range.length + h.seq2Range.length) / 3 && r.push(h), o = h.getEndExclusives()
                }
                for (; i.length > 0;) {
                    const e = i.shift();
                    e.seq1Range.isEmpty || (a(e.getStarts(), e), a(e.getEndExclusives().delta(-1), e))
                }
                return function(e, t) {
                    const n = [];
                    for (; e.length > 0 || t.length > 0;) {
                        const i = e[0],
                            r = t[0];
                        let s;
                        s = i && (!r || i.seq1Range.start < r.seq1Range.start) ? e.shift() : t.shift(), n.length > 0 && n[n.length - 1].seq1Range.endExclusive >= s.seq1Range.start ? n[n.length - 1] = n[n.length - 1].join(s) : n.push(s)
                    }
                    return n
                }(n, r)
            }

            function g(e, t, n) {
                let i = n;
                if (0 === i.length) return i;
                let s, o = 0;
                do {
                    s = !1;
                    const a = [i[0]];
                    for (let l = 1; l < i.length; l++) {
                        const u = i[l],
                            h = a[a.length - 1];

                        function g(t, n) {
                            const i = new r.q(h.seq1Range.endExclusive, u.seq1Range.start);
                            return e.getText(i).replace(/\s/g, "").length <= 4 && (t.seq1Range.length + t.seq2Range.length > 5 || n.seq1Range.length + n.seq2Range.length > 5)
                        }
                        g(h, u) ? (s = !0, a[a.length - 1] = a[a.length - 1].join(u)) : a.push(u)
                    }
                    i = a
                } while (o++ < 10 && s);
                return i
            }

            function m(e, t, n) {
                let o = n;
                if (0 === o.length) return o;
                let a, l = 0;
                do {
                    a = !1;
                    const h = [o[0]];
                    for (let g = 1; g < o.length; g++) {
                        const m = o[g],
                            d = h[h.length - 1];

                        function c(n, i) {
                            const s = new r.q(d.seq1Range.endExclusive, m.seq1Range.start);
                            if (e.countLinesIn(s) > 5 || s.length > 500) return !1;
                            const o = e.getText(s).trim();
                            if (o.length > 20 || o.split(/\r\n|\r|\n/).length > 1) return !1;
                            const a = e.countLinesIn(n.seq1Range),
                                l = n.seq1Range.length,
                                u = t.countLinesIn(n.seq2Range),
                                h = n.seq2Range.length,
                                g = e.countLinesIn(i.seq1Range),
                                c = i.seq1Range.length,
                                f = t.countLinesIn(i.seq2Range),
                                L = i.seq2Range.length,
                                b = 130;

                            function N(e) {
                                return Math.min(e, b)
                            }
                            return Math.pow(Math.pow(N(40 * a + l), 1.5) + Math.pow(N(40 * u + h), 1.5), 1.5) + Math.pow(Math.pow(N(40 * g + c), 1.5) + Math.pow(N(40 * f + L), 1.5), 1.5) > (b ** 1.5) ** 1.5 * 1.3
                        }
                        c(d, m) ? (a = !0, h[h.length - 1] = h[h.length - 1].join(m)) : h.push(m)
                    }
                    o = h
                } while (l++ < 10 && a);
                const u = [];
                return (0, i.KO)(o, ((t, n, i) => {
                    let o = n;

                    function a(e) {
                        return e.length > 0 && e.trim().length <= 3 && n.seq1Range.length + n.seq2Range.length > 100
                    }
                    const l = e.extendToFullLines(n.seq1Range),
                        h = e.getText(new r.q(l.start, n.seq1Range.start));
                    a(h) && (o = o.deltaStart(-h.length));
                    const g = e.getText(new r.q(n.seq1Range.endExclusive, l.endExclusive));
                    a(g) && (o = o.deltaEnd(g.length));
                    const m = s.i8.fromOffsetPairs(t ? t.getEndExclusives() : s.zl.zero, i ? i.getStarts() : s.zl.max),
                        d = o.intersect(m);
                    u.length > 0 && d.getStarts().equals(u[u.length - 1].getEndExclusives()) ? u[u.length - 1] = u[u.length - 1].join(d) : u.push(d)
                })), u
            }
        },
        "6QcS": (e, t, n) => {
            n.d(t, {
                h: () => i,
                y: () => r
            });
            class i {
                constructor(e, t, n) {
                    this.changes = e, this.moves = t, this.hitTimeout = n
                }
            }
            class r {
                constructor(e, t) {
                    this.lineRangeMapping = e, this.changes = t
                }
                flip() {
                    return new r(this.lineRangeMapping.flip(), this.changes.map((e => e.flip())))
                }
            }
        },
        "z+Ny": (e, t, n) => {
            n.d(t, {
                f0: () => a,
                gB: () => l,
                iy: () => u
            });
            var i = n("PUdK"),
                r = n("MAz2"),
                s = n("Aw1u"),
                o = n("spkp");
            class a {
                static inverse(e, t, n) {
                    const i = [];
                    let s = 1,
                        o = 1;
                    for (const t of e) {
                        const e = new a(new r.z(s, t.original.startLineNumber), new r.z(o, t.modified.startLineNumber));
                        e.modified.isEmpty || i.push(e), s = t.original.endLineNumberExclusive, o = t.modified.endLineNumberExclusive
                    }
                    const l = new a(new r.z(s, t + 1), new r.z(o, n + 1));
                    return l.modified.isEmpty || i.push(l), i
                }
                static clip(e, t, n) {
                    const i = [];
                    for (const r of e) {
                        const e = r.original.intersect(t),
                            s = r.modified.intersect(n);
                        e && !e.isEmpty && s && !s.isEmpty && i.push(new a(e, s))
                    }
                    return i
                }
                constructor(e, t) {
                    this.original = e, this.modified = t
                }
                toString() {
                    return `{${this.original.toString()}->${this.modified.toString()}}`
                }
                flip() {
                    return new a(this.modified, this.original)
                }
                join(e) {
                    return new a(this.original.join(e.original), this.modified.join(e.modified))
                }
                get changedLineCount() {
                    return Math.max(this.original.length, this.modified.length)
                }
                toRangeMapping() {
                    const e = this.original.toInclusiveRange(),
                        t = this.modified.toInclusiveRange();
                    if (e && t) return new u(e, t);
                    if (1 === this.original.startLineNumber || 1 === this.modified.startLineNumber) {
                        if (1 !== this.modified.startLineNumber || 1 !== this.original.startLineNumber) throw new i.he("not a valid diff");
                        return new u(new s.e(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new s.e(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1))
                    }
                    return new u(new s.e(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new s.e(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER))
                }
            }
            class l extends a {
                static fromRangeMappings(e) {
                    const t = r.z.join(e.map((e => r.z.fromRangeInclusive(e.originalRange)))),
                        n = r.z.join(e.map((e => r.z.fromRangeInclusive(e.modifiedRange))));
                    return new l(t, n, e)
                }
                constructor(e, t, n) {
                    super(e, t), this.innerChanges = n
                }
                flip() {
                    return new l(this.modified, this.original, this.innerChanges ? .map((e => e.flip())))
                }
                withInnerChangesFromLineRanges() {
                    return new l(this.original, this.modified, [this.toRangeMapping()])
                }
            }
            class u {
                constructor(e, t) {
                    this.originalRange = e, this.modifiedRange = t
                }
                toString() {
                    return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`
                }
                flip() {
                    return new u(this.modifiedRange, this.originalRange)
                }
                toTextEdit(e) {
                    const t = e.getValueOfRange(this.modifiedRange);
                    return new o.At(this.originalRange, t)
                }
            }
        },
        Ph77: (e, t, n) => {
            n.d(t, {
                O: () => d
            });
            var i = n("rJtg"),
                r = n("7icl"),
                s = n("yc7/"),
                o = n("naIR"),
                a = n("6PFX"),
                l = n("Aw1u"),
                u = n("j3Ei"),
                h = n("Oe9y"),
                g = n("B6+6");
            class m {
                static {
                    this.CtrlCmd = s.DC.CtrlCmd
                }
                static {
                    this.Shift = s.DC.Shift
                }
                static {
                    this.Alt = s.DC.Alt
                }
                static {
                    this.WinCtrl = s.DC.WinCtrl
                }
                static chord(e, t) {
                    return (0, s.gx)(e, t)
                }
            }

            function d() {
                return {
                    editor: void 0,
                    languages: void 0,
                    CancellationTokenSource: i.AU,
                    Emitter: r.Q5,
                    KeyCode: g.VD,
                    KeyMod: m,
                    Position: a.L,
                    Range: l.e,
                    Selection: u.Y,
                    SelectionDirection: g.a$,
                    MarkerSeverity: g.ZL,
                    MarkerTag: g.eB,
                    Uri: o.ov,
                    Token: h.WU
                }
            }
        },
        QFUP: (e, t, n) => {
            n.d(t, {
                k: () => K
            });
            var i = n("8sQX"),
                r = n("naIR"),
                s = n("6PFX"),
                o = n("Aw1u"),
                a = n("zr1e"),
                l = n("5G63"),
                u = n("5hxU");
            class h {
                constructor() {
                    this._defaultValueSet = [
                        ["true", "false"],
                        ["True", "False"],
                        ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
                        ["public", "protected", "private"]
                    ]
                }
                static {
                    this.INSTANCE = new h
                }
                navigateValueSet(e, t, n, i, r) {
                    if (e && t) {
                        const n = this.doNavigateValueSet(t, r);
                        if (n) return {
                            range: e,
                            value: n
                        }
                    }
                    if (n && i) {
                        const e = this.doNavigateValueSet(i, r);
                        if (e) return {
                            range: n,
                            value: e
                        }
                    }
                    return null
                }
                doNavigateValueSet(e, t) {
                    const n = this.numberReplace(e, t);
                    return null !== n ? n : this.textReplace(e, t)
                }
                numberReplace(e, t) {
                    const n = Math.pow(10, e.length - (e.lastIndexOf(".") + 1));
                    let i = Number(e);
                    const r = parseFloat(e);
                    return isNaN(i) || isNaN(r) || i !== r ? null : 0 !== i || t ? (i = Math.floor(i * n), i += t ? n : -n, String(i / n)) : null
                }
                textReplace(e, t) {
                    return this.valueSetsReplace(this._defaultValueSet, e, t)
                }
                valueSetsReplace(e, t, n) {
                    let i = null;
                    for (let r = 0, s = e.length; null === i && r < s; r++) i = this.valueSetReplace(e[r], t, n);
                    return i
                }
                valueSetReplace(e, t, n) {
                    let i = e.indexOf(t);
                    return i >= 0 ? (i += n ? 1 : -1, i < 0 ? i = e.length - 1 : i %= e.length, e[i]) : null
                }
            }
            var g = n("Ph77"),
                m = n("V2Gl"),
                d = n("nUoo"),
                c = n("U7Xe"),
                f = n("6QcS"),
                L = n("z+Ny"),
                b = n("p044"),
                N = n("/hu5"),
                p = n("MAz2");
            class E {
                computeDiff(e, t, n) {
                    const i = new _(e, t, {
                            maxComputationTime: n.maxComputationTimeMs,
                            shouldIgnoreTrimWhitespace: n.ignoreTrimWhitespace,
                            shouldComputeCharChanges: !0,
                            shouldMakePrettyDiff: !0,
                            shouldPostProcessCharChanges: !0
                        }).computeDiff(),
                        r = [];
                    let s = null;
                    for (const e of i.changes) {
                        let t, n;
                        t = 0 === e.originalEndLineNumber ? new p.z(e.originalStartLineNumber + 1, e.originalStartLineNumber + 1) : new p.z(e.originalStartLineNumber, e.originalEndLineNumber + 1), n = 0 === e.modifiedEndLineNumber ? new p.z(e.modifiedStartLineNumber + 1, e.modifiedStartLineNumber + 1) : new p.z(e.modifiedStartLineNumber, e.modifiedEndLineNumber + 1);
                        let i = new L.gB(t, n, e.charChanges ? .map((e => new L.iy(new o.e(e.originalStartLineNumber, e.originalStartColumn, e.originalEndLineNumber, e.originalEndColumn), new o.e(e.modifiedStartLineNumber, e.modifiedStartColumn, e.modifiedEndLineNumber, e.modifiedEndColumn)))));
                        s && (s.modified.endLineNumberExclusive !== i.modified.startLineNumber && s.original.endLineNumberExclusive !== i.original.startLineNumber || (i = new L.gB(s.original.join(i.original), s.modified.join(i.modified), s.innerChanges && i.innerChanges ? s.innerChanges.concat(i.innerChanges) : void 0), r.pop())), r.push(i), s = i
                    }
                    return (0, N.eZ)((() => (0, N.DM)(r, ((e, t) => t.original.startLineNumber - e.original.endLineNumberExclusive == t.modified.startLineNumber - e.modified.endLineNumberExclusive && e.original.endLineNumberExclusive < t.original.startLineNumber && e.modified.endLineNumberExclusive < t.modified.startLineNumber)))), new f.h(r, [], i.quitEarly)
                }
            }

            function R(e, t, n, r) {
                return new i.Hs(e, t, n).ComputeDiff(r)
            }
            class v {
                constructor(e) {
                    const t = [],
                        n = [];
                    for (let i = 0, r = e.length; i < r; i++) t[i] = S(e[i], 1), n[i] = q(e[i], 1);
                    this.lines = e, this._startColumns = t, this._endColumns = n
                }
                getElements() {
                    const e = [];
                    for (let t = 0, n = this.lines.length; t < n; t++) e[t] = this.lines[t].substring(this._startColumns[t] - 1, this._endColumns[t] - 1);
                    return e
                }
                getStrictElement(e) {
                    return this.lines[e]
                }
                getStartLineNumber(e) {
                    return e + 1
                }
                getEndLineNumber(e) {
                    return e + 1
                }
                createCharSequence(e, t, n) {
                    const i = [],
                        r = [],
                        s = [];
                    let o = 0;
                    for (let a = t; a <= n; a++) {
                        const t = this.lines[a],
                            l = e ? this._startColumns[a] : 1,
                            u = e ? this._endColumns[a] : t.length + 1;
                        for (let e = l; e < u; e++) i[o] = t.charCodeAt(e - 1), r[o] = a + 1, s[o] = e, o++;
                        !e && a < n && (i[o] = c.m.LineFeed, r[o] = a + 1, s[o] = t.length + 1, o++)
                    }
                    return new w(i, r, s)
                }
            }
            class w {
                constructor(e, t, n) {
                    this._charCodes = e, this._lineNumbers = t, this._columns = n
                }
                toString() {
                    return "[" + this._charCodes.map(((e, t) => (e === c.m.LineFeed ? "\\n" : String.fromCharCode(e)) + `-(${this._lineNumbers[t]},${this._columns[t]})`)).join(", ") + "]"
                }
                _assertIndex(e, t) {
                    if (e < 0 || e >= t.length) throw new Error("Illegal index")
                }
                getElements() {
                    return this._charCodes
                }
                getStartLineNumber(e) {
                    return e > 0 && e === this._lineNumbers.length ? this.getEndLineNumber(e - 1) : (this._assertIndex(e, this._lineNumbers), this._lineNumbers[e])
                }
                getEndLineNumber(e) {
                    return -1 === e ? this.getStartLineNumber(e + 1) : (this._assertIndex(e, this._lineNumbers), this._charCodes[e] === c.m.LineFeed ? this._lineNumbers[e] + 1 : this._lineNumbers[e])
                }
                getStartColumn(e) {
                    return e > 0 && e === this._columns.length ? this.getEndColumn(e - 1) : (this._assertIndex(e, this._columns), this._columns[e])
                }
                getEndColumn(e) {
                    return -1 === e ? this.getStartColumn(e + 1) : (this._assertIndex(e, this._columns), this._charCodes[e] === c.m.LineFeed ? 1 : this._columns[e] + 1)
                }
            }
            class x {
                constructor(e, t, n, i, r, s, o, a) {
                    this.originalStartLineNumber = e, this.originalStartColumn = t, this.originalEndLineNumber = n, this.originalEndColumn = i, this.modifiedStartLineNumber = r, this.modifiedStartColumn = s, this.modifiedEndLineNumber = o, this.modifiedEndColumn = a
                }
                static createFromDiffChange(e, t, n) {
                    const i = t.getStartLineNumber(e.originalStart),
                        r = t.getStartColumn(e.originalStart),
                        s = t.getEndLineNumber(e.originalStart + e.originalLength - 1),
                        o = t.getEndColumn(e.originalStart + e.originalLength - 1),
                        a = n.getStartLineNumber(e.modifiedStart),
                        l = n.getStartColumn(e.modifiedStart),
                        u = n.getEndLineNumber(e.modifiedStart + e.modifiedLength - 1),
                        h = n.getEndColumn(e.modifiedStart + e.modifiedLength - 1);
                    return new x(i, r, s, o, a, l, u, h)
                }
            }
            class C {
                constructor(e, t, n, i, r) {
                    this.originalStartLineNumber = e, this.originalEndLineNumber = t, this.modifiedStartLineNumber = n, this.modifiedEndLineNumber = i, this.charChanges = r
                }
                static createFromDiffResult(e, t, n, i, r, s, o) {
                    let a, l, u, h, g;
                    if (0 === t.originalLength ? (a = n.getStartLineNumber(t.originalStart) - 1, l = 0) : (a = n.getStartLineNumber(t.originalStart), l = n.getEndLineNumber(t.originalStart + t.originalLength - 1)), 0 === t.modifiedLength ? (u = i.getStartLineNumber(t.modifiedStart) - 1, h = 0) : (u = i.getStartLineNumber(t.modifiedStart), h = i.getEndLineNumber(t.modifiedStart + t.modifiedLength - 1)), s && t.originalLength > 0 && t.originalLength < 20 && t.modifiedLength > 0 && t.modifiedLength < 20 && r()) {
                        const s = n.createCharSequence(e, t.originalStart, t.originalStart + t.originalLength - 1),
                            a = i.createCharSequence(e, t.modifiedStart, t.modifiedStart + t.modifiedLength - 1);
                        if (s.getElements().length > 0 && a.getElements().length > 0) {
                            let e = R(s, a, r, !0).changes;
                            o && (e = function(e) {
                                if (e.length <= 1) return e;
                                const t = [e[0]];
                                let n = t[0];
                                for (let i = 1, r = e.length; i < r; i++) {
                                    const r = e[i],
                                        s = r.originalStart - (n.originalStart + n.originalLength),
                                        o = r.modifiedStart - (n.modifiedStart + n.modifiedLength);
                                    Math.min(s, o) < 3 ? (n.originalLength = r.originalStart + r.originalLength - n.originalStart, n.modifiedLength = r.modifiedStart + r.modifiedLength - n.modifiedStart) : (t.push(r), n = r)
                                }
                                return t
                            }(e)), g = [];
                            for (let t = 0, n = e.length; t < n; t++) g.push(x.createFromDiffChange(e[t], s, a))
                        }
                    }
                    return new C(a, l, u, h, g)
                }
            }
            class _ {
                constructor(e, t, n) {
                    this.shouldComputeCharChanges = n.shouldComputeCharChanges, this.shouldPostProcessCharChanges = n.shouldPostProcessCharChanges, this.shouldIgnoreTrimWhitespace = n.shouldIgnoreTrimWhitespace, this.shouldMakePrettyDiff = n.shouldMakePrettyDiff, this.originalLines = e, this.modifiedLines = t, this.original = new v(e), this.modified = new v(t), this.continueLineDiff = M(n.maxComputationTime), this.continueCharDiff = M(0 === n.maxComputationTime ? 0 : Math.min(n.maxComputationTime, 5e3))
                }
                computeDiff() {
                    if (1 === this.original.lines.length && 0 === this.original.lines[0].length) return 1 === this.modified.lines.length && 0 === this.modified.lines[0].length ? {
                        quitEarly: !1,
                        changes: []
                    } : {
                        quitEarly: !1,
                        changes: [{
                            originalStartLineNumber: 1,
                            originalEndLineNumber: 1,
                            modifiedStartLineNumber: 1,
                            modifiedEndLineNumber: this.modified.lines.length,
                            charChanges: void 0
                        }]
                    };
                    if (1 === this.modified.lines.length && 0 === this.modified.lines[0].length) return {
                        quitEarly: !1,
                        changes: [{
                            originalStartLineNumber: 1,
                            originalEndLineNumber: this.original.lines.length,
                            modifiedStartLineNumber: 1,
                            modifiedEndLineNumber: 1,
                            charChanges: void 0
                        }]
                    };
                    const e = R(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff),
                        t = e.changes,
                        n = e.quitEarly;
                    if (this.shouldIgnoreTrimWhitespace) {
                        const e = [];
                        for (let n = 0, i = t.length; n < i; n++) e.push(C.createFromDiffResult(this.shouldIgnoreTrimWhitespace, t[n], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
                        return {
                            quitEarly: n,
                            changes: e
                        }
                    }
                    const i = [];
                    let r = 0,
                        s = 0;
                    for (let e = -1, n = t.length; e < n; e++) {
                        const o = e + 1 < n ? t[e + 1] : null,
                            a = o ? o.originalStart : this.originalLines.length,
                            l = o ? o.modifiedStart : this.modifiedLines.length;
                        for (; r < a && s < l;) {
                            const e = this.originalLines[r],
                                t = this.modifiedLines[s];
                            if (e !== t) {
                                {
                                    let n = S(e, 1),
                                        o = S(t, 1);
                                    for (; n > 1 && o > 1 && e.charCodeAt(n - 2) === t.charCodeAt(o - 2);) n--, o--;
                                    (n > 1 || o > 1) && this._pushTrimWhitespaceCharChange(i, r + 1, 1, n, s + 1, 1, o)
                                } {
                                    let n = q(e, 1),
                                        o = q(t, 1);
                                    const a = e.length + 1,
                                        l = t.length + 1;
                                    for (; n < a && o < l && e.charCodeAt(n - 1) === e.charCodeAt(o - 1);) n++, o++;
                                    (n < a || o < l) && this._pushTrimWhitespaceCharChange(i, r + 1, n, a, s + 1, o, l)
                                }
                            }
                            r++, s++
                        }
                        o && (i.push(C.createFromDiffResult(this.shouldIgnoreTrimWhitespace, o, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges)), r += o.originalLength, s += o.modifiedLength)
                    }
                    return {
                        quitEarly: n,
                        changes: i
                    }
                }
                _pushTrimWhitespaceCharChange(e, t, n, i, r, s, o) {
                    if (this._mergeTrimWhitespaceCharChange(e, t, n, i, r, s, o)) return;
                    let a;
                    this.shouldComputeCharChanges && (a = [new x(t, n, t, i, r, s, r, o)]), e.push(new C(t, t, r, r, a))
                }
                _mergeTrimWhitespaceCharChange(e, t, n, i, r, s, o) {
                    const a = e.length;
                    if (0 === a) return !1;
                    const l = e[a - 1];
                    return 0 !== l.originalEndLineNumber && 0 !== l.modifiedEndLineNumber && (l.originalEndLineNumber === t && l.modifiedEndLineNumber === r ? (this.shouldComputeCharChanges && l.charChanges && l.charChanges.push(new x(t, n, t, i, r, s, r, o)), !0) : l.originalEndLineNumber + 1 === t && l.modifiedEndLineNumber + 1 === r && (l.originalEndLineNumber = t, l.modifiedEndLineNumber = r, this.shouldComputeCharChanges && l.charChanges && l.charChanges.push(new x(t, n, t, i, r, s, r, o)), !0))
                }
            }

            function S(e, t) {
                const n = (0, b.LC)(e);
                return -1 === n ? t : n + 1
            }

            function q(e, t) {
                const n = (0, b.ow)(e);
                return -1 === n ? t : n + 2
            }

            function M(e) {
                if (0 === e) return () => !0;
                const t = Date.now();
                return () => Date.now() - t < e
            }
            var y = n("qruf");
            const A = () => new y.DW;
            var z = n("7eUP"),
                T = n("PUdK"),
                I = n("KFZf");

            function P(e) {
                const t = [];
                for (const n of e) {
                    const e = Number(n);
                    (e || 0 === e && "" !== n.replace(/\s/g, "")) && t.push(e)
                }
                return t
            }

            function U(e, t, n, i) {
                return {
                    red: e / 255,
                    blue: n / 255,
                    green: t / 255,
                    alpha: i
                }
            }

            function D(e, t) {
                const n = t.index,
                    i = t[0].length;
                if (!n) return;
                const r = e.positionAt(n);
                return {
                    startLineNumber: r.lineNumber,
                    startColumn: r.column,
                    endLineNumber: r.lineNumber,
                    endColumn: r.column + i
                }
            }

            function O(e, t) {
                if (!e) return;
                const n = I.Il.Format.CSS.parseHex(t);
                return n ? {
                    range: e,
                    color: U(n.rgba.r, n.rgba.g, n.rgba.b, n.rgba.a)
                } : void 0
            }

            function W(e, t, n) {
                if (!e || 1 !== t.length) return;
                const i = P(t[0].values());
                return {
                    range: e,
                    color: U(i[0], i[1], i[2], n ? i[3] : 1)
                }
            }

            function F(e, t, n) {
                if (!e || 1 !== t.length) return;
                const i = P(t[0].values()),
                    r = new I.Il(new I.Oz(i[0], i[1] / 100, i[2] / 100, n ? i[3] : 1));
                return {
                    range: e,
                    color: U(r.rgba.r, r.rgba.g, r.rgba.b, r.rgba.a)
                }
            }

            function j(e, t) {
                return "string" == typeof e ? [...e.matchAll(t)] : e.findMatches(t)
            }
            const k = new RegExp("\\bMARK:\\s*(.*)$", "d"),
                B = /^-+|-+$/g;

            function $(e, t, n) {
                k.lastIndex = 0;
                const i = k.exec(e);
                if (i) {
                    const e = {
                        startLineNumber: t,
                        startColumn: i.indices[1][0] + 1,
                        endLineNumber: t,
                        endColumn: i.indices[1][1] + 1
                    };
                    if (e.endColumn > e.startColumn) {
                        const t = {
                            range: e,
                            ...V(i[1]),
                            shouldBeInComments: !0
                        };
                        (t.text || t.hasSeparatorLine) && n.push(t)
                    }
                }
            }

            function V(e) {
                const t = (e = e.trim()).startsWith("-");
                return {
                    text: e = e.replace(B, ""),
                    hasSeparatorLine: t
                }
            }
            class X extends a.v {
                get uri() {
                    return this._uri
                }
                get eol() {
                    return this._eol
                }
                getValue() {
                    return this.getText()
                }
                findMatches(e) {
                    const t = [];
                    for (let n = 0; n < this._lines.length; n++) {
                        const i = this._lines[n],
                            r = this.offsetAt(new s.L(n + 1, 1)),
                            o = i.matchAll(e);
                        for (const e of o)(e.index || 0 === e.index) && (e.index = e.index + r), t.push(e)
                    }
                    return t
                }
                getLinesContent() {
                    return this._lines.slice(0)
                }
                getLineCount() {
                    return this._lines.length
                }
                getLineContent(e) {
                    return this._lines[e - 1]
                }
                getWordAtPosition(e, t) {
                    const n = (0, l.t2)(e.column, (0, l.eq)(t), this._lines[e.lineNumber - 1], 0);
                    return n ? new o.e(e.lineNumber, n.startColumn, e.lineNumber, n.endColumn) : null
                }
                getWordUntilPosition(e, t) {
                    const n = this.getWordAtPosition(e, t);
                    return n ? {
                        word: this._lines[e.lineNumber - 1].substring(n.startColumn - 1, e.column - 1),
                        startColumn: n.startColumn,
                        endColumn: e.column
                    } : {
                        word: "",
                        startColumn: e.column,
                        endColumn: e.column
                    }
                }
                words(e) {
                    const t = this._lines,
                        n = this._wordenize.bind(this);
                    let i = 0,
                        r = "",
                        s = 0,
                        o = [];
                    return {*[Symbol.iterator]() {
                            for (;;)
                                if (s < o.length) {
                                    const e = r.substring(o[s].start, o[s].end);
                                    s += 1, yield e
                                } else {
                                    if (!(i < t.length)) break;
                                    r = t[i], o = n(r, e), s = 0, i += 1
                                }
                        }
                    }
                }
                getLineWords(e, t) {
                    const n = this._lines[e - 1],
                        i = this._wordenize(n, t),
                        r = [];
                    for (const e of i) r.push({
                        word: n.substring(e.start, e.end),
                        startColumn: e.start + 1,
                        endColumn: e.end + 1
                    });
                    return r
                }
                _wordenize(e, t) {
                    const n = [];
                    let i;
                    for (t.lastIndex = 0;
                        (i = t.exec(e)) && 0 !== i[0].length;) n.push({
                        start: i.index,
                        end: i.index + i[0].length
                    });
                    return n
                }
                getValueInRange(e) {
                    if ((e = this._validateRange(e)).startLineNumber === e.endLineNumber) return this._lines[e.startLineNumber - 1].substring(e.startColumn - 1, e.endColumn - 1);
                    const t = this._eol,
                        n = e.startLineNumber - 1,
                        i = e.endLineNumber - 1,
                        r = [];
                    r.push(this._lines[n].substring(e.startColumn - 1));
                    for (let e = n + 1; e < i; e++) r.push(this._lines[e]);
                    return r.push(this._lines[i].substring(0, e.endColumn - 1)), r.join(t)
                }
                offsetAt(e) {
                    return e = this._validatePosition(e), this._ensureLineStarts(), this._lineStarts.getPrefixSum(e.lineNumber - 2) + (e.column - 1)
                }
                positionAt(e) {
                    e = Math.floor(e), e = Math.max(0, e), this._ensureLineStarts();
                    const t = this._lineStarts.getIndexOf(e),
                        n = this._lines[t.index].length;
                    return {
                        lineNumber: 1 + t.index,
                        column: 1 + Math.min(t.remainder, n)
                    }
                }
                _validateRange(e) {
                    const t = this._validatePosition({
                            lineNumber: e.startLineNumber,
                            column: e.startColumn
                        }),
                        n = this._validatePosition({
                            lineNumber: e.endLineNumber,
                            column: e.endColumn
                        });
                    return t.lineNumber !== e.startLineNumber || t.column !== e.startColumn || n.lineNumber !== e.endLineNumber || n.column !== e.endColumn ? {
                        startLineNumber: t.lineNumber,
                        startColumn: t.column,
                        endLineNumber: n.lineNumber,
                        endColumn: n.column
                    } : e
                }
                _validatePosition(e) {
                    if (!s.L.isIPosition(e)) throw new Error("bad position");
                    let {
                        lineNumber: t,
                        column: n
                    } = e, i = !1;
                    if (t < 1) t = 1, n = 1, i = !0;
                    else if (t > this._lines.length) t = this._lines.length, n = this._lines[t - 1].length + 1, i = !0;
                    else {
                        const e = this._lines[t - 1].length + 1;
                        n < 1 ? (n = 1, i = !0) : n > e && (n = e, i = !0)
                    }
                    return i ? {
                        lineNumber: t,
                        column: n
                    } : e
                }
            }
            class K {
                constructor(e, t) {
                    this._host = e, this._models = Object.create(null), this._foreignModuleFactory = t, this._foreignModule = null
                }
                dispose() {
                    this._models = Object.create(null)
                }
                _getModel(e) {
                    return this._models[e]
                }
                _getModels() {
                    const e = [];
                    return Object.keys(this._models).forEach((t => e.push(this._models[t]))), e
                }
                acceptNewModel(e) {
                    this._models[e.url] = new X(r.ov.parse(e.url), e.lines, e.EOL, e.versionId)
                }
                acceptModelChanged(e, t) {
                    this._models[e] && this._models[e].onEvents(t)
                }
                acceptRemovedModel(e) {
                    this._models[e] && delete this._models[e]
                }
                async computeUnicodeHighlights(e, t, n) {
                    const i = this._getModel(e);
                    return i ? d.a.computeUnicodeHighlights(i, t, n) : {
                        ranges: [],
                        hasMore: !1,
                        ambiguousCharacterCount: 0,
                        invisibleCharacterCount: 0,
                        nonBasicAsciiCharacterCount: 0
                    }
                }
                async findSectionHeaders(e, t) {
                    const n = this._getModel(e);
                    return n ? function(e, t) {
                        let n = [];
                        if (t.findRegionSectionHeaders && t.foldingRules ? .markers) {
                            const i = function(e, t) {
                                const n = [],
                                    i = e.getLineCount();
                                for (let r = 1; r <= i; r++) {
                                    const i = e.getLineContent(r),
                                        s = i.match(t.foldingRules.markers.start);
                                    if (s) {
                                        const e = {
                                            startLineNumber: r,
                                            startColumn: s[0].length + 1,
                                            endLineNumber: r,
                                            endColumn: i.length + 1
                                        };
                                        if (e.endColumn > e.startColumn) {
                                            const t = {
                                                range: e,
                                                ...V(i.substring(s[0].length)),
                                                shouldBeInComments: !1
                                            };
                                            (t.text || t.hasSeparatorLine) && n.push(t)
                                        }
                                    }
                                }
                                return n
                            }(e, t);
                            n = n.concat(i)
                        }
                        if (t.findMarkSectionHeaders) {
                            const t = function(e) {
                                const t = [],
                                    n = e.getLineCount();
                                for (let i = 1; i <= n; i++) $(e.getLineContent(i), i, t);
                                return t
                            }(e);
                            n = n.concat(t)
                        }
                        return n
                    }(n, t) : []
                }
                async computeDiff(e, t, n, i) {
                    const r = this._getModel(e),
                        s = this._getModel(t);
                    return r && s ? K.computeDiff(r, s, n, i) : null
                }
                static computeDiff(e, t, n, i) {
                    const r = "advanced" === i ? A() : new E,
                        s = e.getLinesContent(),
                        o = t.getLinesContent(),
                        a = r.computeDiff(s, o, n);

                    function l(e) {
                        return e.map((e => [e.original.startLineNumber, e.original.endLineNumberExclusive, e.modified.startLineNumber, e.modified.endLineNumberExclusive, e.innerChanges ? .map((e => [e.originalRange.startLineNumber, e.originalRange.startColumn, e.originalRange.endLineNumber, e.originalRange.endColumn, e.modifiedRange.startLineNumber, e.modifiedRange.startColumn, e.modifiedRange.endLineNumber, e.modifiedRange.endColumn]))]))
                    }
                    return {
                        identical: !(a.changes.length > 0) && this._modelsAreIdentical(e, t),
                        quitEarly: a.hitTimeout,
                        changes: l(a.changes),
                        moves: a.moves.map((e => [e.lineRangeMapping.original.startLineNumber, e.lineRangeMapping.original.endLineNumberExclusive, e.lineRangeMapping.modified.startLineNumber, e.lineRangeMapping.modified.endLineNumberExclusive, l(e.changes)]))
                    }
                }
                static _modelsAreIdentical(e, t) {
                    const n = e.getLineCount();
                    if (n !== t.getLineCount()) return !1;
                    for (let i = 1; i <= n; i++)
                        if (e.getLineContent(i) !== t.getLineContent(i)) return !1;
                    return !0
                }
                async computeDirtyDiff(e, t, n) {
                    const i = this._getModel(e),
                        r = this._getModel(t);
                    if (!i || !r) return null;
                    const s = i.getLinesContent(),
                        o = r.getLinesContent();
                    return new _(s, o, {
                        shouldComputeCharChanges: !1,
                        shouldPostProcessCharChanges: !1,
                        shouldIgnoreTrimWhitespace: n,
                        shouldMakePrettyDiff: !0,
                        maxComputationTime: 1e3
                    }).computeDiff().changes
                }
                static {
                    this._diffLimit = 1e5
                }
                async computeMoreMinimalEdits(e, t, n) {
                    const r = this._getModel(e);
                    if (!r) return t;
                    const s = [];
                    let a;
                    t = t.slice(0).sort(((e, t) => e.range && t.range ? o.e.compareRangesUsingStarts(e.range, t.range) : (e.range ? 0 : 1) - (t.range ? 0 : 1)));
                    let l = 0;
                    for (let e = 1; e < t.length; e++) o.e.getEndPosition(t[l].range).equals(o.e.getStartPosition(t[e].range)) ? (t[l].range = o.e.fromPositions(o.e.getStartPosition(t[l].range), o.e.getEndPosition(t[e].range)), t[l].text += t[e].text) : (l++, t[l] = t[e]);
                    t.length = l + 1;
                    for (let {
                            range: e,
                            text: l,
                            eol: u
                        } of t) {
                        if ("number" == typeof u && (a = u), o.e.isEmpty(e) && !l) continue;
                        const t = r.getValueInRange(e);
                        if (l = l.replace(/\r\n|\n|\r/g, r.eol), t === l) continue;
                        if (Math.max(l.length, t.length) > K._diffLimit) {
                            s.push({
                                range: e,
                                text: l
                            });
                            continue
                        }
                        const h = (0, i.a$)(t, l, n),
                            g = r.offsetAt(o.e.lift(e).getStartPosition());
                        for (const e of h) {
                            const t = r.positionAt(g + e.originalStart),
                                n = r.positionAt(g + e.originalStart + e.originalLength),
                                i = {
                                    text: l.substr(e.modifiedStart, e.modifiedLength),
                                    range: {
                                        startLineNumber: t.lineNumber,
                                        startColumn: t.column,
                                        endLineNumber: n.lineNumber,
                                        endColumn: n.column
                                    }
                                };
                            r.getValueInRange(i.range) !== i.text && s.push(i)
                        }
                    }
                    return "number" == typeof a && s.push({
                        eol: a,
                        text: "",
                        range: {
                            startLineNumber: 0,
                            startColumn: 0,
                            endLineNumber: 0,
                            endColumn: 0
                        }
                    }), s
                }
                computeHumanReadableDiff(e, t, n) {
                    const i = this._getModel(e);
                    if (!i) return t;
                    const r = [];
                    let a;
                    t = t.slice(0).sort(((e, t) => e.range && t.range ? o.e.compareRangesUsingStarts(e.range, t.range) : (e.range ? 0 : 1) - (t.range ? 0 : 1)));
                    for (let {
                            range: l,
                            text: u,
                            eol: h
                        } of t) {
                        if ("number" == typeof h && (a = h), o.e.isEmpty(l) && !u) continue;
                        const g = i.getValueInRange(l);
                        if (u = u.replace(/\r\n|\n|\r/g, i.eol), g === u) continue;
                        if (Math.max(u.length, g.length) > K._diffLimit) {
                            r.push({
                                range: l,
                                text: u
                            });
                            continue
                        }
                        const m = g.split(/\r\n|\n|\r/),
                            d = u.split(/\r\n|\n|\r/),
                            c = A().computeDiff(m, d, n),
                            f = o.e.lift(l).getStartPosition();

                        function L(e, t) {
                            return new s.L(e.lineNumber + t.lineNumber - 1, 1 === t.lineNumber ? e.column + t.column - 1 : t.column)
                        }

                        function b(e, t) {
                            const n = [];
                            for (let i = t.startLineNumber; i <= t.endLineNumber; i++) {
                                const r = e[i - 1];
                                i === t.startLineNumber && i === t.endLineNumber ? n.push(r.substring(t.startColumn - 1, t.endColumn - 1)) : i === t.startLineNumber ? n.push(r.substring(t.startColumn - 1)) : i === t.endLineNumber ? n.push(r.substring(0, t.endColumn - 1)) : n.push(r)
                            }
                            return n
                        }
                        for (const N of c.changes) {
                            if (!N.innerChanges) throw new T.he("The experimental diff algorithm always produces inner changes");
                            for (const p of N.innerChanges) r.push({
                                range: o.e.fromPositions(L(f, p.originalRange.getStartPosition()), L(f, p.originalRange.getEndPosition())),
                                text: b(d, p.modifiedRange).join(i.eol)
                            })
                        }
                    }
                    return "number" == typeof a && r.push({
                        eol: a,
                        text: "",
                        range: {
                            startLineNumber: 0,
                            startColumn: 0,
                            endLineNumber: 0,
                            endColumn: 0
                        }
                    }), r
                }
                async computeLinks(e) {
                    const t = this._getModel(e);
                    return t ? (0, u.E)(t) : null
                }
                async computeDefaultDocumentColors(e) {
                    const t = this._getModel(e);
                    return t ? function(e) {
                        return e && "function" == typeof e.getValue && "function" == typeof e.positionAt ? function(e) {
                            const t = [],
                                n = j(e, /\b(rgb|rgba|hsl|hsla)(\([0-9\s,.\%]*\))|(#)([A-Fa-f0-9]{3})\b|(#)([A-Fa-f0-9]{4})\b|(#)([A-Fa-f0-9]{6})\b|(#)([A-Fa-f0-9]{8})\b/gm);
                            if (n.length > 0)
                                for (const i of n) {
                                    const n = i.filter((e => void 0 !== e)),
                                        r = n[1],
                                        s = n[2];
                                    if (!s) continue;
                                    let o;
                                    if ("rgb" === r) {
                                        const t = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*\)$/gm;
                                        o = W(D(e, i), j(s, t), !1)
                                    } else if ("rgba" === r) {
                                        const t = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
                                        o = W(D(e, i), j(s, t), !0)
                                    } else if ("hsl" === r) {
                                        const t = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*\)$/gm;
                                        o = F(D(e, i), j(s, t), !1)
                                    } else if ("hsla" === r) {
                                        const t = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
                                        o = F(D(e, i), j(s, t), !0)
                                    } else "#" === r && (o = O(D(e, i), r + s));
                                    o && t.push(o)
                                }
                            return t
                        }(e) : []
                    }(t) : null
                }
                static {
                    this._suggestionsLimit = 1e4
                }
                async textualSuggest(e, t, n, i) {
                    const r = new m.G,
                        s = new RegExp(n, i),
                        o = new Set;
                    e: for (const n of e) {
                        const e = this._getModel(n);
                        if (e)
                            for (const n of e.words(s))
                                if (n !== t && isNaN(Number(n)) && (o.add(n), o.size > K._suggestionsLimit)) break e
                    }
                    return {
                        words: Array.from(o),
                        duration: r.elapsed()
                    }
                }
                async computeWordRanges(e, t, n, i) {
                    const r = this._getModel(e);
                    if (!r) return Object.create(null);
                    const s = new RegExp(n, i),
                        o = Object.create(null);
                    for (let e = t.startLineNumber; e < t.endLineNumber; e++) {
                        const t = r.getLineWords(e, s);
                        for (const n of t) {
                            if (!isNaN(Number(n.word))) continue;
                            let t = o[n.word];
                            t || (t = [], o[n.word] = t), t.push({
                                startLineNumber: e,
                                startColumn: n.startColumn,
                                endLineNumber: e,
                                endColumn: n.endColumn
                            })
                        }
                    }
                    return o
                }
                async navigateValueSet(e, t, n, i, r) {
                    const s = this._getModel(e);
                    if (!s) return null;
                    const o = new RegExp(i, r);
                    t.startColumn === t.endColumn && (t = {
                        startLineNumber: t.startLineNumber,
                        startColumn: t.startColumn,
                        endLineNumber: t.endLineNumber,
                        endColumn: t.endColumn + 1
                    });
                    const a = s.getValueInRange(t),
                        l = s.getWordAtPosition({
                            lineNumber: t.startLineNumber,
                            column: t.startColumn
                        }, o);
                    if (!l) return null;
                    const u = s.getValueInRange(l);
                    return h.INSTANCE.navigateValueSet(t, a, l, u, n)
                }
                loadForeignModule(e, t, n) {
                    const i = {
                        host: (0, z.IU)(n, ((e, t) => this._host.fhr(e, t))),
                        getMirrorModels: () => this._getModels()
                    };
                    return this._foreignModuleFactory ? (this._foreignModule = this._foreignModuleFactory(i, t), Promise.resolve((0, z.$E)(this._foreignModule))) : Promise.reject(new Error("Unexpected usage"))
                }
                fmr(e, t) {
                    if (!this._foreignModule || "function" != typeof this._foreignModule[e]) return Promise.reject(new Error("Missing requestHandler or method: " + e));
                    try {
                        return Promise.resolve(this._foreignModule[e].apply(this._foreignModule, t))
                    } catch (e) {
                        return Promise.reject(e)
                    }
                }
            }
            "function" == typeof importScripts && (globalThis.monaco = (0, g.O)())
        }
    }
]);
//# sourceMappingURL=https://hrcdn.net/fcore/assets/sourcemaps/defaultVendors-node_modules_vscode_vscode_src_vs_base_common_diff_diffChange_js-node_modules_-0535b1-7d80d1c5.js.map