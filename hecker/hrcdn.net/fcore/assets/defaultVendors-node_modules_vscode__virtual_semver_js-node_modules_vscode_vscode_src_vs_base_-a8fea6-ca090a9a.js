"use strict";
(self.webpackChunkhackerrank_lib = self.webpackChunkhackerrank_lib || []).push([
    ["defaultVendors-node_modules_vscode__virtual_semver_js-node_modules_vscode_vscode_src_vs_base_-a8fea6"], {
        uBBT: (e, t, n) => {
            n.d(t, {
                p: () => r
            });
            var r = {
                exports: {}
            }
        },
        t5wJ: (e, t, n) => {
            function r(e, t, n, r) {
                var i, s = arguments.length,
                    o = s < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
                if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r);
                else
                    for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (o = (s < 3 ? i(o) : s > 3 ? i(t, n, o) : i(t, n)) || o);
                return s > 3 && o && Object.defineProperty(t, n, o), o
            }

            function i(e, t) {
                return function(n, r) {
                    t(n, r, e)
                }
            }
            n.d(t, {
                f: () => i,
                g: () => r
            })
        },
        "80+w": (e, t, n) => {
            n.d(t, {
                Z: () => fe
            });
            var r = n("ziTh"),
                i = {
                    exports: {}
                };
            i.exports = {
                defaults: {
                    baseUrl: null,
                    breaks: !1,
                    extensions: null,
                    gfm: !0,
                    headerIds: !0,
                    headerPrefix: "",
                    highlight: null,
                    langPrefix: "language-",
                    mangle: !0,
                    pedantic: !1,
                    renderer: null,
                    sanitize: !1,
                    sanitizer: null,
                    silent: !1,
                    smartLists: !1,
                    smartypants: !1,
                    tokenizer: null,
                    walkTokens: null,
                    xhtml: !1
                },
                getDefaults: function() {
                    return {
                        baseUrl: null,
                        breaks: !1,
                        extensions: null,
                        gfm: !0,
                        headerIds: !0,
                        headerPrefix: "",
                        highlight: null,
                        langPrefix: "language-",
                        mangle: !0,
                        pedantic: !1,
                        renderer: null,
                        sanitize: !1,
                        sanitizer: null,
                        silent: !1,
                        smartLists: !1,
                        smartypants: !1,
                        tokenizer: null,
                        walkTokens: null,
                        xhtml: !1
                    }
                },
                changeDefaults: function(e) {
                    i.exports.defaults = e
                }
            };
            const s = /[&<>"']/,
                o = /[&<>"']/g,
                a = /[<>"']|&(?!#?\w+;)/,
                c = /[<>"']|&(?!#?\w+;)/g,
                l = {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#39;"
                },
                u = e => l[e],
                h = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi;

            function d(e) {
                return e.replace(h, ((e, t) => "colon" === (t = t.toLowerCase()) ? ":" : "#" === t.charAt(0) ? "x" === t.charAt(1) ? String.fromCharCode(parseInt(t.substring(2), 16)) : String.fromCharCode(+t.substring(1)) : ""))
            }
            const f = /(^|[^\[])\^/g,
                p = /[^\w:]/g,
                g = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i,
                m = {},
                b = /^[^:]+:\/*[^/]*$/,
                _ = /^([^:]+:)[\s\S]*$/,
                v = /^([^:]+:\/*[^/]*)[\s\S]*$/;

            function w(e, t) {
                m[" " + e] || (b.test(e) ? m[" " + e] = e + "/" : m[" " + e] = y(e, "/", !0));
                const n = -1 === (e = m[" " + e]).indexOf(":");
                return "//" === t.substring(0, 2) ? n ? t : e.replace(_, "$1") + t : "/" === t.charAt(0) ? n ? t : e.replace(v, "$1") + t : e + t
            }

            function y(e, t, n) {
                const r = e.length;
                if (0 === r) return "";
                let i = 0;
                for (; i < r;) {
                    const s = e.charAt(r - i - 1);
                    if (s !== t || n) {
                        if (s === t || !n) break;
                        i++
                    } else i++
                }
                return e.substr(0, r - i)
            }
            var x = {
                escape: function(e, t) {
                    if (t) {
                        if (s.test(e)) return e.replace(o, u)
                    } else if (a.test(e)) return e.replace(c, u);
                    return e
                },
                unescape: d,
                edit: function(e, t) {
                    e = e.source || e, t = t || "";
                    const n = {
                        replace: (t, r) => (r = (r = r.source || r).replace(f, "$1"), e = e.replace(t, r), n),
                        getRegex: () => new RegExp(e, t)
                    };
                    return n
                },
                cleanUrl: function(e, t, n) {
                    if (e) {
                        let e;
                        try {
                            e = decodeURIComponent(d(n)).replace(p, "").toLowerCase()
                        } catch (e) {
                            return null
                        }
                        if (0 === e.indexOf("javascript:") || 0 === e.indexOf("vbscript:") || 0 === e.indexOf("data:")) return null
                    }
                    t && !g.test(n) && (n = w(t, n));
                    try {
                        n = encodeURI(n).replace(/%25/g, "%")
                    } catch (e) {
                        return null
                    }
                    return n
                },
                resolveUrl: w,
                noopTest: {
                    exec: function() {}
                },
                merge: function(e) {
                    let t, n, r = 1;
                    for (; r < arguments.length; r++)
                        for (n in t = arguments[r], t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
                    return e
                },
                splitCells: function(e, t) {
                    const n = e.replace(/\|/g, ((e, t, n) => {
                        let r = !1,
                            i = t;
                        for (; --i >= 0 && "\\" === n[i];) r = !r;
                        return r ? "|" : " |"
                    })).split(/ \|/);
                    let r = 0;
                    if (n[0].trim() || n.shift(), n[n.length - 1].trim() || n.pop(), n.length > t) n.splice(t);
                    else
                        for (; n.length < t;) n.push("");
                    for (; r < n.length; r++) n[r] = n[r].trim().replace(/\\\|/g, "|");
                    return n
                },
                rtrim: y,
                findClosingBracket: function(e, t) {
                    if (-1 === e.indexOf(t[1])) return -1;
                    const n = e.length;
                    let r = 0,
                        i = 0;
                    for (; i < n; i++)
                        if ("\\" === e[i]) i++;
                        else if (e[i] === t[0]) r++;
                    else if (e[i] === t[1] && (r--, r < 0)) return i;
                    return -1
                },
                checkSanitizeDeprecation: function(e) {
                    e && e.sanitize && !e.silent && r.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options")
                },
                repeatString: function(e, t) {
                    if (t < 1) return "";
                    let n = "";
                    for (; t > 1;) 1 & t && (n += e), t >>= 1, e += e;
                    return n + e
                }
            };
            const {
                defaults: k
            } = i.exports, {
                rtrim: C,
                splitCells: I,
                escape: S,
                findClosingBracket: E
            } = x;

            function T(e, t, n, r) {
                const i = t.href,
                    s = t.title ? S(t.title) : null,
                    o = e[1].replace(/\\([\[\]])/g, "$1");
                if ("!" !== e[0].charAt(0)) {
                    r.state.inLink = !0;
                    const e = {
                        type: "link",
                        raw: n,
                        href: i,
                        title: s,
                        text: o,
                        tokens: r.inlineTokens(o, [])
                    };
                    return r.state.inLink = !1, e
                }
                return {
                    type: "image",
                    raw: n,
                    href: i,
                    title: s,
                    text: S(o)
                }
            }
            var L = class {
                constructor(e) {
                    this.options = e || k
                }
                space(e) {
                    const t = this.rules.block.newline.exec(e);
                    if (t) return t[0].length > 1 ? {
                        type: "space",
                        raw: t[0]
                    } : {
                        raw: "\n"
                    }
                }
                code(e) {
                    const t = this.rules.block.code.exec(e);
                    if (t) {
                        const e = t[0].replace(/^ {1,4}/gm, "");
                        return {
                            type: "code",
                            raw: t[0],
                            codeBlockStyle: "indented",
                            text: this.options.pedantic ? e : C(e, "\n")
                        }
                    }
                }
                fences(e) {
                    const t = this.rules.block.fences.exec(e);
                    if (t) {
                        const e = t[0],
                            n = function(e, t) {
                                const n = e.match(/^(\s+)(?:```)/);
                                if (null === n) return t;
                                const r = n[1];
                                return t.split("\n").map((e => {
                                    const t = e.match(/^\s+/);
                                    if (null === t) return e;
                                    const [n] = t;
                                    return n.length >= r.length ? e.slice(r.length) : e
                                })).join("\n")
                            }(e, t[3] || "");
                        return {
                            type: "code",
                            raw: e,
                            lang: t[2] ? t[2].trim() : t[2],
                            text: n
                        }
                    }
                }
                heading(e) {
                    const t = this.rules.block.heading.exec(e);
                    if (t) {
                        let e = t[2].trim();
                        if (/#$/.test(e)) {
                            const t = C(e, "#");
                            this.options.pedantic ? e = t.trim() : t && !/ $/.test(t) || (e = t.trim())
                        }
                        const n = {
                            type: "heading",
                            raw: t[0],
                            depth: t[1].length,
                            text: e,
                            tokens: []
                        };
                        return this.lexer.inline(n.text, n.tokens), n
                    }
                }
                hr(e) {
                    const t = this.rules.block.hr.exec(e);
                    if (t) return {
                        type: "hr",
                        raw: t[0]
                    }
                }
                blockquote(e) {
                    const t = this.rules.block.blockquote.exec(e);
                    if (t) {
                        const e = t[0].replace(/^ *> ?/gm, "");
                        return {
                            type: "blockquote",
                            raw: t[0],
                            tokens: this.lexer.blockTokens(e, []),
                            text: e
                        }
                    }
                }
                list(e) {
                    let t = this.rules.block.list.exec(e);
                    if (t) {
                        let n, r, i, s, o, a, c, l, u, h, d = t[1].trim();
                        const f = d.length > 1,
                            p = {
                                type: "list",
                                raw: "",
                                ordered: f,
                                start: f ? +d.slice(0, -1) : "",
                                loose: !1,
                                items: []
                            };
                        d = f ? `\\d{1,9}\\${d.slice(-1)}` : `\\${d}`, this.options.pedantic && (d = f ? d : "[*+-]");
                        const g = new RegExp(`^( {0,3}${d})((?: [^\\n]*| *)(?:\\n[^\\n]*)*(?:\\n|$))`);
                        for (; e && !this.rules.block.hr.test(e) && (t = g.exec(e));) {
                            u = t[2].split("\n"), this.options.pedantic ? (s = 2, h = u[0].trimLeft()) : (s = t[2].search(/[^ ]/), s = t[1].length + (s > 4 ? 1 : s), h = u[0].slice(s - t[1].length)), a = !1, n = t[0], !u[0] && /^ *$/.test(u[1]) && (n = t[1] + u.slice(0, 2).join("\n") + "\n", p.loose = !0, u = []);
                            const d = new RegExp(`^ {0,${Math.min(3,s-1)}}(?:[*+-]|\\d{1,9}[.)])`);
                            for (o = 1; o < u.length; o++) {
                                if (l = u[o], this.options.pedantic && (l = l.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), d.test(l)) {
                                    n = t[1] + u.slice(0, o).join("\n") + "\n";
                                    break
                                }
                                if (a) {
                                    if (!(l.search(/[^ ]/) >= s) && l.trim()) {
                                        n = t[1] + u.slice(0, o).join("\n") + "\n";
                                        break
                                    }
                                    h += "\n" + l.slice(s)
                                } else l.trim() || (a = !0), l.search(/[^ ]/) >= s ? h += "\n" + l.slice(s) : h += "\n" + l
                            }
                            p.loose || (c ? p.loose = !0 : /\n *\n *$/.test(n) && (c = !0)), this.options.gfm && (r = /^\[[ xX]\] /.exec(h), r && (i = "[ ] " !== r[0], h = h.replace(/^\[[ xX]\] +/, ""))), p.items.push({
                                type: "list_item",
                                raw: n,
                                task: !!r,
                                checked: i,
                                loose: !1,
                                text: h
                            }), p.raw += n, e = e.slice(n.length)
                        }
                        p.items[p.items.length - 1].raw = n.trimRight(), p.items[p.items.length - 1].text = h.trimRight(), p.raw = p.raw.trimRight();
                        const m = p.items.length;
                        for (o = 0; o < m; o++) this.lexer.state.top = !1, p.items[o].tokens = this.lexer.blockTokens(p.items[o].text, []), p.items[o].tokens.some((e => "space" === e.type)) && (p.loose = !0, p.items[o].loose = !0);
                        return p
                    }
                }
                html(e) {
                    const t = this.rules.block.html.exec(e);
                    if (t) {
                        const e = {
                            type: "html",
                            raw: t[0],
                            pre: !this.options.sanitizer && ("pre" === t[1] || "script" === t[1] || "style" === t[1]),
                            text: t[0]
                        };
                        return this.options.sanitize && (e.type = "paragraph", e.text = this.options.sanitizer ? this.options.sanitizer(t[0]) : S(t[0]), e.tokens = [], this.lexer.inline(e.text, e.tokens)), e
                    }
                }
                def(e) {
                    const t = this.rules.block.def.exec(e);
                    if (t) return t[3] && (t[3] = t[3].substring(1, t[3].length - 1)), {
                        type: "def",
                        tag: t[1].toLowerCase().replace(/\s+/g, " "),
                        raw: t[0],
                        href: t[2],
                        title: t[3]
                    }
                }
                table(e) {
                    const t = this.rules.block.table.exec(e);
                    if (t) {
                        const e = {
                            type: "table",
                            header: I(t[1]).map((e => ({
                                text: e
                            }))),
                            align: t[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
                            rows: t[3] ? t[3].replace(/\n$/, "").split("\n") : []
                        };
                        if (e.header.length === e.align.length) {
                            e.raw = t[0];
                            let n, r, i, s, o = e.align.length;
                            for (n = 0; n < o; n++) /^ *-+: *$/.test(e.align[n]) ? e.align[n] = "right" : /^ *:-+: *$/.test(e.align[n]) ? e.align[n] = "center" : /^ *:-+ *$/.test(e.align[n]) ? e.align[n] = "left" : e.align[n] = null;
                            for (o = e.rows.length, n = 0; n < o; n++) e.rows[n] = I(e.rows[n], e.header.length).map((e => ({
                                text: e
                            })));
                            for (o = e.header.length, r = 0; r < o; r++) e.header[r].tokens = [], this.lexer.inlineTokens(e.header[r].text, e.header[r].tokens);
                            for (o = e.rows.length, r = 0; r < o; r++)
                                for (s = e.rows[r], i = 0; i < s.length; i++) s[i].tokens = [], this.lexer.inlineTokens(s[i].text, s[i].tokens);
                            return e
                        }
                    }
                }
                lheading(e) {
                    const t = this.rules.block.lheading.exec(e);
                    if (t) {
                        const e = {
                            type: "heading",
                            raw: t[0],
                            depth: "=" === t[2].charAt(0) ? 1 : 2,
                            text: t[1],
                            tokens: []
                        };
                        return this.lexer.inline(e.text, e.tokens), e
                    }
                }
                paragraph(e) {
                    const t = this.rules.block.paragraph.exec(e);
                    if (t) {
                        const e = {
                            type: "paragraph",
                            raw: t[0],
                            text: "\n" === t[1].charAt(t[1].length - 1) ? t[1].slice(0, -1) : t[1],
                            tokens: []
                        };
                        return this.lexer.inline(e.text, e.tokens), e
                    }
                }
                text(e) {
                    const t = this.rules.block.text.exec(e);
                    if (t) {
                        const e = {
                            type: "text",
                            raw: t[0],
                            text: t[0],
                            tokens: []
                        };
                        return this.lexer.inline(e.text, e.tokens), e
                    }
                }
                escape(e) {
                    const t = this.rules.inline.escape.exec(e);
                    if (t) return {
                        type: "escape",
                        raw: t[0],
                        text: S(t[1])
                    }
                }
                tag(e) {
                    const t = this.rules.inline.tag.exec(e);
                    if (t) return !this.lexer.state.inLink && /^<a /i.test(t[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(t[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(t[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(t[0]) && (this.lexer.state.inRawBlock = !1), {
                        type: this.options.sanitize ? "text" : "html",
                        raw: t[0],
                        inLink: this.lexer.state.inLink,
                        inRawBlock: this.lexer.state.inRawBlock,
                        text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(t[0]) : S(t[0]) : t[0]
                    }
                }
                link(e) {
                    const t = this.rules.inline.link.exec(e);
                    if (t) {
                        const e = t[2].trim();
                        if (!this.options.pedantic && /^</.test(e)) {
                            if (!/>$/.test(e)) return;
                            const t = C(e.slice(0, -1), "\\");
                            if ((e.length - t.length) % 2 == 0) return
                        } else {
                            const e = E(t[2], "()");
                            if (e > -1) {
                                const n = (0 === t[0].indexOf("!") ? 5 : 4) + t[1].length + e;
                                t[2] = t[2].substring(0, e), t[0] = t[0].substring(0, n).trim(), t[3] = ""
                            }
                        }
                        let n = t[2],
                            r = "";
                        if (this.options.pedantic) {
                            const e = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(n);
                            e && (n = e[1], r = e[3])
                        } else r = t[3] ? t[3].slice(1, -1) : "";
                        return n = n.trim(), /^</.test(n) && (n = this.options.pedantic && !/>$/.test(e) ? n.slice(1) : n.slice(1, -1)), T(t, {
                            href: n ? n.replace(this.rules.inline._escapes, "$1") : n,
                            title: r ? r.replace(this.rules.inline._escapes, "$1") : r
                        }, t[0], this.lexer)
                    }
                }
                reflink(e, t) {
                    let n;
                    if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
                        let e = (n[2] || n[1]).replace(/\s+/g, " ");
                        if (e = t[e.toLowerCase()], !e || !e.href) {
                            const e = n[0].charAt(0);
                            return {
                                type: "text",
                                raw: e,
                                text: e
                            }
                        }
                        return T(n, e, n[0], this.lexer)
                    }
                }
                emStrong(e, t, n = "") {
                    let r = this.rules.inline.emStrong.lDelim.exec(e);
                    if (!r) return;
                    if (r[3] && n.match(/[\p{L}\p{N}]/u)) return;
                    const i = r[1] || r[2] || "";
                    if (!i || i && ("" === n || this.rules.inline.punctuation.exec(n))) {
                        const n = r[0].length - 1;
                        let i, s, o = n,
                            a = 0;
                        const c = "*" === r[0][0] ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
                        for (c.lastIndex = 0, t = t.slice(-1 * e.length + n); null != (r = c.exec(t));) {
                            if (i = r[1] || r[2] || r[3] || r[4] || r[5] || r[6], !i) continue;
                            if (s = i.length, r[3] || r[4]) {
                                o += s;
                                continue
                            }
                            if ((r[5] || r[6]) && n % 3 && !((n + s) % 3)) {
                                a += s;
                                continue
                            }
                            if (o -= s, o > 0) continue;
                            if (s = Math.min(s, s + o + a), Math.min(n, s) % 2) {
                                const t = e.slice(1, n + r.index + s);
                                return {
                                    type: "em",
                                    raw: e.slice(0, n + r.index + s + 1),
                                    text: t,
                                    tokens: this.lexer.inlineTokens(t, [])
                                }
                            }
                            const t = e.slice(2, n + r.index + s - 1);
                            return {
                                type: "strong",
                                raw: e.slice(0, n + r.index + s + 1),
                                text: t,
                                tokens: this.lexer.inlineTokens(t, [])
                            }
                        }
                    }
                }
                codespan(e) {
                    const t = this.rules.inline.code.exec(e);
                    if (t) {
                        let e = t[2].replace(/\n/g, " ");
                        const n = /[^ ]/.test(e),
                            r = /^ /.test(e) && / $/.test(e);
                        return n && r && (e = e.substring(1, e.length - 1)), e = S(e, !0), {
                            type: "codespan",
                            raw: t[0],
                            text: e
                        }
                    }
                }
                br(e) {
                    const t = this.rules.inline.br.exec(e);
                    if (t) return {
                        type: "br",
                        raw: t[0]
                    }
                }
                del(e) {
                    const t = this.rules.inline.del.exec(e);
                    if (t) return {
                        type: "del",
                        raw: t[0],
                        text: t[2],
                        tokens: this.lexer.inlineTokens(t[2], [])
                    }
                }
                autolink(e, t) {
                    const n = this.rules.inline.autolink.exec(e);
                    if (n) {
                        let e, r;
                        return "@" === n[2] ? (e = S(this.options.mangle ? t(n[1]) : n[1]), r = "mailto:" + e) : (e = S(n[1]), r = e), {
                            type: "link",
                            raw: n[0],
                            text: e,
                            href: r,
                            tokens: [{
                                type: "text",
                                raw: e,
                                text: e
                            }]
                        }
                    }
                }
                url(e, t) {
                    let n;
                    if (n = this.rules.inline.url.exec(e)) {
                        let e, r;
                        if ("@" === n[2]) e = S(this.options.mangle ? t(n[0]) : n[0]), r = "mailto:" + e;
                        else {
                            let t;
                            do {
                                t = n[0], n[0] = this.rules.inline._backpedal.exec(n[0])[0]
                            } while (t !== n[0]);
                            e = S(n[0]), r = "www." === n[1] ? "http://" + e : e
                        }
                        return {
                            type: "link",
                            raw: n[0],
                            text: e,
                            href: r,
                            tokens: [{
                                type: "text",
                                raw: e,
                                text: e
                            }]
                        }
                    }
                }
                inlineText(e, t) {
                    const n = this.rules.inline.text.exec(e);
                    if (n) {
                        let e;
                        return e = this.lexer.state.inRawBlock ? this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(n[0]) : S(n[0]) : n[0] : S(this.options.smartypants ? t(n[0]) : n[0]), {
                            type: "text",
                            raw: n[0],
                            text: e
                        }
                    }
                }
            };
            const {
                noopTest: R,
                edit: A,
                merge: N
            } = x, O = {
                newline: /^(?: *(?:\n|$))+/,
                code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
                fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
                hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
                heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
                blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
                list: /^( {0,3}bull)( [^\n]+?)?(?:\n|$)/,
                html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
                def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
                table: R,
                lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
                _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html| +\n)[^\n]+)*)/,
                text: /^[^\n]+/,
                _label: /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/,
                _title: /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/
            };
            O.def = A(O.def).replace("label", O._label).replace("title", O._title).getRegex(), O.bullet = /(?:[*+-]|\d{1,9}[.)])/, O.listItemStart = A(/^( *)(bull) */).replace("bull", O.bullet).getRegex(), O.list = A(O.list).replace(/bull/g, O.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + O.def.source + ")").getRegex(), O._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", O._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/, O.html = A(O.html, "i").replace("comment", O._comment).replace("tag", O._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), O.paragraph = A(O._paragraph).replace("hr", O.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", O._tag).getRegex(), O.blockquote = A(O.blockquote).replace("paragraph", O.paragraph).getRegex(), O.normal = N({}, O), O.gfm = N({}, O.normal, {
                table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)\\|?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
            }), O.gfm.table = A(O.gfm.table).replace("hr", O.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", O._tag).getRegex(), O.pedantic = N({}, O.normal, {
                html: A("^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))").replace("comment", O._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
                def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
                heading: /^(#{1,6})(.*)(?:\n+|$)/,
                fences: R,
                paragraph: A(O.normal._paragraph).replace("hr", O.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", O.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
            });
            const M = {
                escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
                autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
                url: R,
                tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
                link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
                reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
                nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
                reflinkSearch: "reflink|nolink(?!\\()",
                emStrong: {
                    lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
                    rDelimAst: /\_\_[^_*]*?\*[^_*]*?\_\_|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
                    rDelimUnd: /\*\*[^_*]*?\_[^_*]*?\*\*|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
                },
                code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
                br: /^( {2,}|\\)\n(?!\s*$)/,
                del: R,
                text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
                punctuation: /^([\spunctuation])/,
                _punctuation: "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~"
            };
            M.punctuation = A(M.punctuation).replace(/punctuation/g, M._punctuation).getRegex(), M.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g, M.escapedEmSt = /\\\*|\\_/g, M._comment = A(O._comment).replace("(?:--\x3e|$)", "--\x3e").getRegex(), M.emStrong.lDelim = A(M.emStrong.lDelim).replace(/punct/g, M._punctuation).getRegex(), M.emStrong.rDelimAst = A(M.emStrong.rDelimAst, "g").replace(/punct/g, M._punctuation).getRegex(), M.emStrong.rDelimUnd = A(M.emStrong.rDelimUnd, "g").replace(/punct/g, M._punctuation).getRegex(), M._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g, M._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/, M._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/, M.autolink = A(M.autolink).replace("scheme", M._scheme).replace("email", M._email).getRegex(), M._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/, M.tag = A(M.tag).replace("comment", M._comment).replace("attribute", M._attribute).getRegex(), M._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, M._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/, M._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/, M.link = A(M.link).replace("label", M._label).replace("href", M._href).replace("title", M._title).getRegex(), M.reflink = A(M.reflink).replace("label", M._label).getRegex(), M.reflinkSearch = A(M.reflinkSearch, "g").replace("reflink", M.reflink).replace("nolink", M.nolink).getRegex(), M.normal = N({}, M), M.pedantic = N({}, M.normal, {
                strong: {
                    start: /^__|\*\*/,
                    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
                    endAst: /\*\*(?!\*)/g,
                    endUnd: /__(?!_)/g
                },
                em: {
                    start: /^_|\*/,
                    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
                    endAst: /\*(?!\*)/g,
                    endUnd: /_(?!_)/g
                },
                link: A(/^!?\[(label)\]\((.*?)\)/).replace("label", M._label).getRegex(),
                reflink: A(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", M._label).getRegex()
            }), M.gfm = N({}, M.normal, {
                escape: A(M.escape).replace("])", "~|])").getRegex(),
                _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
                url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
                _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
                del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
                text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
            }), M.gfm.url = A(M.gfm.url, "i").replace("email", M.gfm._extended_email).getRegex(), M.breaks = N({}, M.gfm, {
                br: A(M.br).replace("{2,}", "*").getRegex(),
                text: A(M.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
            });
            var D = {
                block: O,
                inline: M
            };
            const P = L,
                {
                    defaults: U
                } = i.exports,
                {
                    block: F,
                    inline: B
                } = D,
                {
                    repeatString: $
                } = x;

            function z(e) {
                return e.replace(/---/g, "—").replace(/--/g, "–").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…")
            }

            function q(e) {
                let t, n, r = "";
                const i = e.length;
                for (t = 0; t < i; t++) n = e.charCodeAt(t), Math.random() > .5 && (n = "x" + n.toString(16)), r += "&#" + n + ";";
                return r
            }
            const {
                defaults: W
            } = i.exports, {
                cleanUrl: j,
                escape: V
            } = x;
            var H = class {
                    constructor(e) {
                        this.options = e || W
                    }
                    code(e, t, n) {
                        const r = (t || "").match(/\S*/)[0];
                        if (this.options.highlight) {
                            const t = this.options.highlight(e, r);
                            null != t && t !== e && (n = !0, e = t)
                        }
                        return e = e.replace(/\n$/, "") + "\n", r ? '<pre><code class="' + this.options.langPrefix + V(r, !0) + '">' + (n ? e : V(e, !0)) + "</code></pre>\n" : "<pre><code>" + (n ? e : V(e, !0)) + "</code></pre>\n"
                    }
                    blockquote(e) {
                        return "<blockquote>\n" + e + "</blockquote>\n"
                    }
                    html(e) {
                        return e
                    }
                    heading(e, t, n, r) {
                        return this.options.headerIds ? "<h" + t + ' id="' + this.options.headerPrefix + r.slug(n) + '">' + e + "</h" + t + ">\n" : "<h" + t + ">" + e + "</h" + t + ">\n"
                    }
                    hr() {
                        return this.options.xhtml ? "<hr/>\n" : "<hr>\n"
                    }
                    list(e, t, n) {
                        const r = t ? "ol" : "ul";
                        return "<" + r + (t && 1 !== n ? ' start="' + n + '"' : "") + ">\n" + e + "</" + r + ">\n"
                    }
                    listitem(e) {
                        return "<li>" + e + "</li>\n"
                    }
                    checkbox(e) {
                        return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> "
                    }
                    paragraph(e) {
                        return "<p>" + e + "</p>\n"
                    }
                    table(e, t) {
                        return t && (t = "<tbody>" + t + "</tbody>"), "<table>\n<thead>\n" + e + "</thead>\n" + t + "</table>\n"
                    }
                    tablerow(e) {
                        return "<tr>\n" + e + "</tr>\n"
                    }
                    tablecell(e, t) {
                        const n = t.header ? "th" : "td";
                        return (t.align ? "<" + n + ' align="' + t.align + '">' : "<" + n + ">") + e + "</" + n + ">\n"
                    }
                    strong(e) {
                        return "<strong>" + e + "</strong>"
                    }
                    em(e) {
                        return "<em>" + e + "</em>"
                    }
                    codespan(e) {
                        return "<code>" + e + "</code>"
                    }
                    br() {
                        return this.options.xhtml ? "<br/>" : "<br>"
                    }
                    del(e) {
                        return "<del>" + e + "</del>"
                    }
                    link(e, t, n) {
                        if (null === (e = j(this.options.sanitize, this.options.baseUrl, e))) return n;
                        let r = '<a href="' + V(e) + '"';
                        return t && (r += ' title="' + t + '"'), r += ">" + n + "</a>", r
                    }
                    image(e, t, n) {
                        if (null === (e = j(this.options.sanitize, this.options.baseUrl, e))) return n;
                        let r = '<img src="' + e + '" alt="' + n + '"';
                        return t && (r += ' title="' + t + '"'), r += this.options.xhtml ? "/>" : ">", r
                    }
                    text(e) {
                        return e
                    }
                },
                K = class {
                    strong(e) {
                        return e
                    }
                    em(e) {
                        return e
                    }
                    codespan(e) {
                        return e
                    }
                    del(e) {
                        return e
                    }
                    html(e) {
                        return e
                    }
                    text(e) {
                        return e
                    }
                    link(e, t, n) {
                        return "" + n
                    }
                    image(e, t, n) {
                        return "" + n
                    }
                    br() {
                        return ""
                    }
                },
                Z = class {
                    constructor() {
                        this.seen = {}
                    }
                    serialize(e) {
                        return e.toLowerCase().trim().replace(/<[!\/a-z].*?>/gi, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-")
                    }
                    getNextSafeSlug(e, t) {
                        let n = e,
                            r = 0;
                        if (this.seen.hasOwnProperty(n)) {
                            r = this.seen[e];
                            do {
                                r++, n = e + "-" + r
                            } while (this.seen.hasOwnProperty(n))
                        }
                        return t || (this.seen[e] = r, this.seen[n] = 0), n
                    }
                    slug(e, t = {}) {
                        const n = this.serialize(e);
                        return this.getNextSafeSlug(n, t.dryrun)
                    }
                };
            const G = H,
                J = K,
                Y = Z,
                {
                    defaults: Q
                } = i.exports,
                {
                    unescape: X
                } = x,
                ee = class e {
                    constructor(e) {
                        this.tokens = [], this.tokens.links = Object.create(null), this.options = e || U, this.options.tokenizer = this.options.tokenizer || new P, this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
                            inLink: !1,
                            inRawBlock: !1,
                            top: !0
                        };
                        const t = {
                            block: F.normal,
                            inline: B.normal
                        };
                        this.options.pedantic ? (t.block = F.pedantic, t.inline = B.pedantic) : this.options.gfm && (t.block = F.gfm, this.options.breaks ? t.inline = B.breaks : t.inline = B.gfm), this.tokenizer.rules = t
                    }
                    static get rules() {
                        return {
                            block: F,
                            inline: B
                        }
                    }
                    static lex(t, n) {
                        return new e(n).lex(t)
                    }
                    static lexInline(t, n) {
                        return new e(n).inlineTokens(t)
                    }
                    lex(e) {
                        let t;
                        for (e = e.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    "), this.blockTokens(e, this.tokens); t = this.inlineQueue.shift();) this.inlineTokens(t.src, t.tokens);
                        return this.tokens
                    }
                    blockTokens(e, t = []) {
                        let n, i, s, o;
                        for (this.options.pedantic && (e = e.replace(/^ +$/gm, "")); e;)
                            if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((r => !!(n = r.call({
                                    lexer: this
                                }, e, t)) && (e = e.substring(n.raw.length), t.push(n), !0)))))
                                if (n = this.tokenizer.space(e)) e = e.substring(n.raw.length), n.type && t.push(n);
                                else if (n = this.tokenizer.code(e)) e = e.substring(n.raw.length), i = t[t.length - 1], !i || "paragraph" !== i.type && "text" !== i.type ? t.push(n) : (i.raw += "\n" + n.raw, i.text += "\n" + n.text, this.inlineQueue[this.inlineQueue.length - 1].src = i.text);
                        else if (n = this.tokenizer.fences(e)) e = e.substring(n.raw.length), t.push(n);
                        else if (n = this.tokenizer.heading(e)) e = e.substring(n.raw.length), t.push(n);
                        else if (n = this.tokenizer.hr(e)) e = e.substring(n.raw.length), t.push(n);
                        else if (n = this.tokenizer.blockquote(e)) e = e.substring(n.raw.length), t.push(n);
                        else if (n = this.tokenizer.list(e)) e = e.substring(n.raw.length), t.push(n);
                        else if (n = this.tokenizer.html(e)) e = e.substring(n.raw.length), t.push(n);
                        else if (n = this.tokenizer.def(e)) e = e.substring(n.raw.length), i = t[t.length - 1], !i || "paragraph" !== i.type && "text" !== i.type ? this.tokens.links[n.tag] || (this.tokens.links[n.tag] = {
                            href: n.href,
                            title: n.title
                        }) : (i.raw += "\n" + n.raw, i.text += "\n" + n.raw, this.inlineQueue[this.inlineQueue.length - 1].src = i.text);
                        else if (n = this.tokenizer.table(e)) e = e.substring(n.raw.length), t.push(n);
                        else if (n = this.tokenizer.lheading(e)) e = e.substring(n.raw.length), t.push(n);
                        else {
                            if (s = e, this.options.extensions && this.options.extensions.startBlock) {
                                let t = 1 / 0;
                                const n = e.slice(1);
                                let r;
                                this.options.extensions.startBlock.forEach((function(e) {
                                    r = e.call({
                                        lexer: this
                                    }, n), "number" == typeof r && r >= 0 && (t = Math.min(t, r))
                                })), t < 1 / 0 && t >= 0 && (s = e.substring(0, t + 1))
                            }
                            if (this.state.top && (n = this.tokenizer.paragraph(s))) i = t[t.length - 1], o && "paragraph" === i.type ? (i.raw += "\n" + n.raw, i.text += "\n" + n.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : t.push(n), o = s.length !== e.length, e = e.substring(n.raw.length);
                            else if (n = this.tokenizer.text(e)) e = e.substring(n.raw.length), i = t[t.length - 1], i && "text" === i.type ? (i.raw += "\n" + n.raw, i.text += "\n" + n.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = i.text) : t.push(n);
                            else if (e) {
                                const t = "Infinite loop on byte: " + e.charCodeAt(0);
                                if (this.options.silent) {
                                    r.error(t);
                                    break
                                }
                                throw new Error(t)
                            }
                        }
                        return this.state.top = !0, t
                    }
                    inline(e, t) {
                        this.inlineQueue.push({
                            src: e,
                            tokens: t
                        })
                    }
                    inlineTokens(e, t = []) {
                        let n, i, s, o, a, c, l = e;
                        if (this.tokens.links) {
                            const e = Object.keys(this.tokens.links);
                            if (e.length > 0)
                                for (; null != (o = this.tokenizer.rules.inline.reflinkSearch.exec(l));) e.includes(o[0].slice(o[0].lastIndexOf("[") + 1, -1)) && (l = l.slice(0, o.index) + "[" + $("a", o[0].length - 2) + "]" + l.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))
                        }
                        for (; null != (o = this.tokenizer.rules.inline.blockSkip.exec(l));) l = l.slice(0, o.index) + "[" + $("a", o[0].length - 2) + "]" + l.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
                        for (; null != (o = this.tokenizer.rules.inline.escapedEmSt.exec(l));) l = l.slice(0, o.index) + "++" + l.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
                        for (; e;)
                            if (a || (c = ""), a = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((r => !!(n = r.call({
                                    lexer: this
                                }, e, t)) && (e = e.substring(n.raw.length), t.push(n), !0)))))
                                if (n = this.tokenizer.escape(e)) e = e.substring(n.raw.length), t.push(n);
                                else if (n = this.tokenizer.tag(e)) e = e.substring(n.raw.length), i = t[t.length - 1], i && "text" === n.type && "text" === i.type ? (i.raw += n.raw, i.text += n.text) : t.push(n);
                        else if (n = this.tokenizer.link(e)) e = e.substring(n.raw.length), t.push(n);
                        else if (n = this.tokenizer.reflink(e, this.tokens.links)) e = e.substring(n.raw.length), i = t[t.length - 1], i && "text" === n.type && "text" === i.type ? (i.raw += n.raw, i.text += n.text) : t.push(n);
                        else if (n = this.tokenizer.emStrong(e, l, c)) e = e.substring(n.raw.length), t.push(n);
                        else if (n = this.tokenizer.codespan(e)) e = e.substring(n.raw.length), t.push(n);
                        else if (n = this.tokenizer.br(e)) e = e.substring(n.raw.length), t.push(n);
                        else if (n = this.tokenizer.del(e)) e = e.substring(n.raw.length), t.push(n);
                        else if (n = this.tokenizer.autolink(e, q)) e = e.substring(n.raw.length), t.push(n);
                        else if (this.state.inLink || !(n = this.tokenizer.url(e, q))) {
                            if (s = e, this.options.extensions && this.options.extensions.startInline) {
                                let t = 1 / 0;
                                const n = e.slice(1);
                                let r;
                                this.options.extensions.startInline.forEach((function(e) {
                                    r = e.call({
                                        lexer: this
                                    }, n), "number" == typeof r && r >= 0 && (t = Math.min(t, r))
                                })), t < 1 / 0 && t >= 0 && (s = e.substring(0, t + 1))
                            }
                            if (n = this.tokenizer.inlineText(s, z)) e = e.substring(n.raw.length), "_" !== n.raw.slice(-1) && (c = n.raw.slice(-1)), a = !0, i = t[t.length - 1], i && "text" === i.type ? (i.raw += n.raw, i.text += n.text) : t.push(n);
                            else if (e) {
                                const t = "Infinite loop on byte: " + e.charCodeAt(0);
                                if (this.options.silent) {
                                    r.error(t);
                                    break
                                }
                                throw new Error(t)
                            }
                        } else e = e.substring(n.raw.length), t.push(n);
                        return t
                    }
                },
                te = class e {
                    constructor(e) {
                        this.options = e || Q, this.options.renderer = this.options.renderer || new G, this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new J, this.slugger = new Y
                    }
                    static parse(t, n) {
                        return new e(n).parse(t)
                    }
                    static parseInline(t, n) {
                        return new e(n).parseInline(t)
                    }
                    parse(e, t = !0) {
                        let n, i, s, o, a, c, l, u, h, d, f, p, g, m, b, _, v, w, y, x = "";
                        const k = e.length;
                        for (n = 0; n < k; n++)
                            if (d = e[n], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[d.type] && (y = this.options.extensions.renderers[d.type].call({
                                    parser: this
                                }, d), !1 !== y || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(d.type))) x += y || "";
                            else switch (d.type) {
                                case "space":
                                    continue;
                                case "hr":
                                    x += this.renderer.hr();
                                    continue;
                                case "heading":
                                    x += this.renderer.heading(this.parseInline(d.tokens), d.depth, X(this.parseInline(d.tokens, this.textRenderer)), this.slugger);
                                    continue;
                                case "code":
                                    x += this.renderer.code(d.text, d.lang, d.escaped);
                                    continue;
                                case "table":
                                    for (u = "", l = "", o = d.header.length, i = 0; i < o; i++) l += this.renderer.tablecell(this.parseInline(d.header[i].tokens), {
                                        header: !0,
                                        align: d.align[i]
                                    });
                                    for (u += this.renderer.tablerow(l), h = "", o = d.rows.length, i = 0; i < o; i++) {
                                        for (c = d.rows[i], l = "", a = c.length, s = 0; s < a; s++) l += this.renderer.tablecell(this.parseInline(c[s].tokens), {
                                            header: !1,
                                            align: d.align[s]
                                        });
                                        h += this.renderer.tablerow(l)
                                    }
                                    x += this.renderer.table(u, h);
                                    continue;
                                case "blockquote":
                                    h = this.parse(d.tokens), x += this.renderer.blockquote(h);
                                    continue;
                                case "list":
                                    for (f = d.ordered, p = d.start, g = d.loose, o = d.items.length, h = "", i = 0; i < o; i++) b = d.items[i], _ = b.checked, v = b.task, m = "", b.task && (w = this.renderer.checkbox(_), g ? b.tokens.length > 0 && "paragraph" === b.tokens[0].type ? (b.tokens[0].text = w + " " + b.tokens[0].text, b.tokens[0].tokens && b.tokens[0].tokens.length > 0 && "text" === b.tokens[0].tokens[0].type && (b.tokens[0].tokens[0].text = w + " " + b.tokens[0].tokens[0].text)) : b.tokens.unshift({
                                        type: "text",
                                        text: w
                                    }) : m += w), m += this.parse(b.tokens, g), h += this.renderer.listitem(m, v, _);
                                    x += this.renderer.list(h, f, p);
                                    continue;
                                case "html":
                                    x += this.renderer.html(d.text);
                                    continue;
                                case "paragraph":
                                    x += this.renderer.paragraph(this.parseInline(d.tokens));
                                    continue;
                                case "text":
                                    for (h = d.tokens ? this.parseInline(d.tokens) : d.text; n + 1 < k && "text" === e[n + 1].type;) d = e[++n], h += "\n" + (d.tokens ? this.parseInline(d.tokens) : d.text);
                                    x += t ? this.renderer.paragraph(h) : h;
                                    continue;
                                default:
                                    {
                                        const e = 'Token with "' + d.type + '" type was not found.';
                                        if (this.options.silent) return void r.error(e);
                                        throw new Error(e)
                                    }
                            }
                        return x
                    }
                    parseInline(e, t) {
                        t = t || this.renderer;
                        let n, i, s, o = "";
                        const a = e.length;
                        for (n = 0; n < a; n++)
                            if (i = e[n], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[i.type] && (s = this.options.extensions.renderers[i.type].call({
                                    parser: this
                                }, i), !1 !== s || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(i.type))) o += s || "";
                            else switch (i.type) {
                                case "escape":
                                case "text":
                                    o += t.text(i.text);
                                    break;
                                case "html":
                                    o += t.html(i.text);
                                    break;
                                case "link":
                                    o += t.link(i.href, i.title, this.parseInline(i.tokens, t));
                                    break;
                                case "image":
                                    o += t.image(i.href, i.title, i.text);
                                    break;
                                case "strong":
                                    o += t.strong(this.parseInline(i.tokens, t));
                                    break;
                                case "em":
                                    o += t.em(this.parseInline(i.tokens, t));
                                    break;
                                case "codespan":
                                    o += t.codespan(i.text);
                                    break;
                                case "br":
                                    o += t.br();
                                    break;
                                case "del":
                                    o += t.del(this.parseInline(i.tokens, t));
                                    break;
                                default:
                                    {
                                        const e = 'Token with "' + i.type + '" type was not found.';
                                        if (this.options.silent) return void r.error(e);
                                        throw new Error(e)
                                    }
                            }
                        return o
                    }
                },
                ne = L,
                re = H,
                ie = K,
                se = Z,
                {
                    merge: oe,
                    checkSanitizeDeprecation: ae,
                    escape: ce
                } = x,
                {
                    getDefaults: le,
                    changeDefaults: ue,
                    defaults: he
                } = i.exports;

            function de(e, t, n) {
                if (null == e) throw new Error("marked(): input parameter is undefined or null");
                if ("string" != typeof e) throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(e) + ", string expected");
                if ("function" == typeof t && (n = t, t = null), t = oe({}, de.defaults, t || {}), ae(t), n) {
                    const r = t.highlight;
                    let i;
                    try {
                        i = ee.lex(e, t)
                    } catch (e) {
                        return n(e)
                    }
                    const s = function(e) {
                        let s;
                        if (!e) try {
                            t.walkTokens && de.walkTokens(i, t.walkTokens), s = te.parse(i, t)
                        } catch (t) {
                            e = t
                        }
                        return t.highlight = r, e ? n(e) : n(null, s)
                    };
                    if (!r || r.length < 3) return s();
                    if (delete t.highlight, !i.length) return s();
                    let o = 0;
                    return de.walkTokens(i, (function(e) {
                        "code" === e.type && (o++, setTimeout((() => {
                            r(e.text, e.lang, (function(t, n) {
                                if (t) return s(t);
                                null != n && n !== e.text && (e.text = n, e.escaped = !0), o--, 0 === o && s()
                            }))
                        }), 0))
                    })), void(0 === o && s())
                }
                try {
                    const n = ee.lex(e, t);
                    return t.walkTokens && de.walkTokens(n, t.walkTokens), te.parse(n, t)
                } catch (e) {
                    if (e.message += "\nPlease report this to https://github.com/markedjs/marked.", t.silent) return "<p>An error occurred:</p><pre>" + ce(e.message + "", !0) + "</pre>";
                    throw e
                }
            }
            de.options = de.setOptions = function(e) {
                return oe(de.defaults, e), ue(de.defaults), de
            }, de.getDefaults = le, de.defaults = he, de.use = function(...e) {
                const t = oe({}, ...e),
                    n = de.defaults.extensions || {
                        renderers: {},
                        childTokens: {}
                    };
                let r;
                e.forEach((e => {
                    if (e.extensions && (r = !0, e.extensions.forEach((e => {
                            if (!e.name) throw new Error("extension name required");
                            if (e.renderer) {
                                const t = n.renderers ? n.renderers[e.name] : null;
                                n.renderers[e.name] = t ? function(...n) {
                                    let r = e.renderer.apply(this, n);
                                    return !1 === r && (r = t.apply(this, n)), r
                                } : e.renderer
                            }
                            if (e.tokenizer) {
                                if (!e.level || "block" !== e.level && "inline" !== e.level) throw new Error("extension level must be 'block' or 'inline'");
                                n[e.level] ? n[e.level].unshift(e.tokenizer) : n[e.level] = [e.tokenizer], e.start && ("block" === e.level ? n.startBlock ? n.startBlock.push(e.start) : n.startBlock = [e.start] : "inline" === e.level && (n.startInline ? n.startInline.push(e.start) : n.startInline = [e.start]))
                            }
                            e.childTokens && (n.childTokens[e.name] = e.childTokens)
                        }))), e.renderer) {
                        const n = de.defaults.renderer || new re;
                        for (const t in e.renderer) {
                            const r = n[t];
                            n[t] = (...i) => {
                                let s = e.renderer[t].apply(n, i);
                                return !1 === s && (s = r.apply(n, i)), s
                            }
                        }
                        t.renderer = n
                    }
                    if (e.tokenizer) {
                        const n = de.defaults.tokenizer || new ne;
                        for (const t in e.tokenizer) {
                            const r = n[t];
                            n[t] = (...i) => {
                                let s = e.tokenizer[t].apply(n, i);
                                return !1 === s && (s = r.apply(n, i)), s
                            }
                        }
                        t.tokenizer = n
                    }
                    if (e.walkTokens) {
                        const n = de.defaults.walkTokens;
                        t.walkTokens = t => {
                            e.walkTokens.call(this, t), n && n(t)
                        }
                    }
                    r && (t.extensions = n), de.setOptions(t)
                }))
            }, de.walkTokens = function(e, t) {
                for (const n of e) switch (t(n), n.type) {
                    case "table":
                        for (const e of n.header) de.walkTokens(e.tokens, t);
                        for (const e of n.rows)
                            for (const n of e) de.walkTokens(n.tokens, t);
                        break;
                    case "list":
                        de.walkTokens(n.items, t);
                        break;
                    default:
                        de.defaults.extensions && de.defaults.extensions.childTokens && de.defaults.extensions.childTokens[n.type] ? de.defaults.extensions.childTokens[n.type].forEach((function(e) {
                            de.walkTokens(n[e], t)
                        })) : n.tokens && de.walkTokens(n.tokens, t)
                }
            }, de.parseInline = function(e, t) {
                if (null == e) throw new Error("marked.parseInline(): input parameter is undefined or null");
                if ("string" != typeof e) throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(e) + ", string expected");
                t = oe({}, de.defaults, t || {}), ae(t);
                try {
                    const n = ee.lexInline(e, t);
                    return t.walkTokens && de.walkTokens(n, t.walkTokens), te.parseInline(n, t)
                } catch (e) {
                    if (e.message += "\nPlease report this to https://github.com/markedjs/marked.", t.silent) return "<p>An error occurred:</p><pre>" + ce(e.message + "", !0) + "</pre>";
                    throw e
                }
            }, de.Parser = te, de.parser = te.parse, de.Renderer = re, de.TextRenderer = ie, de.Lexer = ee, de.lexer = ee.lex, de.Tokenizer = ne, de.Slugger = se, de.parse = de;
            var fe = de
        },
        mYXM: (e, t, n) => {
            n.d(t, {
                u: () => o,
                z: () => s
            });
            var r = n("K30K");
            const i = Object.create(null);

            function s(e, t) {
                if ((0, r.HD)(t)) {
                    const n = i[t];
                    if (void 0 === n) throw new Error(`${e} references an unknown codicon: ${t}`);
                    t = n
                }
                return i[e] = t, {
                    id: e
                }
            }

            function o() {
                return i
            }
        },
        "9HFd": (e, t, n) => {
            var r;
            n.d(t, {
                    m: () => r
                }),
                function(e) {
                    e[e.Uri = 1] = "Uri", e[e.Regexp = 2] = "Regexp", e[e.ScmResource = 3] = "ScmResource", e[e.ScmResourceGroup = 4] = "ScmResourceGroup", e[e.ScmProvider = 5] = "ScmProvider", e[e.CommentController = 6] = "CommentController", e[e.CommentThread = 7] = "CommentThread", e[e.CommentThreadInstance = 8] = "CommentThreadInstance", e[e.CommentThreadReply = 9] = "CommentThreadReply", e[e.CommentNode = 10] = "CommentNode", e[e.CommentThreadNode = 11] = "CommentThreadNode", e[e.TimelineActionContext = 12] = "TimelineActionContext", e[e.NotebookCellActionContext = 13] = "NotebookCellActionContext", e[e.NotebookActionContext = 14] = "NotebookActionContext", e[e.TerminalContext = 15] = "TerminalContext", e[e.TestItemContext = 16] = "TestItemContext", e[e.Date = 17] = "Date", e[e.TestMessageMenuArgs = 18] = "TestMessageMenuArgs"
                }(r || (r = {}))
        },
        knwV: (e, t, n) => {
            n.d(t, {
                $P: () => c,
                IZ: () => r
            });
            class r {
                constructor(e, t, n) {
                    this.owner = e, this.debugNameSource = t, this.referenceFn = n
                }
                getDebugName(e) {
                    return function(e, t) {
                        const n = s.get(e);
                        if (n) return n;
                        const r = function(e, t) {
                            const n = s.get(e);
                            if (n) return n;
                            const r = t.owner ? function(e) {
                                const t = a.get(e);
                                if (t) return t;
                                const n = function(e) {
                                    const t = e.constructor;
                                    return t ? t.name : "Object"
                                }(e);
                                let r = o.get(n) ? ? 0;
                                r++, o.set(n, r);
                                const i = 1 === r ? n : `${n}#${r}`;
                                return a.set(e, i), i
                            }(t.owner) + "." : "";
                            let i;
                            const l = t.debugNameSource;
                            if (void 0 !== l) {
                                if ("function" != typeof l) return r + l;
                                if (i = l(), void 0 !== i) return r + i
                            }
                            const u = t.referenceFn;
                            if (void 0 !== u && (i = c(u), void 0 !== i)) return r + i;
                            if (void 0 !== t.owner) {
                                const n = function(e, t) {
                                    for (const n in e)
                                        if (e[n] === t) return n
                                }(t.owner, e);
                                if (void 0 !== n) return r + n
                            }
                        }(e, t);
                        if (r) {
                            let t = i.get(r) ? ? 0;
                            t++, i.set(r, t);
                            const n = 1 === t ? r : `${r}#${t}`;
                            return s.set(e, n), n
                        }
                    }(e, this)
                }
            }
            const i = new Map,
                s = new WeakMap,
                o = new Map,
                a = new WeakMap;

            function c(e) {
                const t = e.toString(),
                    n = /\/\*\*\s*@description\s*([^*]*)\*\//.exec(t),
                    r = n ? n[1] : void 0;
                return r ? .trim()
            }
        },
        "9n9+": (e, t, n) => {
            function r() {}
            n.d(t, {
                j: () => r
            })
        },
        JKRA: (e, t, n) => {
            n.d(t, {
                B: () => r,
                _: () => i
            });
            const r = e => {
                    performance.mark(e)
                },
                i = () => {
                    let e = performance.timeOrigin;
                    "number" != typeof e && (e = performance.timing.navigationStart || performance.timing.redirectStart || performance.timing.fetchStart);
                    const t = [{
                        name: "code/timeOrigin",
                        startTime: Math.round(e)
                    }];
                    for (const n of performance.getEntriesByType("mark")) t.push({
                        name: n.name,
                        startTime: Math.round(e + n.startTime)
                    });
                    return t
                }
        },
        C0CW: (e, t, n) => {
            n.d(t, {
                F: () => s
            });
            var r = n("wBFb");
            const i = Symbol("unset");
            class s {
                constructor() {
                    this.root = new a, this._size = 0
                }
                get size() {
                    return this._size
                }
                get nodes() {
                    return this.root.children ? .values() || r.$.empty()
                }
                insert(e, t, n) {
                    this.opNode(e, (e => e._value = t), n)
                }
                mutate(e, t) {
                    this.opNode(e, (e => e._value = t(e._value === i ? void 0 : e._value)))
                }
                mutatePath(e, t) {
                    this.opNode(e, (() => {}), (e => t(e)))
                }
                delete(e) {
                    const t = this.getPathToKey(e);
                    if (!t) return;
                    let n = t.length - 1;
                    const r = t[n].node._value;
                    if (r !== i) {
                        for (this._size--, t[n].node._value = i; n > 0; n--) {
                            const {
                                node: e,
                                part: r
                            } = t[n];
                            if (e.children ? .size || e._value !== i) break;
                            t[n - 1].node.children.delete(r)
                        }
                        return r
                    }
                }* deleteRecursive(e) {
                    const t = this.getPathToKey(e);
                    if (!t) return;
                    const n = t[t.length - 1].node;
                    for (let e = t.length - 1; e > 0; e--) {
                        const n = t[e - 1];
                        if (n.node.children.delete(t[e].part), n.node.children.size > 0 || n.node._value !== i) break
                    }
                    for (const e of o(n)) e._value !== i && (this._size--, yield e._value)
                }
                find(e) {
                    let t = this.root;
                    for (const n of e) {
                        const e = t.children ? .get(n);
                        if (!e) return;
                        t = e
                    }
                    return t._value === i ? void 0 : t._value
                }
                hasKeyOrParent(e) {
                    let t = this.root;
                    for (const n of e) {
                        const e = t.children ? .get(n);
                        if (!e) return !1;
                        if (e._value !== i) return !0;
                        t = e
                    }
                    return !1
                }
                hasKeyOrChildren(e) {
                    let t = this.root;
                    for (const n of e) {
                        const e = t.children ? .get(n);
                        if (!e) return !1;
                        t = e
                    }
                    return !0
                }
                hasKey(e) {
                    let t = this.root;
                    for (const n of e) {
                        const e = t.children ? .get(n);
                        if (!e) return !1;
                        t = e
                    }
                    return t._value !== i
                }
                getPathToKey(e) {
                    const t = [{
                        part: "",
                        node: this.root
                    }];
                    let n = 0;
                    for (const r of e) {
                        const e = t[n].node.children ? .get(r);
                        if (!e) return;
                        t.push({
                            part: r,
                            node: e
                        }), n++
                    }
                    return t
                }
                opNode(e, t, n) {
                    let r = this.root;
                    for (const t of e) {
                        if (r.children)
                            if (r.children.has(t)) r = r.children.get(t);
                            else {
                                const e = new a;
                                r.children.set(t, e), r = e
                            }
                        else {
                            const e = new a;
                            r.children = new Map([
                                [t, e]
                            ]), r = e
                        }
                        n ? .(r)
                    }
                    const s = r._value === i ? 0 : 1;
                    t(r);
                    const o = r._value === i ? 0 : 1;
                    this._size += o - s
                }* values() {
                    for (const {
                            _value: e
                        } of o(this.root)) e !== i && (yield e)
                }
            }

            function* o(e) {
                const t = [e];
                for (; t.length > 0;) {
                    const e = t.pop();
                    if (yield e, e.children)
                        for (const n of e.children.values()) t.push(n)
                }
            }
            class a {
                constructor() {
                    this._value = i
                }
                get value() {
                    return this._value === i ? void 0 : this._value
                }
                set value(e) {
                    this._value = void 0 === e ? i : e
                }
            }
        },
        R6K4: (e, t, n) => {
            n.d(t, {
                Z: () => s
            });
            var r, i = n("p044");
            ! function(e) {
                e[e.Ignore = 0] = "Ignore", e[e.Info = 1] = "Info", e[e.Warning = 2] = "Warning", e[e.Error = 3] = "Error"
            }(r || (r = {})),
            function(e) {
                const t = "error",
                    n = "warning",
                    r = "info";
                e.fromValue = function(s) {
                    return s ? (0, i.qq)(t, s) ? e.Error : (0, i.qq)(n, s) || (0, i.qq)("warn", s) ? e.Warning : (0, i.qq)(r, s) ? e.Info : e.Ignore : e.Ignore
                }, e.toString = function(i) {
                    switch (i) {
                        case e.Error:
                            return t;
                        case e.Warning:
                            return n;
                        case e.Info:
                            return r;
                        default:
                            return "ignore"
                    }
                }
            }(r || (r = {}));
            var s = r
        },
        naIR: (e, t, n) => {
            n.d(t, {
                _9: () => p,
                ov: () => f,
                qP: () => w
            });
            var r = n("U7Xe"),
                i = n("9HFd"),
                s = n("RRaN"),
                o = n("pLPy");
            const a = /^\w[\w\d+.-]*$/,
                c = /^\//,
                l = /^\/\//,
                u = "",
                h = "/",
                d = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
            class f {
                static isUri(e) {
                    return e instanceof f || !!e && "string" == typeof e.authority && "string" == typeof e.fragment && "string" == typeof e.path && "string" == typeof e.query && "string" == typeof e.scheme && "string" == typeof e.fsPath && "function" == typeof e.with && "function" == typeof e.toString
                }
                constructor(e, t, n, r, i, s = !1) {
                    "object" == typeof e ? (this.scheme = e.scheme || u, this.authority = e.authority || u, this.path = e.path || u, this.query = e.query || u, this.fragment = e.fragment || u) : (this.scheme = function(e, t) {
                        return e || t ? e : "file"
                    }(e, s), this.authority = t || u, this.path = function(e, t) {
                        switch (e) {
                            case "https":
                            case "http":
                            case "file":
                                t ? t[0] !== h && (t = h + t) : t = h
                        }
                        return t
                    }(this.scheme, n || u), this.query = r || u, this.fragment = i || u, function(e, t) {
                        if (!e.scheme && t) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${e.authority}", path: "${e.path}", query: "${e.query}", fragment: "${e.fragment}"}`);
                        if (e.scheme && !a.test(e.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
                        if (e.path)
                            if (e.authority) {
                                if (!c.test(e.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character')
                            } else if (l.test(e.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")')
                    }(this, s))
                }
                get fsPath() {
                    return w(this, !1)
                }
                with(e) {
                    if (!e) return this;
                    let {
                        scheme: t,
                        authority: n,
                        path: r,
                        query: i,
                        fragment: s
                    } = e;
                    return void 0 === t ? t = this.scheme : null === t && (t = u), void 0 === n ? n = this.authority : null === n && (n = u), void 0 === r ? r = this.path : null === r && (r = u), void 0 === i ? i = this.query : null === i && (i = u), void 0 === s ? s = this.fragment : null === s && (s = u), t === this.scheme && n === this.authority && r === this.path && i === this.query && s === this.fragment ? this : new m(t, n, r, i, s)
                }
                static parse(e, t = !1) {
                    const n = d.exec(e);
                    return n ? new m(n[2] || u, C(n[4] || u), C(n[5] || u), C(n[7] || u), C(n[9] || u), t) : new m(u, u, u, u, u)
                }
                static file(e) {
                    let t = u;
                    if (o.ED && (e = e.replace(/\\/g, h)), e[0] === h && e[1] === h) {
                        const n = e.indexOf(h, 2); - 1 === n ? (t = e.substring(2), e = h) : (t = e.substring(2, n), e = e.substring(n) || h)
                    }
                    return new m("file", t, e, u, u)
                }
                static from(e, t) {
                    return new m(e.scheme, e.authority, e.path, e.query, e.fragment, t)
                }
                static joinPath(e, ...t) {
                    if (!e.path) throw new Error("[UriError]: cannot call joinPath on URI without path");
                    let n;
                    return n = o.ED && "file" === e.scheme ? f.file(s.Ku.join(w(e, !0), ...t)).path : s.KR.join(e.path, ...t), e.with({
                        path: n
                    })
                }
                toString(e = !1) {
                    return y(this, e)
                }
                toJSON() {
                    return this
                }
                static revive(e) {
                    if (e) {
                        if (e instanceof f) return e; {
                            const t = new m(e);
                            return t._formatted = e.external ? ? null, t._fsPath = e._sep === g ? e.fsPath ? ? null : null, t
                        }
                    }
                    return e
                }
            }

            function p(e) {
                return !(!e || "object" != typeof e || "string" != typeof e.scheme || "string" != typeof e.authority && void 0 !== e.authority || "string" != typeof e.path && void 0 !== e.path || "string" != typeof e.query && void 0 !== e.query || "string" != typeof e.fragment && void 0 !== e.fragment)
            }
            const g = o.ED ? 1 : void 0;
            class m extends f {
                constructor() {
                    super(...arguments), this._formatted = null, this._fsPath = null
                }
                get fsPath() {
                    return this._fsPath || (this._fsPath = w(this, !1)), this._fsPath
                }
                toString(e = !1) {
                    return e ? y(this, !0) : (this._formatted || (this._formatted = y(this, !1)), this._formatted)
                }
                toJSON() {
                    const e = {
                        $mid: i.m.Uri
                    };
                    return this._fsPath && (e.fsPath = this._fsPath, e._sep = g), this._formatted && (e.external = this._formatted), this.path && (e.path = this.path), this.scheme && (e.scheme = this.scheme), this.authority && (e.authority = this.authority), this.query && (e.query = this.query), this.fragment && (e.fragment = this.fragment), e
                }
            }
            const b = {
                [r.m.Colon]: "%3A",
                [r.m.Slash]: "%2F",
                [r.m.QuestionMark]: "%3F",
                [r.m.Hash]: "%23",
                [r.m.OpenSquareBracket]: "%5B",
                [r.m.CloseSquareBracket]: "%5D",
                [r.m.AtSign]: "%40",
                [r.m.ExclamationMark]: "%21",
                [r.m.DollarSign]: "%24",
                [r.m.Ampersand]: "%26",
                [r.m.SingleQuote]: "%27",
                [r.m.OpenParen]: "%28",
                [r.m.CloseParen]: "%29",
                [r.m.Asterisk]: "%2A",
                [r.m.Plus]: "%2B",
                [r.m.Comma]: "%2C",
                [r.m.Semicolon]: "%3B",
                [r.m.Equals]: "%3D",
                [r.m.Space]: "%20"
            };

            function _(e, t, n) {
                let i, s = -1;
                for (let o = 0; o < e.length; o++) {
                    const a = e.charCodeAt(o);
                    if (a >= r.m.a && a <= r.m.z || a >= r.m.A && a <= r.m.Z || a >= r.m.Digit0 && a <= r.m.Digit9 || a === r.m.Dash || a === r.m.Period || a === r.m.Underline || a === r.m.Tilde || t && a === r.m.Slash || n && a === r.m.OpenSquareBracket || n && a === r.m.CloseSquareBracket || n && a === r.m.Colon) - 1 !== s && (i += encodeURIComponent(e.substring(s, o)), s = -1), void 0 !== i && (i += e.charAt(o));
                    else {
                        void 0 === i && (i = e.substr(0, o));
                        const t = b[a];
                        void 0 !== t ? (-1 !== s && (i += encodeURIComponent(e.substring(s, o)), s = -1), i += t) : -1 === s && (s = o)
                    }
                }
                return -1 !== s && (i += encodeURIComponent(e.substring(s))), void 0 !== i ? i : e
            }

            function v(e) {
                let t;
                for (let n = 0; n < e.length; n++) {
                    const i = e.charCodeAt(n);
                    i === r.m.Hash || i === r.m.QuestionMark ? (void 0 === t && (t = e.substr(0, n)), t += b[i]) : void 0 !== t && (t += e[n])
                }
                return void 0 !== t ? t : e
            }

            function w(e, t) {
                let n;
                return n = e.authority && e.path.length > 1 && "file" === e.scheme ? `//${e.authority}${e.path}` : e.path.charCodeAt(0) === r.m.Slash && (e.path.charCodeAt(1) >= r.m.A && e.path.charCodeAt(1) <= r.m.Z || e.path.charCodeAt(1) >= r.m.a && e.path.charCodeAt(1) <= r.m.z) && e.path.charCodeAt(2) === r.m.Colon ? t ? e.path.substr(1) : e.path[1].toLowerCase() + e.path.substr(2) : e.path, o.ED && (n = n.replace(/\//g, "\\")), n
            }

            function y(e, t) {
                const n = t ? v : _;
                let i = "",
                    {
                        scheme: s,
                        authority: o,
                        path: a,
                        query: c,
                        fragment: l
                    } = e;
                if (s && (i += s, i += ":"), (o || "file" === s) && (i += h, i += h), o) {
                    let e = o.indexOf("@");
                    if (-1 !== e) {
                        const t = o.substr(0, e);
                        o = o.substr(e + 1), e = t.lastIndexOf(":"), -1 === e ? i += n(t, !1, !1) : (i += n(t.substr(0, e), !1, !1), i += ":", i += n(t.substr(e + 1), !1, !0)), i += "@"
                    }
                    o = o.toLowerCase(), e = o.lastIndexOf(":"), -1 === e ? i += n(o, !1, !0) : (i += n(o.substr(0, e), !1, !0), i += o.substr(e))
                }
                if (a) {
                    if (a.length >= 3 && a.charCodeAt(0) === r.m.Slash && a.charCodeAt(2) === r.m.Colon) {
                        const e = a.charCodeAt(1);
                        e >= r.m.A && e <= r.m.Z && (a = `/${String.fromCharCode(e+32)}:${a.substr(3)}`)
                    } else if (a.length >= 2 && a.charCodeAt(1) === r.m.Colon) {
                        const e = a.charCodeAt(0);
                        e >= r.m.A && e <= r.m.Z && (a = `${String.fromCharCode(e+32)}:${a.substr(2)}`)
                    }
                    i += n(a, !0, !1)
                }
                return c && (i += "?", i += n(c, !1, !1)), l && (i += "#", i += t ? l : _(l, !1, !1)), i
            }

            function x(e) {
                try {
                    return decodeURIComponent(e)
                } catch {
                    return e.length > 3 ? e.substr(0, 3) + x(e.substr(3)) : e
                }
            }
            const k = /(%[0-9A-Za-z][0-9A-Za-z])+/g;

            function C(e) {
                return e.match(k) ? e.replace(k, (e => x(e))) : e
            }
        },
        sqMd: (e, t, n) => {
            n.d(t, {
                YT: () => a
            });
            var r = n("jxI3"),
                i = n("9HFd"),
                s = n("naIR");

            function o(e, t, n, a) {
                if (!e || a > 200) return null;
                if ("object" == typeof e) {
                    if (e.$mid === i.m.Uri) return n ? s.ov.revive(t.transformIncoming(e)) : t.transformIncoming(e);
                    if (e instanceof r.KN) return null;
                    for (const r in e)
                        if (Object.hasOwnProperty.call(e, r)) {
                            const i = o(e[r], t, n, a + 1);
                            null !== i && (e[r] = i)
                        }
                }
                return null
            }

            function a(e, t) {
                const n = o(e, t, !1, 0);
                return null === n ? e : n
            }
            new class {
                transformIncoming(e) {
                    return e
                }
                transformOutgoing(e) {
                    return e
                }
                transformOutgoingURI(e) {
                    return e
                }
                transformOutgoingScheme(e) {
                    return e
                }
            }
        },
        YMLI: (e, t, n) => {
            n.d(t, {
                Q: () => s,
                b: () => r
            });
            var r, i = n("U7Xe");

            function s(e) {
                let t = 0,
                    n = 0,
                    s = 0,
                    o = r.Unknown;
                for (let a = 0, c = e.length; a < c; a++) {
                    const l = e.charCodeAt(a);
                    l === i.m.CarriageReturn ? (0 === t && (n = a), t++, a + 1 < c && e.charCodeAt(a + 1) === i.m.LineFeed ? (o |= r.CRLF, a++) : o |= r.Invalid, s = a + 1) : l === i.m.LineFeed && (o |= r.LF, 0 === t && (n = a), t++, s = a + 1)
                }
                return 0 === t && (n = e.length), [t, n, e.length - s, o]
            }! function(e) {
                e[e.Unknown = 0] = "Unknown", e[e.Invalid = 3] = "Invalid", e[e.LF = 1] = "LF", e[e.CRLF = 2] = "CRLF"
            }(r || (r = {}))
        },
        "7hFA": (e, t, n) => {
            n.d(t, {
                D: () => r
            });
            const r = {
                tabSize: 4,
                indentSize: 4,
                insertSpaces: !0,
                detectIndentation: !0,
                trimAutoWhitespace: !0,
                largeFileOptimizations: !0,
                bracketPairColorizationOptions: {
                    enabled: !0,
                    independentColorPoolPerBracketType: !1
                }
            }
        },
        "4kee": (e, t, n) => {
            n.d(t, {
                G: () => s,
                J: () => o
            });
            var r = n("y5Nw"),
                i = n("RRaN");

            function s(e, t, n, o, a, c) {
                if (Array.isArray(e)) {
                    let r = 0;
                    for (const i of e) {
                        const e = s(i, t, n, o, a, c);
                        if (10 === e) return e;
                        e > r && (r = e)
                    }
                    return r
                }
                if ("string" == typeof e) return o ? "*" === e ? 5 : e === n ? 10 : 0 : 0;
                if (e) {
                    const {
                        language: s,
                        pattern: l,
                        scheme: u,
                        hasAccessToAllModels: h,
                        notebookType: d
                    } = e;
                    if (!o && !h) return 0;
                    d && a && (t = a);
                    let f = 0;
                    if (u)
                        if (u === t.scheme) f = 10;
                        else {
                            if ("*" !== u) return 0;
                            f = 5
                        }
                    if (s)
                        if (s === n) f = 10;
                        else {
                            if ("*" !== s) return 0;
                            f = Math.max(f, 5)
                        }
                    if (d)
                        if (d === c) f = 10;
                        else {
                            if ("*" !== d || void 0 === c) return 0;
                            f = Math.max(f, 5)
                        }
                    if (l) {
                        let e;
                        if (e = "string" == typeof l ? l : { ...l,
                                base: (0, i.Fv)(l.base)
                            }, e !== t.fsPath && !(0, r.EQ)(e, t.fsPath)) return 0;
                        f = 10
                    }
                    return f
                }
                return 0
            }

            function o(e) {
                return "string" != typeof e && (Array.isArray(e) ? e.some(o) : !!e.notebookType)
            }
        },
        "5e3k": (e, t, n) => {
            n.d(t, {
                Lv: () => g,
                Nr: () => f,
                Xp: () => d,
                nD: () => _
            });
            var r = n("U7Xe"),
                i = n("6PFX"),
                s = n("Aw1u"),
                o = n("PLiU"),
                a = n("17nu"),
                c = n("KZ22");
            const l = 65535;

            function u(e) {
                let t;
                return t = e[e.length - 1] < 65536 ? new Uint16Array(e.length) : new Uint32Array(e.length), t.set(e, 0), t
            }
            class h {
                constructor(e, t, n, r, i) {
                    this.lineStarts = e, this.cr = t, this.lf = n, this.crlf = r, this.isBasicASCII = i
                }
            }

            function d(e, t = !0) {
                const n = [0];
                let i = 1;
                for (let t = 0, s = e.length; t < s; t++) {
                    const o = e.charCodeAt(t);
                    o === r.m.CarriageReturn ? t + 1 < s && e.charCodeAt(t + 1) === r.m.LineFeed ? (n[i++] = t + 2, t++) : n[i++] = t + 1 : o === r.m.LineFeed && (n[i++] = t + 1)
                }
                return t ? u(n) : n
            }

            function f(e, t) {
                e.length = 0, e[0] = 0;
                let n = 1,
                    i = 0,
                    s = 0,
                    o = 0,
                    a = !0;
                for (let c = 0, l = t.length; c < l; c++) {
                    const u = t.charCodeAt(c);
                    u === r.m.CarriageReturn ? c + 1 < l && t.charCodeAt(c + 1) === r.m.LineFeed ? (o++, e[n++] = c + 2, c++) : (i++, e[n++] = c + 1) : u === r.m.LineFeed ? (s++, e[n++] = c + 1) : a && u !== r.m.Tab && (u < 32 || u > 126) && (a = !1)
                }
                const c = new h(u(e), i, s, o, a);
                return e.length = 0, c
            }
            class p {
                constructor(e, t, n, r, i) {
                    this.bufferIndex = e, this.start = t, this.end = n, this.lineFeedCnt = r, this.length = i
                }
            }
            class g {
                constructor(e, t) {
                    this.buffer = e, this.lineStarts = t
                }
            }
            class m {
                constructor(e, t) {
                    this._pieces = [], this._tree = e, this._BOM = t, this._index = 0, e.root !== a.Nc && e.iterate(e.root, (e => (e !== a.Nc && this._pieces.push(e.piece), !0)))
                }
                read() {
                    return 0 === this._pieces.length ? 0 === this._index ? (this._index++, this._BOM) : null : this._index > this._pieces.length - 1 ? null : 0 === this._index ? this._BOM + this._tree.getPieceContent(this._pieces[this._index++]) : this._tree.getPieceContent(this._pieces[this._index++])
                }
            }
            class b {
                constructor(e) {
                    this._limit = e, this._cache = []
                }
                get(e) {
                    for (let t = this._cache.length - 1; t >= 0; t--) {
                        const n = this._cache[t];
                        if (n.nodeStartOffset <= e && n.nodeStartOffset + n.node.piece.length >= e) return n
                    }
                    return null
                }
                get2(e) {
                    for (let t = this._cache.length - 1; t >= 0; t--) {
                        const n = this._cache[t];
                        if (n.nodeStartLineNumber && n.nodeStartLineNumber < e && n.nodeStartLineNumber + n.node.piece.lineFeedCnt >= e) return n
                    }
                    return null
                }
                set(e) {
                    this._cache.length >= this._limit && this._cache.shift(), this._cache.push(e)
                }
                validate(e) {
                    let t = !1;
                    const n = this._cache;
                    for (let r = 0; r < n.length; r++) {
                        const i = n[r];
                        (null === i.node.parent || i.nodeStartOffset >= e) && (n[r] = null, t = !0)
                    }
                    if (t) {
                        const e = [];
                        for (const t of n) null !== t && e.push(t);
                        this._cache = e
                    }
                }
            }
            class _ {
                constructor(e, t, n) {
                    this.create(e, t, n)
                }
                create(e, t, n) {
                    this._buffers = [new g("", [0])], this._lastChangeBufferPos = {
                        line: 0,
                        column: 0
                    }, this.root = a.Nc, this._lineCnt = 1, this._length = 0, this._EOL = t, this._EOLLength = t.length, this._EOLNormalized = n;
                    let r = null;
                    for (let t = 0, n = e.length; t < n; t++)
                        if (e[t].buffer.length > 0) {
                            e[t].lineStarts || (e[t].lineStarts = d(e[t].buffer));
                            const n = new p(t + 1, {
                                line: 0,
                                column: 0
                            }, {
                                line: e[t].lineStarts.length - 1,
                                column: e[t].buffer.length - e[t].lineStarts[e[t].lineStarts.length - 1]
                            }, e[t].lineStarts.length - 1, e[t].buffer.length);
                            this._buffers.push(e[t]), r = this.rbInsertRight(r, n)
                        }
                    this._searchCache = new b(1), this._lastVisitedLine = {
                        lineNumber: 0,
                        value: ""
                    }, this.computeBufferMetadata()
                }
                normalizeEOL(e) {
                    const t = 65535 - Math.floor(21845),
                        n = 2 * t;
                    let r = "",
                        i = 0;
                    const s = [];
                    if (this.iterate(this.root, (o => {
                            const a = this.getNodeContent(o),
                                c = a.length;
                            if (i <= t || i + c < n) return r += a, i += c, !0;
                            const l = r.replace(/\r\n|\r|\n/g, e);
                            return s.push(new g(l, d(l))), r = a, i = c, !0
                        })), i > 0) {
                        const t = r.replace(/\r\n|\r|\n/g, e);
                        s.push(new g(t, d(t)))
                    }
                    this.create(s, e, !0)
                }
                getEOL() {
                    return this._EOL
                }
                setEOL(e) {
                    this._EOL = e, this._EOLLength = this._EOL.length, this.normalizeEOL(e)
                }
                createSnapshot(e) {
                    return new m(this, e)
                }
                equal(e) {
                    if (this.getLength() !== e.getLength()) return !1;
                    if (this.getLineCount() !== e.getLineCount()) return !1;
                    let t = 0;
                    return this.iterate(this.root, (n => {
                        if (n === a.Nc) return !0;
                        const r = this.getNodeContent(n),
                            i = r.length,
                            s = e.nodeAt(t),
                            o = e.nodeAt(t + i),
                            c = e.getValueInRange2(s, o);
                        return t += i, r === c
                    }))
                }
                getOffsetAt(e, t) {
                    let n = 0,
                        r = this.root;
                    for (; r !== a.Nc;)
                        if (r.left !== a.Nc && r.lf_left + 1 >= e) r = r.left;
                        else {
                            if (r.lf_left + r.piece.lineFeedCnt + 1 >= e) return n += r.size_left, n + (this.getAccumulatedValue(r, e - r.lf_left - 2) + t - 1);
                            e -= r.lf_left + r.piece.lineFeedCnt, n += r.size_left + r.piece.length, r = r.right
                        }
                    return n
                }
                getPositionAt(e) {
                    e = Math.floor(e), e = Math.max(0, e);
                    let t = this.root,
                        n = 0;
                    const r = e;
                    for (; t !== a.Nc;)
                        if (0 !== t.size_left && t.size_left >= e) t = t.left;
                        else {
                            if (t.size_left + t.piece.length >= e) {
                                const s = this.getIndexOf(t, e - t.size_left);
                                if (n += t.lf_left + s.index, 0 === s.index) {
                                    const e = r - this.getOffsetAt(n + 1, 1);
                                    return new i.L(n + 1, e + 1)
                                }
                                return new i.L(n + 1, s.remainder + 1)
                            }
                            if (e -= t.size_left + t.piece.length, n += t.lf_left + t.piece.lineFeedCnt, t.right === a.Nc) {
                                const t = r - e - this.getOffsetAt(n + 1, 1);
                                return new i.L(n + 1, t + 1)
                            }
                            t = t.right
                        }
                    return new i.L(1, 1)
                }
                getValueInRange(e, t) {
                    if (e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn) return "";
                    const n = this.nodeAt2(e.startLineNumber, e.startColumn),
                        r = this.nodeAt2(e.endLineNumber, e.endColumn),
                        i = this.getValueInRange2(n, r);
                    return t ? t === this._EOL && this._EOLNormalized && t === this.getEOL() && this._EOLNormalized ? i : i.replace(/\r\n|\r|\n/g, t) : i
                }
                getValueInRange2(e, t) {
                    if (e.node === t.node) {
                        const n = e.node,
                            r = this._buffers[n.piece.bufferIndex].buffer,
                            i = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start);
                        return r.substring(i + e.remainder, i + t.remainder)
                    }
                    let n = e.node;
                    const r = this._buffers[n.piece.bufferIndex].buffer,
                        i = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start);
                    let s = r.substring(i + e.remainder, i + n.piece.length);
                    for (n = n.next(); n !== a.Nc;) {
                        const e = this._buffers[n.piece.bufferIndex].buffer,
                            r = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start);
                        if (n === t.node) {
                            s += e.substring(r, r + t.remainder);
                            break
                        }
                        s += e.substr(r, n.piece.length), n = n.next()
                    }
                    return s
                }
                getLinesContent() {
                    const e = [];
                    let t = 0,
                        n = "",
                        i = !1;
                    return this.iterate(this.root, (s => {
                        if (s === a.Nc) return !0;
                        const o = s.piece;
                        let c = o.length;
                        if (0 === c) return !0;
                        const l = this._buffers[o.bufferIndex].buffer,
                            u = this._buffers[o.bufferIndex].lineStarts,
                            h = o.start.line,
                            d = o.end.line;
                        let f = u[h] + o.start.column;
                        if (i && (l.charCodeAt(f) === r.m.LineFeed && (f++, c--), e[t++] = n, n = "", i = !1, 0 === c)) return !0;
                        if (h === d) return this._EOLNormalized || l.charCodeAt(f + c - 1) !== r.m.CarriageReturn ? n += l.substr(f, c) : (i = !0, n += l.substr(f, c - 1)), !0;
                        n += this._EOLNormalized ? l.substring(f, Math.max(f, u[h + 1] - this._EOLLength)) : l.substring(f, u[h + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = n;
                        for (let r = h + 1; r < d; r++) n = this._EOLNormalized ? l.substring(u[r], u[r + 1] - this._EOLLength) : l.substring(u[r], u[r + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = n;
                        return this._EOLNormalized || l.charCodeAt(u[d] + o.end.column - 1) !== r.m.CarriageReturn ? n = l.substr(u[d], o.end.column) : (i = !0, 0 === o.end.column ? t-- : n = l.substr(u[d], o.end.column - 1)), !0
                    })), i && (e[t++] = n, n = ""), e[t++] = n, e
                }
                getLength() {
                    return this._length
                }
                getLineCount() {
                    return this._lineCnt
                }
                getLineContent(e) {
                    return this._lastVisitedLine.lineNumber === e || (this._lastVisitedLine.lineNumber = e, e === this._lineCnt ? this._lastVisitedLine.value = this.getLineRawContent(e) : this._EOLNormalized ? this._lastVisitedLine.value = this.getLineRawContent(e, this._EOLLength) : this._lastVisitedLine.value = this.getLineRawContent(e).replace(/(\r\n|\r|\n)$/, "")), this._lastVisitedLine.value
                }
                _getCharCode(e) {
                    if (e.remainder === e.node.piece.length) {
                        const t = e.node.next();
                        if (!t) return 0;
                        const n = this._buffers[t.piece.bufferIndex],
                            r = this.offsetInBuffer(t.piece.bufferIndex, t.piece.start);
                        return n.buffer.charCodeAt(r)
                    } {
                        const t = this._buffers[e.node.piece.bufferIndex],
                            n = this.offsetInBuffer(e.node.piece.bufferIndex, e.node.piece.start) + e.remainder;
                        return t.buffer.charCodeAt(n)
                    }
                }
                getLineCharCode(e, t) {
                    const n = this.nodeAt2(e, t + 1);
                    return this._getCharCode(n)
                }
                getLineLength(e) {
                    if (e === this.getLineCount()) {
                        const t = this.getOffsetAt(e, 1);
                        return this.getLength() - t
                    }
                    return this.getOffsetAt(e + 1, 1) - this.getOffsetAt(e, 1) - this._EOLLength
                }
                getCharCode(e) {
                    const t = this.nodeAt(e);
                    return this._getCharCode(t)
                }
                getNearestChunk(e) {
                    const t = this.nodeAt(e);
                    if (t.remainder === t.node.piece.length) {
                        const e = t.node.next();
                        if (!e || e === a.Nc) return "";
                        const n = this._buffers[e.piece.bufferIndex],
                            r = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start);
                        return n.buffer.substring(r, r + e.piece.length)
                    } {
                        const e = this._buffers[t.node.piece.bufferIndex],
                            n = this.offsetInBuffer(t.node.piece.bufferIndex, t.node.piece.start),
                            r = n + t.remainder,
                            i = n + t.node.piece.length;
                        return e.buffer.substring(r, i)
                    }
                }
                findMatchesInNode(e, t, n, r, i, o, a, l, u, h, d) {
                    const f = this._buffers[e.piece.bufferIndex],
                        p = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start),
                        g = this.offsetInBuffer(e.piece.bufferIndex, i),
                        m = this.offsetInBuffer(e.piece.bufferIndex, o);
                    let b;
                    const _ = {
                        line: 0,
                        column: 0
                    };
                    let v, w;
                    t._wordSeparators ? (v = f.buffer.substring(g, m), w = e => e + g, t.reset(0)) : (v = f.buffer, w = e => e, t.reset(g));
                    do {
                        if (b = t.next(v), b) {
                            if (w(b.index) >= m) return h;
                            this.positionInBuffer(e, w(b.index) - p, _);
                            const t = this.getLineFeedCnt(e.piece.bufferIndex, i, _),
                                o = _.line === i.line ? _.column - i.column + r : _.column + 1,
                                a = o + b[0].length;
                            if (d[h++] = (0, c.iE)(new s.e(n + t, o, n + t, a), b, l), w(b.index) + b[0].length >= m) return h;
                            if (h >= u) return h
                        }
                    } while (b);
                    return h
                }
                findMatchesLineByLine(e, t, n, r) {
                    const i = [];
                    let s = 0;
                    const o = new c.sz(t.wordSeparators, t.regex);
                    let a = this.nodeAt2(e.startLineNumber, e.startColumn);
                    if (null === a) return [];
                    const l = this.nodeAt2(e.endLineNumber, e.endColumn);
                    if (null === l) return [];
                    let u = this.positionInBuffer(a.node, a.remainder);
                    const h = this.positionInBuffer(l.node, l.remainder);
                    if (a.node === l.node) return this.findMatchesInNode(a.node, o, e.startLineNumber, e.startColumn, u, h, t, n, r, s, i), i;
                    let d = e.startLineNumber,
                        f = a.node;
                    for (; f !== l.node;) {
                        const c = this.getLineFeedCnt(f.piece.bufferIndex, u, f.piece.end);
                        if (c >= 1) {
                            const a = this._buffers[f.piece.bufferIndex].lineStarts,
                                l = this.offsetInBuffer(f.piece.bufferIndex, f.piece.start),
                                h = a[u.line + c],
                                p = d === e.startLineNumber ? e.startColumn : 1;
                            if (s = this.findMatchesInNode(f, o, d, p, u, this.positionInBuffer(f, h - l), t, n, r, s, i), s >= r) return i;
                            d += c
                        }
                        const l = d === e.startLineNumber ? e.startColumn - 1 : 0;
                        if (d === e.endLineNumber) {
                            const a = this.getLineContent(d).substring(l, e.endColumn - 1);
                            return s = this._findMatchesInLine(t, o, a, e.endLineNumber, l, s, i, n, r), i
                        }
                        if (s = this._findMatchesInLine(t, o, this.getLineContent(d).substr(l), d, l, s, i, n, r), s >= r) return i;
                        d++, a = this.nodeAt2(d, 1), f = a.node, u = this.positionInBuffer(a.node, a.remainder)
                    }
                    if (d === e.endLineNumber) {
                        const a = d === e.startLineNumber ? e.startColumn - 1 : 0,
                            c = this.getLineContent(d).substring(a, e.endColumn - 1);
                        return s = this._findMatchesInLine(t, o, c, e.endLineNumber, a, s, i, n, r), i
                    }
                    const p = d === e.startLineNumber ? e.startColumn : 1;
                    return s = this.findMatchesInNode(l.node, o, d, p, u, h, t, n, r, s, i), i
                }
                _findMatchesInLine(e, t, n, r, i, a, l, u, h) {
                    const d = e.wordSeparators;
                    if (!u && e.simpleSearch) {
                        const t = e.simpleSearch,
                            u = t.length,
                            f = n.length;
                        let p = -u;
                        for (; - 1 !== (p = n.indexOf(t, p + u));)
                            if ((!d || (0, c.cM)(d, n, f, p, u)) && (l[a++] = new o.tk(new s.e(r, p + 1 + i, r, p + 1 + u + i), null), a >= h)) return a;
                        return a
                    }
                    let f;
                    t.reset(0);
                    do {
                        if (f = t.next(n), f && (l[a++] = (0, c.iE)(new s.e(r, f.index + 1 + i, r, f.index + 1 + f[0].length + i), f, u), a >= h)) return a
                    } while (f);
                    return a
                }
                insert(e, t, n = !1) {
                    if (this._EOLNormalized = this._EOLNormalized && n, this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", this.root !== a.Nc) {
                        const {
                            node: n,
                            remainder: r,
                            nodeStartOffset: i
                        } = this.nodeAt(e), s = n.piece, o = s.bufferIndex, a = this.positionInBuffer(n, r);
                        if (0 === n.piece.bufferIndex && s.end.line === this._lastChangeBufferPos.line && s.end.column === this._lastChangeBufferPos.column && i + s.length === e && t.length < l) return this.appendToNode(n, t), void this.computeBufferMetadata();
                        if (i === e) this.insertContentToNodeLeft(t, n), this._searchCache.validate(e);
                        else if (i + n.piece.length > e) {
                            const e = [];
                            let i = new p(s.bufferIndex, a, s.end, this.getLineFeedCnt(s.bufferIndex, a, s.end), this.offsetInBuffer(o, s.end) - this.offsetInBuffer(o, a));
                            if (this.shouldCheckCRLF() && this.endWithCR(t) && 10 === this.nodeCharCodeAt(n, r)) {
                                const e = {
                                    line: i.start.line + 1,
                                    column: 0
                                };
                                i = new p(i.bufferIndex, e, i.end, this.getLineFeedCnt(i.bufferIndex, e, i.end), i.length - 1), t += "\n"
                            }
                            if (this.shouldCheckCRLF() && this.startWithLF(t))
                                if (13 === this.nodeCharCodeAt(n, r - 1)) {
                                    const i = this.positionInBuffer(n, r - 1);
                                    this.deleteNodeTail(n, i), t = "\r" + t, 0 === n.piece.length && e.push(n)
                                } else this.deleteNodeTail(n, a);
                            else this.deleteNodeTail(n, a);
                            const c = this.createNewPieces(t);
                            i.length > 0 && this.rbInsertRight(n, i);
                            let l = n;
                            for (let e = 0; e < c.length; e++) l = this.rbInsertRight(l, c[e]);
                            this.deleteNodes(e)
                        } else this.insertContentToNodeRight(t, n)
                    } else {
                        const e = this.createNewPieces(t);
                        let n = this.rbInsertLeft(null, e[0]);
                        for (let t = 1; t < e.length; t++) n = this.rbInsertRight(n, e[t])
                    }
                    this.computeBufferMetadata()
                }
                delete(e, t) {
                    if (this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", t <= 0 || this.root === a.Nc) return;
                    const n = this.nodeAt(e),
                        r = this.nodeAt(e + t),
                        i = n.node,
                        s = r.node;
                    if (i === s) {
                        const s = this.positionInBuffer(i, n.remainder),
                            o = this.positionInBuffer(i, r.remainder);
                        if (n.nodeStartOffset === e) {
                            if (t === i.piece.length) {
                                const e = i.next();
                                return (0, a.KI)(this, i), this.validateCRLFWithPrevNode(e), void this.computeBufferMetadata()
                            }
                            return this.deleteNodeHead(i, o), this._searchCache.validate(e), this.validateCRLFWithPrevNode(i), void this.computeBufferMetadata()
                        }
                        return n.nodeStartOffset + i.piece.length === e + t ? (this.deleteNodeTail(i, s), this.validateCRLFWithNextNode(i), void this.computeBufferMetadata()) : (this.shrinkNode(i, s, o), void this.computeBufferMetadata())
                    }
                    const o = [],
                        c = this.positionInBuffer(i, n.remainder);
                    this.deleteNodeTail(i, c), this._searchCache.validate(e), 0 === i.piece.length && o.push(i);
                    const l = this.positionInBuffer(s, r.remainder);
                    this.deleteNodeHead(s, l), 0 === s.piece.length && o.push(s);
                    for (let e = i.next(); e !== a.Nc && e !== s; e = e.next()) o.push(e);
                    const u = 0 === i.piece.length ? i.prev() : i;
                    this.deleteNodes(o), this.validateCRLFWithNextNode(u), this.computeBufferMetadata()
                }
                insertContentToNodeLeft(e, t) {
                    const n = [];
                    if (this.shouldCheckCRLF() && this.endWithCR(e) && this.startWithLF(t)) {
                        const r = t.piece,
                            i = {
                                line: r.start.line + 1,
                                column: 0
                            },
                            s = new p(r.bufferIndex, i, r.end, this.getLineFeedCnt(r.bufferIndex, i, r.end), r.length - 1);
                        t.piece = s, e += "\n", (0, a.Z2)(this, t, -1, -1), 0 === t.piece.length && n.push(t)
                    }
                    const r = this.createNewPieces(e);
                    let i = this.rbInsertLeft(t, r[r.length - 1]);
                    for (let e = r.length - 2; e >= 0; e--) i = this.rbInsertLeft(i, r[e]);
                    this.validateCRLFWithPrevNode(i), this.deleteNodes(n)
                }
                insertContentToNodeRight(e, t) {
                    this.adjustCarriageReturnFromNext(e, t) && (e += "\n");
                    const n = this.createNewPieces(e),
                        r = this.rbInsertRight(t, n[0]);
                    let i = r;
                    for (let e = 1; e < n.length; e++) i = this.rbInsertRight(i, n[e]);
                    this.validateCRLFWithPrevNode(r)
                }
                positionInBuffer(e, t, n) {
                    const r = e.piece,
                        i = e.piece.bufferIndex,
                        s = this._buffers[i].lineStarts,
                        o = s[r.start.line] + r.start.column + t;
                    let a = r.start.line,
                        c = r.end.line,
                        l = 0,
                        u = 0,
                        h = 0;
                    for (; a <= c && (l = a + (c - a) / 2 | 0, h = s[l], l !== c);)
                        if (u = s[l + 1], o < h) c = l - 1;
                        else {
                            if (!(o >= u)) break;
                            a = l + 1
                        }
                    return n ? (n.line = l, n.column = o - h, null) : {
                        line: l,
                        column: o - h
                    }
                }
                getLineFeedCnt(e, t, n) {
                    if (0 === n.column) return n.line - t.line;
                    const r = this._buffers[e].lineStarts;
                    if (n.line === r.length - 1) return n.line - t.line;
                    const i = r[n.line + 1],
                        s = r[n.line] + n.column;
                    if (i > s + 1) return n.line - t.line;
                    const o = s - 1;
                    return 13 === this._buffers[e].buffer.charCodeAt(o) ? n.line - t.line + 1 : n.line - t.line
                }
                offsetInBuffer(e, t) {
                    return this._buffers[e].lineStarts[t.line] + t.column
                }
                deleteNodes(e) {
                    for (let t = 0; t < e.length; t++)(0, a.KI)(this, e[t])
                }
                createNewPieces(e) {
                    if (e.length > l) {
                        const t = [];
                        for (; e.length > l;) {
                            const n = e.charCodeAt(65534);
                            let i;
                            n === r.m.CarriageReturn || n >= 55296 && n <= 56319 ? (i = e.substring(0, 65534), e = e.substring(65534)) : (i = e.substring(0, l), e = e.substring(l));
                            const s = d(i);
                            t.push(new p(this._buffers.length, {
                                line: 0,
                                column: 0
                            }, {
                                line: s.length - 1,
                                column: i.length - s[s.length - 1]
                            }, s.length - 1, i.length)), this._buffers.push(new g(i, s))
                        }
                        const n = d(e);
                        return t.push(new p(this._buffers.length, {
                            line: 0,
                            column: 0
                        }, {
                            line: n.length - 1,
                            column: e.length - n[n.length - 1]
                        }, n.length - 1, e.length)), this._buffers.push(new g(e, n)), t
                    }
                    let t = this._buffers[0].buffer.length;
                    const n = d(e, !1);
                    let i = this._lastChangeBufferPos;
                    if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === t && 0 !== t && this.startWithLF(e) && this.endWithCR(this._buffers[0].buffer)) {
                        this._lastChangeBufferPos = {
                            line: this._lastChangeBufferPos.line,
                            column: this._lastChangeBufferPos.column + 1
                        }, i = this._lastChangeBufferPos;
                        for (let e = 0; e < n.length; e++) n[e] += t + 1;
                        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(n.slice(1)), this._buffers[0].buffer += "_" + e, t += 1
                    } else {
                        if (0 !== t)
                            for (let e = 0; e < n.length; e++) n[e] += t;
                        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(n.slice(1)), this._buffers[0].buffer += e
                    }
                    const s = this._buffers[0].buffer.length,
                        o = this._buffers[0].lineStarts.length - 1,
                        a = {
                            line: o,
                            column: s - this._buffers[0].lineStarts[o]
                        },
                        c = new p(0, i, a, this.getLineFeedCnt(0, i, a), s - t);
                    return this._lastChangeBufferPos = a, [c]
                }
                getLinesRawContent() {
                    return this.getContentOfSubTree(this.root)
                }
                getLineRawContent(e, t = 0) {
                    let n = this.root,
                        r = "";
                    const i = this._searchCache.get2(e);
                    if (i) {
                        n = i.node;
                        const s = this.getAccumulatedValue(n, e - i.nodeStartLineNumber - 1),
                            o = this._buffers[n.piece.bufferIndex].buffer,
                            a = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start);
                        if (i.nodeStartLineNumber + n.piece.lineFeedCnt !== e) {
                            const r = this.getAccumulatedValue(n, e - i.nodeStartLineNumber);
                            return o.substring(a + s, a + r - t)
                        }
                        r = o.substring(a + s, a + n.piece.length)
                    } else {
                        let i = 0;
                        const s = e;
                        for (; n !== a.Nc;)
                            if (n.left !== a.Nc && n.lf_left >= e - 1) n = n.left;
                            else {
                                if (n.lf_left + n.piece.lineFeedCnt > e - 1) {
                                    const r = this.getAccumulatedValue(n, e - n.lf_left - 2),
                                        o = this.getAccumulatedValue(n, e - n.lf_left - 1),
                                        a = this._buffers[n.piece.bufferIndex].buffer,
                                        c = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start);
                                    return i += n.size_left, this._searchCache.set({
                                        node: n,
                                        nodeStartOffset: i,
                                        nodeStartLineNumber: s - (e - 1 - n.lf_left)
                                    }), a.substring(c + r, c + o - t)
                                }
                                if (n.lf_left + n.piece.lineFeedCnt === e - 1) {
                                    const t = this.getAccumulatedValue(n, e - n.lf_left - 2),
                                        i = this._buffers[n.piece.bufferIndex].buffer,
                                        s = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start);
                                    r = i.substring(s + t, s + n.piece.length);
                                    break
                                }
                                e -= n.lf_left + n.piece.lineFeedCnt, i += n.size_left + n.piece.length, n = n.right
                            }
                    }
                    for (n = n.next(); n !== a.Nc;) {
                        const e = this._buffers[n.piece.bufferIndex].buffer;
                        if (n.piece.lineFeedCnt > 0) {
                            const i = this.getAccumulatedValue(n, 0),
                                s = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start);
                            return r += e.substring(s, s + i - t), r
                        } {
                            const t = this.offsetInBuffer(n.piece.bufferIndex, n.piece.start);
                            r += e.substr(t, n.piece.length)
                        }
                        n = n.next()
                    }
                    return r
                }
                computeBufferMetadata() {
                    let e = this.root,
                        t = 1,
                        n = 0;
                    for (; e !== a.Nc;) t += e.lf_left + e.piece.lineFeedCnt, n += e.size_left + e.piece.length, e = e.right;
                    this._lineCnt = t, this._length = n, this._searchCache.validate(this._length)
                }
                getIndexOf(e, t) {
                    const n = e.piece,
                        r = this.positionInBuffer(e, t),
                        i = r.line - n.start.line;
                    if (this.offsetInBuffer(n.bufferIndex, n.end) - this.offsetInBuffer(n.bufferIndex, n.start) === t) {
                        const t = this.getLineFeedCnt(e.piece.bufferIndex, n.start, r);
                        if (t !== i) return {
                            index: t,
                            remainder: 0
                        }
                    }
                    return {
                        index: i,
                        remainder: r.column
                    }
                }
                getAccumulatedValue(e, t) {
                    if (t < 0) return 0;
                    const n = e.piece,
                        r = this._buffers[n.bufferIndex].lineStarts,
                        i = n.start.line + t + 1;
                    return i > n.end.line ? r[n.end.line] + n.end.column - r[n.start.line] - n.start.column : r[i] - r[n.start.line] - n.start.column
                }
                deleteNodeTail(e, t) {
                    const n = e.piece,
                        r = n.lineFeedCnt,
                        i = this.offsetInBuffer(n.bufferIndex, n.end),
                        s = t,
                        o = this.offsetInBuffer(n.bufferIndex, s),
                        c = this.getLineFeedCnt(n.bufferIndex, n.start, s),
                        l = c - r,
                        u = o - i,
                        h = n.length + u;
                    e.piece = new p(n.bufferIndex, n.start, s, c, h), (0, a.Z2)(this, e, u, l)
                }
                deleteNodeHead(e, t) {
                    const n = e.piece,
                        r = n.lineFeedCnt,
                        i = this.offsetInBuffer(n.bufferIndex, n.start),
                        s = t,
                        o = this.getLineFeedCnt(n.bufferIndex, s, n.end),
                        c = o - r,
                        l = i - this.offsetInBuffer(n.bufferIndex, s),
                        u = n.length + l;
                    e.piece = new p(n.bufferIndex, s, n.end, o, u), (0, a.Z2)(this, e, l, c)
                }
                shrinkNode(e, t, n) {
                    const r = e.piece,
                        i = r.start,
                        s = r.end,
                        o = r.length,
                        c = r.lineFeedCnt,
                        l = t,
                        u = this.getLineFeedCnt(r.bufferIndex, r.start, l),
                        h = this.offsetInBuffer(r.bufferIndex, t) - this.offsetInBuffer(r.bufferIndex, i);
                    e.piece = new p(r.bufferIndex, r.start, l, u, h), (0, a.Z2)(this, e, h - o, u - c);
                    const d = new p(r.bufferIndex, n, s, this.getLineFeedCnt(r.bufferIndex, n, s), this.offsetInBuffer(r.bufferIndex, s) - this.offsetInBuffer(r.bufferIndex, n)),
                        f = this.rbInsertRight(e, d);
                    this.validateCRLFWithPrevNode(f)
                }
                appendToNode(e, t) {
                    this.adjustCarriageReturnFromNext(t, e) && (t += "\n");
                    const n = this.shouldCheckCRLF() && this.startWithLF(t) && this.endWithCR(e),
                        r = this._buffers[0].buffer.length;
                    this._buffers[0].buffer += t;
                    const i = d(t, !1);
                    for (let e = 0; e < i.length; e++) i[e] += r;
                    if (n) {
                        const e = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];
                        this._buffers[0].lineStarts.pop(), this._lastChangeBufferPos = {
                            line: this._lastChangeBufferPos.line - 1,
                            column: r - e
                        }
                    }
                    this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1));
                    const s = this._buffers[0].lineStarts.length - 1,
                        o = {
                            line: s,
                            column: this._buffers[0].buffer.length - this._buffers[0].lineStarts[s]
                        },
                        c = e.piece.length + t.length,
                        l = e.piece.lineFeedCnt,
                        u = this.getLineFeedCnt(0, e.piece.start, o),
                        h = u - l;
                    e.piece = new p(e.piece.bufferIndex, e.piece.start, o, u, c), this._lastChangeBufferPos = o, (0, a.Z2)(this, e, t.length, h)
                }
                nodeAt(e) {
                    let t = this.root;
                    const n = this._searchCache.get(e);
                    if (n) return {
                        node: n.node,
                        nodeStartOffset: n.nodeStartOffset,
                        remainder: e - n.nodeStartOffset
                    };
                    let r = 0;
                    for (; t !== a.Nc;)
                        if (t.size_left > e) t = t.left;
                        else {
                            if (t.size_left + t.piece.length >= e) {
                                r += t.size_left;
                                const n = {
                                    node: t,
                                    remainder: e - t.size_left,
                                    nodeStartOffset: r
                                };
                                return this._searchCache.set(n), n
                            }
                            e -= t.size_left + t.piece.length, r += t.size_left + t.piece.length, t = t.right
                        }
                    return null
                }
                nodeAt2(e, t) {
                    let n = this.root,
                        r = 0;
                    for (; n !== a.Nc;)
                        if (n.left !== a.Nc && n.lf_left >= e - 1) n = n.left;
                        else {
                            if (n.lf_left + n.piece.lineFeedCnt > e - 1) {
                                const i = this.getAccumulatedValue(n, e - n.lf_left - 2),
                                    s = this.getAccumulatedValue(n, e - n.lf_left - 1);
                                return r += n.size_left, {
                                    node: n,
                                    remainder: Math.min(i + t - 1, s),
                                    nodeStartOffset: r
                                }
                            }
                            if (n.lf_left + n.piece.lineFeedCnt === e - 1) {
                                const i = this.getAccumulatedValue(n, e - n.lf_left - 2);
                                if (i + t - 1 <= n.piece.length) return {
                                    node: n,
                                    remainder: i + t - 1,
                                    nodeStartOffset: r
                                };
                                t -= n.piece.length - i;
                                break
                            }
                            e -= n.lf_left + n.piece.lineFeedCnt, r += n.size_left + n.piece.length, n = n.right
                        }
                    for (n = n.next(); n !== a.Nc;) {
                        if (n.piece.lineFeedCnt > 0) {
                            const e = this.getAccumulatedValue(n, 0),
                                r = this.offsetOfNode(n);
                            return {
                                node: n,
                                remainder: Math.min(t - 1, e),
                                nodeStartOffset: r
                            }
                        }
                        if (n.piece.length >= t - 1) return {
                            node: n,
                            remainder: t - 1,
                            nodeStartOffset: this.offsetOfNode(n)
                        };
                        t -= n.piece.length, n = n.next()
                    }
                    return null
                }
                nodeCharCodeAt(e, t) {
                    if (e.piece.lineFeedCnt < 1) return -1;
                    const n = this._buffers[e.piece.bufferIndex],
                        r = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start) + t;
                    return n.buffer.charCodeAt(r)
                }
                offsetOfNode(e) {
                    if (!e) return 0;
                    let t = e.size_left;
                    for (; e !== this.root;) e.parent.right === e && (t += e.parent.size_left + e.parent.piece.length), e = e.parent;
                    return t
                }
                shouldCheckCRLF() {
                    return !(this._EOLNormalized && "\n" === this._EOL)
                }
                startWithLF(e) {
                    if ("string" == typeof e) return 10 === e.charCodeAt(0);
                    if (e === a.Nc || 0 === e.piece.lineFeedCnt) return !1;
                    const t = e.piece,
                        n = this._buffers[t.bufferIndex].lineStarts,
                        r = t.start.line,
                        i = n[r] + t.start.column;
                    return r !== n.length - 1 && (!(n[r + 1] > i + 1) && 10 === this._buffers[t.bufferIndex].buffer.charCodeAt(i))
                }
                endWithCR(e) {
                    return "string" == typeof e ? 13 === e.charCodeAt(e.length - 1) : e !== a.Nc && 0 !== e.piece.lineFeedCnt && 13 === this.nodeCharCodeAt(e, e.piece.length - 1)
                }
                validateCRLFWithPrevNode(e) {
                    if (this.shouldCheckCRLF() && this.startWithLF(e)) {
                        const t = e.prev();
                        this.endWithCR(t) && this.fixCRLF(t, e)
                    }
                }
                validateCRLFWithNextNode(e) {
                    if (this.shouldCheckCRLF() && this.endWithCR(e)) {
                        const t = e.next();
                        this.startWithLF(t) && this.fixCRLF(e, t)
                    }
                }
                fixCRLF(e, t) {
                    const n = [],
                        r = this._buffers[e.piece.bufferIndex].lineStarts;
                    let i;
                    i = 0 === e.piece.end.column ? {
                        line: e.piece.end.line - 1,
                        column: r[e.piece.end.line] - r[e.piece.end.line - 1] - 1
                    } : {
                        line: e.piece.end.line,
                        column: e.piece.end.column - 1
                    };
                    const s = e.piece.length - 1,
                        o = e.piece.lineFeedCnt - 1;
                    e.piece = new p(e.piece.bufferIndex, e.piece.start, i, o, s), (0, a.Z2)(this, e, -1, -1), 0 === e.piece.length && n.push(e);
                    const c = {
                            line: t.piece.start.line + 1,
                            column: 0
                        },
                        l = t.piece.length - 1,
                        u = this.getLineFeedCnt(t.piece.bufferIndex, c, t.piece.end);
                    t.piece = new p(t.piece.bufferIndex, c, t.piece.end, u, l), (0, a.Z2)(this, t, -1, -1), 0 === t.piece.length && n.push(t);
                    const h = this.createNewPieces("\r\n");
                    this.rbInsertRight(e, h[0]);
                    for (let e = 0; e < n.length; e++)(0, a.KI)(this, n[e])
                }
                adjustCarriageReturnFromNext(e, t) {
                    if (this.shouldCheckCRLF() && this.endWithCR(e)) {
                        const n = t.next();
                        if (this.startWithLF(n)) {
                            if (e += "\n", 1 === n.piece.length)(0, a.KI)(this, n);
                            else {
                                const e = n.piece,
                                    t = {
                                        line: e.start.line + 1,
                                        column: 0
                                    },
                                    r = e.length - 1,
                                    i = this.getLineFeedCnt(e.bufferIndex, t, e.end);
                                n.piece = new p(e.bufferIndex, t, e.end, i, r), (0, a.Z2)(this, n, -1, -1)
                            }
                            return !0
                        }
                    }
                    return !1
                }
                iterate(e, t) {
                    if (e === a.Nc) return t(a.Nc);
                    const n = this.iterate(e.left, t);
                    return n ? t(e) && this.iterate(e.right, t) : n
                }
                getNodeContent(e) {
                    if (e === a.Nc) return "";
                    const t = this._buffers[e.piece.bufferIndex],
                        n = e.piece,
                        r = this.offsetInBuffer(n.bufferIndex, n.start),
                        i = this.offsetInBuffer(n.bufferIndex, n.end);
                    return t.buffer.substring(r, i)
                }
                getPieceContent(e) {
                    const t = this._buffers[e.bufferIndex],
                        n = this.offsetInBuffer(e.bufferIndex, e.start),
                        r = this.offsetInBuffer(e.bufferIndex, e.end);
                    return t.buffer.substring(n, r)
                }
                rbInsertRight(e, t) {
                    const n = new a.OF(t, a.dK.Red);
                    if (n.left = a.Nc, n.right = a.Nc, n.parent = a.Nc, n.size_left = 0, n.lf_left = 0, this.root === a.Nc) this.root = n, n.color = a.dK.Black;
                    else if (e.right === a.Nc) e.right = n, n.parent = e;
                    else {
                        const t = (0, a.xq)(e.right);
                        t.left = n, n.parent = t
                    }
                    return (0, a.h4)(this, n), n
                }
                rbInsertLeft(e, t) {
                    const n = new a.OF(t, a.dK.Red);
                    if (n.left = a.Nc, n.right = a.Nc, n.parent = a.Nc, n.size_left = 0, n.lf_left = 0, this.root === a.Nc) this.root = n, n.color = a.dK.Black;
                    else if (e.left === a.Nc) e.left = n, n.parent = e;
                    else {
                        const t = (0, a.Q$)(e.left);
                        t.right = n, n.parent = t
                    }
                    return (0, a.h4)(this, n), n
                }
                getContentOfSubTree(e) {
                    let t = "";
                    return this.iterate(e, (e => (t += this.getNodeContent(e), !0))), t
                }
            }
        },
        Hf6G: (e, t, n) => {
            n.d(t, {
                A: () => h
            });
            var r = n("7icl"),
                i = n("p044"),
                s = n("Aw1u"),
                o = n("PLiU"),
                a = n("5e3k"),
                c = n("YMLI"),
                l = n("wi2w"),
                u = n("RVdl");
            class h extends u.JT {
                constructor(e, t, n, i, s, o, c) {
                    super(), this._onDidChangeContent = this._register(new r.Q5), this.onDidChangeContent = this._onDidChangeContent.event, this._BOM = t, this._mightContainNonBasicASCII = !o, this._mightContainRTL = i, this._mightContainUnusualLineTerminators = s, this._pieceTree = new a.nD(e, n, c)
                }
                equals(e) {
                    return e instanceof h && this._BOM === e._BOM && this.getEOL() === e.getEOL() && this._pieceTree.equal(e._pieceTree)
                }
                mightContainRTL() {
                    return this._mightContainRTL
                }
                mightContainUnusualLineTerminators() {
                    return this._mightContainUnusualLineTerminators
                }
                resetMightContainUnusualLineTerminators() {
                    this._mightContainUnusualLineTerminators = !1
                }
                mightContainNonBasicASCII() {
                    return this._mightContainNonBasicASCII
                }
                getBOM() {
                    return this._BOM
                }
                getEOL() {
                    return this._pieceTree.getEOL()
                }
                createSnapshot(e) {
                    return this._pieceTree.createSnapshot(e ? this._BOM : "")
                }
                getOffsetAt(e, t) {
                    return this._pieceTree.getOffsetAt(e, t)
                }
                getPositionAt(e) {
                    return this._pieceTree.getPositionAt(e)
                }
                getRangeAt(e, t) {
                    const n = e + t,
                        r = this.getPositionAt(e),
                        i = this.getPositionAt(n);
                    return new s.e(r.lineNumber, r.column, i.lineNumber, i.column)
                }
                getValueInRange(e, t = o.gm.TextDefined) {
                    if (e.isEmpty()) return "";
                    const n = this._getEndOfLine(t);
                    return this._pieceTree.getValueInRange(e, n)
                }
                getValueLengthInRange(e, t = o.gm.TextDefined) {
                    if (e.isEmpty()) return 0;
                    if (e.startLineNumber === e.endLineNumber) return e.endColumn - e.startColumn;
                    const n = this.getOffsetAt(e.startLineNumber, e.startColumn),
                        r = this.getOffsetAt(e.endLineNumber, e.endColumn);
                    let i = 0;
                    const s = this._getEndOfLine(t),
                        a = this.getEOL();
                    return s.length !== a.length && (i = (s.length - a.length) * (e.endLineNumber - e.startLineNumber)), r - n + i
                }
                getCharacterCountInRange(e, t = o.gm.TextDefined) {
                    if (this._mightContainNonBasicASCII) {
                        let n = 0;
                        const r = e.startLineNumber,
                            s = e.endLineNumber;
                        for (let t = r; t <= s; t++) {
                            const o = this.getLineContent(t),
                                a = t === r ? e.startColumn - 1 : 0,
                                c = t === s ? e.endColumn - 1 : o.length;
                            for (let e = a; e < c; e++)(0, i.ZG)(o.charCodeAt(e)) ? (n += 1, e += 1) : n += 1
                        }
                        return n += this._getEndOfLine(t).length * (s - r), n
                    }
                    return this.getValueLengthInRange(e, t)
                }
                getNearestChunk(e) {
                    return this._pieceTree.getNearestChunk(e)
                }
                getLength() {
                    return this._pieceTree.getLength()
                }
                getLineCount() {
                    return this._pieceTree.getLineCount()
                }
                getLinesContent() {
                    return this._pieceTree.getLinesContent()
                }
                getLineContent(e) {
                    return this._pieceTree.getLineContent(e)
                }
                getLineCharCode(e, t) {
                    return this._pieceTree.getLineCharCode(e, t)
                }
                getCharCode(e) {
                    return this._pieceTree.getCharCode(e)
                }
                getLineLength(e) {
                    return this._pieceTree.getLineLength(e)
                }
                getLineMinColumn(e) {
                    return 1
                }
                getLineMaxColumn(e) {
                    return this.getLineLength(e) + 1
                }
                getLineFirstNonWhitespaceColumn(e) {
                    const t = (0, i.LC)(this.getLineContent(e));
                    return -1 === t ? 0 : t + 1
                }
                getLineLastNonWhitespaceColumn(e) {
                    const t = (0, i.ow)(this.getLineContent(e));
                    return -1 === t ? 0 : t + 2
                }
                _getEndOfLine(e) {
                    switch (e) {
                        case o.gm.LF:
                            return "\n";
                        case o.gm.CRLF:
                            return "\r\n";
                        case o.gm.TextDefined:
                            return this.getEOL();
                        default:
                            throw new Error("Unknown EOL preference")
                    }
                }
                setEOL(e) {
                    this._pieceTree.setEOL(e)
                }
                applyEdits(e, t, n) {
                    let r = this._mightContainRTL,
                        s = this._mightContainUnusualLineTerminators,
                        a = this._mightContainNonBasicASCII,
                        u = !0,
                        d = [];
                    for (let t = 0; t < e.length; t++) {
                        const n = e[t];
                        u && n._isTracked && (u = !1);
                        const o = n.range;
                        if (n.text) {
                            let e = !0;
                            a || (e = !(0, i.$i)(n.text), a = e), !r && e && (r = (0, i.Ut)(n.text)), !s && e && (s = (0, i.ab)(n.text))
                        }
                        let l = "",
                            h = 0,
                            f = 0,
                            p = 0;
                        if (n.text) {
                            let e;
                            [h, f, p, e] = (0, c.Q)(n.text);
                            const t = this.getEOL(),
                                r = "\r\n" === t ? c.b.CRLF : c.b.LF;
                            l = e === c.b.Unknown || e === r ? n.text : n.text.replace(/\r\n|\r|\n/g, t)
                        }
                        d[t] = {
                            sortIndex: t,
                            identifier: n.identifier || null,
                            range: o,
                            rangeOffset: this.getOffsetAt(o.startLineNumber, o.startColumn),
                            rangeLength: this.getValueLengthInRange(o),
                            text: l,
                            eolCount: h,
                            firstLineLength: f,
                            lastLineLength: p,
                            forceMoveMarkers: Boolean(n.forceMoveMarkers),
                            isAutoWhitespaceEdit: n.isAutoWhitespaceEdit || !1
                        }
                    }
                    d.sort(h._sortOpsAscending);
                    let f = !1;
                    for (let e = 0, t = d.length - 1; e < t; e++) {
                        const t = d[e].range.getEndPosition(),
                            n = d[e + 1].range.getStartPosition();
                        if (n.isBeforeOrEqual(t)) {
                            if (n.isBefore(t)) throw new Error("Overlapping ranges are not allowed!");
                            f = !0
                        }
                    }
                    u && (d = this._reduceOperations(d));
                    const p = n || t ? h._getInverseEditRanges(d) : [],
                        g = [];
                    if (t)
                        for (let e = 0; e < d.length; e++) {
                            const t = d[e],
                                n = p[e];
                            if (t.isAutoWhitespaceEdit && t.range.isEmpty())
                                for (let e = n.startLineNumber; e <= n.endLineNumber; e++) {
                                    let r = "";
                                    e === n.startLineNumber && (r = this.getLineContent(t.range.startLineNumber), -1 !== (0, i.LC)(r)) || g.push({
                                        lineNumber: e,
                                        oldContent: r
                                    })
                                }
                        }
                    let m = null;
                    if (n) {
                        let e = 0;
                        m = [];
                        for (let t = 0; t < d.length; t++) {
                            const n = d[t],
                                r = p[t],
                                i = this.getValueInRange(n.range),
                                s = n.rangeOffset + e;
                            e += n.text.length - i.length, m[t] = {
                                sortIndex: n.sortIndex,
                                identifier: n.identifier,
                                range: r,
                                text: i,
                                textChange: new l.q(n.rangeOffset, i, s, n.text)
                            }
                        }
                        f || m.sort(((e, t) => e.sortIndex - t.sortIndex))
                    }
                    this._mightContainRTL = r, this._mightContainUnusualLineTerminators = s, this._mightContainNonBasicASCII = a;
                    const b = this._doApplyEdits(d);
                    let _ = null;
                    if (t && g.length > 0) {
                        g.sort(((e, t) => t.lineNumber - e.lineNumber)), _ = [];
                        for (let e = 0, t = g.length; e < t; e++) {
                            const t = g[e].lineNumber;
                            if (e > 0 && g[e - 1].lineNumber === t) continue;
                            const n = g[e].oldContent,
                                r = this.getLineContent(t);
                            0 !== r.length && r !== n && -1 === (0, i.LC)(r) && _.push(t)
                        }
                    }
                    return this._onDidChangeContent.fire(), new o.je(m, b, _)
                }
                _reduceOperations(e) {
                    return e.length < 1e3 ? e : [this._toSingleEditOperation(e)]
                }
                _toSingleEditOperation(e) {
                    let t = !1;
                    const n = e[0].range,
                        r = e[e.length - 1].range,
                        i = new s.e(n.startLineNumber, n.startColumn, r.endLineNumber, r.endColumn);
                    let a = n.startLineNumber,
                        l = n.startColumn;
                    const u = [];
                    for (let n = 0, r = e.length; n < r; n++) {
                        const r = e[n],
                            i = r.range;
                        t = t || r.forceMoveMarkers, u.push(this.getValueInRange(new s.e(a, l, i.startLineNumber, i.startColumn))), r.text.length > 0 && u.push(r.text), a = i.endLineNumber, l = i.endColumn
                    }
                    const h = u.join(""),
                        [d, f, p] = (0, c.Q)(h);
                    return {
                        sortIndex: 0,
                        identifier: e[0].identifier,
                        range: i,
                        rangeOffset: this.getOffsetAt(i.startLineNumber, i.startColumn),
                        rangeLength: this.getValueLengthInRange(i, o.gm.TextDefined),
                        text: h,
                        eolCount: d,
                        firstLineLength: f,
                        lastLineLength: p,
                        forceMoveMarkers: t,
                        isAutoWhitespaceEdit: !1
                    }
                }
                _doApplyEdits(e) {
                    e.sort(h._sortOpsDescending);
                    const t = [];
                    for (let n = 0; n < e.length; n++) {
                        const r = e[n],
                            i = r.range.startLineNumber,
                            o = r.range.startColumn,
                            a = r.range.endLineNumber,
                            c = r.range.endColumn;
                        if (i === a && o === c && 0 === r.text.length) continue;
                        r.text ? (this._pieceTree.delete(r.rangeOffset, r.rangeLength), this._pieceTree.insert(r.rangeOffset, r.text, !0)) : this._pieceTree.delete(r.rangeOffset, r.rangeLength);
                        const l = new s.e(i, o, a, c);
                        t.push({
                            range: l,
                            rangeLength: r.rangeLength,
                            text: r.text,
                            rangeOffset: r.rangeOffset,
                            forceMoveMarkers: r.forceMoveMarkers
                        })
                    }
                    return t
                }
                findMatchesLineByLine(e, t, n, r) {
                    return this._pieceTree.findMatchesLineByLine(e, t, n, r)
                }
                getPieceTree() {
                    return this._pieceTree
                }
                static _getInverseEditRange(e, t) {
                    const n = e.startLineNumber,
                        r = e.startColumn,
                        [i, o, a] = (0, c.Q)(t);
                    let l;
                    if (t.length > 0) {
                        const e = i + 1;
                        l = 1 === e ? new s.e(n, r, n, r + o) : new s.e(n, r, n + e - 1, a + 1)
                    } else l = new s.e(n, r, n, r);
                    return l
                }
                static _getInverseEditRanges(e) {
                    const t = [];
                    let n = 0,
                        r = 0,
                        i = null;
                    for (let o = 0, a = e.length; o < a; o++) {
                        const a = e[o];
                        let c, l, u;
                        if (i ? i.range.endLineNumber === a.range.startLineNumber ? (c = n, l = r + (a.range.startColumn - i.range.endColumn)) : (c = n + (a.range.startLineNumber - i.range.endLineNumber), l = a.range.startColumn) : (c = a.range.startLineNumber, l = a.range.startColumn), a.text.length > 0) {
                            const e = a.eolCount + 1;
                            u = 1 === e ? new s.e(c, l, c, l + a.firstLineLength) : new s.e(c, l, c + e - 1, a.lastLineLength + 1)
                        } else u = new s.e(c, l, c, l);
                        n = u.endLineNumber, r = u.endColumn, t.push(u), i = a
                    }
                    return t
                }
                static _sortOpsAscending(e, t) {
                    const n = s.e.compareRangesUsingEnds(e.range, t.range);
                    return 0 === n ? e.sortIndex - t.sortIndex : n
                }
                static _sortOpsDescending(e, t) {
                    const n = s.e.compareRangesUsingEnds(e.range, t.range);
                    return 0 === n ? t.sortIndex - e.sortIndex : -n
                }
            }
        },
        "3Ld1": (e, t, n) => {
            n.d(t, {
                M: () => l
            });
            var r = n("U7Xe"),
                i = n("p044"),
                s = n("PLiU"),
                o = n("5e3k"),
                a = n("Hf6G");
            class c {
                constructor(e, t, n, r, i, s, o, a, c) {
                    this._chunks = e, this._bom = t, this._cr = n, this._lf = r, this._crlf = i, this._containsRTL = s, this._containsUnusualLineTerminators = o, this._isBasicASCII = a, this._normalizeEOL = c
                }
                _getEOL(e) {
                    const t = this._cr + this._lf + this._crlf,
                        n = this._cr + this._crlf;
                    return 0 === t ? e === s._x.LF ? "\n" : "\r\n" : n > t / 2 ? "\r\n" : "\n"
                }
                create(e) {
                    const t = this._getEOL(e),
                        n = this._chunks;
                    if (this._normalizeEOL && ("\r\n" === t && (this._cr > 0 || this._lf > 0) || "\n" === t && (this._cr > 0 || this._crlf > 0)))
                        for (let e = 0, r = n.length; e < r; e++) {
                            const r = n[e].buffer.replace(/\r\n|\r|\n/g, t),
                                i = (0, o.Xp)(r);
                            n[e] = new o.Lv(r, i)
                        }
                    const r = new a.A(n, this._bom, t, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);
                    return {
                        textBuffer: r,
                        disposable: r
                    }
                }
                getFirstLineText(e) {
                    return this._chunks[0].buffer.substr(0, e).split(/\r\n|\r|\n/)[0]
                }
            }
            class l {
                constructor() {
                    this.chunks = [], this.BOM = "", this._hasPreviousChar = !1, this._previousChar = 0, this._tmpLineStarts = [], this.cr = 0, this.lf = 0, this.crlf = 0, this.containsRTL = !1, this.containsUnusualLineTerminators = !1, this.isBasicASCII = !0
                }
                acceptChunk(e) {
                    if (0 === e.length) return;
                    0 === this.chunks.length && (0, i.uS)(e) && (this.BOM = i.c1, e = e.substr(1));
                    const t = e.charCodeAt(e.length - 1);
                    t === r.m.CarriageReturn || t >= 55296 && t <= 56319 ? (this._acceptChunk1(e.substr(0, e.length - 1), !1), this._hasPreviousChar = !0, this._previousChar = t) : (this._acceptChunk1(e, !1), this._hasPreviousChar = !1, this._previousChar = t)
                }
                _acceptChunk1(e, t) {
                    (t || 0 !== e.length) && (this._hasPreviousChar ? this._acceptChunk2(String.fromCharCode(this._previousChar) + e) : this._acceptChunk2(e))
                }
                _acceptChunk2(e) {
                    const t = (0, o.Nr)(this._tmpLineStarts, e);
                    this.chunks.push(new o.Lv(e, t.lineStarts)), this.cr += t.cr, this.lf += t.lf, this.crlf += t.crlf, t.isBasicASCII || (this.isBasicASCII = !1, this.containsRTL || (this.containsRTL = (0, i.Ut)(e)), this.containsUnusualLineTerminators || (this.containsUnusualLineTerminators = (0, i.ab)(e)))
                }
                finish(e = !0) {
                    return this._finish(), new c(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, e)
                }
                _finish() {
                    if (0 === this.chunks.length && this._acceptChunk1("", !0), this._hasPreviousChar) {
                        this._hasPreviousChar = !1;
                        const e = this.chunks[this.chunks.length - 1];
                        e.buffer += String.fromCharCode(this._previousChar);
                        const t = (0, o.Xp)(e.buffer);
                        e.lineStarts = t, this._previousChar === r.m.CarriageReturn && this.cr++
                    }
                }
            }
        },
        UMYg: (e, t, n) => {
            n.d(t, {
                C: () => a,
                O: () => c
            });
            var r, i = n("jxI3"),
                s = n("pLPy");

            function o(e) {
                for (let t = 0, n = e.length; t < n; t += 4) {
                    const n = e[t + 0],
                        r = e[t + 1],
                        i = e[t + 2],
                        s = e[t + 3];
                    e[t + 0] = s, e[t + 1] = i, e[t + 2] = r, e[t + 3] = n
                }
            }

            function a(e) {
                const t = new Uint32Array(function(e) {
                    let t = 0;
                    if (t += 2, "full" === e.type) t += 1 + e.data.length;
                    else {
                        t += 1, t += 3 * e.deltas.length;
                        for (const n of e.deltas) n.data && (t += n.data.length)
                    }
                    return t
                }(e));
                let n = 0;
                if (t[n++] = e.id, "full" === e.type) t[n++] = r.Full, t[n++] = e.data.length, t.set(e.data, n), n += e.data.length;
                else {
                    t[n++] = r.Delta, t[n++] = e.deltas.length;
                    for (const r of e.deltas) t[n++] = r.start, t[n++] = r.deleteCount, r.data ? (t[n++] = r.data.length, t.set(r.data, n), n += r.data.length) : t[n++] = 0
                }
                return function(e) {
                    const t = new Uint8Array(e.buffer, e.byteOffset, 4 * e.length);
                    return (0, s.r)() || o(t), i.KN.wrap(t)
                }(t)
            }

            function c(e) {
                const t = function(e) {
                    const t = e.buffer;
                    if ((0, s.r)() || o(t), t.byteOffset % 4 == 0) return new Uint32Array(t.buffer, t.byteOffset, t.length / 4); {
                        const e = new Uint8Array(t.byteLength);
                        return e.set(t), new Uint32Array(e.buffer, e.byteOffset, e.length / 4)
                    }
                }(e);
                let n = 0;
                const i = t[n++];
                if (t[n++] === r.Full) {
                    const e = t[n++],
                        r = t.subarray(n, n + e);
                    return n += e, {
                        id: i,
                        type: "full",
                        data: r
                    }
                }
                const a = t[n++],
                    c = [];
                for (let e = 0; e < a; e++) {
                    const r = t[n++],
                        i = t[n++],
                        s = t[n++];
                    let o;
                    s > 0 && (o = t.subarray(n, n + s), n += s), c[e] = {
                        start: r,
                        deleteCount: i,
                        data: o
                    }
                }
                return {
                    id: i,
                    type: "delta",
                    deltas: c
                }
            }! function(e) {
                e[e.Full = 1] = "Full", e[e.Delta = 2] = "Delta"
            }(r || (r = {}))
        },
        yFKF: (e, t, n) => {
            n.d(t, {
                C$: () => c,
                OQ: () => l,
                aj: () => u
            });
            let r = "undefined" != typeof document && document.location && document.location.hash.indexOf("pseudo=true") >= 0;

            function i(e, t) {
                let n;
                return n = 0 === t.length ? e : e.replace(/\{(\d+)\}/g, ((e, n) => {
                    const r = n[0],
                        i = t[r];
                    let s = e;
                    return "string" == typeof i ? s = i : "number" != typeof i && "boolean" != typeof i && null != i || (s = String(i)), s
                })), r && (n = "［" + n.replace(/[aouei]/g, "$&$&") + "］"), n
            }
            let s, o = !1,
                a = {};

            function c(e, t, n, ...r) {
                o = !0;
                const s = "object" == typeof t ? t.key : t;
                return i((a[e] ? ? {})[s] ? ? n, r)
            }

            function l(e, t, n, ...r) {
                o = !0;
                const s = "object" == typeof t ? t.key : t;
                return {
                    value: i((a[e] ? ? {})[s] ? ? n, r),
                    original: i(n, r)
                }
            }

            function u(e) {
                return s
            }
        },
        uE0G: (e, t, n) => {
            n.d(t, {
                Z: () => h,
                i: () => a
            });
            var r = n("U7Xe"),
                i = n("PUdK"),
                s = n("yFKF");
            const o = "vs/platform/contextkey/common/scanner";
            var a;

            function c(...e) {
                switch (e.length) {
                    case 1:
                        return (0, s.C$)(o, 0, "Did you mean {0}?", e[0]);
                    case 2:
                        return (0, s.C$)(o, 1, "Did you mean {0} or {1}?", e[0], e[1]);
                    case 3:
                        return (0, s.C$)(o, 2, "Did you mean {0}, {1} or {2}?", e[0], e[1], e[2]);
                    default:
                        return
                }
            }! function(e) {
                e[e.LParen = 0] = "LParen", e[e.RParen = 1] = "RParen", e[e.Neg = 2] = "Neg", e[e.Eq = 3] = "Eq", e[e.NotEq = 4] = "NotEq", e[e.Lt = 5] = "Lt", e[e.LtEq = 6] = "LtEq", e[e.Gt = 7] = "Gt", e[e.GtEq = 8] = "GtEq", e[e.RegexOp = 9] = "RegexOp", e[e.RegexStr = 10] = "RegexStr", e[e.True = 11] = "True", e[e.False = 12] = "False", e[e.In = 13] = "In", e[e.Not = 14] = "Not", e[e.And = 15] = "And", e[e.Or = 16] = "Or", e[e.Str = 17] = "Str", e[e.QuotedStr = 18] = "QuotedStr", e[e.Error = 19] = "Error", e[e.EOF = 20] = "EOF"
            }(a || (a = {}));
            const l = (0, s.C$)(o, 3, "Did you forget to open or close the quote?"),
                u = (0, s.C$)(o, 4, "Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\/'.");
            class h {
                constructor() {
                    this._input = "", this._start = 0, this._current = 0, this._tokens = [], this._errors = [], this.stringRe = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy
                }
                static getLexeme(e) {
                    switch (e.type) {
                        case a.LParen:
                            return "(";
                        case a.RParen:
                            return ")";
                        case a.Neg:
                            return "!";
                        case a.Eq:
                            return e.isTripleEq ? "===" : "==";
                        case a.NotEq:
                            return e.isTripleEq ? "!==" : "!=";
                        case a.Lt:
                            return "<";
                        case a.LtEq:
                            return "<=";
                        case a.Gt:
                        case a.GtEq:
                            return ">=";
                        case a.RegexOp:
                            return "=~";
                        case a.RegexStr:
                            return e.lexeme;
                        case a.True:
                            return "true";
                        case a.False:
                            return "false";
                        case a.In:
                            return "in";
                        case a.Not:
                            return "not";
                        case a.And:
                            return "&&";
                        case a.Or:
                            return "||";
                        case a.Str:
                        case a.QuotedStr:
                        case a.Error:
                            return e.lexeme;
                        case a.EOF:
                            return "EOF";
                        default:
                            throw (0, i.L6)(`unhandled token type: ${JSON.stringify(e)}; have you forgotten to add a case?`)
                    }
                }
                static {
                    this._regexFlags = new Set(["i", "g", "s", "m", "y", "u"].map((e => e.charCodeAt(0))))
                }
                static {
                    this._keywords = new Map([
                        ["not", a.Not],
                        ["in", a.In],
                        ["false", a.False],
                        ["true", a.True]
                    ])
                }
                get errors() {
                    return this._errors
                }
                reset(e) {
                    return this._input = e, this._start = 0, this._current = 0, this._tokens = [], this._errors = [], this
                }
                scan() {
                    for (; !this._isAtEnd();) switch (this._start = this._current, this._advance()) {
                        case r.m.OpenParen:
                            this._addToken(a.LParen);
                            break;
                        case r.m.CloseParen:
                            this._addToken(a.RParen);
                            break;
                        case r.m.ExclamationMark:
                            if (this._match(r.m.Equals)) {
                                const e = this._match(r.m.Equals);
                                this._tokens.push({
                                    type: a.NotEq,
                                    offset: this._start,
                                    isTripleEq: e
                                })
                            } else this._addToken(a.Neg);
                            break;
                        case r.m.SingleQuote:
                            this._quotedString();
                            break;
                        case r.m.Slash:
                            this._regex();
                            break;
                        case r.m.Equals:
                            if (this._match(r.m.Equals)) {
                                const e = this._match(r.m.Equals);
                                this._tokens.push({
                                    type: a.Eq,
                                    offset: this._start,
                                    isTripleEq: e
                                })
                            } else this._match(r.m.Tilde) ? this._addToken(a.RegexOp) : this._error(c("==", "=~"));
                            break;
                        case r.m.LessThan:
                            this._addToken(this._match(r.m.Equals) ? a.LtEq : a.Lt);
                            break;
                        case r.m.GreaterThan:
                            this._addToken(this._match(r.m.Equals) ? a.GtEq : a.Gt);
                            break;
                        case r.m.Ampersand:
                            this._match(r.m.Ampersand) ? this._addToken(a.And) : this._error(c("&&"));
                            break;
                        case r.m.Pipe:
                            this._match(r.m.Pipe) ? this._addToken(a.Or) : this._error(c("||"));
                            break;
                        case r.m.Space:
                        case r.m.CarriageReturn:
                        case r.m.Tab:
                        case r.m.LineFeed:
                        case r.m.NoBreakSpace:
                            break;
                        default:
                            this._string()
                    }
                    return this._start = this._current, this._addToken(a.EOF), Array.from(this._tokens)
                }
                _match(e) {
                    return !this._isAtEnd() && this._input.charCodeAt(this._current) === e && (this._current++, !0)
                }
                _advance() {
                    return this._input.charCodeAt(this._current++)
                }
                _peek() {
                    return this._isAtEnd() ? r.m.Null : this._input.charCodeAt(this._current)
                }
                _addToken(e) {
                    this._tokens.push({
                        type: e,
                        offset: this._start
                    })
                }
                _error(e) {
                    const t = this._start,
                        n = this._input.substring(this._start, this._current),
                        r = {
                            type: a.Error,
                            offset: this._start,
                            lexeme: n
                        };
                    this._errors.push({
                        offset: t,
                        lexeme: n,
                        additionalInfo: e
                    }), this._tokens.push(r)
                }
                _string() {
                    this.stringRe.lastIndex = this._start;
                    const e = this.stringRe.exec(this._input);
                    if (e) {
                        this._current = this._start + e[0].length;
                        const t = this._input.substring(this._start, this._current),
                            n = h._keywords.get(t);
                        n ? this._addToken(n) : this._tokens.push({
                            type: a.Str,
                            lexeme: t,
                            offset: this._start
                        })
                    }
                }
                _quotedString() {
                    for (; this._peek() !== r.m.SingleQuote && !this._isAtEnd();) this._advance();
                    this._isAtEnd() ? this._error(l) : (this._advance(), this._tokens.push({
                        type: a.QuotedStr,
                        lexeme: this._input.substring(this._start + 1, this._current - 1),
                        offset: this._start + 1
                    }))
                }
                _regex() {
                    let e = this._current,
                        t = !1,
                        n = !1;
                    for (;;) {
                        if (e >= this._input.length) return this._current = e, void this._error(u);
                        const i = this._input.charCodeAt(e);
                        if (t) t = !1;
                        else {
                            if (i === r.m.Slash && !n) {
                                e++;
                                break
                            }
                            i === r.m.OpenSquareBracket ? n = !0 : i === r.m.Backslash ? t = !0 : i === r.m.CloseSquareBracket && (n = !1)
                        }
                        e++
                    }
                    for (; e < this._input.length && h._regexFlags.has(this._input.charCodeAt(e));) e++;
                    this._current = e;
                    const i = this._input.substring(this._start, this._current);
                    this._tokens.push({
                        type: a.RegexStr,
                        lexeme: i,
                        offset: this._start
                    })
                }
                _isAtEnd() {
                    return this._current >= this._input.length
                }
            }
        },
        XBPS: (e, t, n) => {
            n.d(t, {
                Y: () => r
            });
            const r = (0, n("OYZR").yh)("environmentService")
        },
        "k6+O": (e, t, n) => {
            n.d(t, {
                S: () => s
            });
            var r = n("PUdK"),
                i = n("6zxw");
            const s = new class {
                constructor() {
                    this._generators = new Map, this._cache = new WeakMap
                }
                register(e, t) {
                    this._generators.set(e, t)
                }
                readActivationEvents(e) {
                    return this._cache.has(e) || this._cache.set(e, this._readActivationEvents(e)), this._cache.get(e)
                }
                createActivationEventsMap(e) {
                    const t = Object.create(null);
                    for (const n of e) {
                        const e = this.readActivationEvents(n);
                        e.length > 0 && (t[i.kP.toKey(n.identifier)] = e)
                    }
                    return t
                }
                _readActivationEvents(e) {
                    if (void 0 === e.main && void 0 === e.browser) return [];
                    const t = Array.isArray(e.activationEvents) ? e.activationEvents.slice(0) : [];
                    for (let n = 0; n < t.length; n++) "onUri" === t[n] && (t[n] = `onUri:${i.kP.toKey(e.identifier)}`);
                    if (!e.contributes) return t;
                    for (const n in e.contributes) {
                        const i = this._generators.get(n);
                        if (!i) continue;
                        const s = e.contributes[n],
                            o = Array.isArray(s) ? s : [s];
                        try {
                            i(o, t)
                        } catch (e) {
                            (0, r.dL)(e)
                        }
                    }
                    return t
                }
            }
        },
        "9r3b": (e, t, n) => {
            n.d(t, {
                M: () => r
            });
            class r {
                constructor(e, t = [], n = !1) {
                    this.ctor = e, this.staticArguments = t, this.supportsDelayedInstantiation = n
                }
            }
        },
        "yJ/l": (e, t, n) => {
            n.d(t, {
                _Z: () => s,
                dh: () => a,
                zr: () => o
            });
            var r = n("9r3b");
            const i = [];
            var s;

            function o(e, t, n) {
                t instanceof r.M || (t = new r.M(t, [], Boolean(n))), i.push([e, t])
            }

            function a() {
                return i
            }! function(e) {
                e[e.Eager = 0] = "Eager", e[e.Delayed = 1] = "Delayed"
            }(s || (s = {}))
        },
        D2uF: (e, t, n) => {
            n.d(t, {
                F: () => g
            });
            var r = n("opu4"),
                i = n("PUdK"),
                s = n("RVdl"),
                o = n("9r3b");
            class a {
                constructor(e, t) {
                    this.key = e, this.data = t, this.incoming = new Map, this.outgoing = new Map
                }
            }
            class c {
                constructor(e) {
                    this._hashFn = e, this._nodes = new Map
                }
                roots() {
                    const e = [];
                    for (const t of this._nodes.values()) 0 === t.outgoing.size && e.push(t);
                    return e
                }
                insertEdge(e, t) {
                    const n = this.lookupOrInsertNode(e),
                        r = this.lookupOrInsertNode(t);
                    n.outgoing.set(r.key, r), r.incoming.set(n.key, n)
                }
                removeNode(e) {
                    const t = this._hashFn(e);
                    this._nodes.delete(t);
                    for (const e of this._nodes.values()) e.outgoing.delete(t), e.incoming.delete(t)
                }
                lookupOrInsertNode(e) {
                    const t = this._hashFn(e);
                    let n = this._nodes.get(t);
                    return n || (n = new a(t, e), this._nodes.set(t, n)), n
                }
                lookup(e) {
                    return this._nodes.get(this._hashFn(e))
                }
                isEmpty() {
                    return 0 === this._nodes.size
                }
                toString() {
                    const e = [];
                    for (const [t, n] of this._nodes) e.push(`${t}\n\t(-> incoming)[${[...n.incoming.keys()].join(", ")}]\n\t(outgoing ->)[${[...n.outgoing.keys()].join(",")}]\n`);
                    return e.join("\n")
                }
                findCycleSlow() {
                    for (const [e, t] of this._nodes) {
                        const n = new Set([e]),
                            r = this._findCycle(t, n);
                        if (r) return r
                    }
                }
                _findCycle(e, t) {
                    for (const [n, r] of e.outgoing) {
                        if (t.has(n)) return [...t, n].join(" -> ");
                        t.add(n);
                        const e = this._findCycle(r, t);
                        if (e) return e;
                        t.delete(n)
                    }
                }
            }
            var l, u = n("OYZR"),
                h = n("5g4k"),
                d = n("U+Fb"),
                f = n("ziTh");
            class p extends Error {
                constructor(e) {
                    super("cyclic dependency between services"), this.message = e.findCycleSlow() ? ? `UNABLE to detect cycle, dumping graph: \n${e.toString()}`
                }
            }
            class g {
                constructor(e = new h.y, t = !1, n, r = !1) {
                    this._services = e, this._strict = t, this._parent = n, this._enableTracing = r, this._isDisposed = !1, this._servicesToMaybeDispose = new Set, this._children = new Set, this._activeInstantiations = new Set, this._services.set(u.TG, this), this._globalGraph = r ? n ? ._globalGraph ? ? new c((e => e)) : void 0
                }
                dispose() {
                    if (!this._isDisposed) {
                        this._isDisposed = !0, (0, s.B9)(this._children), this._children.clear();
                        for (const e of this._servicesToMaybeDispose)(0, s.Wf)(e) && e.dispose();
                        this._servicesToMaybeDispose.clear()
                    }
                }
                _throwIfDisposed() {
                    if (this._isDisposed) throw new Error("InstantiationService has been disposed")
                }
                createChild(e, t) {
                    this._throwIfDisposed();
                    const n = this,
                        r = new class extends g {
                            dispose() {
                                n._children.delete(r), super.dispose()
                            }
                        }(e, this._strict, this, this._enableTracing);
                    return this._children.add(r), t ? .add(r), r
                }
                invokeFunction(e, ...t) {
                    this._throwIfDisposed();
                    const n = m.traceInvocation(this._enableTracing, e);
                    let r = !1;
                    try {
                        return e({
                            get: e => {
                                if (r) throw (0, i.L6)("service accessor is only valid during the invocation of its target method");
                                const t = this._getOrCreateServiceInstance(e, n);
                                if (!t) throw new Error(`[invokeFunction] unknown service '${e}'`);
                                return t
                            }
                        }, ...t)
                    } finally {
                        r = !0, n.stop()
                    }
                }
                createInstance(e, ...t) {
                    let n, r;
                    return this._throwIfDisposed(), e instanceof o.M ? (n = m.traceCreation(this._enableTracing, e.ctor), r = this._createInstance(e.ctor, e.staticArguments.concat(t), n)) : (n = m.traceCreation(this._enableTracing, e), r = this._createInstance(e, t, n)), n.stop(), r
                }
                _createInstance(e, t = [], n) {
                    const r = u.I8.getServiceDependencies(e).sort(((e, t) => e.index - t.index)),
                        i = [];
                    for (const t of r) {
                        const r = this._getOrCreateServiceInstance(t.id, n);
                        r || this._throwIfStrict(`[createInstance] ${e.name} depends on UNKNOWN service ${t.id}.`, !1), i.push(r)
                    }
                    const s = r.length > 0 ? r[0].index : t.length;
                    if (t.length !== s) {
                        f.trace(`[createInstance] First service dependency of ${e.name} at position ${s+1} conflicts with ${t.length} static arguments`);
                        const n = s - t.length;
                        t = n > 0 ? t.concat(new Array(n)) : t.slice(0, s)
                    }
                    return Reflect.construct(e, t.concat(i))
                }
                _setCreatedServiceInstance(e, t) {
                    if (this._services.get(e) instanceof o.M) this._services.set(e, t);
                    else {
                        if (!this._parent) throw new Error("illegalState - setting UNKNOWN service instance");
                        this._parent._setCreatedServiceInstance(e, t)
                    }
                }
                _getServiceInstanceOrDescriptor(e) {
                    const t = this._services.get(e);
                    return !t && this._parent ? this._parent._getServiceInstanceOrDescriptor(e) : t
                }
                _getOrCreateServiceInstance(e, t) {
                    this._globalGraph && this._globalGraphImplicitDependency && this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(e));
                    const n = this._getServiceInstanceOrDescriptor(e);
                    return n instanceof o.M ? this._safeCreateAndCacheServiceInstance(e, n, t.branch(e, !0)) : (t.branch(e, !1), n)
                }
                _safeCreateAndCacheServiceInstance(e, t, n) {
                    if (this._activeInstantiations.has(e)) throw new Error(`illegal state - RECURSIVELY instantiating service '${e}'`);
                    this._activeInstantiations.add(e);
                    try {
                        return this._createAndCacheServiceInstance(e, t, n)
                    } finally {
                        this._activeInstantiations.delete(e)
                    }
                }
                _createAndCacheServiceInstance(e, t, n) {
                    const r = new c((e => e.id.toString()));
                    let i = 0;
                    const s = [{
                        id: e,
                        desc: t,
                        _trace: n
                    }];
                    for (; s.length;) {
                        const t = s.pop();
                        if (r.lookupOrInsertNode(t), i++ > 1e3) throw new p(r);
                        for (const n of u.I8.getServiceDependencies(t.desc.ctor)) {
                            const i = this._getServiceInstanceOrDescriptor(n.id);
                            if (i || this._throwIfStrict(`[createInstance] ${e} depends on ${n.id} which is NOT registered.`, !0), this._globalGraph ? .insertEdge(String(t.id), String(n.id)), i instanceof o.M) {
                                const e = {
                                    id: n.id,
                                    desc: i,
                                    _trace: t._trace.branch(n.id, !0)
                                };
                                r.lookup(e) || s.push(e), r.insertEdge(t, e)
                            }
                        }
                    }
                    for (;;) {
                        const e = r.roots();
                        if (0 === e.length) {
                            if (!r.isEmpty()) throw new p(r);
                            break
                        }
                        for (const {
                                data: t
                            } of e) {
                            if (this._getServiceInstanceOrDescriptor(t.id) instanceof o.M) {
                                const e = this._createServiceInstanceWithOwner(t.id, t.desc.ctor, t.desc.staticArguments, t.desc.supportsDelayedInstantiation, t._trace);
                                this._setCreatedServiceInstance(t.id, e)
                            }
                            r.removeNode(t)
                        }
                    }
                    return this._getServiceInstanceOrDescriptor(e)
                }
                _createServiceInstanceWithOwner(e, t, n = [], r, i) {
                    if (this._services.get(e) instanceof o.M) return this._createServiceInstance(e, t, n, r, i, this._servicesToMaybeDispose);
                    if (this._parent) return this._parent._createServiceInstanceWithOwner(e, t, n, r, i);
                    throw new Error(`illegalState - creating UNKNOWN service instance ${t.name}`)
                }
                _createServiceInstance(e, t, n = [], i, o, a) {
                    if (i) {
                        const i = new g(void 0, this._strict, this, this._enableTracing);
                        i._globalGraphImplicitDependency = String(e);
                        const c = new Map,
                            l = new r.R5((() => {
                                const e = i._createInstance(t, n, o);
                                for (const [t, n] of c) {
                                    const r = e[t];
                                    if ("function" == typeof r)
                                        for (const t of n) t.disposable = r.apply(e, t.listener)
                                }
                                return c.clear(), a.add(e), e
                            }));
                        return new Proxy(Object.create(null), {
                            get(e, t) {
                                if (!l.isInitialized && "string" == typeof t && (t.startsWith("onDid") || t.startsWith("onWill"))) {
                                    let e = c.get(t);
                                    return e || (e = new d.S, c.set(t, e)), (n, r, i) => {
                                        if (l.isInitialized) return l.value[t](n, r, i); {
                                            const t = {
                                                    listener: [n, r, i],
                                                    disposable: void 0
                                                },
                                                o = e.push(t);
                                            return (0, s.OF)((() => {
                                                o(), t.disposable ? .dispose()
                                            }))
                                        }
                                    }
                                }
                                if (t in e) return e[t];
                                const n = l.value;
                                let r = n[t];
                                return "function" != typeof r || (r = r.bind(n), e[t] = r), r
                            },
                            set: (e, t, n) => (l.value[t] = n, !0),
                            getPrototypeOf: e => t.prototype
                        })
                    } {
                        const e = this._createInstance(t, n, o);
                        return a.add(e), e
                    }
                }
                _throwIfStrict(e, t) {
                    if (t && f.warn(e), this._strict) throw new Error(e)
                }
            }! function(e) {
                e[e.None = 0] = "None", e[e.Creation = 1] = "Creation", e[e.Invocation = 2] = "Invocation", e[e.Branch = 3] = "Branch"
            }(l || (l = {}));
            class m {
                static {
                    this.all = new Set
                }
                static {
                    this._None = new class extends m {
                        constructor() {
                            super(l.None, null)
                        }
                        stop() {}
                        branch() {
                            return this
                        }
                    }
                }
                static traceInvocation(e, t) {
                    return e ? new m(l.Invocation, t.name || (new Error).stack.split("\n").slice(3, 4).join("\n")) : m._None
                }
                static traceCreation(e, t) {
                    return e ? new m(l.Creation, t.name) : m._None
                }
                static {
                    this._totals = 0
                }
                constructor(e, t) {
                    this.type = e, this.name = t, this._start = Date.now(), this._dep = []
                }
                branch(e, t) {
                    const n = new m(l.Branch, e.toString());
                    return this._dep.push([e, t, n]), n
                }
                stop() {
                    const e = Date.now() - this._start;
                    m._totals += e;
                    let t = !1;
                    const n = [`${this.type===l.Creation?"CREATE":"CALL"} ${this.name}`, `${function e(n,r){const i=[],s=new Array(n+1).join("\t");for(const[o,a,c]of r._dep)if(a&&c){t=!0,i.push(`${s}CREATES -> ${o}`);const r=e(n+1,c);r&&i.push(r)}else i.push(`
                        $ {
                            s
                        }
                        uses - > $ {
                            o
                        }
                        `);return i.join("\n")}(1,this)}`, `DONE, took ${e.toFixed(2)}ms (grand total ${m._totals.toFixed(2)}ms)`
                    ];
                    (e > 2 || t) && m.all.add(n.join("\n"))
                }
            }
        },
        "5g4k": (e, t, n) => {
            n.d(t, {
                y: () => r
            });
            class r {
                constructor(...e) {
                    this._entries = new Map;
                    for (const [t, n] of e) this.set(t, n)
                }
                set(e, t) {
                    const n = this._entries.get(e);
                    return this._entries.set(e, t), n
                }
                has(e) {
                    return this._entries.has(e)
                }
                get(e) {
                    return this._entries.get(e)
                }
            }
        },
        sttp: (e, t, n) => {
            n.d(t, {
                I: () => s
            });
            var r = n("7icl"),
                i = n("gQuC");
            const s = {
                    JSONContribution: "base.contributions.json"
                },
                o = new class {
                    constructor() {
                        this._onDidChangeSchema = new r.Q5, this.onDidChangeSchema = this._onDidChangeSchema.event, this.schemasById = {}
                    }
                    registerSchema(e, t) {
                        var n;
                        this.schemasById[(n = e, n.length > 0 && "#" === n.charAt(n.length - 1) ? n.substring(0, n.length - 1) : n)] = t, this._onDidChangeSchema.fire(e)
                    }
                    notifySchemaChanged(e) {
                        this._onDidChangeSchema.fire(e)
                    }
                    getSchemaContributions() {
                        return {
                            schemas: this.schemasById
                        }
                    }
                };
            i.B.add(s.JSONContribution, o)
        },
        Pz4e: (e, t, n) => {
            n.d(t, {
                $: () => s
            });
            var r = n("RVdl"),
                i = n("7EzT");
            class s extends r.JT {
                constructor(e, t = []) {
                    super(), this.logger = new i.qA([e, ...t]), this._register(e.onDidChangeLogLevel((e => this.setLevel(e))))
                }
                get onDidChangeLogLevel() {
                    return this.logger.onDidChangeLogLevel
                }
                setLevel(e) {
                    this.logger.setLevel(e)
                }
                getLevel() {
                    return this.logger.getLevel()
                }
                trace(e, ...t) {
                    this.logger.trace(e, ...t)
                }
                debug(e, ...t) {
                    this.logger.debug(e, ...t)
                }
                info(e, ...t) {
                    this.logger.info(e, ...t)
                }
                warn(e, ...t) {
                    this.logger.warn(e, ...t)
                }
                error(e, ...t) {
                    this.logger.error(e, ...t)
                }
                flush() {
                    this.logger.flush()
                }
            }
        },
        MEcd: (e, t, n) => {
            n.d(t, {
                h: () => r
            });
            const r = "vscode://schemas/vscode-product"
        },
        eOE0: (e, t, n) => {
            n.d(t, {
                a: () => r
            });
            const r = (0, n("OYZR").yh)("productService")
        },
        "6kFV": (e, t, n) => {
            n.d(t, {
                U: () => r
            });
            const r = (0, n("OYZR").yh)("requestService")
        },
        "E++z": (e, t, n) => {
            n.d(t, {
                $: () => r
            });
            class r {
                constructor(e) {
                    this._callback = e, this._terminalBufferMap = new Map
                }
                dispose() {
                    for (const e of this._terminalBufferMap.values()) e.dispose()
                }
                startBuffering(e, t, n = 5) {
                    const r = t((t => {
                        const i = "string" == typeof t ? t : t.data;
                        let s = this._terminalBufferMap.get(e);
                        if (s) return void s.data.push(i);
                        const o = setTimeout((() => this.flushBuffer(e)), n);
                        s = {
                            data: [i],
                            timeoutId: o,
                            dispose: () => {
                                clearTimeout(o), this.flushBuffer(e), r.dispose()
                            }
                        }, this._terminalBufferMap.set(e, s)
                    }));
                    return r
                }
                stopBuffering(e) {
                    const t = this._terminalBufferMap.get(e);
                    t ? .dispose()
                }
                flushBuffer(e) {
                    const t = this._terminalBufferMap.get(e);
                    t && (this._terminalBufferMap.delete(e), this._callback(e, t.data.join("")))
                }
            }
        },
        Ahbz: (e, t, n) => {
            n.d(t, {
                l: () => r
            });
            const r = (0, n("OYZR").yh)("IUserDataProfilesService")
        },
        t5JL: (e, t, n) => {
            var r;
            n.d(t, {
                    i: () => r
                }),
                function(e) {
                    e[e.Complete = 100] = "Complete", e[e.Partial = 50] = "Partial", e[e.None = 0] = "None"
                }(r || (r = {}))
        },
        "5h1i": (e, t, n) => {
            n.d(t, {
                $: () => r
            });
            const r = (0, n("OYZR").yh)("IExtHostInitDataService")
        },
        Ayc8: (e, t, n) => {
            n.d(t, {
                O: () => r,
                i: () => i
            });
            const r = (0, n("OYZR").yh)("IExtHostRpcService");
            class i {
                constructor(e) {
                    this.getProxy = e.getProxy.bind(e), this.set = e.set.bind(e), this.dispose = e.dispose.bind(e), this.assertRegistered = e.assertRegistered.bind(e), this.drain = e.drain.bind(e)
                }
            }
        },
        Jr0N: (e, t, n) => {
            n.d(t, {
                b: () => s,
                l: () => o
            });
            var r = n("V6Y4");
            const i = new WeakMap,
                s = (e, t) => {
                    const n = {
                        controllerId: t
                    };
                    return i.set(e, n), n
                },
                o = e => {
                    const t = i.get(e);
                    if (!t) throw new r.Mh(e ? .id || "<unknown>");
                    return t
                }
        },
        IqsH: (e, t, n) => {
            n.d(t, {
                MP: () => fe,
                ll: () => de,
                RV: () => pe,
                e5: () => Ft,
                TU: () => Dt,
                hq: () => Bt,
                $l: () => $t,
                IE: () => Ut,
                a8: () => _t,
                oY: () => Pt,
                tr: () => St,
                WT: () => At,
                Ik: () => Ct,
                s8: () => kt,
                ZJ: () => It,
                HY: () => yt,
                Zg: () => xt,
                Sm: () => Mt,
                Gl: () => Et,
                Ht: () => Ot,
                cG: () => Nt,
                fk: () => Tt,
                JL: () => Lt,
                cq: () => Rt,
                CD: () => ft,
                Il: () => Ue,
                oi: () => Pe,
                TK: () => Ie,
                FG: () => Te,
                cm: () => Ee,
                we: () => Se,
                tn: () => bt,
                rT: () => jt,
                aw: () => se,
                nc: () => be,
                R9: () => Y,
                eh: () => xe,
                jW: () => De,
                Lq: () => G,
                w6: () => he,
                b6: () => ze,
                hf: () => ve,
                so: () => We,
                RW: () => He,
                TM: () => _e,
                t7: () => Ne,
                gl: () => Me,
                CR: () => we,
                GS: () => ye,
                xf: () => wt,
                Hv: () => Vt,
                $z: () => Ke,
                OU: () => Ze,
                W5: () => te,
                lM: () => ke,
                KP: () => Ye,
                _2: () => Je,
                wU: () => Qe,
                JO: () => nt,
                x$: () => tt,
                c4: () => Xe,
                RG: () => ot,
                wN: () => rt,
                ac: () => st,
                Xs: () => Ge,
                xT: () => at,
                b$: () => it,
                hI: () => qt,
                Ly: () => Z,
                uT: () => qe,
                e6: () => V,
                Y1: () => j,
                xm: () => Fe,
                vy: () => Ae,
                cR: () => ce,
                r4: () => le,
                w7: () => zt,
                xC: () => dt,
                UK: () => ut,
                lt: () => ct,
                P1: () => ht,
                Ld: () => lt,
                wD: () => Be,
                PY: () => oe,
                lP: () => $e,
                P5: () => Ve,
                iv: () => K,
                fQ: () => pt,
                z0: () => gt,
                eI: () => ee,
                Db: () => ae,
                $P: () => ue,
                MA: () => Xt,
                J1: () => Qt,
                xh: () => ge,
                Ru: () => en
            });
            var r = n("iDmX"),
                i = n("jxI3"),
                s = n("kCZW"),
                o = n("G9Uv"),
                a = n("o1+4"),
                c = n("Ef4y"),
                l = n("80+w"),
                u = n("GHax"),
                h = n("qf7F"),
                d = n("7eUP"),
                f = n("C0CW"),
                p = n("oVnE"),
                g = n("6JmM"),
                m = n("K30K"),
                b = n("naIR"),
                _ = n("xxnL"),
                v = n("Aw1u"),
                w = n("6ksn"),
                y = n("Oe9y"),
                x = n("PLiU"),
                k = n("Ekjh"),
                C = n("xoT7"),
                I = n("Jr0N"),
                S = n("2Azc"),
                E = n("HcNz"),
                T = n("t5wJ"),
                L = n("7icl"),
                R = n("wBFb"),
                A = n("RVdl"),
                N = n("p044"),
                O = n("yFKF"),
                M = n("6zxw"),
                D = n("Vvlp"),
                P = n("LE1I"),
                U = n("0P4T"),
                F = n("GkOh");
            const B = "vs/workbench/contrib/chat/common/languageModels";
            var $;
            ! function(e) {
                e[e.System = 0] = "System", e[e.User = 1] = "User", e[e.Assistant = 2] = "Assistant"
            }($ || ($ = {}));
            const z = {
                    type: "object",
                    properties: {
                        vendor: {
                            type: "string",
                            description: (0, O.C$)(B, 0, "A globally unique vendor of language models.")
                        }
                    }
                },
                q = F.ut.registerExtensionPoint({
                    extensionPoint: "languageModels",
                    jsonSchema: {
                        description: (0, O.C$)(B, 1, "Contribute language models of a specific vendor."),
                        oneOf: [z, {
                            type: "array",
                            items: z
                        }]
                    },
                    activationEventsGenerator: (e, t) => {
                        for (const n of e) t.push(`onLanguageModelChat:${n.vendor}`)
                    }
                });
            let W = class {
                constructor(e, t) {
                    this._extensionService = e, this._logService = t, this._store = new A.SL, this._providers = new Map, this._vendors = new Set, this._onDidChangeProviders = this._store.add(new L.Q5), this.onDidChangeLanguageModels = this._onDidChangeProviders.event, this._store.add(q.setHandler((e => {
                        this._vendors.clear();
                        for (const t of e)
                            if ((0, P.$x)(t.description, "chatProvider"))
                                for (const e of R.$.wrap(t.value)) this._vendors.has(e.vendor) ? t.collector.error((0, O.C$)(B, 3, "The vendor '{0}' is already registered and cannot be registered twice", e.vendor)) : (0, N.m5)(e.vendor) ? t.collector.error((0, O.C$)(B, 4, "The vendor field cannot be empty.")) : e.vendor.trim() === e.vendor ? this._vendors.add(e.vendor) : t.collector.error((0, O.C$)(B, 5, "The vendor field cannot start or end with whitespace."));
                            else t.collector.error((0, O.C$)(B, 2, "This contribution point requires the 'chatProvider' proposal."));
                        const t = [];
                        for (const [e, n] of this._providers) this._vendors.has(n.metadata.vendor) || (this._providers.delete(e), t.push(e));
                        t.length > 0 && this._onDidChangeProviders.fire({
                            removed: t
                        })
                    })))
                }
                dispose() {
                    this._store.dispose(), this._providers.clear()
                }
                getLanguageModelIds() {
                    return Array.from(this._providers.keys())
                }
                lookupLanguageModel(e) {
                    return this._providers.get(e) ? .metadata
                }
                async selectLanguageModels(e) {
                    if (e.vendor) await this._extensionService.activateByEvent(`onLanguageModelChat:${e.vendor}}`);
                    else {
                        const e = Array.from(this._vendors).map((e => this._extensionService.activateByEvent(`onLanguageModelChat:${e}`)));
                        await Promise.all(e)
                    }
                    const t = [];
                    for (const [n, r] of this._providers) void 0 !== e.vendor && r.metadata.vendor !== e.vendor || void 0 !== e.family && r.metadata.family !== e.family || void 0 !== e.version && r.metadata.version !== e.version || void 0 !== e.identifier && r.metadata.id !== e.identifier || r.metadata.targetExtensions && !r.metadata.targetExtensions.some((t => M.kP.equals(t, e.extension))) || t.push(n);
                    return this._logService.trace("[LM] selected language models", e, t), t
                }
                registerLanguageModelChat(e, t) {
                    if (this._logService.trace("[LM] registering language model chat", e, t.metadata), !this._vendors.has(t.metadata.vendor)) throw new Error(`Chat response provider uses UNKNOWN vendor ${t.metadata.vendor}.`);
                    if (this._providers.has(e)) throw new Error(`Chat response provider with identifier ${e} is already registered.`);
                    return this._providers.set(e, t), this._onDidChangeProviders.fire({
                        added: [{
                            identifier: e,
                            metadata: t.metadata
                        }]
                    }), (0, A.OF)((() => {
                        this._providers.delete(e) && (this._onDidChangeProviders.fire({
                            removed: [e]
                        }), this._logService.trace("[LM] UNregistered language model chat", e, t.metadata))
                    }))
                }
                async sendChatRequest(e, t, n, r, i) {
                    const s = this._providers.get(e);
                    if (!s) throw new Error(`Chat response provider with identifier ${e} is not registered.`);
                    return s.sendChatRequest(n, t, r, i)
                }
                computeTokenLength(e, t, n) {
                    const r = this._providers.get(e);
                    if (!r) throw new Error(`Chat response provider with identifier ${e} is not registered.`);
                    return r.provideTokenCount(t, n)
                }
            };
            W = (0, T.g)([(0, T.f)(0, U.Q), (0, T.f)(1, D.V)], W);
            var j, V, H, K, Z, G, J, Y, Q, X, ee, te, ne, re, ie, se, oe, ae, ce, le, ue, he, de, fe, pe, ge, me, be, _e, ve, we, ye, xe, ke, Ce, Ie, Se, Ee, Te, Le, Re, Ae, Ne, Oe, Me, De, Pe, Ue, Fe, Be, $e, ze, qe, We, je, Ve, He, Ke, Ze, Ge, Je, Ye, Qe, Xe, et, tt, nt, rt, it, st, ot, at, ct, lt, ut, ht, dt, ft, pt, gt, mt, bt, _t, vt, wt, yt, xt, kt, Ct, It, St, Et, Tt, Lt, Rt, At, Nt, Ot, Mt, Dt, Pt, Ut, Ft, Bt, $t, zt, qt, Wt, jt, Vt, Ht = n("xHkz"),
                Kt = n("O9sO"),
                Zt = n("2chr"),
                Gt = n("Of1J"),
                Jt = n("QX7q"),
                Yt = n("7NN/");

            function Qt(e) {
                return 0 === e.length || !! function(e) {
                    return void 0 !== e.range
                }(e[0])
            }

            function Xt(e) {
                return Qt(e) ? e.map((e => ({
                    range: V.from(e.range),
                    hoverMessage: Array.isArray(e.hoverMessage) ? te.fromMany(e.hoverMessage) : e.hoverMessage ? te.from(e.hoverMessage) : void 0,
                    renderOptions: e.renderOptions
                }))) : e.map((e => ({
                    range: V.from(e)
                })))
            }

            function en(e) {
                return void 0 === e ? e : "string" == typeof e ? b.ov.file(e) : e
            }! function(e) {
                e.to = function(e) {
                    const {
                        selectionStartLineNumber: t,
                        selectionStartColumn: n,
                        positionLineNumber: r,
                        positionColumn: i
                    } = e, s = new Yt.Lyo(t - 1, n - 1), o = new Yt.Lyo(r - 1, i - 1);
                    return new Yt.Y19(s, o)
                }, e.from = function(e) {
                    const {
                        anchor: t,
                        active: n
                    } = e;
                    return {
                        selectionStartLineNumber: t.line + 1,
                        selectionStartColumn: t.character + 1,
                        positionLineNumber: n.line + 1,
                        positionColumn: n.character + 1
                    }
                }
            }(j || (j = {})),
            function(e) {
                e.from = function(e) {
                    if (!e) return;
                    const {
                        start: t,
                        end: n
                    } = e;
                    return {
                        startLineNumber: t.line + 1,
                        startColumn: t.character + 1,
                        endLineNumber: n.line + 1,
                        endColumn: n.character + 1
                    }
                }, e.to = function(e) {
                    if (!e) return;
                    const {
                        startLineNumber: t,
                        startColumn: n,
                        endLineNumber: r,
                        endColumn: i
                    } = e;
                    return new Yt.e6w(t - 1, n - 1, r - 1, i - 1)
                }
            }(V || (V = {})),
            function(e) {
                e.from = function(e) {
                    return {
                        uri: e.uri,
                        range: V.from(e.range)
                    }
                }, e.to = function(e) {
                    return new Yt.YeX(b.ov.revive(e.uri), V.to(e.range))
                }
            }(H || (H = {})),
            function(e) {
                e.to = function(e) {
                    switch (e) {
                        case w.xJ.Comment:
                            return Yt.xJH.Comment;
                        case w.xJ.Other:
                            return Yt.xJH.Other;
                        case w.xJ.RegEx:
                            return Yt.xJH.RegEx;
                        case w.xJ.String:
                            return Yt.xJH.String
                    }
                }
            }(K || (K = {})),
            function(e) {
                e.to = function(e) {
                    return new Yt.Lyo(e.lineNumber - 1, e.column - 1)
                }, e.from = function(e) {
                    return {
                        lineNumber: e.line + 1,
                        column: e.character + 1
                    }
                }
            }(Z || (Z = {})),
            function(e) {
                function t(e, t) {
                    return t && "string" == typeof e ? t.transformOutgoingScheme(e) : e
                }
                e.from = function(e, n, i) {
                    return (0, r.kX)((0, r._2)(e).map((e => function(e, n, r) {
                        return "string" == typeof e ? {
                            $serialized: !0,
                            language: e,
                            isBuiltin: r ? .isBuiltin
                        } : e ? {
                            $serialized: !0,
                            language: e.language,
                            scheme: t(e.scheme, n),
                            pattern: He.from(e.pattern) ? ? void 0,
                            exclusive: e.exclusive,
                            notebookType: e.notebookType,
                            isBuiltin: r ? .isBuiltin
                        } : void 0
                    }(e, n, i))))
                }
            }(G || (G = {})),
            function(e) {
                e.from = function(e) {
                    switch (e) {
                        case Yt.$uQ.Unnecessary:
                            return k.eB.Unnecessary;
                        case Yt.$uQ.Deprecated:
                            return k.eB.Deprecated
                    }
                }, e.to = function(e) {
                    switch (e) {
                        case k.eB.Unnecessary:
                            return Yt.$uQ.Unnecessary;
                        case k.eB.Deprecated:
                            return Yt.$uQ.Deprecated;
                        default:
                            return
                    }
                }
            }(J || (J = {})),
            function(e) {
                e.from = function(e) {
                    let t;
                    return e.code && (t = (0, m.HD)(e.code) || (0, m.hj)(e.code) ? String(e.code) : {
                        value: String(e.code.value),
                        target: e.code.target
                    }), { ...V.from(e.range),
                        message: e.message,
                        source: e.source,
                        code: t,
                        severity: X.from(e.severity),
                        relatedInformation: e.relatedInformation && e.relatedInformation.map(Q.from),
                        tags: Array.isArray(e.tags) ? (0, r.kX)(e.tags.map(J.from)) : void 0
                    }
                }, e.to = function(e) {
                    const t = new Yt.R9_(V.to(e), e.message, X.to(e.severity));
                    return t.source = e.source, t.code = (0, m.HD)(e.code) ? e.code : e.code ? .value, t.relatedInformation = e.relatedInformation && e.relatedInformation.map(Q.to), t.tags = e.tags && (0, r.kX)(e.tags.map(J.to)), t
                }
            }(Y || (Y = {})),
            function(e) {
                e.from = function(e) {
                    return { ...V.from(e.location.range),
                        message: e.message,
                        resource: e.location.uri
                    }
                }, e.to = function(e) {
                    return new Yt.va0(new Yt.YeX(e.resource, V.to(e)), e.message)
                }
            }(Q || (Q = {})),
            function(e) {
                e.from = function(e) {
                    switch (e) {
                        case Yt.H_B.Error:
                            return k.ZL.Error;
                        case Yt.H_B.Warning:
                            return k.ZL.Warning;
                        case Yt.H_B.Information:
                            return k.ZL.Info;
                        case Yt.H_B.Hint:
                            return k.ZL.Hint
                    }
                    return k.ZL.Error
                }, e.to = function(e) {
                    switch (e) {
                        case k.ZL.Info:
                            return Yt.H_B.Information;
                        case k.ZL.Warning:
                            return Yt.H_B.Warning;
                        case k.ZL.Error:
                            return Yt.H_B.Error;
                        case k.ZL.Hint:
                            return Yt.H_B.Hint;
                        default:
                            return Yt.H_B.Error
                    }
                }
            }(X || (X = {})),
            function(e) {
                e.from = function(e) {
                    return "number" == typeof e && e >= Yt.eIC.One ? e - 1 : e === Yt.eIC.Beside ? Jt.O3 : Jt.LP
                }, e.to = function(e) {
                    if ("number" == typeof e && e >= 0) return e + 1;
                    throw new Error("invalid 'EditorGroupColumn'")
                }
            }(ee || (ee = {})),
            function(e) {
                function t(e, t) {
                    if (!e) return e;
                    let n;
                    try {
                        n = (0, u.Qc)(e)
                    } catch (e) {}
                    if (!n) return e;
                    let r = !1;
                    return n = (0, d.rs)(n, (e => {
                        if (b.ov.isUri(e)) {
                            const n = `__uri_${Math.random().toString(16).slice(2,8)}`;
                            return t[n] = e, r = !0, n
                        }
                    })), r ? JSON.stringify(n) : e
                }
                e.fromMany = function(t) {
                    return t.map(e.from)
                }, e.from = function(e) {
                    let n;
                    if ((r = e) && "object" == typeof r && "string" == typeof r.language && "string" == typeof r.value) {
                        const {
                            language: t,
                            value: r
                        } = e;
                        n = {
                            value: "```" + t + "\n" + r + "\n```\n"
                        }
                    } else n = Yt.W5C.isMarkdownString(e) ? {
                        value: e.value,
                        isTrusted: e.isTrusted,
                        supportThemeIcons: e.supportThemeIcons,
                        supportHtml: e.supportHtml,
                        baseUri: e.baseUri
                    } : "string" == typeof e ? {
                        value: e
                    } : {
                        value: ""
                    };
                    var r;
                    const i = Object.create(null);
                    n.uris = i;
                    const s = e => {
                            try {
                                let n = b.ov.parse(e, !0);
                                n = n.with({
                                    query: t(n.query, i)
                                }), i[e] = n
                            } catch (e) {}
                            return ""
                        },
                        o = new l.Z.Renderer;
                    return o.link = s, o.image = e => "string" == typeof e ? s((0, a.v1)(e).href) : "", (0, l.Z)(n.value, {
                        renderer: o
                    }), n
                }, e.to = function(e) {
                    const t = new Yt.W5C(e.value, e.supportThemeIcons);
                    return t.isTrusted = e.isTrusted, t.supportHtml = e.supportHtml, t.baseUri = e.baseUri ? b.ov.from(e.baseUri) : void 0, t
                }, e.fromStrict = function(t) {
                    if (t) return "string" == typeof t ? t : e.from(t)
                }
            }(te || (te = {})),
            function(e) {
                e.from = function(e) {
                    return void 0 === e ? e : {
                        contentText: e.contentText,
                        contentIconPath: e.contentIconPath ? en(e.contentIconPath) : void 0,
                        border: e.border,
                        borderColor: e.borderColor,
                        fontStyle: e.fontStyle,
                        fontWeight: e.fontWeight,
                        textDecoration: e.textDecoration,
                        color: e.color,
                        backgroundColor: e.backgroundColor,
                        margin: e.margin,
                        width: e.width,
                        height: e.height
                    }
                }
            }(ne || (ne = {})),
            function(e) {
                e.from = function(e) {
                    return void 0 === e ? e : {
                        backgroundColor: e.backgroundColor,
                        outline: e.outline,
                        outlineColor: e.outlineColor,
                        outlineStyle: e.outlineStyle,
                        outlineWidth: e.outlineWidth,
                        border: e.border,
                        borderColor: e.borderColor,
                        borderRadius: e.borderRadius,
                        borderSpacing: e.borderSpacing,
                        borderStyle: e.borderStyle,
                        borderWidth: e.borderWidth,
                        fontStyle: e.fontStyle,
                        fontWeight: e.fontWeight,
                        textDecoration: e.textDecoration,
                        cursor: e.cursor,
                        color: e.color,
                        opacity: e.opacity,
                        letterSpacing: e.letterSpacing,
                        gutterIconPath: e.gutterIconPath ? en(e.gutterIconPath) : void 0,
                        gutterIconSize: e.gutterIconSize,
                        overviewRulerColor: e.overviewRulerColor,
                        before: e.before ? ne.from(e.before) : void 0,
                        after: e.after ? ne.from(e.after) : void 0
                    }
                }
            }(re || (re = {})),
            function(e) {
                e.from = function(e) {
                    if (void 0 === e) return e;
                    switch (e) {
                        case Yt.TED.OpenOpen:
                            return x.OI.AlwaysGrowsWhenTypingAtEdges;
                        case Yt.TED.ClosedClosed:
                            return x.OI.NeverGrowsWhenTypingAtEdges;
                        case Yt.TED.OpenClosed:
                            return x.OI.GrowsOnlyWhenTypingBefore;
                        case Yt.TED.ClosedOpen:
                            return x.OI.GrowsOnlyWhenTypingAfter
                    }
                }
            }(ie || (ie = {})),
            function(e) {
                e.from = function(e) {
                    return {
                        isWholeLine: e.isWholeLine,
                        rangeBehavior: e.rangeBehavior ? ie.from(e.rangeBehavior) : void 0,
                        overviewRulerLane: e.overviewRulerLane,
                        light: e.light ? re.from(e.light) : void 0,
                        dark: e.dark ? re.from(e.dark) : void 0,
                        backgroundColor: e.backgroundColor,
                        outline: e.outline,
                        outlineColor: e.outlineColor,
                        outlineStyle: e.outlineStyle,
                        outlineWidth: e.outlineWidth,
                        border: e.border,
                        borderColor: e.borderColor,
                        borderRadius: e.borderRadius,
                        borderSpacing: e.borderSpacing,
                        borderStyle: e.borderStyle,
                        borderWidth: e.borderWidth,
                        fontStyle: e.fontStyle,
                        fontWeight: e.fontWeight,
                        textDecoration: e.textDecoration,
                        cursor: e.cursor,
                        color: e.color,
                        opacity: e.opacity,
                        letterSpacing: e.letterSpacing,
                        gutterIconPath: e.gutterIconPath ? en(e.gutterIconPath) : void 0,
                        gutterIconSize: e.gutterIconSize,
                        overviewRulerColor: e.overviewRulerColor,
                        before: e.before ? ne.from(e.before) : void 0,
                        after: e.after ? ne.from(e.after) : void 0
                    }
                }
            }(se || (se = {})),
            function(e) {
                e.from = function(e) {
                    return {
                        text: e.newText,
                        eol: e.newEol && ze.from(e.newEol),
                        range: V.from(e.range)
                    }
                }, e.to = function(e) {
                    const t = new Yt.PYv(V.to(e.range), e.text);
                    return t.newEol = void 0 === e.eol ? void 0 : ze.to(e.eol), t
                }
            }(oe || (oe = {})),
            function(e) {
                e.from = function(e, t) {
                    const n = {
                        edits: []
                    };
                    if (e instanceof Yt.DbP) {
                        const r = new c.XV;
                        for (const t of e._allEntries()) t._type === Yt.Max.File && b.ov.isUri(t.to) && void 0 === t.from && r.add(t.to);
                        for (const s of e._allEntries())
                            if (s._type === Yt.Max.File) {
                                let e;
                                s.options ? .contents && (e = ArrayBuffer.isView(s.options.contents) ? {
                                    type: "base64",
                                    value: (0, i.oF)(i.KN.wrap(s.options.contents))
                                } : {
                                    type: "dataTransferItem",
                                    id: s.options.contents._itemId
                                }), n.edits.push({
                                    oldResource: s.from,
                                    newResource: s.to,
                                    options: { ...s.options,
                                        contents: e
                                    },
                                    metadata: s.metadata
                                })
                            } else s._type === Yt.Max.Text ? n.edits.push({
                                resource: s.uri,
                                textEdit: oe.from(s.edit),
                                versionId: r.has(s.uri) ? void 0 : t ? .getTextDocumentVersion(s.uri),
                                metadata: s.metadata
                            }) : s._type === Yt.Max.Snippet ? n.edits.push({
                                resource: s.uri,
                                textEdit: {
                                    range: V.from(s.range),
                                    text: s.edit.value,
                                    insertAsSnippet: !0
                                },
                                versionId: r.has(s.uri) ? void 0 : t ? .getTextDocumentVersion(s.uri),
                                metadata: s.metadata
                            }) : s._type === Yt.Max.Cell ? n.edits.push({
                                metadata: s.metadata,
                                resource: s.uri,
                                cellEdit: s.edit,
                                notebookMetadata: s.notebookMetadata,
                                notebookVersionId: t ? .getNotebookDocumentVersion(s.uri)
                            }) : s._type === Yt.Max.CellReplace && n.edits.push({
                                metadata: s.metadata,
                                resource: s.uri,
                                notebookVersionId: t ? .getNotebookDocumentVersion(s.uri),
                                cellEdit: {
                                    editType: Kt.w.Replace,
                                    index: s.index,
                                    count: s.count,
                                    cells: s.cells.map(et.from)
                                }
                            })
                    }
                    return n
                }, e.to = function(e) {
                    const t = new Yt.DbP,
                        n = new c.Y9;
                    for (const r of e.edits)
                        if (r.textEdit) {
                            const e = r,
                                t = b.ov.revive(e.resource),
                                i = V.to(e.textEdit.range),
                                s = e.textEdit.text;
                            let o;
                            o = e.textEdit.insertAsSnippet ? Yt.M0$.replace(i, new Yt.EG5(s)) : Yt.PYv.replace(i, s);
                            const a = n.get(t);
                            a ? a.push(o) : n.set(t, [o])
                        } else t.renameFile(b.ov.revive(r.oldResource), b.ov.revive(r.newResource), r.options);
                    for (const [e, r] of n) t.set(e, r);
                    return t
                }
            }(ae || (ae = {})),
            function(e) {
                const t = Object.create(null);
                t[Yt.cRn.File] = y.cR.File, t[Yt.cRn.Module] = y.cR.Module, t[Yt.cRn.Namespace] = y.cR.Namespace, t[Yt.cRn.Package] = y.cR.Package, t[Yt.cRn.Class] = y.cR.Class, t[Yt.cRn.Method] = y.cR.Method, t[Yt.cRn.Property] = y.cR.Property, t[Yt.cRn.Field] = y.cR.Field, t[Yt.cRn.Constructor] = y.cR.Constructor, t[Yt.cRn.Enum] = y.cR.Enum, t[Yt.cRn.Interface] = y.cR.Interface, t[Yt.cRn.Function] = y.cR.Function, t[Yt.cRn.Variable] = y.cR.Variable, t[Yt.cRn.Constant] = y.cR.Constant, t[Yt.cRn.String] = y.cR.String, t[Yt.cRn.Number] = y.cR.Number, t[Yt.cRn.Boolean] = y.cR.Boolean, t[Yt.cRn.Array] = y.cR.Array, t[Yt.cRn.Object] = y.cR.Object, t[Yt.cRn.Key] = y.cR.Key, t[Yt.cRn.Null] = y.cR.Null, t[Yt.cRn.EnumMember] = y.cR.EnumMember, t[Yt.cRn.Struct] = y.cR.Struct, t[Yt.cRn.Event] = y.cR.Event, t[Yt.cRn.Operator] = y.cR.Operator, t[Yt.cRn.TypeParameter] = y.cR.TypeParameter, e.from = function(e) {
                    return "number" == typeof t[e] ? t[e] : y.cR.Property
                }, e.to = function(e) {
                    for (const n in t)
                        if (t[n] === e) return Number(n);
                    return Yt.cRn.Property
                }
            }(ce || (ce = {})),
            function(e) {
                e.from = function(e) {
                    if (e === Yt.r4c.Deprecated) return y.r4.Deprecated
                }, e.to = function(e) {
                    if (e === y.r4.Deprecated) return Yt.r4c.Deprecated
                }
            }(le || (le = {})),
            function(e) {
                e.from = function(e) {
                    return {
                        name: e.name,
                        kind: ce.from(e.kind),
                        tags: e.tags && e.tags.map(le.from),
                        containerName: e.containerName,
                        location: ge.from(e.location)
                    }
                }, e.to = function(e) {
                    const t = new Yt.JNW(e.name, ce.to(e.kind), e.containerName, ge.to(e.location));
                    return t.tags = e.tags && e.tags.map(le.to), t
                }
            }(ue || (ue = {})),
            function(e) {
                e.from = function e(t) {
                    const n = {
                        name: t.name || "!!MISSING: name!!",
                        detail: t.detail,
                        range: V.from(t.range),
                        selectionRange: V.from(t.selectionRange),
                        kind: ce.from(t.kind),
                        tags: t.tags ? .map(le.from) ? ? []
                    };
                    return t.children && (n.children = t.children.map(e)), n
                }, e.to = function e(t) {
                    const n = new Yt.w6Q(t.name, t.detail, ce.to(t.kind), V.to(t.range), V.to(t.selectionRange));
                    return (0, r.Of)(t.tags) && (n.tags = t.tags.map(le.to)), t.children && (n.children = t.children.map(e)), n
                }
            }(he || (he = {})),
            function(e) {
                e.to = function(e) {
                    const t = new Yt.llk(ce.to(e.kind), e.name, e.detail || "", b.ov.revive(e.uri), V.to(e.range), V.to(e.selectionRange));
                    return t._sessionId = e._sessionId, t._itemId = e._itemId, t
                }, e.from = function(e, t, n) {
                    if (t = t ? ? e._sessionId, n = n ? ? e._itemId, void 0 === t || void 0 === n) throw new Error("invalid item");
                    return {
                        _sessionId: t,
                        _itemId: n,
                        name: e.name,
                        detail: e.detail,
                        kind: ce.from(e.kind),
                        uri: e.uri,
                        range: V.from(e.range),
                        selectionRange: V.from(e.selectionRange),
                        tags: e.tags ? .map(le.from)
                    }
                }
            }(de || (de = {})),
            function(e) {
                e.to = function(e) {
                    return new Yt.MPI(de.to(e.from), e.fromRanges.map((e => V.to(e))))
                }
            }(fe || (fe = {})),
            function(e) {
                e.to = function(e) {
                    return new Yt.RVV(de.to(e.to), e.fromRanges.map((e => V.to(e))))
                }
            }(pe || (pe = {})), (me = ge || (ge = {})).from = function(e) {
                    return {
                        range: e.range && V.from(e.range),
                        uri: e.uri
                    }
                }, me.to = function(e) {
                    return new Yt.YeX(b.ov.revive(e.uri), V.to(e.range))
                },
                function(e) {
                    e.from = function(e) {
                        const t = e,
                            n = e;
                        return {
                            originSelectionRange: t.originSelectionRange ? V.from(t.originSelectionRange) : void 0,
                            uri: t.targetUri ? t.targetUri : n.uri,
                            range: V.from(t.targetRange ? t.targetRange : n.range),
                            targetSelectionRange: t.targetSelectionRange ? V.from(t.targetSelectionRange) : void 0
                        }
                    }, e.to = function(e) {
                        return {
                            targetUri: b.ov.revive(e.uri),
                            targetRange: V.to(e.range),
                            targetSelectionRange: e.targetSelectionRange ? V.to(e.targetSelectionRange) : void 0,
                            originSelectionRange: e.originSelectionRange ? V.to(e.originSelectionRange) : void 0
                        }
                    }
                }(be || (be = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            range: V.from(e.range),
                            contents: te.fromMany(e.contents),
                            canIncreaseVerbosity: e.canIncreaseVerbosity,
                            canDecreaseVerbosity: e.canDecreaseVerbosity
                        }
                    }, e.to = function(e) {
                        const t = e.contents.map(te.to),
                            n = V.to(e.range),
                            r = e.canIncreaseVerbosity,
                            i = e.canDecreaseVerbosity;
                        return new Yt.GLX(t, n, r, i)
                    }
                }(_e || (_e = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            range: V.from(e.range),
                            expression: e.expression
                        }
                    }, e.to = function(e) {
                        return new Yt.hfl(V.to(e.range), e.expression)
                    }
                }(ve || (ve = {})),
                function(e) {
                    e.from = function(e) {
                        if (e instanceof Yt.$KE) return {
                            type: "text",
                            range: V.from(e.range),
                            text: e.text
                        };
                        if (e instanceof Yt.wJF) return {
                            type: "variable",
                            range: V.from(e.range),
                            variableName: e.variableName,
                            caseSensitiveLookup: e.caseSensitiveLookup
                        };
                        if (e instanceof Yt.rLr) return {
                            type: "expression",
                            range: V.from(e.range),
                            expression: e.expression
                        };
                        throw new Error("Unknown 'InlineValue' type")
                    }, e.to = function(e) {
                        switch (e.type) {
                            case "text":
                                return {
                                    range: V.to(e.range),
                                    text: e.text
                                };
                            case "variable":
                                return {
                                    range: V.to(e.range),
                                    variableName: e.variableName,
                                    caseSensitiveLookup: e.caseSensitiveLookup
                                };
                            case "expression":
                                return {
                                    range: V.to(e.range),
                                    expression: e.expression
                                }
                        }
                    }
                }(we || (we = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            frameId: e.frameId,
                            stoppedLocation: V.from(e.stoppedLocation)
                        }
                    }, e.to = function(e) {
                        return new Yt.GSm(e.frameId, V.to(e.stoppedLocation))
                    }
                }(ye || (ye = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            range: V.from(e.range),
                            kind: e.kind
                        }
                    }, e.to = function(e) {
                        return new Yt.ehQ(V.to(e.range), e.kind)
                    }
                }(xe || (xe = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            uri: e.uri,
                            highlights: e.highlights.map(xe.from)
                        }
                    }, e.to = function(e) {
                        return new Yt.lMH(b.ov.revive(e.uri), e.highlights.map(xe.to))
                    }
                }(ke || (ke = {})),
                function(e) {
                    e.to = function(e) {
                        switch (e) {
                            case y.Ij.TriggerCharacter:
                                return Yt.IjA.TriggerCharacter;
                            case y.Ij.TriggerForIncompleteCompletions:
                                return Yt.IjA.TriggerForIncompleteCompletions;
                            case y.Ij.Invoke:
                            default:
                                return Yt.IjA.Invoke
                        }
                    }
                }(Ce || (Ce = {})),
                function(e) {
                    e.to = function(e) {
                        return {
                            triggerKind: Ce.to(e.triggerKind),
                            triggerCharacter: e.triggerCharacter
                        }
                    }
                }(Ie || (Ie = {})),
                function(e) {
                    e.from = function(e) {
                        if (e === Yt.weh.Deprecated) return y.we.Deprecated
                    }, e.to = function(e) {
                        if (e === y.we.Deprecated) return Yt.weh.Deprecated
                    }
                }(Se || (Se = {})),
                function(e) {
                    const t = new Map([
                        [Yt.cmM.Method, y.cm.Method],
                        [Yt.cmM.Function, y.cm.Function],
                        [Yt.cmM.Constructor, y.cm.Constructor],
                        [Yt.cmM.Field, y.cm.Field],
                        [Yt.cmM.Variable, y.cm.Variable],
                        [Yt.cmM.Class, y.cm.Class],
                        [Yt.cmM.Interface, y.cm.Interface],
                        [Yt.cmM.Struct, y.cm.Struct],
                        [Yt.cmM.Module, y.cm.Module],
                        [Yt.cmM.Property, y.cm.Property],
                        [Yt.cmM.Unit, y.cm.Unit],
                        [Yt.cmM.Value, y.cm.Value],
                        [Yt.cmM.Constant, y.cm.Constant],
                        [Yt.cmM.Enum, y.cm.Enum],
                        [Yt.cmM.EnumMember, y.cm.EnumMember],
                        [Yt.cmM.Keyword, y.cm.Keyword],
                        [Yt.cmM.Snippet, y.cm.Snippet],
                        [Yt.cmM.Text, y.cm.Text],
                        [Yt.cmM.Color, y.cm.Color],
                        [Yt.cmM.File, y.cm.File],
                        [Yt.cmM.Reference, y.cm.Reference],
                        [Yt.cmM.Folder, y.cm.Folder],
                        [Yt.cmM.Event, y.cm.Event],
                        [Yt.cmM.Operator, y.cm.Operator],
                        [Yt.cmM.TypeParameter, y.cm.TypeParameter],
                        [Yt.cmM.Issue, y.cm.Issue],
                        [Yt.cmM.User, y.cm.User]
                    ]);
                    e.from = function(e) {
                        return t.get(e) ? ? y.cm.Property
                    };
                    const n = new Map([
                        [y.cm.Method, Yt.cmM.Method],
                        [y.cm.Function, Yt.cmM.Function],
                        [y.cm.Constructor, Yt.cmM.Constructor],
                        [y.cm.Field, Yt.cmM.Field],
                        [y.cm.Variable, Yt.cmM.Variable],
                        [y.cm.Class, Yt.cmM.Class],
                        [y.cm.Interface, Yt.cmM.Interface],
                        [y.cm.Struct, Yt.cmM.Struct],
                        [y.cm.Module, Yt.cmM.Module],
                        [y.cm.Property, Yt.cmM.Property],
                        [y.cm.Unit, Yt.cmM.Unit],
                        [y.cm.Value, Yt.cmM.Value],
                        [y.cm.Constant, Yt.cmM.Constant],
                        [y.cm.Enum, Yt.cmM.Enum],
                        [y.cm.EnumMember, Yt.cmM.EnumMember],
                        [y.cm.Keyword, Yt.cmM.Keyword],
                        [y.cm.Snippet, Yt.cmM.Snippet],
                        [y.cm.Text, Yt.cmM.Text],
                        [y.cm.Color, Yt.cmM.Color],
                        [y.cm.File, Yt.cmM.File],
                        [y.cm.Reference, Yt.cmM.Reference],
                        [y.cm.Folder, Yt.cmM.Folder],
                        [y.cm.Event, Yt.cmM.Event],
                        [y.cm.Operator, Yt.cmM.Operator],
                        [y.cm.TypeParameter, Yt.cmM.TypeParameter],
                        [y.cm.User, Yt.cmM.User],
                        [y.cm.Issue, Yt.cmM.Issue]
                    ]);
                    e.to = function(e) {
                        return n.get(e) ? ? Yt.cmM.Property
                    }
                }(Ee || (Ee = {})),
                function(e) {
                    e.to = function(e, t) {
                        const n = new Yt.FGT(e.label);
                        return n.insertText = e.insertText, n.kind = Ee.to(e.kind), n.tags = e.tags ? .map(Se.to), n.detail = e.detail, n.documentation = (0, a.Fr)(e.documentation) ? te.to(e.documentation) : e.documentation, n.sortText = e.sortText, n.filterText = e.filterText, n.preselect = e.preselect, n.commitCharacters = e.commitCharacters, v.e.isIRange(e.range) ? n.range = V.to(e.range) : "object" == typeof e.range && (n.range = {
                            inserting: V.to(e.range.insert),
                            replacing: V.to(e.range.replace)
                        }), n.keepWhitespace = void 0 !== e.insertTextRules && Boolean(e.insertTextRules & y.a7.KeepWhitespace), void 0 !== e.insertTextRules && e.insertTextRules & y.a7.InsertAsSnippet ? n.insertText = new Yt.EG5(e.insertText) : (n.insertText = e.insertText, n.textEdit = n.range instanceof Yt.e6w ? new Yt.PYv(n.range, n.insertText) : void 0), e.additionalTextEdits && e.additionalTextEdits.length > 0 && (n.additionalTextEdits = e.additionalTextEdits.map((e => oe.to(e)))), n.command = t && e.command ? t.fromInternal(e.command) : void 0, n
                    }
                }(Te || (Te = {})),
                function(e) {
                    e.from = function(e) {
                        if ("string" != typeof e.label && !Array.isArray(e.label)) throw new TypeError("Invalid label");
                        return {
                            label: e.label,
                            documentation: te.fromStrict(e.documentation)
                        }
                    }, e.to = function(e) {
                        return {
                            label: e.label,
                            documentation: (0, a.Fr)(e.documentation) ? te.to(e.documentation) : e.documentation
                        }
                    }
                }(Le || (Le = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            label: e.label,
                            documentation: te.fromStrict(e.documentation),
                            parameters: Array.isArray(e.parameters) ? e.parameters.map(Le.from) : [],
                            activeParameter: e.activeParameter
                        }
                    }, e.to = function(e) {
                        return {
                            label: e.label,
                            documentation: (0, a.Fr)(e.documentation) ? te.to(e.documentation) : e.documentation,
                            parameters: Array.isArray(e.parameters) ? e.parameters.map(Le.to) : [],
                            activeParameter: e.activeParameter
                        }
                    }
                }(Re || (Re = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            activeSignature: e.activeSignature,
                            activeParameter: e.activeParameter,
                            signatures: Array.isArray(e.signatures) ? e.signatures.map(Re.from) : []
                        }
                    }, e.to = function(e) {
                        return {
                            activeSignature: e.activeSignature,
                            activeParameter: e.activeParameter,
                            signatures: Array.isArray(e.signatures) ? e.signatures.map(Re.to) : []
                        }
                    }
                }(Ae || (Ae = {})),
                function(e) {
                    e.to = function(e, t) {
                        const n = new Yt.t7_(Z.to(t.position), "string" == typeof t.label ? t.label : t.label.map(Oe.to.bind(void 0, e)), t.kind && Me.to(t.kind));
                        return n.textEdits = t.textEdits && t.textEdits.map(oe.to), n.tooltip = (0, a.Fr)(t.tooltip) ? te.to(t.tooltip) : t.tooltip, n.paddingLeft = t.paddingLeft, n.paddingRight = t.paddingRight, n
                    }
                }(Ne || (Ne = {})),
                function(e) {
                    e.to = function(e, t) {
                        const n = new Yt.qR(t.label);
                        return n.tooltip = (0, a.Fr)(t.tooltip) ? te.to(t.tooltip) : t.tooltip, y.mY.is(t.command) && (n.command = e.fromInternal(t.command)), t.location && (n.location = ge.to(t.location)), n
                    }
                }(Oe || (Oe = {})),
                function(e) {
                    e.from = function(e) {
                        return e
                    }, e.to = function(e) {
                        return e
                    }
                }(Me || (Me = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            range: V.from(e.range),
                            url: e.target,
                            tooltip: e.tooltip
                        }
                    }, e.to = function(e) {
                        let t;
                        if (e.url) try {
                            t = "string" == typeof e.url ? b.ov.parse(e.url, !0) : b.ov.revive(e.url)
                        } catch (e) {}
                        const n = new Yt.jWy(V.to(e.range), t);
                        return n.tooltip = e.tooltip, n
                    }
                }(De || (De = {})),
                function(e) {
                    e.to = function(e) {
                        const t = new Yt.oi2(e.label);
                        return e.textEdit && (t.textEdit = oe.to(e.textEdit)), e.additionalTextEdits && (t.additionalTextEdits = e.additionalTextEdits.map((e => oe.to(e)))), t
                    }, e.from = function(e) {
                        return {
                            label: e.label,
                            textEdit: e.textEdit ? oe.from(e.textEdit) : void 0,
                            additionalTextEdits: e.additionalTextEdits ? e.additionalTextEdits.map((e => oe.from(e))) : void 0
                        }
                    }
                }(Pe || (Pe = {})),
                function(e) {
                    e.to = function(e) {
                        return new Yt.Ilk(e[0], e[1], e[2], e[3])
                    }, e.from = function(e) {
                        return [e.red, e.green, e.blue, e.alpha]
                    }
                }(Ue || (Ue = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            range: V.from(e.range)
                        }
                    }, e.to = function(e) {
                        return new Yt.xm7(V.to(e.range))
                    }
                }(Fe || (Fe = {})),
                function(e) {
                    e.to = function(e) {
                        switch (e) {
                            case S.tp.AUTO:
                                return Yt.wDJ.AfterDelay;
                            case S.tp.EXPLICIT:
                                return Yt.wDJ.Manual;
                            case S.tp.FOCUS_CHANGE:
                            case S.tp.WINDOW_CHANGE:
                                return Yt.wDJ.FocusOut
                        }
                    }
                }(Be || (Be = {})),
                function(e) {
                    e.from = function(e) {
                        switch (e) {
                            case Yt.lP6.Off:
                                return _.Lu.Off;
                            case Yt.lP6.Relative:
                                return _.Lu.Relative;
                            case Yt.lP6.Interval:
                                return _.Lu.Interval;
                            case Yt.lP6.On:
                            default:
                                return _.Lu.On
                        }
                    }, e.to = function(e) {
                        switch (e) {
                            case _.Lu.Off:
                                return Yt.lP6.Off;
                            case _.Lu.Relative:
                                return Yt.lP6.Relative;
                            case _.Lu.Interval:
                                return Yt.lP6.Interval;
                            case _.Lu.On:
                            default:
                                return Yt.lP6.On
                        }
                    }
                }($e || ($e = {})),
                function(e) {
                    e.from = function(e) {
                        return e === Yt.b6q.CRLF ? x.jl.CRLF : e === Yt.b6q.LF ? x.jl.LF : void 0
                    }, e.to = function(e) {
                        return e === x.jl.CRLF ? Yt.b6q.CRLF : e === x.jl.LF ? Yt.b6q.LF : void 0
                    }
                }(ze || (ze = {})),
                function(e) {
                    e.from = function(e) {
                        if ("object" == typeof e) return e.viewId;
                        switch (e) {
                            case Yt.uTI.SourceControl:
                                return C.uT.Scm;
                            case Yt.uTI.Window:
                                return C.uT.Window;
                            case Yt.uTI.Notification:
                                return C.uT.Notification
                        }
                        throw new Error("Unknown 'ProgressLocation'")
                    }
                }(qe || (qe = {})),
                function(e) {
                    e.from = function(e) {
                        const t = {
                            start: e.start + 1,
                            end: e.end + 1
                        };
                        return e.kind && (t.kind = je.from(e.kind)), t
                    }, e.to = function(e) {
                        const t = {
                            start: e.start - 1,
                            end: e.end - 1
                        };
                        return e.kind && (t.kind = je.to(e.kind)), t
                    }
                }(We || (We = {})),
                function(e) {
                    e.from = function(e) {
                        if (e) switch (e) {
                            case Yt.ADb.Comment:
                                return y.AD.Comment;
                            case Yt.ADb.Imports:
                                return y.AD.Imports;
                            case Yt.ADb.Region:
                                return y.AD.Region
                        }
                    }, e.to = function(e) {
                        if (e) switch (e.value) {
                            case y.AD.Comment.value:
                                return Yt.ADb.Comment;
                            case y.AD.Imports.value:
                                return Yt.ADb.Imports;
                            case y.AD.Region.value:
                                return Yt.ADb.Region
                        }
                    }
                }(je || (je = {})),
                function(e) {
                    e.from = function(e) {
                        if (e) return {
                            pinned: "boolean" == typeof e.preview ? !e.preview : void 0,
                            inactive: e.background,
                            preserveFocus: e.preserveFocus,
                            selection: "object" == typeof e.selection ? V.from(e.selection) : void 0,
                            override: "boolean" == typeof e.override ? S.Cr.id : void 0
                        }
                    }
                }(Ve || (Ve = {})),
                function(e) {
                    e.from = function(e) {
                        return e instanceof Yt.sUC ? e.toJSON() : "string" == typeof e ? e : function(e) {
                            const t = e;
                            return !!t && (b.ov.isUri(t.baseUri) && "string" == typeof t.pattern)
                        }(e) || function(e) {
                            const t = e;
                            return !!t && ("string" == typeof t.base && "string" == typeof t.pattern)
                        }(e) ? new Yt.sUC(e.baseUri ? ? e.base, e.pattern).toJSON() : e
                    }, e.to = function(e) {
                        return "string" == typeof e ? e : new Yt.sUC(b.ov.revive(e.baseUri), e.pattern)
                    }
                }(He || (He = {})),
                function(e) {
                    e.from = function e(t) {
                        if (t) {
                            if (Array.isArray(t)) return t.map(e);
                            if ("string" == typeof t) return t; {
                                const e = t;
                                return {
                                    language: e.language,
                                    scheme: e.scheme,
                                    pattern: He.from(e.pattern),
                                    exclusive: e.exclusive,
                                    notebookType: e.notebookType
                                }
                            }
                        }
                    }
                }(Ke || (Ke = {})),
                function(e) {
                    e.is = function(e) {
                        return !!e && "object" == typeof e && "documents" in e && Array.isArray(e.documents) && e.documents.every((e => Array.isArray(e) && e.every((e => e && "object" == typeof e && "uri" in e && b.ov.isUri(e.uri) && "version" in e && "number" == typeof e.version && "ranges" in e && Array.isArray(e.ranges) && e.ranges.every((e => e instanceof Yt.e6w))))))
                    }, e.from = function(e) {
                        return {
                            documents: e.documents.map((e => e.map((e => ({
                                uri: b.ov.from(e.uri),
                                version: e.version,
                                ranges: e.ranges.map((e => V.from(e)))
                            })))))
                        }
                    }
                }(Ze || (Ze = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            start: e.start,
                            end: e.end
                        }
                    }, e.to = function(e) {
                        return new Yt.XsU(e.start, e.end)
                    }
                }(Ge || (Ge = {})),
                function(e) {
                    e.to = function(e) {
                        return {
                            timing: "number" == typeof e.runStartTime && "number" == typeof e.runEndTime ? {
                                startTime: e.runStartTime,
                                endTime: e.runEndTime
                            } : void 0,
                            executionOrder: e.executionOrder,
                            success: e.lastRunSuccess
                        }
                    }, e.from = function(e) {
                        return {
                            lastRunSuccess: e.success,
                            runStartTime: e.timing ? .startTime,
                            runEndTime: e.timing ? .endTime,
                            executionOrder: e.executionOrder
                        }
                    }
                }(Je || (Je = {})),
                function(e) {
                    e.to = function(e) {
                        if (e === Kt.KP.Unconfirmed) return Yt.KPz.Pending;
                        if (e !== Kt.KP.Pending) {
                            if (e === Kt.KP.Executing) return Yt.KPz.Executing;
                            throw new Error(`Unknown state: ${e}`)
                        }
                    }
                }(Ye || (Ye = {})),
                function(e) {
                    e.from = function(e) {
                        switch (e) {
                            case Yt.wUy.Markup:
                                return Kt.gM.Markup;
                            case Yt.wUy.Code:
                            default:
                                return Kt.gM.Code
                        }
                    }, e.to = function(e) {
                        switch (e) {
                            case Kt.gM.Markup:
                                return Yt.wUy.Markup;
                            case Kt.gM.Code:
                            default:
                                return Yt.wUy.Code
                        }
                    }
                }(Qe || (Qe = {})),
                function(e) {
                    e.from = function(e) {
                        const t = {
                            metadata: e.metadata ? ? Object.create(null),
                            cells: []
                        };
                        for (const n of e.cells) Yt.Ul.validate(n), t.cells.push(et.from(n));
                        return t
                    }, e.to = function(e) {
                        const t = new Yt.c4G(e.cells.map(et.to));
                        return (0, m.Qr)(e.metadata) || (t.metadata = e.metadata), t
                    }
                }(Xe || (Xe = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            cellKind: Qe.from(e.kind),
                            language: e.languageId,
                            mime: e.mime,
                            source: e.value,
                            metadata: e.metadata,
                            internalMetadata: Je.from(e.executionSummary ? ? {}),
                            outputs: e.outputs ? e.outputs.map(nt.from) : []
                        }
                    }, e.to = function(e) {
                        return new Yt.Ul(Qe.to(e.cellKind), e.source, e.language, e.mime, e.outputs ? e.outputs.map(nt.to) : void 0, e.metadata, e.internalMetadata ? Je.to(e.internalMetadata) : void 0)
                    }
                }(et || (et = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            mime: e.mime,
                            valueBytes: i.KN.wrap(e.data)
                        }
                    }, e.to = function(e) {
                        return new Yt.x$B(e.valueBytes.buffer, e.mime)
                    }
                }(tt || (tt = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            outputId: e.id,
                            items: e.items.map(tt.from),
                            metadata: e.metadata
                        }
                    }, e.to = function(e) {
                        const t = e.items.map(tt.to);
                        return new Yt.JOq(t, e.outputId, e.metadata)
                    }
                }(nt || (nt = {})),
                function(e) {
                    function t(e) {
                        const t = e;
                        return !!t && !(0, m.Jp)(t.include) && !(0, m.Jp)(t.exclude)
                    }
                    e.from = function(e) {
                        return t(e) ? {
                            include: He.from(e.include) ? ? void 0,
                            exclude: He.from(e.exclude) ? ? void 0
                        } : He.from(e) ? ? void 0
                    }, e.to = function(e) {
                        return t(e) ? {
                            include: He.to(e.include),
                            exclude: He.to(e.exclude)
                        } : He.to(e)
                    }
                }(rt || (rt = {})),
                function(e) {
                    e.from = function(e, t, n) {
                        const r = "string" == typeof e.command ? {
                            title: "",
                            command: e.command
                        } : e.command;
                        return {
                            alignment: e.alignment === Yt.F3Y.Left ? Kt.rs.Left : Kt.rs.Right,
                            command: t.toInternal(r, n),
                            text: e.text,
                            tooltip: e.tooltip,
                            accessibilityInformation: e.accessibilityInformation,
                            priority: e.priority
                        }
                    }
                }(it || (it = {})),
                function(e) {
                    e.from = function(e, t, n) {
                        const r = "string" == typeof e.command ? {
                            title: "",
                            command: e.command
                        } : e.command;
                        return {
                            command: t.toInternal(r, n),
                            label: e.label,
                            description: e.description,
                            detail: e.detail,
                            documentation: e.documentation
                        }
                    }
                }(st || (st = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            transientOutputs: e ? .transientOutputs ? ? !1,
                            transientCellMetadata: e ? .transientCellMetadata ? ? {},
                            transientDocumentMetadata: e ? .transientDocumentMetadata ? ? {},
                            cellContentMetadata: e ? .cellContentMetadata ? ? {}
                        }
                    }
                }(ot || (ot = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            uri: e.uri,
                            provides: e.provides
                        }
                    }, e.to = function(e) {
                        return new Yt.xTW(b.ov.revive(e.uri), e.provides)
                    }
                }(at || (at = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            message: te.fromStrict(e.message) || "",
                            type: Gt.Cg.Error,
                            expected: e.expectedOutput,
                            actual: e.actualOutput,
                            contextValue: e.contextValue,
                            location: e.location && {
                                range: V.from(e.location.range),
                                uri: e.location.uri
                            }
                        }
                    }, e.to = function(e) {
                        const t = new Yt.ltp("string" == typeof e.message ? e.message : te.to(e.message));
                        return t.actualOutput = e.actual, t.expectedOutput = e.expected, t.contextValue = e.contextValue, t.location = e.location ? ge.to(e.location) : void 0, t
                    }
                }(ct || (ct = {})),
                function(e) {
                    e.namespace = Gt.B2, e.denamespace = Gt._v
                }(lt || (lt = {})),
                function(e) {
                    e.from = function(e) {
                        const t = (0, I.l)(e).controllerId;
                        return {
                            extId: Zt.u0.fromExtHostTestItem(e, t).toString(),
                            label: e.label,
                            uri: b.ov.revive(e.uri),
                            busy: e.busy,
                            tags: e.tags.map((e => lt.namespace(t, e.id))),
                            range: v.e.lift(V.from(e.range)),
                            description: e.description || null,
                            sortText: e.sortText || null,
                            error: e.error && te.fromStrict(e.error) || null
                        }
                    }, e.toPlain = function(e) {
                        return {
                            parent: void 0,
                            error: void 0,
                            id: Zt.u0.fromString(e.extId).localId,
                            label: e.label,
                            uri: b.ov.revive(e.uri),
                            tags: (e.tags || []).map((e => {
                                const {
                                    tagId: t
                                } = lt.denamespace(e);
                                return new Yt.LdD(t)
                            })),
                            children: {
                                add: () => {},
                                delete: () => {},
                                forEach: () => {},
                                *[Symbol.iterator]() {},
                                get: () => {},
                                replace: () => {},
                                size: 0
                            },
                            range: V.to(e.range || void 0),
                            canResolveChildren: !1,
                            busy: e.busy,
                            description: e.description || void 0,
                            sortText: e.sortText || void 0
                        }
                    }
                }(ut || (ut = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            id: e.id
                        }
                    }, e.to = function(e) {
                        return new Yt.LdD(e.id)
                    }
                }(lt || (lt = {})),
                function(e) {
                    const t = (e, n) => {
                        const r = e.value;
                        if (!r) return;
                        const i = { ...ut.toPlain(r.item),
                            parent: n,
                            taskStates: r.tasks.map((e => ({
                                state: e.state,
                                duration: e.duration,
                                messages: e.messages.filter((e => e.type === Gt.Cg.Error)).map(ct.to)
                            }))),
                            children: []
                        };
                        if (e.children)
                            for (const n of e.children.values()) {
                                const e = t(n, i);
                                e && i.children.push(e)
                            }
                        return i
                    };
                    e.to = function(e) {
                        const n = new f.F;
                        for (const t of e.items) n.insert(Zt.u0.fromString(t.item.extId).path, t);
                        const r = [n.nodes],
                            i = [];
                        for (; r.length;)
                            for (const e of r.pop()) e.value ? i.push(e) : e.children && r.push(e.children.values());
                        return {
                            completedAt: e.completedAt,
                            results: i.map((e => t(e))).filter(m.$K)
                        }
                    }
                }(ht || (ht = {})),
                function(e) {
                    function t(e) {
                        return {
                            covered: e.covered,
                            total: e.total
                        }
                    }

                    function n(e) {
                        return "line" in e ? Z.from(e) : V.from(e)
                    }
                    e.fromDetails = function(e) {
                        if ("number" == typeof e.executed && e.executed < 0) throw new Error(`Invalid coverage count ${e.executed}`);
                        return "branches" in e ? {
                            count: e.executed,
                            location: n(e.location),
                            type: Gt.SB.Statement,
                            branches: e.branches.length ? e.branches.map((e => ({
                                count: e.executed,
                                location: e.location && n(e.location),
                                label: e.label
                            }))) : void 0
                        } : {
                            type: Gt.SB.Declaration,
                            name: e.name,
                            count: e.executed,
                            location: n(e.location)
                        }
                    }, e.fromFile = function(e, n, r) {
                        return (0, Yt.kGi)(r.statementCoverage), (0, Yt.kGi)(r.branchCoverage), (0, Yt.kGi)(r.declarationCoverage), {
                            id: n,
                            uri: r.uri,
                            statement: t(r.statementCoverage),
                            branch: r.branchCoverage && t(r.branchCoverage),
                            declaration: r.declarationCoverage && t(r.declarationCoverage),
                            testIds: r instanceof Yt.XuI && r.fromTests.length ? r.fromTests.map((t => Zt.u0.fromExtHostTestItem(t, e).toString())) : void 0
                        }
                    }
                }(dt || (dt = {})),
                function(e) {
                    e.to = function(e) {
                        switch (e) {
                            case y.np.Invoke:
                                return Yt.CDv.Invoke;
                            case y.np.Auto:
                                return Yt.CDv.Automatic
                        }
                    }
                }(ft || (ft = {})),
                function(e) {
                    e.to = function(e) {
                        const t = new Yt.fQK(ce.to(e.kind), e.name, e.detail || "", b.ov.revive(e.uri), V.to(e.range), V.to(e.selectionRange));
                        return t._sessionId = e._sessionId, t._itemId = e._itemId, t
                    }, e.from = function(e, t, n) {
                        if (t = t ? ? e._sessionId, n = n ? ? e._itemId, void 0 === t || void 0 === n) throw new Error("invalid item");
                        return {
                            _sessionId: t,
                            _itemId: n,
                            kind: ce.from(e.kind),
                            name: e.name,
                            detail: e.detail ? ? "",
                            uri: e.uri,
                            range: V.from(e.range),
                            selectionRange: V.from(e.selectionRange),
                            tags: e.tags ? .map(le.from)
                        }
                    }
                }(pt || (pt = {})),
                function(e) {
                    e.from = function(e) {
                        if (e) return {
                            value: e.value,
                            tooltip: e.tooltip
                        }
                    }
                }(gt || (gt = {})),
                function(e) {
                    function t(e) {
                        return s.Z0.split(e).map((e => {
                            if (e.startsWith("#")) return e;
                            try {
                                return b.ov.parse(e)
                            } catch {}
                            return e
                        }))
                    }
                    e.to = function(e, t, n) {
                        const r = t.fileData;
                        return r ? new Yt.ctj(new Yt.kaV(r.name, b.ov.revive(r.uri), r.id, (0, o.M)((() => n(r.id))))) : e === h.vW.uriList && t.uriListData ? new Yt.qDr((i = t.uriListData, s.Z0.create(i.map((e => "string" == typeof e ? e : b.ov.revive(e)))))) : new Yt.qDr(t.asString);
                        var i
                    }, e.from = async function(e, n) {
                        const r = await n.asString();
                        if (e === h.vW.uriList) return {
                            asString: r,
                            fileData: void 0,
                            uriListData: t(r)
                        };
                        const i = n.asFile();
                        return {
                            asString: r,
                            fileData: i ? {
                                name: i.name,
                                uri: i.uri,
                                id: i._itemId ? ? i.id
                            } : void 0
                        }
                    }
                }(mt || (mt = {})),
                function(e) {
                    e.toDataTransfer = function(e, t) {
                        const n = e.items.map((([e, n]) => [e, mt.to(e, n, t)]));
                        return new Yt.tnH(n)
                    }, e.from = async function(e) {
                        const t = {
                                items: []
                            },
                            n = [];
                        for (const [r, i] of e) n.push((async () => {
                            t.items.push([r, await mt.from(r, i)])
                        })());
                        return await Promise.all(n), t
                    }
                }(bt || (bt = {})),
                function(e) {
                    e.from = function(e, t) {
                        return {
                            kind: "reply",
                            agentId: e.participant ? ? t ? .agentId ? ? "",
                            subCommand: e.command ? ? t ? .command,
                            message: e.prompt,
                            title: e.label
                        }
                    }, e.to = function(e) {
                        return {
                            prompt: e.message,
                            label: e.title,
                            participant: e.agentId,
                            command: e.subCommand
                        }
                    }
                }(_t || (_t = {})),
                function(e) {
                    e.to = function(e) {
                        switch (e) {
                            case $.System:
                                return Yt.grl.System;
                            case $.User:
                                return Yt.grl.User;
                            case $.Assistant:
                                return Yt.grl.Assistant
                        }
                    }, e.from = function(e) {
                        switch (e) {
                            case Yt.grl.System:
                                return $.System;
                            case Yt.grl.User:
                                return $.User;
                            case Yt.grl.Assistant:
                                return $.Assistant
                        }
                        return $.User
                    }
                }(vt || (vt = {})),
                function(e) {
                    e.to = function(e) {
                        let t, n = "";
                        "text" === e.content.type ? n = e.content.value : t = new Yt.DHf(e.content.name, e.content.value, e.content.isError);
                        const r = vt.to(e.role),
                            i = new Yt.xf$(r, n, e.name);
                        return void 0 !== t && (i.content2 = t), i
                    }, e.from = function(e) {
                        const t = vt.from(e.role),
                            n = e.name;
                        let r;
                        return r = e.content2 instanceof Yt.DHf ? {
                            type: "function_result",
                            name: e.content2.name,
                            value: e.content2.content,
                            isError: e.content2.isError
                        } : {
                            type: "text",
                            value: e.content
                        }, {
                            role: t,
                            name: n,
                            content: r
                        }
                    }
                }(wt || (wt = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            kind: "markdownContent",
                            content: te.from(e.value)
                        }
                    }, e.to = function(e) {
                        return new Yt.HYr(te.to(e.content))
                    }
                }(yt || (yt = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            kind: "markdownVuln",
                            content: te.from(e.value),
                            vulnerabilities: e.vulnerabilities
                        }
                    }, e.to = function(e) {
                        return new Yt.Zgy(te.to(e.content), e.vulnerabilities)
                    }
                }(xt || (xt = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            kind: "agentDetection",
                            agentId: e.participant,
                            command: e.command
                        }
                    }, e.to = function(e) {
                        return new Yt.s8P(e.agentId, e.command)
                    }
                }(kt || (kt = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            kind: "confirmation",
                            title: e.title,
                            message: e.message,
                            data: e.data
                        }
                    }
                }(Ct || (Ct = {})),
                function(e) {
                    e.from = function(e) {
                        const {
                            value: t,
                            baseUri: n
                        } = e;
                        return {
                            kind: "treeData",
                            treeData: {
                                label: (0, p.EZ)(n),
                                uri: n,
                                children: function e(t, n) {
                                    return t.map((t => {
                                        const r = b.ov.joinPath(n, t.name);
                                        return {
                                            label: t.name,
                                            uri: r,
                                            children: t.children && e(t.children, r)
                                        }
                                    }))
                                }(t, n)
                            }
                        }
                    }, e.to = function(e) {
                        const t = (0, u.wL)(e.treeData),
                            n = t.uri,
                            r = t.children ? function e(t) {
                                return t.map((t => ({
                                    name: t.label,
                                    children: t.children && e(t.children)
                                })))
                            }(t.children) : [];
                        return new Yt.Y08(r, n)
                    }
                }(It || (It = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            kind: "inlineReference",
                            name: e.title,
                            inlineReference: (t = e.value, b.ov.isUri(t) ? e.value : H.from(e.value))
                        };
                        var t
                    }, e.to = function(e) {
                        const t = (0, u.wL)(e);
                        return new Yt.trJ(b.ov.isUri(t.inlineReference) ? t.inlineReference : H.to(t.inlineReference), e.name)
                    }
                }(St || (St = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            kind: "progressMessage",
                            content: te.from(e.value)
                        }
                    }, e.to = function(e) {
                        return new Yt.Gli(e.content.value)
                    }
                }(Et || (Et = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            kind: "warning",
                            content: te.from(e.value)
                        }
                    }, e.to = function(e) {
                        return new Yt.fkf(e.content.value)
                    }
                }(Tt || (Tt = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            kind: "progressTask",
                            content: te.from(e.value)
                        }
                    }
                }(Lt || (Lt = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            kind: "progressTaskResult",
                            content: "string" == typeof e ? te.from(e) : void 0
                        }
                    }
                }(Rt || (Rt = {})),
                function(e) {
                    e.from = function(e, t, n) {
                        return {
                            kind: "command",
                            command: t.toInternal(e.value, n) ? ? {
                                command: e.value.command,
                                title: e.value.title
                            }
                        }
                    }, e.to = function(e, t) {
                        return new Yt.WTw(t.fromInternal(e.command) ? ? {
                            command: e.command.id,
                            title: e.command.title
                        })
                    }
                }(At || (At = {})),
                function(e) {
                    e.from = function(e) {
                        return {
                            kind: "textEdit",
                            uri: e.uri,
                            edits: e.edits.map((e => oe.from(e)))
                        }
                    }, e.to = function(e) {
                        return new Yt.cGf(b.ov.revive(e.uri), e.edits.map((e => oe.to(e))))
                    }
                }(Nt || (Nt = {})),
                function(e) {
                    e.from = function(e) {
                        const t = g.kS.isThemeIcon(e.iconPath) ? e.iconPath : b.ov.isUri(e.iconPath) ? {
                            light: b.ov.revive(e.iconPath)
                        } : e.iconPath && "light" in e.iconPath && "dark" in e.iconPath && b.ov.isUri(e.iconPath.light) && b.ov.isUri(e.iconPath.dark) ? {
                            light: b.ov.revive(e.iconPath.light),
                            dark: b.ov.revive(e.iconPath.dark)
                        } : void 0;
                        return "variableName" in e.value ? {
                            kind: "reference",
                            reference: {
                                variableName: e.value.variableName,
                                value: b.ov.isUri(e.value.value) || !e.value.value ? e.value.value : H.from(e.value.value)
                            },
                            iconPath: t
                        } : {
                            kind: "reference",
                            reference: b.ov.isUri(e.value) ? e.value : H.from(e.value),
                            iconPath: t
                        }
                    }, e.to = function(e) {
                        const t = (0, u.wL)(e),
                            n = e => b.ov.isUri(e) ? e : H.to(e);
                        return new Yt.Ht3("variableName" in t.reference ? {
                            variableName: t.reference.variableName,
                            value: t.reference.value && n(t.reference.value)
                        } : n(t.reference))
                    }
                }(Ot || (Ot = {})),
                function(e) {
                    function t(e, t) {
                        switch (e.kind) {
                            case "markdownContent":
                                return yt.to(e);
                            case "inlineReference":
                                return St.to(e);
                            case "progressMessage":
                                return;
                            case "treeData":
                                return It.to(e);
                            case "command":
                                return At.to(e, t)
                        }
                    }
                    e.from = function(e, t, n) {
                        return e instanceof Yt.HYr ? yt.from(e) : e instanceof Yt.trJ ? St.from(e) : e instanceof Yt.Ht3 ? Ot.from(e) : e instanceof Yt.Gli ? Et.from(e) : e instanceof Yt.Y08 ? It.from(e) : e instanceof Yt.WTw ? At.from(e, t, n) : e instanceof Yt.cGf ? Nt.from(e) : e instanceof Yt.Zgy ? xt.from(e) : e instanceof Yt.s8P ? kt.from(e) : e instanceof Yt.fkf ? Tt.from(e) : {
                            kind: "markdownContent",
                            content: te.from("")
                        }
                    }, e.to = function(e, n) {
                        switch (e.kind) {
                            case "reference":
                                return Ot.to(e);
                            case "markdownContent":
                            case "inlineReference":
                            case "progressMessage":
                            case "treeData":
                            case "command":
                                return t(e, n)
                        }
                    }, e.toContent = t
                }(Mt || (Mt = {})),
                function(e) {
                    e.to = function(e) {
                        return {
                            prompt: e.message,
                            command: e.command,
                            attempt: e.attempt ? ? 0,
                            enableCommandDetection: e.enableCommandDetection ? ? !0,
                            references: e.variables.variables.map(Ut.to),
                            location: Pt.to(e.location),
                            acceptedConfirmationData: e.acceptedConfirmationData,
                            rejectedConfirmationData: e.rejectedConfirmationData
                        }
                    }
                }(Dt || (Dt = {})),
                function(e) {
                    e.to = function(e) {
                        switch (e) {
                            case E.O$.Notebook:
                                return Yt.oYl.Notebook;
                            case E.O$.Terminal:
                                return Yt.oYl.Terminal;
                            case E.O$.Panel:
                                return Yt.oYl.Panel;
                            case E.O$.Editor:
                                return Yt.oYl.Editor
                        }
                    }, e.from = function(e) {
                        switch (e) {
                            case Yt.oYl.Notebook:
                                return E.O$.Notebook;
                            case Yt.oYl.Terminal:
                                return E.O$.Terminal;
                            case Yt.oYl.Panel:
                                return E.O$.Panel;
                            case Yt.oYl.Editor:
                                return E.O$.Editor
                        }
                    }
                }(Pt || (Pt = {})),
                function(e) {
                    e.to = function(e) {
                        const t = e.value;
                        if (!t) throw new Error("Invalid value reference");
                        return {
                            id: e.id,
                            name: e.name,
                            range: e.range && [e.range.start, e.range.endExclusive],
                            value: (0, b._9)(t) ? b.ov.revive(t) : t && "object" == typeof t && "uri" in t && "range" in t && (0, b._9)(t.uri) ? H.to((0, u.wL)(t)) : t,
                            modelDescription: e.modelDescription
                        }
                    }
                }(Ut || (Ut = {})),
                function(e) {
                    e.from = function(e, t, n) {
                        return {
                            id: e.id,
                            label: e.label,
                            fullName: e.fullName,
                            icon: e.icon ? .id,
                            value: e.values[0].value,
                            insertText: e.insertText,
                            detail: e.detail,
                            documentation: e.documentation,
                            command: t.toInternal(e.command, n)
                        }
                    }
                }(Ft || (Ft = {})),
                function(e) {
                    e.to = function(e) {
                        return {
                            errorDetails: e.errorDetails,
                            metadata: e.metadata
                        }
                    }
                }(Bt || (Bt = {})),
                function(e) {
                    e.to = function(e, t, n) {
                        if ("vote" === t.action.kind) return;
                        const r = Bt.to(e);
                        if ("command" === t.action.kind) {
                            const e = t.action.commandButton.command;
                            return {
                                action: {
                                    kind: "command",
                                    commandButton: {
                                        command: n.fromInternal(e) ? ? {
                                            command: e.id,
                                            title: e.title
                                        }
                                    }
                                },
                                result: r
                            }
                        }
                        return "followUp" === t.action.kind ? {
                            action: {
                                kind: "followUp",
                                followup: _t.to(t.action.followup)
                            },
                            result: r
                        } : "inlineChat" === t.action.kind ? {
                            action: {
                                kind: "editor",
                                accepted: "accepted" === t.action.action
                            },
                            result: r
                        } : {
                            action: t.action,
                            result: r
                        }
                    }
                }($t || ($t = {})),
                function(e) {
                    e.from = function(e, t, n) {
                        return "terminalCommand" in e ? {
                            terminalCommand: e.terminalCommand,
                            shouldExecute: e.shouldExecute
                        } : "uri" in e ? {
                            uri: e.uri
                        } : t.toInternal(e, n)
                    }
                }(zt || (zt = {})),
                function(e) {
                    e.to = function(e) {
                        return {
                            kind: Wt.to(e.kind)
                        }
                    }
                }(qt || (qt = {})),
                function(e) {
                    e.to = function(e) {
                        switch (e) {
                            case y.NA.Word:
                                return Yt.NAb.Word;
                            case y.NA.Line:
                                return Yt.NAb.Line;
                            case y.NA.Suggest:
                                return Yt.NAb.Suggest;
                            default:
                                return Yt.NAb.Unknown
                        }
                    }
                }(Wt || (Wt = {})),
                function(e) {
                    e.from = function(e, t) {
                        return {
                            id: t,
                            label: e.label,
                            description: e.description,
                            canEdit: e.canEdit,
                            collapsibleState: e.collapsibleState || Ht.kU.None,
                            contextValue: e.contextValue
                        }
                    }
                }(jt || (jt = {})),
                function(e) {
                    e.to = function(e) {
                        return {
                            name: e.name,
                            description: e.description,
                            parametersSchema: e.parametersSchema
                        }
                    }
                }(Vt || (Vt = {}))
        },
        "7NN/": (e, t, n) => {
            n.d(t, {
                $KE: () => Gt,
                $R: () => br,
                $hL: () => Gn,
                $uQ: () => X,
                ADb: () => on,
                AIo: () => Zn,
                ApZ: () => vn,
                Ay: () => Ln,
                B2n: () => ge,
                CDv: () => pe,
                Cgf: () => ei,
                Coj: () => Pe,
                DHf: () => Hr,
                DKv: () => Et,
                DbP: () => Y,
                EG5: () => Q,
                EU7: () => cr,
                F3Y: () => Tn,
                FGT: () => Me,
                FLm: () => zt,
                FR$: () => mn,
                FZl: () => rt,
                GLX: () => se,
                GSm: () => Qt,
                Gli: () => Fr,
                HCM: () => Z,
                HGt: () => Wt,
                HYr: () => Nr,
                H_B: () => ee,
                Ht3: () => qr,
                Hu0: () => An,
                I01: () => Qr,
                I82: () => tt,
                IAb: () => Ir,
                IAe: () => ar,
                IQN: () => Vr,
                IjA: () => Ae,
                Ik8: () => Dr,
                Ilk: () => Je,
                InX: () => Hn,
                JCu: () => ct,
                JDx: () => Ot,
                JFR: () => xe,
                JNW: () => de,
                JOq: () => Un,
                JQb: () => bn,
                JTr: () => U,
                K1l: () => $t,
                KHd: () => yt,
                KPz: () => En,
                LdD: () => Yn,
                Llw: () => en,
                Lyo: () => F,
                M$5: () => Ce,
                M0$: () => G,
                MIn: () => $e,
                MPI: () => ve,
                MXZ: () => Lt,
                MYA: () => ae,
                Max: () => J,
                N$N: () => ln,
                NAb: () => Fe,
                NEU: () => Gr,
                Ngc: () => Tr,
                NqL: () => Tt,
                OLe: () => ht,
                ORh: () => Jr,
                OTk: () => un,
                PYv: () => K,
                Pts: () => fn,
                QII: () => ot,
                R9_: () => re,
                RVV: () => we,
                Rxm: () => ye,
                S$x: () => yn,
                TED: () => He,
                TGJ: () => Ft,
                TMt: () => Xe,
                TMw: () => ie,
                TPH: () => xn,
                TWf: () => st,
                Tax: () => Yr,
                TpX: () => Bt,
                U07: () => Vt,
                UCC: () => qn,
                UPf: () => Cn,
                Ub$: () => De,
                Ul: () => Mn,
                UoH: () => Ut,
                Usx: () => Wn,
                UwW: () => Rr,
                UyC: () => Er,
                Uzh: () => gn,
                V8w: () => mr,
                W5C: () => ke,
                WBl: () => ft,
                WTw: () => zr,
                WW0: () => Ee,
                Xdk: () => nn,
                Xfu: () => lr,
                XgO: () => Lr,
                XsU: () => On,
                XuI: () => er,
                Y08: () => Pr,
                Y0F: () => sr,
                Y19: () => $,
                YED: () => Kn,
                YL6: () => Pt,
                Y_o: () => wr,
                YeX: () => te,
                YjK: () => Rn,
                ZMD: () => Vn,
                Zgy: () => Or,
                _AT: () => cn,
                _VK: () => We,
                _n6: () => Zr,
                _x0: () => et,
                acJ: () => $n,
                azK: () => pr,
                b6q: () => V,
                bZY: () => In,
                bqK: () => oe,
                bur: () => Ve,
                bwv: () => Zt,
                c4G: () => Dn,
                cGf: () => Wr,
                cRn: () => ue,
                cYW: () => ir,
                cZI: () => qt,
                cmM: () => Ne,
                ctj: () => Ct,
                dEe: () => rr,
                dWA: () => je,
                dql: () => hn,
                e2j: () => it,
                e6w: () => B,
                eIC: () => Be,
                eg0: () => jr,
                ehQ: () => ce,
                fQK: () => vr,
                fkf: () => $r,
                fyj: () => nr,
                gl: () => Te,
                grl: () => fr,
                hNq: () => Ht,
                hfl: () => Kt,
                i23: () => nt,
                iQE: () => mt,
                jWy: () => Ge,
                jqr: () => zn,
                kGi: () => Xn,
                kS8: () => At,
                kU2: () => Cr,
                kaV: () => It,
                kfG: () => vt,
                kiP: () => xr,
                lF4: () => yr,
                lMH: () => le,
                lP6: () => ze,
                lSh: () => xt,
                lZM: () => dn,
                llk: () => _e,
                ltp: () => Jn,
                meY: () => Br,
                mgN: () => gt,
                n2H: () => pn,
                oCf: () => wt,
                oYl: () => dr,
                ogl: () => Sr,
                oi2: () => Qe,
                p5U: () => lt,
                pdQ: () => or,
                pr0: () => Ye,
                qDr: () => kt,
                qIz: () => Ie,
                qNe: () => pt,
                qR: () => Le,
                qRu: () => Qn,
                qaI: () => j,
                qlg: () => wn,
                r4c: () => he,
                rLr: () => Yt,
                rbC: () => Nn,
                rnR: () => _r,
                ryi: () => W,
                s8P: () => Mr,
                sUC: () => Mt,
                sfZ: () => Fn,
                sof: () => sn,
                sz_: () => q,
                t5: () => at,
                t7_: () => Re,
                tHl: () => Xr,
                tPk: () => Nt,
                tfP: () => Ue,
                tnH: () => St,
                trJ: () => Ur,
                u8m: () => hr,
                uOQ: () => Ar,
                uTI: () => bt,
                unW: () => kn,
                vGG: () => H,
                va0: () => ne,
                vvd: () => w,
                vyX: () => Se,
                w6Q: () => fe,
                wDJ: () => qe,
                wJF: () => Jt,
                wUy: () => Sn,
                wa0: () => Xt,
                weh: () => Oe,
                wxO: () => Ke,
                x$B: () => Pn,
                xJH: () => jn,
                xJu: () => gr,
                xKz: () => an,
                xTW: () => Bn,
                xf$: () => Kr,
                xm7: () => be,
                xmj: () => tr,
                xwm: () => Rt,
                yGk: () => dt,
                yHy: () => Ze,
                yNd: () => me,
                yNx: () => rn,
                ySx: () => ur,
                yr7: () => jt,
                yzl: () => _n,
                z0r: () => _t,
                zR2: () => tn,
                zwE: () => kr
            });
            var r, i, s, o, a, c, l, u, h, d, f, p, g, m, b, _, v, w, y = n("t5wJ"),
                x = n("iDmX"),
                k = n("PUdK"),
                C = n("o1+4"),
                I = n("Ef4y"),
                S = n("qf7F"),
                E = n("p044"),
                T = n("K30K"),
                L = n("naIR"),
                R = n("R7Dl"),
                A = n("6zxw"),
                N = n("ts6x"),
                O = n("83Eb"),
                M = n("O9sO"),
                D = n("ziTh");

            function P(e) {
                const t = {
                    apply: function(...t) {
                        if (0 === t.length) return Reflect.construct(e, []); {
                            const n = 1 === t.length ? [] : t[1];
                            return Reflect.construct(e, n, t[0].constructor)
                        }
                    },
                    call: function(...t) {
                        if (0 === t.length) return Reflect.construct(e, []); {
                            const [n, ...r] = t;
                            return Reflect.construct(e, r, n.constructor)
                        }
                    }
                };
                return Object.assign(e, t)
            }! function(e) {
                e[e.Top = 0] = "Top", e[e.Bottom = 1] = "Bottom"
            }(w || (w = {}));
            let U = r = class {
                static from(...e) {
                    let t = e;
                    return new r((function() {
                        if (t) {
                            for (const e of t) e && "function" == typeof e.dispose && e.dispose();
                            t = void 0
                        }
                    }))
                }#
                e;
                constructor(e) {
                    this.#e = e
                }
                dispose() {
                    "function" == typeof this.#e && (this.#e(), this.#e = void 0)
                }
            };
            U = r = (0, y.g)([P], U);
            let F = i = class {
                static Min(...e) {
                    if (0 === e.length) throw new TypeError;
                    let t = e[0];
                    for (let n = 1; n < e.length; n++) {
                        const r = e[n];
                        r.isBefore(t) && (t = r)
                    }
                    return t
                }
                static Max(...e) {
                    if (0 === e.length) throw new TypeError;
                    let t = e[0];
                    for (let n = 1; n < e.length; n++) {
                        const r = e[n];
                        r.isAfter(t) && (t = r)
                    }
                    return t
                }
                static isPosition(e) {
                    if (!e) return !1;
                    if (e instanceof i) return !0;
                    const {
                        line: t,
                        character: n
                    } = e;
                    return "number" == typeof t && "number" == typeof n
                }
                static of (e) {
                    if (e instanceof i) return e;
                    if (this.isPosition(e)) return new i(e.line, e.character);
                    throw new Error("Invalid argument, is NOT a position-like object")
                }
                get line() {
                    return this._line
                }
                get character() {
                    return this._character
                }
                constructor(e, t) {
                    if (e < 0) throw (0, k.b1)("line must be non-negative");
                    if (t < 0) throw (0, k.b1)("character must be non-negative");
                    this._line = e, this._character = t
                }
                isBefore(e) {
                    return this._line < e._line || !(e._line < this._line) && this._character < e._character
                }
                isBeforeOrEqual(e) {
                    return this._line < e._line || !(e._line < this._line) && this._character <= e._character
                }
                isAfter(e) {
                    return !this.isBeforeOrEqual(e)
                }
                isAfterOrEqual(e) {
                    return !this.isBefore(e)
                }
                isEqual(e) {
                    return this._line === e._line && this._character === e._character
                }
                compareTo(e) {
                    return this._line < e._line ? -1 : this._line > e.line ? 1 : this._character < e._character ? -1 : this._character > e._character ? 1 : 0
                }
                translate(e, t = 0) {
                    if (null === e || null === t) throw (0, k.b1)();
                    let n;
                    return void 0 === e ? n = 0 : "number" == typeof e ? n = e : (n = "number" == typeof e.lineDelta ? e.lineDelta : 0, t = "number" == typeof e.characterDelta ? e.characterDelta : 0), 0 === n && 0 === t ? this : new i(this.line + n, this.character + t)
                }
                with(e, t = this.character) {
                    if (null === e || null === t) throw (0, k.b1)();
                    let n;
                    return void 0 === e ? n = this.line : "number" == typeof e ? n = e : (n = "number" == typeof e.line ? e.line : this.line, t = "number" == typeof e.character ? e.character : this.character), n === this.line && t === this.character ? this : new i(n, t)
                }
                toJSON() {
                    return {
                        line: this.line,
                        character: this.character
                    }
                }
            };
            F = i = (0, y.g)([P], F);
            let B = s = class {
                static isRange(e) {
                    return e instanceof s || !!e && F.isPosition(e.start) && F.isPosition(e.end)
                }
                static of (e) {
                    if (e instanceof s) return e;
                    if (this.isRange(e)) return new s(e.start, e.end);
                    throw new Error("Invalid argument, is NOT a range-like object")
                }
                get start() {
                    return this._start
                }
                get end() {
                    return this._end
                }
                constructor(e, t, n, r) {
                    let i, s;
                    if ("number" == typeof e && "number" == typeof t && "number" == typeof n && "number" == typeof r ? (i = new F(e, t), s = new F(n, r)) : F.isPosition(e) && F.isPosition(t) && (i = F.of(e), s = F.of(t)), !i || !s) throw new Error("Invalid arguments");
                    i.isBefore(s) ? (this._start = i, this._end = s) : (this._start = s, this._end = i)
                }
                contains(e) {
                    return s.isRange(e) ? this.contains(e.start) && this.contains(e.end) : !!F.isPosition(e) && !F.of(e).isBefore(this._start) && !this._end.isBefore(e)
                }
                isEqual(e) {
                    return this._start.isEqual(e._start) && this._end.isEqual(e._end)
                }
                intersection(e) {
                    const t = F.Max(e.start, this._start),
                        n = F.Min(e.end, this._end);
                    if (!t.isAfter(n)) return new s(t, n)
                }
                union(e) {
                    if (this.contains(e)) return this;
                    if (e.contains(this)) return e;
                    const t = F.Min(e.start, this._start),
                        n = F.Max(e.end, this.end);
                    return new s(t, n)
                }
                get isEmpty() {
                    return this._start.isEqual(this._end)
                }
                get isSingleLine() {
                    return this._start.line === this._end.line
                }
                with(e, t = this.end) {
                    if (null === e || null === t) throw (0, k.b1)();
                    let n;
                    return e ? F.isPosition(e) ? n = e : (n = e.start || this.start, t = e.end || this.end) : n = this.start, n.isEqual(this._start) && t.isEqual(this.end) ? this : new s(n, t)
                }
                toJSON() {
                    return [this.start, this.end]
                }
            };
            B = s = (0, y.g)([P], B);
            let $ = o = class extends B {
                static isSelection(e) {
                    return e instanceof o || !!e && B.isRange(e) && F.isPosition(e.anchor) && F.isPosition(e.active) && "boolean" == typeof e.isReversed
                }
                get anchor() {
                    return this._anchor
                }
                get active() {
                    return this._active
                }
                constructor(e, t, n, r) {
                    let i, s;
                    if ("number" == typeof e && "number" == typeof t && "number" == typeof n && "number" == typeof r ? (i = new F(e, t), s = new F(n, r)) : F.isPosition(e) && F.isPosition(t) && (i = F.of(e), s = F.of(t)), !i || !s) throw new Error("Invalid arguments");
                    super(i, s), this._anchor = i, this._active = s
                }
                get isReversed() {
                    return this._anchor === this._end
                }
                toJSON() {
                    return {
                        start: this.start,
                        end: this.end,
                        active: this.active,
                        anchor: this.anchor
                    }
                }
            };
            $ = o = (0, y.g)([P], $);
            const z = e => {
                if ("string" != typeof e || 0 === e.length || !/^[0-9A-Za-z_\-]+$/.test(e)) throw (0, k.b1)("connectionToken")
            };
            class q {
                static isResolvedAuthority(e) {
                    return e && "object" == typeof e && "string" == typeof e.host && "number" == typeof e.port && (void 0 === e.connectionToken || "string" == typeof e.connectionToken)
                }
                constructor(e, t, n) {
                    if ("string" != typeof e || 0 === e.length) throw (0, k.b1)("host");
                    if ("number" != typeof t || 0 === t || Math.round(t) !== t) throw (0, k.b1)("port");
                    void 0 !== n && z(n), this.host = e, this.port = Math.round(t), this.connectionToken = n
                }
            }
            class W {
                static isManagedResolvedAuthority(e) {
                    return e && "object" == typeof e && "function" == typeof e.makeConnection && (void 0 === e.connectionToken || "string" == typeof e.connectionToken)
                }
                constructor(e, t) {
                    this.makeConnection = e, this.connectionToken = t, void 0 !== t && z(t)
                }
            }
            class j extends Error {
                static NotAvailable(e, t) {
                    return new j(e, O.XP.NotAvailable, t)
                }
                static TemporarilyNotAvailable(e) {
                    return new j(e, O.XP.TemporarilyNotAvailable)
                }
                constructor(e, t = O.XP.Unknown, n) {
                    super(e), this._message = e, this._code = t, this._detail = n, Object.setPrototypeOf(this, j.prototype)
                }
            }
            var V, H;
            ! function(e) {
                e[e.LF = 1] = "LF", e[e.CRLF = 2] = "CRLF"
            }(V || (V = {})),
            function(e) {
                e[e.Replace = 1] = "Replace", e[e.Append = 2] = "Append", e[e.Prepend = 3] = "Prepend"
            }(H || (H = {}));
            let K = a = class {
                static isTextEdit(e) {
                    return e instanceof a || !!e && B.isRange(e) && "string" == typeof e.newText
                }
                static replace(e, t) {
                    return new a(e, t)
                }
                static insert(e, t) {
                    return a.replace(new B(e, e), t)
                }
                static delete(e) {
                    return a.replace(e, "")
                }
                static setEndOfLine(e) {
                    const t = new a(new B(new F(0, 0), new F(0, 0)), "");
                    return t.newEol = e, t
                }
                get range() {
                    return this._range
                }
                set range(e) {
                    if (e && !B.isRange(e)) throw (0, k.b1)("range");
                    this._range = e
                }
                get newText() {
                    return this._newText || ""
                }
                set newText(e) {
                    if (e && "string" != typeof e) throw (0, k.b1)("newText");
                    this._newText = e
                }
                get newEol() {
                    return this._newEol
                }
                set newEol(e) {
                    if (e && "number" != typeof e) throw (0, k.b1)("newEol");
                    this._newEol = e
                }
                constructor(e, t) {
                    this._range = e, this._newText = t
                }
                toJSON() {
                    return {
                        range: this.range,
                        newText: this.newText,
                        newEol: this._newEol
                    }
                }
            };
            K = a = (0, y.g)([P], K);
            let Z = c = class {
                static isNotebookCellEdit(e) {
                    return e instanceof c || !!e && On.isNotebookRange(e) && Array.isArray(e.newCells)
                }
                static replaceCells(e, t) {
                    return new c(e, t)
                }
                static insertCells(e, t) {
                    return new c(new On(e, e), t)
                }
                static deleteCells(e) {
                    return new c(e, [])
                }
                static updateCellMetadata(e, t) {
                    const n = new c(new On(e, e), []);
                    return n.newCellMetadata = t, n
                }
                static updateNotebookMetadata(e) {
                    const t = new c(new On(0, 0), []);
                    return t.newNotebookMetadata = e, t
                }
                constructor(e, t) {
                    this.range = e, this.newCells = t
                }
            };
            Z = c = (0, y.g)([P], Z);
            class G {
                static isSnippetTextEdit(e) {
                    return e instanceof G || !!e && B.isRange(e.range) && Q.isSnippetString(e.snippet)
                }
                static replace(e, t) {
                    return new G(e, t)
                }
                static insert(e, t) {
                    return G.replace(new B(e, e), t)
                }
                constructor(e, t) {
                    this.range = e, this.snippet = t
                }
            }
            var J;
            ! function(e) {
                e[e.File = 1] = "File", e[e.Text = 2] = "Text", e[e.Cell = 3] = "Cell", e[e.CellReplace = 5] = "CellReplace", e[e.Snippet = 6] = "Snippet"
            }(J || (J = {}));
            let Y = class {
                constructor() {
                    this._edits = []
                }
                _allEntries() {
                    return this._edits
                }
                renameFile(e, t, n, r) {
                    this._edits.push({
                        _type: J.File,
                        from: e,
                        to: t,
                        options: n,
                        metadata: r
                    })
                }
                createFile(e, t, n) {
                    this._edits.push({
                        _type: J.File,
                        from: void 0,
                        to: e,
                        options: t,
                        metadata: n
                    })
                }
                deleteFile(e, t, n) {
                    this._edits.push({
                        _type: J.File,
                        from: e,
                        to: void 0,
                        options: t,
                        metadata: n
                    })
                }
                replaceNotebookMetadata(e, t, n) {
                    this._edits.push({
                        _type: J.Cell,
                        metadata: n,
                        uri: e,
                        edit: {
                            editType: M.w.DocumentMetadata,
                            metadata: t
                        },
                        notebookMetadata: t
                    })
                }
                replaceNotebookCells(e, t, n, r) {
                    const i = t.start,
                        s = t.end;
                    (i !== s || n.length > 0) && this._edits.push({
                        _type: J.CellReplace,
                        uri: e,
                        index: i,
                        count: s - i,
                        cells: n,
                        metadata: r
                    })
                }
                replaceNotebookCellMetadata(e, t, n, r) {
                    this._edits.push({
                        _type: J.Cell,
                        metadata: r,
                        uri: e,
                        edit: {
                            editType: M.w.Metadata,
                            index: t,
                            metadata: n
                        }
                    })
                }
                replace(e, t, n, r) {
                    this._edits.push({
                        _type: J.Text,
                        uri: e,
                        edit: new K(t, n),
                        metadata: r
                    })
                }
                insert(e, t, n, r) {
                    this.replace(e, new B(t, t), n, r)
                }
                delete(e, t, n) {
                    this.replace(e, t, "", n)
                }
                has(e) {
                    return this._edits.some((t => t._type === J.Text && t.uri.toString() === e.toString()))
                }
                set(e, t) {
                    if (t)
                        for (const n of t) {
                            if (!n) continue;
                            let t, r;
                            Array.isArray(n) ? (t = n[0], r = n[1]) : t = n, Z.isNotebookCellEdit(t) ? t.newCellMetadata ? this.replaceNotebookCellMetadata(e, t.range.start, t.newCellMetadata, r) : t.newNotebookMetadata ? this.replaceNotebookMetadata(e, t.newNotebookMetadata, r) : this.replaceNotebookCells(e, t.range, t.newCells, r) : G.isSnippetTextEdit(t) ? this._edits.push({
                                _type: J.Snippet,
                                uri: e,
                                range: t.range,
                                edit: t.snippet,
                                metadata: r
                            }) : this._edits.push({
                                _type: J.Text,
                                uri: e,
                                edit: t,
                                metadata: r
                            })
                        } else {
                            for (let t = 0; t < this._edits.length; t++) {
                                const n = this._edits[t];
                                switch (n._type) {
                                    case J.Text:
                                    case J.Snippet:
                                    case J.Cell:
                                    case J.CellReplace:
                                        n.uri.toString() === e.toString() && (this._edits[t] = void 0)
                                }
                            }(0, x.Rs)(this._edits)
                        }
                }
                get(e) {
                    const t = [];
                    for (const n of this._edits) n._type === J.Text && n.uri.toString() === e.toString() && t.push(n.edit);
                    return t
                }
                entries() {
                    const e = new I.Y9;
                    for (const t of this._edits)
                        if (t._type === J.Text) {
                            let n = e.get(t.uri);
                            n || (n = [t.uri, []], e.set(t.uri, n)), n[1].push(t.edit)
                        }
                    return [...e.values()]
                }
                get size() {
                    return this.entries().length
                }
                toJSON() {
                    return this.entries()
                }
            };
            Y = (0, y.g)([P], Y);
            let Q = l = class {
                static isSnippetString(e) {
                    return e instanceof l || !!e && "string" == typeof e.value
                }
                static _escape(e) {
                    return e.replace(/\$|}|\\/g, "\\$&")
                }
                constructor(e) {
                    this._tabstop = 1, this.value = e || ""
                }
                appendText(e) {
                    return this.value += l._escape(e), this
                }
                appendTabstop(e = this._tabstop++) {
                    return this.value += "$", this.value += e, this
                }
                appendPlaceholder(e, t = this._tabstop++) {
                    if ("function" == typeof e) {
                        const t = new l;
                        t._tabstop = this._tabstop, e(t), this._tabstop = t._tabstop, e = t.value
                    } else e = l._escape(e);
                    return this.value += "${", this.value += t, this.value += ":", this.value += e, this.value += "}", this
                }
                appendChoice(e, t = this._tabstop++) {
                    const n = e.map((e => e.replaceAll(/[|\\,]/g, "\\$&"))).join(",");
                    return this.value += "${", this.value += t, this.value += "|", this.value += n, this.value += "|}", this
                }
                appendVariable(e, t) {
                    if ("function" == typeof t) {
                        const e = new l;
                        e._tabstop = this._tabstop, t(e), this._tabstop = e._tabstop, t = e.value
                    } else "string" == typeof t && (t = t.replace(/\$|}/g, "\\$&"));
                    return this.value += "${", this.value += e, t && (this.value += ":", this.value += t), this.value += "}", this
                }
            };
            var X, ee;
            Q = l = (0, y.g)([P], Q),
                function(e) {
                    e[e.Unnecessary = 1] = "Unnecessary", e[e.Deprecated = 2] = "Deprecated"
                }(X || (X = {})),
                function(e) {
                    e[e.Hint = 3] = "Hint", e[e.Information = 2] = "Information", e[e.Warning = 1] = "Warning", e[e.Error = 0] = "Error"
                }(ee || (ee = {}));
            let te = u = class {
                static isLocation(e) {
                    return e instanceof u || !!e && B.isRange(e.range) && L.ov.isUri(e.uri)
                }
                constructor(e, t) {
                    if (this.uri = e, t)
                        if (B.isRange(t)) this.range = B.of(t);
                        else {
                            if (!F.isPosition(t)) throw new Error("Illegal argument");
                            this.range = new B(t, t)
                        }
                }
                toJSON() {
                    return {
                        uri: this.uri,
                        range: this.range
                    }
                }
            };
            te = u = (0, y.g)([P], te);
            let ne = class {
                static is(e) {
                    return !!e && "string" == typeof e.message && e.location && B.isRange(e.location.range) && L.ov.isUri(e.location.uri)
                }
                constructor(e, t) {
                    this.location = e, this.message = t
                }
                static isEqual(e, t) {
                    return e === t || !(!e || !t) && e.message === t.message && e.location.range.isEqual(t.location.range) && e.location.uri.toString() === t.location.uri.toString()
                }
            };
            ne = (0, y.g)([P], ne);
            let re = class {
                constructor(e, t, n = ee.Error) {
                    if (!B.isRange(e)) throw new TypeError("range must be set");
                    if (!t) throw new TypeError("message must be set");
                    this.range = e, this.message = t, this.severity = n
                }
                toJSON() {
                    return {
                        severity: ee[this.severity],
                        message: this.message,
                        range: this.range,
                        source: this.source,
                        code: this.code
                    }
                }
                static isEqual(e, t) {
                    return e === t || !(!e || !t) && e.message === t.message && e.severity === t.severity && e.code === t.code && e.severity === t.severity && e.source === t.source && e.range.isEqual(t.range) && (0, x.fS)(e.tags, t.tags) && (0, x.fS)(e.relatedInformation, t.relatedInformation, ne.isEqual)
                }
            };
            re = (0, y.g)([P], re);
            let ie = class {
                constructor(e, t) {
                    if (!e) throw new Error("Illegal argument, contents must be defined");
                    Array.isArray(e) ? this.contents = e : this.contents = [e], this.range = t
                }
            };
            ie = (0, y.g)([P], ie);
            let se = class extends ie {
                constructor(e, t, n, r) {
                    super(e, t), this.canIncreaseHover = n, this.canDecreaseHover = r
                }
            };
            var oe, ae;
            se = (0, y.g)([P], se),
                function(e) {
                    e[e.Increase = 0] = "Increase", e[e.Decrease = 1] = "Decrease"
                }(oe || (oe = {})),
                function(e) {
                    e[e.Text = 0] = "Text", e[e.Read = 1] = "Read", e[e.Write = 2] = "Write"
                }(ae || (ae = {}));
            let ce = class {
                constructor(e, t = ae.Text) {
                    this.range = e, this.kind = t
                }
                toJSON() {
                    return {
                        range: this.range,
                        kind: ae[this.kind]
                    }
                }
            };
            ce = (0, y.g)([P], ce);
            let le = class {
                constructor(e, t) {
                    this.uri = e, this.highlights = t
                }
                toJSON() {
                    return {
                        uri: this.uri,
                        highlights: this.highlights.map((e => e.toJSON()))
                    }
                }
            };
            var ue, he;
            le = (0, y.g)([P], le),
                function(e) {
                    e[e.File = 0] = "File", e[e.Module = 1] = "Module", e[e.Namespace = 2] = "Namespace", e[e.Package = 3] = "Package", e[e.Class = 4] = "Class", e[e.Method = 5] = "Method", e[e.Property = 6] = "Property", e[e.Field = 7] = "Field", e[e.Constructor = 8] = "Constructor", e[e.Enum = 9] = "Enum", e[e.Interface = 10] = "Interface", e[e.Function = 11] = "Function", e[e.Variable = 12] = "Variable", e[e.Constant = 13] = "Constant", e[e.String = 14] = "String", e[e.Number = 15] = "Number", e[e.Boolean = 16] = "Boolean", e[e.Array = 17] = "Array", e[e.Object = 18] = "Object", e[e.Key = 19] = "Key", e[e.Null = 20] = "Null", e[e.EnumMember = 21] = "EnumMember", e[e.Struct = 22] = "Struct", e[e.Event = 23] = "Event", e[e.Operator = 24] = "Operator", e[e.TypeParameter = 25] = "TypeParameter"
                }(ue || (ue = {})),
                function(e) {
                    e[e.Deprecated = 1] = "Deprecated"
                }(he || (he = {}));
            let de = h = class {
                static validate(e) {
                    if (!e.name) throw new Error("name must not be falsy")
                }
                constructor(e, t, n, r, i) {
                    this.name = e, this.kind = t, this.containerName = i, "string" == typeof n && (this.containerName = n), r instanceof te ? this.location = r : n instanceof B && (this.location = new te(r, n)), h.validate(this)
                }
                toJSON() {
                    return {
                        name: this.name,
                        kind: ue[this.kind],
                        location: this.location,
                        containerName: this.containerName
                    }
                }
            };
            de = h = (0, y.g)([P], de);
            let fe = d = class {
                static validate(e) {
                    if (!e.name) throw new Error("name must not be falsy");
                    if (!e.range.contains(e.selectionRange)) throw new Error("selectionRange must be contained in fullRange");
                    e.children ? .forEach(d.validate)
                }
                constructor(e, t, n, r, i) {
                    this.name = e, this.detail = t, this.kind = n, this.range = r, this.selectionRange = i, this.children = [], d.validate(this)
                }
            };
            var pe;
            fe = d = (0, y.g)([P], fe),
                function(e) {
                    e[e.Invoke = 1] = "Invoke", e[e.Automatic = 2] = "Automatic"
                }(pe || (pe = {}));
            let ge = class {
                constructor(e, t) {
                    this.title = e, this.kind = t
                }
            };
            ge = (0, y.g)([P], ge);
            let me = class {
                static {
                    f = this
                }
                static {
                    this.sep = "."
                }
                constructor(e) {
                    this.value = e
                }
                append(e) {
                    return new f(this.value ? this.value + f.sep + e : e)
                }
                intersects(e) {
                    return this.contains(e) || e.contains(this)
                }
                contains(e) {
                    return this.value === e.value || e.value.startsWith(this.value + f.sep)
                }
            };
            me = f = (0, y.g)([P], me), me.Empty = new me(""), me.QuickFix = me.Empty.append("quickfix"), me.Refactor = me.Empty.append("refactor"), me.RefactorExtract = me.Refactor.append("extract"), me.RefactorInline = me.Refactor.append("inline"), me.RefactorMove = me.Refactor.append("move"), me.RefactorRewrite = me.Refactor.append("rewrite"), me.Source = me.Empty.append("source"), me.SourceOrganizeImports = me.Source.append("organizeImports"), me.SourceFixAll = me.Source.append("fixAll"), me.Notebook = me.Empty.append("notebook");
            let be = class {
                constructor(e, t) {
                    if (this.range = e, this.parent = t, t && !t.range.contains(this.range)) throw new Error("Invalid argument: parent must contain this range")
                }
            };
            be = (0, y.g)([P], be);
            class _e {
                constructor(e, t, n, r, i, s) {
                    this.kind = e, this.name = t, this.detail = n, this.uri = r, this.range = i, this.selectionRange = s
                }
            }
            class ve {
                constructor(e, t) {
                    this.fromRanges = t, this.from = e
                }
            }
            class we {
                constructor(e, t) {
                    this.fromRanges = t, this.to = e
                }
            }
            var ye;
            ! function(e) {
                e[e.Information = 0] = "Information", e[e.Warning = 1] = "Warning", e[e.Error = 2] = "Error"
            }(ye || (ye = {}));
            let xe = class {
                constructor(e, t) {
                    this.range = e, this.command = t
                }
                get isResolved() {
                    return !!this.command
                }
            };
            xe = (0, y.g)([P], xe);
            let ke = p = class {#
                t;
                static isMarkdownString(e) {
                    return e instanceof p || e && e.appendCodeblock && e.appendMarkdown && e.appendText && void 0 !== e.value
                }
                constructor(e, t = !1) {
                    this.#t = new C.W5(e, {
                        supportThemeIcons: t
                    })
                }
                get value() {
                    return this.#t.value
                }
                set value(e) {
                    this.#t.value = e
                }
                get isTrusted() {
                    return this.#t.isTrusted
                }
                set isTrusted(e) {
                    this.#t.isTrusted = e
                }
                get supportThemeIcons() {
                    return this.#t.supportThemeIcons
                }
                set supportThemeIcons(e) {
                    this.#t.supportThemeIcons = e
                }
                get supportHtml() {
                    return this.#t.supportHtml
                }
                set supportHtml(e) {
                    this.#t.supportHtml = e
                }
                get baseUri() {
                    return this.#t.baseUri
                }
                set baseUri(e) {
                    this.#t.baseUri = e
                }
                appendText(e) {
                    return this.#t.appendText(e), this
                }
                appendMarkdown(e) {
                    return this.#t.appendMarkdown(e), this
                }
                appendCodeblock(e, t) {
                    return this.#t.appendCodeblock(t ? ? "", e), this
                }
            };
            ke = p = (0, y.g)([P], ke);
            let Ce = class {
                constructor(e, t) {
                    this.label = e, this.documentation = t
                }
            };
            Ce = (0, y.g)([P], Ce);
            let Ie = class {
                constructor(e, t) {
                    this.label = e, this.documentation = t, this.parameters = []
                }
            };
            Ie = (0, y.g)([P], Ie);
            let Se = class {
                constructor() {
                    this.activeSignature = 0, this.activeParameter = 0, this.signatures = []
                }
            };
            var Ee, Te;
            Se = (0, y.g)([P], Se),
                function(e) {
                    e[e.Invoke = 1] = "Invoke", e[e.TriggerCharacter = 2] = "TriggerCharacter", e[e.ContentChange = 3] = "ContentChange"
                }(Ee || (Ee = {})),
                function(e) {
                    e[e.Type = 1] = "Type", e[e.Parameter = 2] = "Parameter"
                }(Te || (Te = {}));
            let Le = class {
                constructor(e) {
                    this.value = e
                }
            };
            Le = (0, y.g)([P], Le);
            let Re = class {
                constructor(e, t, n) {
                    this.position = e, this.label = t, this.kind = n
                }
            };
            var Ae, Ne, Oe;
            Re = (0, y.g)([P], Re),
                function(e) {
                    e[e.Invoke = 0] = "Invoke", e[e.TriggerCharacter = 1] = "TriggerCharacter", e[e.TriggerForIncompleteCompletions = 2] = "TriggerForIncompleteCompletions"
                }(Ae || (Ae = {})),
                function(e) {
                    e[e.Text = 0] = "Text", e[e.Method = 1] = "Method", e[e.Function = 2] = "Function", e[e.Constructor = 3] = "Constructor", e[e.Field = 4] = "Field", e[e.Variable = 5] = "Variable", e[e.Class = 6] = "Class", e[e.Interface = 7] = "Interface", e[e.Module = 8] = "Module", e[e.Property = 9] = "Property", e[e.Unit = 10] = "Unit", e[e.Value = 11] = "Value", e[e.Enum = 12] = "Enum", e[e.Keyword = 13] = "Keyword", e[e.Snippet = 14] = "Snippet", e[e.Color = 15] = "Color", e[e.File = 16] = "File", e[e.Reference = 17] = "Reference", e[e.Folder = 18] = "Folder", e[e.EnumMember = 19] = "EnumMember", e[e.Constant = 20] = "Constant", e[e.Struct = 21] = "Struct", e[e.Event = 22] = "Event", e[e.Operator = 23] = "Operator", e[e.TypeParameter = 24] = "TypeParameter", e[e.User = 25] = "User", e[e.Issue = 26] = "Issue"
                }(Ne || (Ne = {})),
                function(e) {
                    e[e.Deprecated = 1] = "Deprecated"
                }(Oe || (Oe = {}));
            let Me = class {
                constructor(e, t) {
                    this.label = e, this.kind = t
                }
                toJSON() {
                    return {
                        label: this.label,
                        kind: this.kind && Ne[this.kind],
                        detail: this.detail,
                        documentation: this.documentation,
                        sortText: this.sortText,
                        filterText: this.filterText,
                        preselect: this.preselect,
                        insertText: this.insertText,
                        textEdit: this.textEdit
                    }
                }
            };
            Me = (0, y.g)([P], Me);
            let De = class {
                constructor(e = [], t = !1) {
                    this.items = e, this.isIncomplete = t
                }
            };
            De = (0, y.g)([P], De);
            let Pe = class {
                constructor(e, t, n) {
                    this.insertText = e, this.range = t, this.command = n
                }
            };
            Pe = (0, y.g)([P], Pe);
            let Ue = class {
                constructor(e) {
                    this.commands = void 0, this.suppressSuggestions = void 0, this.items = e
                }
            };
            var Fe, Be, $e, ze, qe, We, je, Ve, He, Ke;

            function Ze(e, t) {
                return `${A.kP.toKey(e)}.${t}`
            }
            Ue = (0, y.g)([P], Ue),
                function(e) {
                    e[e.Unknown = 0] = "Unknown", e[e.Word = 1] = "Word", e[e.Line = 2] = "Line", e[e.Suggest = 3] = "Suggest"
                }(Fe || (Fe = {})),
                function(e) {
                    e[e.Active = -1] = "Active", e[e.Beside = -2] = "Beside", e[e.One = 1] = "One", e[e.Two = 2] = "Two", e[e.Three = 3] = "Three", e[e.Four = 4] = "Four", e[e.Five = 5] = "Five", e[e.Six = 6] = "Six", e[e.Seven = 7] = "Seven", e[e.Eight = 8] = "Eight", e[e.Nine = 9] = "Nine"
                }(Be || (Be = {})),
                function(e) {
                    e[e.Left = 1] = "Left", e[e.Right = 2] = "Right"
                }($e || ($e = {})),
                function(e) {
                    e[e.Off = 0] = "Off", e[e.On = 1] = "On", e[e.Relative = 2] = "Relative", e[e.Interval = 3] = "Interval"
                }(ze || (ze = {})),
                function(e) {
                    e[e.Manual = 1] = "Manual", e[e.AfterDelay = 2] = "AfterDelay", e[e.FocusOut = 3] = "FocusOut"
                }(qe || (qe = {})),
                function(e) {
                    e[e.Default = 0] = "Default", e[e.InCenter = 1] = "InCenter", e[e.InCenterIfOutsideViewport = 2] = "InCenterIfOutsideViewport", e[e.AtTop = 3] = "AtTop"
                }(We || (We = {})),
                function(e) {
                    e[e.Keyboard = 1] = "Keyboard", e[e.Mouse = 2] = "Mouse", e[e.Command = 3] = "Command"
                }(je || (je = {})),
                function(e) {
                    e[e.Undo = 1] = "Undo", e[e.Redo = 2] = "Redo"
                }(Ve || (Ve = {})),
                function(e) {
                    e[e.OpenOpen = 0] = "OpenOpen", e[e.ClosedClosed = 1] = "ClosedClosed", e[e.OpenClosed = 2] = "OpenClosed", e[e.ClosedOpen = 3] = "ClosedOpen"
                }(He || (He = {})),
                function(e) {
                    e.fromValue = function(t) {
                        switch (t) {
                            case "keyboard":
                                return e.Keyboard;
                            case "mouse":
                                return e.Mouse;
                            case "api":
                                return e.Command
                        }
                    }
                }(je || (je = {})),
                function(e) {
                    e[e.Other = 0] = "Other", e[e.Comment = 1] = "Comment", e[e.String = 2] = "String", e[e.RegEx = 3] = "RegEx"
                }(Ke || (Ke = {})),
                function(e) {
                    e.toString = function(t) {
                        switch (t) {
                            case e.Other:
                                return "other";
                            case e.Comment:
                                return "comment";
                            case e.String:
                                return "string";
                            case e.RegEx:
                                return "regex"
                        }
                        return "other"
                    }
                }(Ke || (Ke = {}));
            let Ge = class {
                constructor(e, t) {
                    if (t && !L.ov.isUri(t)) throw (0, k.b1)("target");
                    if (!B.isRange(e) || e.isEmpty) throw (0, k.b1)("range");
                    this.range = e, this.target = t
                }
            };
            Ge = (0, y.g)([P], Ge);
            let Je = class {
                constructor(e, t, n, r) {
                    this.red = e, this.green = t, this.blue = n, this.alpha = r
                }
            };
            Je = (0, y.g)([P], Je);
            let Ye = class {
                constructor(e, t) {
                    if (t && !(t instanceof Je)) throw (0, k.b1)("color");
                    if (!B.isRange(e) || e.isEmpty) throw (0, k.b1)("range");
                    this.range = e, this.color = t
                }
            };
            Ye = (0, y.g)([P], Ye);
            let Qe = class {
                constructor(e) {
                    if (!e || "string" != typeof e) throw (0, k.b1)("label");
                    this.label = e
                }
            };
            var Xe, et, tt, nt, rt, it;
            Qe = (0, y.g)([P], Qe),
                function(e) {
                    e[e.Error = 0] = "Error", e[e.Warning = 1] = "Warning", e[e.Information = 2] = "Information"
                }(Xe || (Xe = {})),
                function(e) {
                    e[e.Unknown = 0] = "Unknown", e[e.Shutdown = 1] = "Shutdown", e[e.Process = 2] = "Process", e[e.User = 3] = "User", e[e.Extension = 4] = "Extension"
                }(et || (et = {})),
                function(e) {
                    e[e.Low = 0] = "Low", e[e.Medium = 1] = "Medium", e[e.High = 2] = "High"
                }(tt || (tt = {}));
            class st {
                constructor(e, t, n) {
                    if (this.startIndex = e, this.length = t, this.tooltip = n, "number" != typeof e || e < 0) throw (0, k.b1)("startIndex");
                    if ("number" != typeof t || t < 1) throw (0, k.b1)("length");
                    if (void 0 !== n && "string" != typeof n) throw (0, k.b1)("tooltip")
                }
            }
            class ot {
                constructor(e) {
                    this.uri = e
                }
            }
            class at {
                constructor(e) {
                    this.terminalCommand = e
                }
            }! function(e) {
                e[e.Panel = 1] = "Panel", e[e.Editor = 2] = "Editor"
            }(nt || (nt = {}));
            class ct {
                constructor(e) {
                    if (this.options = e, "object" != typeof e) throw (0, k.b1)("options")
                }
            }! function(e) {
                e[e.Always = 1] = "Always", e[e.Silent = 2] = "Silent", e[e.Never = 3] = "Never"
            }(rt || (rt = {})),
            function(e) {
                e[e.Shared = 1] = "Shared", e[e.Dedicated = 2] = "Dedicated", e[e.New = 3] = "New"
            }(it || (it = {}));
            let lt = class {
                static {
                    g = this
                }
                static {
                    this.Clean = new g("clean", "Clean")
                }
                static {
                    this.Build = new g("build", "Build")
                }
                static {
                    this.Rebuild = new g("rebuild", "Rebuild")
                }
                static {
                    this.Test = new g("test", "Test")
                }
                static from(e) {
                    switch (e) {
                        case "clean":
                            return g.Clean;
                        case "build":
                            return g.Build;
                        case "rebuild":
                            return g.Rebuild;
                        case "test":
                            return g.Test;
                        default:
                            return
                    }
                }
                constructor(e, t) {
                    if (this.label = t, "string" != typeof e) throw (0, k.b1)("name");
                    if ("string" != typeof t) throw (0, k.b1)("name");
                    this._id = e
                }
                get id() {
                    return this._id
                }
            };

            function ut(e) {
                let t = "";
                for (let n = 0; n < e.length; n++) t += e[n].replace(/,/g, ",,") + ",";
                return t
            }
            lt = g = (0, y.g)([P], lt);
            let ht = class {
                constructor(e, t, n) {
                    if ("string" != typeof e) throw (0, k.b1)("process");
                    this._args = [], this._process = e, void 0 !== t && (Array.isArray(t) ? (this._args = t, this._options = n) : this._options = t)
                }
                get process() {
                    return this._process
                }
                set process(e) {
                    if ("string" != typeof e) throw (0, k.b1)("process");
                    this._process = e
                }
                get args() {
                    return this._args
                }
                set args(e) {
                    Array.isArray(e) || (e = []), this._args = e
                }
                get options() {
                    return this._options
                }
                set options(e) {
                    this._options = e
                }
                computeId() {
                    const e = [];
                    if (e.push("process"), void 0 !== this._process && e.push(this._process), this._args && this._args.length > 0)
                        for (const t of this._args) e.push(t);
                    return ut(e)
                }
            };
            ht = (0, y.g)([P], ht);
            let dt = class {
                constructor(e, t, n) {
                    if (this._args = [], Array.isArray(t)) {
                        if (!e) throw (0, k.b1)("command can't be undefined or null");
                        if ("string" != typeof e && "string" != typeof e.value) throw (0, k.b1)("command");
                        this._command = e, this._args = t, this._options = n
                    } else {
                        if ("string" != typeof e) throw (0, k.b1)("commandLine");
                        this._commandLine = e, this._options = t
                    }
                }
                get commandLine() {
                    return this._commandLine
                }
                set commandLine(e) {
                    if ("string" != typeof e) throw (0, k.b1)("commandLine");
                    this._commandLine = e
                }
                get command() {
                    return this._command ? this._command : ""
                }
                set command(e) {
                    if ("string" != typeof e && "string" != typeof e.value) throw (0, k.b1)("command");
                    this._command = e
                }
                get args() {
                    return this._args
                }
                set args(e) {
                    this._args = e || []
                }
                get options() {
                    return this._options
                }
                set options(e) {
                    this._options = e
                }
                computeId() {
                    const e = [];
                    if (e.push("shell"), void 0 !== this._commandLine && e.push(this._commandLine), void 0 !== this._command && e.push("string" == typeof this._command ? this._command : this._command.value), this._args && this._args.length > 0)
                        for (const t of this._args) e.push("string" == typeof t ? t : t.value);
                    return ut(e)
                }
            };
            var ft, pt;
            dt = (0, y.g)([P], dt),
                function(e) {
                    e[e.Escape = 1] = "Escape", e[e.Strong = 2] = "Strong", e[e.Weak = 3] = "Weak"
                }(ft || (ft = {})),
                function(e) {
                    e[e.Global = 1] = "Global", e[e.Workspace = 2] = "Workspace"
                }(pt || (pt = {}));
            class gt {
                constructor(e) {
                    this._callback = e
                }
                computeId() {
                    return "customExecution" + (0, R.R)()
                }
                set callback(e) {
                    this._callback = e
                }
                get callback() {
                    return this._callback
                }
            }
            let mt = class {
                static {
                    m = this
                }
                static {
                    this.ExtensionCallbackType = "customExecution"
                }
                static {
                    this.ProcessType = "process"
                }
                static {
                    this.ShellType = "shell"
                }
                static {
                    this.EmptyType = "$empty"
                }
                constructor(e, t, n, r, i, s) {
                    let o;
                    this.__deprecated = !1, this._definition = this.definition = e, "string" == typeof t ? (this._name = this.name = t, this._source = this.source = n, this.execution = r, o = i, this.__deprecated = !0) : (t === pt.Global || pt.Workspace, this.target = t, this._name = this.name = n, this._source = this.source = r, this.execution = i, o = s), "string" == typeof o ? (this._problemMatchers = [o], this._hasDefinedMatchers = !0) : Array.isArray(o) ? (this._problemMatchers = o, this._hasDefinedMatchers = !0) : (this._problemMatchers = [], this._hasDefinedMatchers = !1), this._isBackground = !1, this._presentationOptions = Object.create(null), this._runOptions = Object.create(null)
                }
                get _id() {
                    return this.__id
                }
                set _id(e) {
                    this.__id = e
                }
                get _deprecated() {
                    return this.__deprecated
                }
                clear() {
                    void 0 !== this.__id && (this.__id = void 0, this._scope = void 0, this.computeDefinitionBasedOnExecution())
                }
                computeDefinitionBasedOnExecution() {
                    this._execution instanceof ht ? this._definition = {
                        type: m.ProcessType,
                        id: this._execution.computeId()
                    } : this._execution instanceof dt ? this._definition = {
                        type: m.ShellType,
                        id: this._execution.computeId()
                    } : this._execution instanceof gt ? this._definition = {
                        type: m.ExtensionCallbackType,
                        id: this._execution.computeId()
                    } : this._definition = {
                        type: m.EmptyType,
                        id: (0, R.R)()
                    }
                }
                get definition() {
                    return this._definition
                }
                set definition(e) {
                    if (null == e) throw (0, k.b1)("Kind can't be undefined or null");
                    this.clear(), this._definition = e
                }
                get scope() {
                    return this._scope
                }
                set target(e) {
                    this.clear(), this._scope = e
                }
                get name() {
                    return this._name
                }
                set name(e) {
                    if ("string" != typeof e) throw (0, k.b1)("name");
                    this.clear(), this._name = e
                }
                get execution() {
                    return this._execution
                }
                set execution(e) {
                    null === e && (e = void 0), this.clear(), this._execution = e;
                    const t = this._definition.type;
                    m.EmptyType !== t && m.ProcessType !== t && m.ShellType !== t && m.ExtensionCallbackType !== t || this.computeDefinitionBasedOnExecution()
                }
                get problemMatchers() {
                    return this._problemMatchers
                }
                set problemMatchers(e) {
                    if (!Array.isArray(e)) return this.clear(), this._problemMatchers = [], void(this._hasDefinedMatchers = !1);
                    this.clear(), this._problemMatchers = e, this._hasDefinedMatchers = !0
                }
                get hasDefinedMatchers() {
                    return this._hasDefinedMatchers
                }
                get isBackground() {
                    return this._isBackground
                }
                set isBackground(e) {
                    !0 !== e && !1 !== e && (e = !1), this.clear(), this._isBackground = e
                }
                get source() {
                    return this._source
                }
                set source(e) {
                    if ("string" != typeof e || 0 === e.length) throw (0, k.b1)("source must be a string of length > 0");
                    this.clear(), this._source = e
                }
                get group() {
                    return this._group
                }
                set group(e) {
                    null === e && (e = void 0), this.clear(), this._group = e
                }
                get detail() {
                    return this._detail
                }
                set detail(e) {
                    null === e && (e = void 0), this._detail = e
                }
                get presentationOptions() {
                    return this._presentationOptions
                }
                set presentationOptions(e) {
                    null == e && (e = Object.create(null)), this.clear(), this._presentationOptions = e
                }
                get runOptions() {
                    return this._runOptions
                }
                set runOptions(e) {
                    null == e && (e = Object.create(null)), this.clear(), this._runOptions = e
                }
            };
            var bt, _t;
            mt = m = (0, y.g)([P], mt),
                function(e) {
                    e[e.SourceControl = 1] = "SourceControl", e[e.Window = 10] = "Window", e[e.Notification = 15] = "Notification"
                }(bt || (bt = {})),
                function(e) {
                    e.isViewBadge = function(e) {
                        const t = e;
                        return (0, T.hj)(t.value) ? !(t.tooltip && !(0, T.HD)(t.tooltip) && (D.log("INVALID view badge, invalid tooltip", t.tooltip), 1)) : (D.log("INVALID view badge, invalid value", t.value), !1)
                    }
                }(_t || (_t = {}));
            let vt = b = class {
                static isTreeItem(e, t) {
                    const n = e;
                    if (void 0 !== n.checkboxState) {
                        const e = (0, T.hj)(n.checkboxState) ? n.checkboxState : (0, T.Kn)(n.checkboxState) && (0, T.hj)(n.checkboxState.state) ? n.checkboxState.state : void 0,
                            t = !(0, T.hj)(n.checkboxState) && (0, T.Kn)(n.checkboxState) ? n.checkboxState.tooltip : void 0;
                        if (void 0 === e || e !== yt.Checked && e !== yt.Unchecked || void 0 !== t && !(0, T.HD)(t)) return D.log("INVALID tree item, invalid checkboxState", n.checkboxState), !1
                    }
                    if (e instanceof b) return !0;
                    if (void 0 !== n.label && !(0, T.HD)(n.label) && !n.label ? .label) return D.log("INVALID tree item, invalid label", n.label), !1;
                    if (void 0 !== n.id && !(0, T.HD)(n.id)) return D.log("INVALID tree item, invalid id", n.id), !1;
                    if (!(void 0 === n.iconPath || (0, T.HD)(n.iconPath) || L.ov.isUri(n.iconPath) || n.iconPath && (0, T.HD)(n.iconPath.id))) {
                        const e = n.iconPath;
                        if (!e || !(0, T.HD)(e.light) && !L.ov.isUri(e.light) && !(0, T.HD)(e.dark) && !L.ov.isUri(e.dark)) return D.log("INVALID tree item, invalid iconPath", n.iconPath), !1
                    }
                    return void 0 === n.description || (0, T.HD)(n.description) || "boolean" == typeof n.description ? void 0 === n.resourceUri || L.ov.isUri(n.resourceUri) ? void 0 === n.tooltip || (0, T.HD)(n.tooltip) || n.tooltip instanceof ke ? void 0 === n.command || n.command.command ? void 0 !== n.collapsibleState && n.collapsibleState < wt.None && n.collapsibleState > wt.Expanded ? (D.log("INVALID tree item, invalid collapsibleState", n.collapsibleState), !1) : void 0 === n.contextValue || (0, T.HD)(n.contextValue) ? !(void 0 !== n.accessibilityInformation && !n.accessibilityInformation ? .label && (D.log("INVALID tree item, invalid accessibilityInformation", n.accessibilityInformation), 1)) : (D.log("INVALID tree item, invalid contextValue", n.contextValue), !1) : (D.log("INVALID tree item, invalid command", n.command), !1) : (D.log("INVALID tree item, invalid tooltip", n.tooltip), !1) : (D.log("INVALID tree item, invalid resourceUri", n.resourceUri), !1) : (D.log("INVALID tree item, invalid description", n.description), !1)
                }
                constructor(e, t = wt.None) {
                    this.collapsibleState = t, L.ov.isUri(e) ? this.resourceUri = e : this.label = e
                }
            };
            var wt, yt;
            vt = b = (0, y.g)([P], vt),
                function(e) {
                    e[e.None = 0] = "None", e[e.Collapsed = 1] = "Collapsed", e[e.Expanded = 2] = "Expanded"
                }(wt || (wt = {})),
                function(e) {
                    e[e.Unchecked = 0] = "Unchecked", e[e.Checked = 1] = "Checked"
                }(yt || (yt = {}));
            let xt = class {
                async asString() {
                    return "string" == typeof this.value ? this.value : JSON.stringify(this.value)
                }
                asFile() {}
                constructor(e) {
                    this.value = e
                }
            };
            xt = (0, y.g)([P], xt);
            class kt extends xt {}
            class Ct extends kt {#
                n;
                constructor(e) {
                    super(""), this.#n = e
                }
                asFile() {
                    return this.#n
                }
            }
            class It {
                constructor(e, t, n, r) {
                    this.name = e, this.uri = t, this._itemId = n, this._getData = r
                }
                data() {
                    return this._getData()
                }
            }
            let St = class {#
                r = new Map;
                constructor(e) {
                    for (const [t, n] of e ? ? []) {
                        const e = this.#r.get(this.#i(t));
                        e ? e.push(n) : this.#r.set(this.#i(t), [n])
                    }
                }
                get(e) {
                    return this.#r.get(this.#i(e)) ? .[0]
                }
                set(e, t) {
                    this.#r.set(this.#i(e), [t])
                }
                forEach(e, t) {
                    for (const [n, r] of this.#r)
                        for (const i of r) e.call(t, i, n, this)
                }*[Symbol.iterator]() {
                    for (const [e, t] of this.#r)
                        for (const n of t) yield [e, n]
                }#
                i(e) {
                    return e.toLowerCase()
                }
            };
            St = (0, y.g)([P], St);
            let Et = class {
                constructor(e, t, n) {
                    this.insertText = e, this.title = t, this.kind = n
                }
            };
            var Tt;
            Et = (0, y.g)([P], Et),
                function(e) {
                    e[e.Automatic = 0] = "Automatic", e[e.PasteAs = 1] = "PasteAs"
                }(Tt || (Tt = {}));
            class Lt {
                static {
                    this.sep = "."
                }
                constructor(e) {
                    this.value = e
                }
                append(...e) {
                    return new Lt((this.value ? [this.value, ...e] : e).join(Lt.sep))
                }
                intersects(e) {
                    return this.contains(e) || e.contains(this)
                }
                contains(e) {
                    return this.value === e.value || e.value.startsWith(this.value + Lt.sep)
                }
            }
            Lt.Empty = new Lt("");
            class Rt {
                constructor(e, t, n) {
                    this.title = t, this.insertText = e, this.kind = n
                }
            }
            let At = class {
                constructor(e, t) {
                    this.id = e, this.color = t
                }
                static isThemeIcon(e) {
                    return "string" == typeof e.id || (D.log("INVALID ThemeIcon, invalid id", e.id), !1)
                }
            };
            At = (0, y.g)([P], At), At.File = new At("file"), At.Folder = new At("folder");
            let Nt = class {
                constructor(e) {
                    this.id = e
                }
            };
            var Ot;
            Nt = (0, y.g)([P], Nt),
                function(e) {
                    e[e.Global = 1] = "Global", e[e.Workspace = 2] = "Workspace", e[e.WorkspaceFolder = 3] = "WorkspaceFolder"
                }(Ot || (Ot = {}));
            let Mt = class {
                get base() {
                    return this._base
                }
                set base(e) {
                    this._base = e, this._baseUri = L.ov.file(e)
                }
                get baseUri() {
                    return this._baseUri
                }
                set baseUri(e) {
                    this._baseUri = e, this._base = e.fsPath
                }
                constructor(e, t) {
                    if ("string" != typeof e && (!e || !L.ov.isUri(e) && !L.ov.isUri(e.uri))) throw (0, k.b1)("base");
                    if ("string" != typeof t) throw (0, k.b1)("pattern");
                    "string" == typeof e ? this.baseUri = L.ov.file(e) : L.ov.isUri(e) ? this.baseUri = e : this.baseUri = e.uri, this.pattern = t
                }
                toJSON() {
                    return {
                        pattern: this.pattern,
                        base: this.base,
                        baseUri: this.baseUri.toJSON()
                    }
                }
            };
            Mt = (0, y.g)([P], Mt);
            const Dt = new WeakMap;

            function Pt(e, t) {
                Dt.set(e, t)
            }
            let Ut = class {
                constructor(e, t, n, r, i) {
                    this.enabled = "boolean" != typeof e || e, "string" == typeof t && (this.condition = t), "string" == typeof n && (this.hitCondition = n), "string" == typeof r && (this.logMessage = r), "string" == typeof i && (this.mode = i)
                }
                get id() {
                    return this._id || (this._id = Dt.get(this) ? ? (0, R.R)()), this._id
                }
            };
            Ut = (0, y.g)([P], Ut);
            let Ft = class extends Ut {
                constructor(e, t, n, r, i, s) {
                    if (super(t, n, r, i, s), null === e) throw (0, k.b1)("location");
                    this.location = e
                }
            };
            Ft = (0, y.g)([P], Ft);
            let Bt = class extends Ut {
                constructor(e, t, n, r, i, s) {
                    super(t, n, r, i, s), this.functionName = e
                }
            };
            Bt = (0, y.g)([P], Bt);
            let $t = class extends Ut {
                constructor(e, t, n, r, i, s, o, a) {
                    if (super(r, i, s, o, a), !t) throw (0, k.b1)("dataId");
                    this.label = e, this.dataId = t, this.canPersist = n
                }
            };
            $t = (0, y.g)([P], $t);
            let zt = class {
                constructor(e, t, n) {
                    this.command = e, this.args = t || [], this.options = n
                }
            };
            zt = (0, y.g)([P], zt);
            let qt = class {
                constructor(e, t) {
                    this.port = e, this.host = t
                }
            };
            qt = (0, y.g)([P], qt);
            let Wt = class {
                constructor(e) {
                    this.path = e
                }
            };
            Wt = (0, y.g)([P], Wt);
            let jt = class {
                constructor(e) {
                    this.implementation = e
                }
            };
            jt = (0, y.g)([P], jt);
            class Vt {
                constructor(e, t, n) {
                    this.session = e, this.threadId = t, this.frameId = n
                }
            }
            class Ht {
                constructor(e, t) {
                    this.session = e, this.threadId = t
                }
            }
            let Kt = class {
                constructor(e, t) {
                    this.range = e, this.expression = t
                }
            };
            var Zt;
            Kt = (0, y.g)([P], Kt),
                function(e) {
                    e[e.Invoke = 0] = "Invoke", e[e.Automatic = 1] = "Automatic"
                }(Zt || (Zt = {}));
            let Gt = class {
                constructor(e, t) {
                    this.range = e, this.text = t
                }
            };
            Gt = (0, y.g)([P], Gt);
            let Jt = class {
                constructor(e, t, n = !0) {
                    this.range = e, this.variableName = t, this.caseSensitiveLookup = n
                }
            };
            Jt = (0, y.g)([P], Jt);
            let Yt = class {
                constructor(e, t) {
                    this.range = e, this.expression = t
                }
            };
            Yt = (0, y.g)([P], Yt);
            let Qt = class {
                constructor(e, t) {
                    this.frameId = e, this.stoppedLocation = t
                }
            };
            var Xt, en, tn;
            Qt = (0, y.g)([P], Qt),
                function(e) {
                    e[e.AIGenerated = 1] = "AIGenerated"
                }(Xt || (Xt = {})),
                function(e) {
                    e[e.Invoke = 0] = "Invoke", e[e.Automatic = 1] = "Automatic"
                }(en || (en = {}));
            class nn {
                constructor(e, t) {
                    this.newSymbolName = e, this.tags = t
                }
            }! function(e) {
                e[e.Changed = 1] = "Changed", e[e.Created = 2] = "Created", e[e.Deleted = 3] = "Deleted"
            }(tn || (tn = {}));
            let rn = _ = class extends Error {
                static FileExists(e) {
                    return new _(e, N.bH.FileExists, _.FileExists)
                }
                static FileNotFound(e) {
                    return new _(e, N.bH.FileNotFound, _.FileNotFound)
                }
                static FileNotADirectory(e) {
                    return new _(e, N.bH.FileNotADirectory, _.FileNotADirectory)
                }
                static FileIsADirectory(e) {
                    return new _(e, N.bH.FileIsADirectory, _.FileIsADirectory)
                }
                static NoPermissions(e) {
                    return new _(e, N.bH.NoPermissions, _.NoPermissions)
                }
                static Unavailable(e) {
                    return new _(e, N.bH.Unavailable, _.Unavailable)
                }
                constructor(e, t = N.bH.Unknown, n) {
                    super(L.ov.isUri(e) ? e.toString(!0) : e), this.code = n ? .name ? ? "Unknown", (0, N.q5)(this, t), Object.setPrototypeOf(this, _.prototype), "function" == typeof Error.captureStackTrace && "function" == typeof n && Error.captureStackTrace(this, n)
                }
            };
            rn = _ = (0, y.g)([P], rn);
            let sn = class {
                constructor(e, t, n) {
                    this.start = e, this.end = t, this.kind = n
                }
            };
            var on, an, cn, ln, un, hn, dn;
            sn = (0, y.g)([P], sn),
                function(e) {
                    e[e.Comment = 1] = "Comment", e[e.Imports = 2] = "Imports", e[e.Region = 3] = "Region"
                }(on || (on = {})),
                function(e) {
                    e[e.Collapsed = 0] = "Collapsed", e[e.Expanded = 1] = "Expanded"
                }(an || (an = {})),
                function(e) {
                    e[e.Editing = 0] = "Editing", e[e.Preview = 1] = "Preview"
                }(cn || (cn = {})),
                function(e) {
                    e[e.Published = 0] = "Published", e[e.Draft = 1] = "Draft"
                }(ln || (ln = {})),
                function(e) {
                    e[e.Unresolved = 0] = "Unresolved", e[e.Resolved = 1] = "Resolved"
                }(un || (un = {})),
                function(e) {
                    e[e.Current = 0] = "Current", e[e.Outdated = 1] = "Outdated"
                }(hn || (hn = {}));
            class fn {
                constructor(e, t = []) {
                    this.tokenTypes = e, this.tokenModifiers = t
                }
            }
            class pn {
                constructor(e) {
                    if (this._prevLine = 0, this._prevChar = 0, this._dataIsSortedAndDeltaEncoded = !0, this._data = [], this._dataLen = 0, this._tokenTypeStrToInt = new Map, this._tokenModifierStrToInt = new Map, this._hasLegend = !1, e) {
                        this._hasLegend = !0;
                        for (let t = 0, n = e.tokenTypes.length; t < n; t++) this._tokenTypeStrToInt.set(e.tokenTypes[t], t);
                        for (let t = 0, n = e.tokenModifiers.length; t < n; t++) this._tokenModifierStrToInt.set(e.tokenModifiers[t], t)
                    }
                }
                push(e, t, n, r, i) {
                    if ("number" == typeof e && "number" == typeof t && "number" == typeof n && "number" == typeof r && ("number" == typeof i || void 0 === i)) return void 0 === i && (i = 0), this._pushEncoded(e, t, n, r, i);
                    if (B.isRange(e) && "string" == typeof t && (void 0 === (s = n) || (0, T.GI)(s))) return this._push(e, t, n);
                    var s;
                    throw (0, k.b1)()
                }
                _push(e, t, n) {
                    if (!this._hasLegend) throw new Error("Legend must be provided in constructor");
                    if (e.start.line !== e.end.line) throw new Error("`range` cannot span multiple lines");
                    if (!this._tokenTypeStrToInt.has(t)) throw new Error("`tokenType` is not in the provided legend");
                    const r = e.start.line,
                        i = e.start.character,
                        s = e.end.character - e.start.character,
                        o = this._tokenTypeStrToInt.get(t);
                    let a = 0;
                    if (n)
                        for (const e of n) {
                            if (!this._tokenModifierStrToInt.has(e)) throw new Error("`tokenModifier` is not in the provided legend");
                            a |= 1 << this._tokenModifierStrToInt.get(e) >>> 0
                        }
                    this._pushEncoded(r, i, s, o, a)
                }
                _pushEncoded(e, t, n, r, i) {
                    if (this._dataIsSortedAndDeltaEncoded && (e < this._prevLine || e === this._prevLine && t < this._prevChar)) {
                        this._dataIsSortedAndDeltaEncoded = !1;
                        const e = this._data.length / 5 | 0;
                        let t = 0,
                            n = 0;
                        for (let r = 0; r < e; r++) {
                            let e = this._data[5 * r],
                                i = this._data[5 * r + 1];
                            0 === e ? (e = t, i += n) : e += t, this._data[5 * r] = e, this._data[5 * r + 1] = i, t = e, n = i
                        }
                    }
                    let s = e,
                        o = t;
                    this._dataIsSortedAndDeltaEncoded && this._dataLen > 0 && (s -= this._prevLine, 0 === s && (o -= this._prevChar)), this._data[this._dataLen++] = s, this._data[this._dataLen++] = o, this._data[this._dataLen++] = n, this._data[this._dataLen++] = r, this._data[this._dataLen++] = i, this._prevLine = e, this._prevChar = t
                }
                static _sortAndDeltaEncode(e) {
                    const t = [],
                        n = e.length / 5 | 0;
                    for (let e = 0; e < n; e++) t[e] = e;
                    t.sort(((t, n) => {
                        const r = e[5 * t],
                            i = e[5 * n];
                        return r === i ? e[5 * t + 1] - e[5 * n + 1] : r - i
                    }));
                    const r = new Uint32Array(e.length);
                    let i = 0,
                        s = 0;
                    for (let o = 0; o < n; o++) {
                        const n = 5 * t[o],
                            a = e[n + 0],
                            c = e[n + 1],
                            l = e[n + 2],
                            u = e[n + 3],
                            h = e[n + 4],
                            d = a - i,
                            f = 0 === d ? c - s : c,
                            p = 5 * o;
                        r[p + 0] = d, r[p + 1] = f, r[p + 2] = l, r[p + 3] = u, r[p + 4] = h, i = a, s = c
                    }
                    return r
                }
                build(e) {
                    return this._dataIsSortedAndDeltaEncoded ? new gn(new Uint32Array(this._data), e) : new gn(pn._sortAndDeltaEncode(this._data), e)
                }
            }
            class gn {
                constructor(e, t) {
                    this.resultId = t, this.data = e
                }
            }
            class mn {
                constructor(e, t, n) {
                    this.start = e, this.deleteCount = t, this.data = n
                }
            }
            class bn {
                constructor(e, t) {
                    this.resultId = t, this.edits = e
                }
            }! function(e) {
                e[e.Separate = 0] = "Separate", e[e.MergeWithParent = 1] = "MergeWithParent"
            }(dn || (dn = {}));
            class _n {
                constructor(e) {
                    this.name = e
                }
            }
            let vn = class {
                static {
                    this.Back = {
                        iconPath: new At("arrow-left")
                    }
                }
                constructor() {}
            };
            var wn, yn, xn;
            vn = (0, y.g)([P], vn),
                function(e) {
                    e[e.Separator = -1] = "Separator", e[e.Default = 0] = "Default"
                }(wn || (wn = {})),
                function(e) {
                    e[e.Info = 1] = "Info", e[e.Warning = 2] = "Warning", e[e.Error = 3] = "Error"
                }(yn || (yn = {})),
                function(e) {
                    e[e.UI = 1] = "UI", e[e.Workspace = 2] = "Workspace"
                }(xn || (xn = {}));
            class kn {
                static validate(e) {
                    if ("string" == typeof e.badge) {
                        let t = (0, E.vH)(e.badge, 0);
                        if (t < e.badge.length && (t += (0, E.vH)(e.badge, t)), e.badge.length > t) throw new Error("The 'badge'-property must be undefined or a short character")
                    } else if (e.badge && !At.isThemeIcon(e.badge)) throw new Error("The 'badge'-property is not a valid ThemeIcon");
                    if (!e.color && !e.badge && !e.tooltip) throw new Error("The decoration is empty");
                    return !0
                }
                constructor(e, t, n) {
                    this.badge = e, this.tooltip = t, this.color = n
                }
            }
            let Cn = class {
                constructor(e) {
                    this.kind = e
                }
            };
            var In, Sn, En, Tn, Ln, Rn, An, Nn;
            Cn = (0, y.g)([P], Cn),
                function(e) {
                    e[e.Light = 1] = "Light", e[e.Dark = 2] = "Dark", e[e.HighContrast = 3] = "HighContrast", e[e.HighContrastLight = 4] = "HighContrastLight"
                }(In || (In = {}));
            class On {
                static isNotebookRange(e) {
                    return e instanceof On || !!e && "number" == typeof e.start && "number" == typeof e.end
                }
                get start() {
                    return this._start
                }
                get end() {
                    return this._end
                }
                get isEmpty() {
                    return this._start === this._end
                }
                constructor(e, t) {
                    if (e < 0) throw (0, k.b1)("start must be positive");
                    if (t < 0) throw (0, k.b1)("end must be positive");
                    e <= t ? (this._start = e, this._end = t) : (this._start = t, this._end = e)
                }
                with(e) {
                    let t = this._start,
                        n = this._end;
                    return void 0 !== e.start && (t = e.start), void 0 !== e.end && (n = e.end), t === this._start && n === this._end ? this : new On(t, n)
                }
            }
            class Mn {
                static validate(e) {
                    if ("number" != typeof e.kind) throw new Error("NotebookCellData MUST have 'kind' property");
                    if ("string" != typeof e.value) throw new Error("NotebookCellData MUST have 'value' property");
                    if ("string" != typeof e.languageId) throw new Error("NotebookCellData MUST have 'languageId' property")
                }
                static isNotebookCellDataArray(e) {
                    return Array.isArray(e) && e.every((e => Mn.isNotebookCellData(e)))
                }
                static isNotebookCellData(e) {
                    return !0
                }
                constructor(e, t, n, r, i, s, o) {
                    this.kind = e, this.value = t, this.languageId = n, this.mime = r, this.outputs = i ? ? [], this.metadata = s, this.executionSummary = o, Mn.validate(this)
                }
            }
            class Dn {
                constructor(e) {
                    this.cells = e
                }
            }
            class Pn {
                static isNotebookCellOutputItem(e) {
                    return e instanceof Pn || !!e && "string" == typeof e.mime && e.data instanceof Uint8Array
                }
                static error(e) {
                    const t = {
                        name: e.name,
                        message: e.message,
                        stack: e.stack
                    };
                    return Pn.json(t, "application/vnd.code.notebook.error")
                }
                static stdout(e) {
                    return Pn.text(e, "application/vnd.code.notebook.stdout")
                }
                static stderr(e) {
                    return Pn.text(e, "application/vnd.code.notebook.stderr")
                }
                static bytes(e, t = "application/octet-stream") {
                    return new Pn(e, t)
                }
                static# s = new TextEncoder;
                static text(e, t = S.vW.text) {
                    const n = Pn.#s.encode(String(e));
                    return new Pn(n, t)
                }
                static json(e, t = "text/x-json") {
                    const n = JSON.stringify(e, void 0, "\t");
                    return Pn.text(n, t)
                }
                constructor(e, t) {
                    this.data = e, this.mime = t;
                    const n = (0, S.PP)(t, !0);
                    if (!n) throw new Error(`INVALID mime type: ${t}. Must be in the format "type/subtype[;optionalparameter]"`);
                    this.mime = n
                }
            }
            class Un {
                static isNotebookCellOutput(e) {
                    return e instanceof Un || !(!e || "object" != typeof e) && "string" == typeof e.id && Array.isArray(e.items)
                }
                static ensureUniqueMimeTypes(e, t = !1) {
                    const n = new Set,
                        r = new Set;
                    for (let i = 0; i < e.length; i++) {
                        const s = e[i],
                            o = (0, S.PP)(s.mime);
                        n.has(o) && !(0, M.OT)(o) ? (r.add(i), t && D.warn(`DUPLICATED mime type '${s.mime}' will be dropped`)) : n.add(o)
                    }
                    return 0 === r.size ? e : e.filter(((e, t) => !r.has(t)))
                }
                constructor(e, t, n) {
                    this.items = Un.ensureUniqueMimeTypes(e, !0), "string" == typeof t ? (this.id = t, this.metadata = n) : (this.id = (0, R.R)(), this.metadata = t ? ? n)
                }
            }! function(e) {
                e[e.Markup = 1] = "Markup", e[e.Code = 2] = "Code"
            }(Sn || (Sn = {})),
            function(e) {
                e[e.Idle = 1] = "Idle", e[e.Pending = 2] = "Pending", e[e.Executing = 3] = "Executing"
            }(En || (En = {})),
            function(e) {
                e[e.Left = 1] = "Left", e[e.Right = 2] = "Right"
            }(Tn || (Tn = {})),
            function(e) {
                e[e.Default = 0] = "Default", e[e.InCenter = 1] = "InCenter", e[e.InCenterIfOutsideViewport = 2] = "InCenterIfOutsideViewport", e[e.AtTop = 3] = "AtTop"
            }(Ln || (Ln = {}));
            class Fn {
                constructor(e, t) {
                    this.text = e, this.alignment = t
                }
            }! function(e) {
                e[e.Default = 1] = "Default", e[e.Preferred = 2] = "Preferred"
            }(Rn || (Rn = {})),
            function(e) {
                e[e.Default = 1] = "Default", e[e.Preferred = 2] = "Preferred", e[e.Hidden = -1] = "Hidden"
            }(An || (An = {}));
            class Bn {
                constructor(e, t = []) {
                    this.uri = e, this.provides = (0, x._2)(t)
                }
            }
            class $n {
                constructor(e) {
                    this.label = e
                }
            }! function(e) {
                e[e.Named = 1] = "Named", e[e.Indexed = 2] = "Indexed"
            }(Nn || (Nn = {}));
            let zn = class {
                constructor(e, t) {
                    this.label = e, this.timestamp = t
                }
            };
            var qn, Wn, jn, Vn, Hn;
            zn = (0, y.g)([P], zn),
                function(e) {
                    e[e.Production = 1] = "Production", e[e.Development = 2] = "Development", e[e.Test = 3] = "Test"
                }(qn || (qn = {})),
                function(e) {
                    e[e.Node = 1] = "Node", e[e.Webworker = 2] = "Webworker"
                }(Wn || (Wn = {})),
                function(e) {
                    e[e.Other = 0] = "Other", e[e.Comment = 1] = "Comment", e[e.String = 2] = "String", e[e.RegEx = 3] = "RegEx"
                }(jn || (jn = {}));
            class Kn {
                constructor(e, t) {
                    this.ranges = e, this.wordPattern = t
                }
            }
            class Zn {
                constructor(e) {
                    this._autoForwardAction = e
                }
                get autoForwardAction() {
                    return this._autoForwardAction
                }
            }! function(e) {
                e[e.Queued = 1] = "Queued", e[e.Running = 2] = "Running", e[e.Passed = 3] = "Passed", e[e.Failed = 4] = "Failed", e[e.Skipped = 5] = "Skipped", e[e.Errored = 6] = "Errored"
            }(Vn || (Vn = {})),
            function(e) {
                e[e.Run = 1] = "Run", e[e.Debug = 2] = "Debug", e[e.Coverage = 3] = "Coverage"
            }(Hn || (Hn = {}));
            let Gn = class {
                constructor(e = undefined, t = undefined, n = undefined, r = !1, i = !0) {
                    this.include = e, this.exclude = t, this.profile = n, this.continuous = r, this.preserveFocus = i
                }
            };
            Gn = (0, y.g)([P], Gn);
            let Jn = v = class {
                static diff(e, t, n) {
                    const r = new v(e);
                    return r.expectedOutput = t, r.actualOutput = n, r
                }
                constructor(e) {
                    this.message = e
                }
            };
            Jn = v = (0, y.g)([P], Jn);
            let Yn = class {
                constructor(e) {
                    this.id = e
                }
            };
            Yn = (0, y.g)([P], Yn);
            class Qn {
                constructor(e, t) {
                    this.covered = e, this.total = t, Xn(this)
                }
            }

            function Xn(e) {
                if (e) {
                    if (e.covered > e.total) throw new Error(`The total number of covered items (${e.covered}) cannot be greater than the total (${e.total})`);
                    if (e.total < 0) throw new Error(`The number of covered items (${e.total}) cannot be negative`)
                }
            }
            class er {
                static fromDetails(e, t) {
                    const n = new Qn(0, 0),
                        r = new Qn(0, 0),
                        i = new Qn(0, 0);
                    for (const e of t)
                        if ("branches" in e) {
                            n.total += 1, n.covered += e.executed ? 1 : 0;
                            for (const t of e.branches) r.total += 1, r.covered += t.executed ? 1 : 0
                        } else i.total += 1, i.covered += e.executed ? 1 : 0;
                    const s = new er(e, n, r.total > 0 ? r : void 0, i.total > 0 ? i : void 0);
                    return s.detailedCoverage = t, s
                }
                constructor(e, t, n, r, i = []) {
                    this.uri = e, this.statementCoverage = t, this.branchCoverage = n, this.declarationCoverage = r, this.fromTests = i
                }
            }
            class tr {
                get executionCount() {
                    return +this.executed
                }
                set executionCount(e) {
                    this.executed = e
                }
                constructor(e, t, n = []) {
                    this.executed = e, this.location = t, this.branches = n
                }
            }
            class nr {
                get executionCount() {
                    return +this.executed
                }
                set executionCount(e) {
                    this.executed = e
                }
                constructor(e, t, n) {
                    this.executed = e, this.location = t, this.label = n
                }
            }
            class rr {
                get executionCount() {
                    return +this.executed
                }
                set executionCount(e) {
                    this.executed = e
                }
                constructor(e, t, n) {
                    this.name = e, this.executed = t, this.location = n
                }
            }
            var ir, sr, or, ar, cr, lr, ur, hr, dr, fr, pr, gr, mr, br, _r;
            ! function(e) {
                e[e.None = 0] = "None", e[e.Option = 1] = "Option", e[e.Default = 2] = "Default", e[e.Preferred = 3] = "Preferred"
            }(ir || (ir = {})),
            function(e) {
                e[e.Untrusted = 0] = "Untrusted", e[e.Trusted = 1] = "Trusted", e[e.Unspecified = 2] = "Unspecified"
            }(sr || (sr = {})),
            function(e) {
                e[e.Notify = 1] = "Notify", e[e.OpenBrowser = 2] = "OpenBrowser", e[e.OpenPreview = 3] = "OpenPreview", e[e.Silent = 4] = "Silent", e[e.Ignore = 5] = "Ignore", e[e.OpenBrowserOnce = 6] = "OpenBrowserOnce"
            }(or || (or = {}));
            class vr {
                constructor(e, t, n, r, i, s) {
                    this.kind = e, this.name = t, this.detail = n, this.uri = r, this.range = i, this.selectionRange = s
                }
            }
            class wr {
                constructor(e) {
                    this.uri = e
                }
            }
            class yr {
                constructor(e, t) {
                    this.original = e, this.modified = t
                }
            }
            class xr {
                constructor(e, t, n, r) {
                    this.base = e, this.input1 = t, this.input2 = n, this.result = r
                }
            }
            class kr {
                constructor(e, t) {
                    this.uri = e, this.viewType = t
                }
            }
            class Cr {
                constructor(e) {
                    this.viewType = e
                }
            }
            class Ir {
                constructor(e, t) {
                    this.uri = e, this.notebookType = t
                }
            }
            class Sr {
                constructor(e, t, n) {
                    this.original = e, this.modified = t, this.notebookType = n
                }
            }
            class Er {
                constructor() {}
            }
            class Tr {
                constructor(e, t) {
                    this.uri = e, this.inputBoxUri = t
                }
            }
            class Lr {
                constructor() {}
            }
            class Rr {
                constructor(e) {
                    this.textDiffs = e
                }
            }! function(e) {
                e[e.Down = 0] = "Down", e[e.Up = 1] = "Up"
            }(ar || (ar = {})),
            function(e) {
                e[e.Action = 1] = "Action", e[e.Toolbar = 2] = "Toolbar"
            }(cr || (cr = {})),
            function(e) {
                e[e.Short = 1] = "Short", e[e.Medium = 2] = "Medium", e[e.Full = 3] = "Full"
            }(lr || (lr = {}));
            class Ar {
                constructor(e, t, n) {
                    this.id = e, this.label = t, this.values = n
                }
            }! function(e) {
                e[e.Unhelpful = 0] = "Unhelpful", e[e.Helpful = 1] = "Helpful", e[e.Undone = 2] = "Undone", e[e.Accepted = 3] = "Accepted", e[e.Bug = 4] = "Bug"
            }(ur || (ur = {})),
            function(e) {
                e[e.Unhelpful = 0] = "Unhelpful", e[e.Helpful = 1] = "Helpful"
            }(hr || (hr = {}));
            class Nr {
                constructor(e) {
                    if ("string" != typeof e && !0 === e.isTrusted) throw new Error("The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.");
                    this.value = "string" == typeof e ? new ke(e) : e
                }
            }
            class Or {
                constructor(e, t) {
                    if ("string" != typeof e && !0 === e.isTrusted) throw new Error("The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.");
                    this.value = "string" == typeof e ? new ke(e) : e, this.vulnerabilities = t
                }
            }
            class Mr {
                constructor(e, t) {
                    this.participant = e, this.command = t
                }
            }
            class Dr {
                constructor(e, t, n) {
                    this.title = e, this.message = t, this.data = n
                }
            }
            class Pr {
                constructor(e, t) {
                    this.value = e, this.baseUri = t
                }
            }
            class Ur {
                constructor(e, t) {
                    this.value = e, this.title = t
                }
            }
            class Fr {
                constructor(e) {
                    this.value = e
                }
            }
            class Br {
                constructor(e, t) {
                    this.value = e, this.task = t
                }
            }
            class $r {
                constructor(e) {
                    if ("string" != typeof e && !0 === e.isTrusted) throw new Error("The boolean form of MarkdownString.isTrusted is NOT supported for chat participants.");
                    this.value = "string" == typeof e ? new ke(e) : e
                }
            }
            class zr {
                constructor(e) {
                    this.value = e
                }
            }
            class qr {
                constructor(e, t) {
                    this.value = e, this.iconPath = t
                }
            }
            class Wr {
                constructor(e, t) {
                    this.uri = e, this.edits = Array.isArray(t) ? t : [t]
                }
            }
            class jr {
                constructor(e, t, n, r) {
                    this.prompt = e, this.command = t, this.references = n, this.participant = r
                }
            }
            class Vr {
                constructor(e, t, n, r) {
                    this.response = e, this.result = t, this.participant = n, this.command = r
                }
            }! function(e) {
                e[e.Panel = 1] = "Panel", e[e.Terminal = 2] = "Terminal", e[e.Notebook = 3] = "Notebook", e[e.Editor = 4] = "Editor"
            }(dr || (dr = {})),
            function(e) {
                e[e.User = 1] = "User", e[e.Assistant = 2] = "Assistant", e[e.System = 3] = "System"
            }(fr || (fr = {}));
            class Hr {
                constructor(e, t, n) {
                    this.name = e, this.content = t, this.isError = n ? ? !1
                }
            }
            class Kr {
                static User(e, t) {
                    const n = new Kr(fr.User, "string" == typeof e ? e : "", t);
                    return n.content2 = e, n
                }
                static Assistant(e, t) {
                    return new Kr(fr.Assistant, e, t)
                }
                constructor(e, t, n) {
                    this.role = e, this.content = t, this.content2 = t, this.name = n
                }
            }
            class Zr {
                constructor(e, t) {
                    this.name = e, this.parameters = t
                }
            }
            class Gr {
                constructor(e) {
                    this.value = e
                }
            }
            class Jr {
                constructor(e) {
                    this.content = e
                }
            }
            class Yr {
                constructor(e, t) {
                    this.content = e, this.name = t
                }
            }
            class Qr {
                constructor(e, t) {
                    this.content = e, this.name = t
                }
            }
            class Xr extends Error {
                static NotFound(e) {
                    return new Xr(e, Xr.NotFound.name)
                }
                static NoPermissions(e) {
                    return new Xr(e, Xr.NoPermissions.name)
                }
                static Blocked(e) {
                    return new Xr(e, Xr.Blocked.name)
                }
                constructor(e, t, n) {
                    super(e, {
                        cause: n
                    }), this.name = "LanguageModelError", this.code = t ? ? ""
                }
            }! function(e) {
                e[e.SymbolInformation = 1] = "SymbolInformation", e[e.CommandInformation = 2] = "CommandInformation", e[e.SearchInformation = 3] = "SearchInformation", e[e.SettingInformation = 4] = "SettingInformation"
            }(pr || (pr = {})),
            function(e) {
                e[e.Started = 1] = "Started", e[e.Recognizing = 2] = "Recognizing", e[e.Recognized = 3] = "Recognized", e[e.Stopped = 4] = "Stopped", e[e.Error = 5] = "Error"
            }(gr || (gr = {})),
            function(e) {
                e[e.Started = 1] = "Started", e[e.Stopped = 2] = "Stopped", e[e.Error = 3] = "Error"
            }(mr || (mr = {})),
            function(e) {
                e[e.Recognized = 1] = "Recognized", e[e.Stopped = 2] = "Stopped"
            }(br || (br = {}));
            class ei {
                constructor(e, t) {
                    this.text = e, this.range = t
                }
            }! function(e) {
                e[e.Invoke = 0] = "Invoke", e[e.Automatic = 1] = "Automatic"
            }(_r || (_r = {}))
        },
        Tg2V: (e, t, n) => {
            n.d(t, {
                j: () => a,
                m: () => o
            });
            var r = n("jxI3"),
                i = n("YrcG");
            class s {
                constructor() {
                    this.buffers = []
                }
                add(e) {
                    let t = this.buffers.indexOf(e);
                    return t < 0 && (t = this.buffers.length, this.buffers.push(e)), t
                }
            }

            function o(e, t) {
                if (t.serializeBuffersForPostMessage) {
                    const t = new s,
                        n = (e, n) => {
                            if (n instanceof ArrayBuffer) return {
                                $$vscode_array_buffer_reference$$: !0,
                                index: t.add(n)
                            };
                            if (ArrayBuffer.isView(n)) {
                                const e = function(e) {
                                    switch (e.constructor.name) {
                                        case "Int8Array":
                                            return i.oR.Int8Array;
                                        case "Uint8Array":
                                            return i.oR.Uint8Array;
                                        case "Uint8ClampedArray":
                                            return i.oR.Uint8ClampedArray;
                                        case "Int16Array":
                                            return i.oR.Int16Array;
                                        case "Uint16Array":
                                            return i.oR.Uint16Array;
                                        case "Int32Array":
                                            return i.oR.Int32Array;
                                        case "Uint32Array":
                                            return i.oR.Uint32Array;
                                        case "Float32Array":
                                            return i.oR.Float32Array;
                                        case "Float64Array":
                                            return i.oR.Float64Array;
                                        case "BigInt64Array":
                                            return i.oR.BigInt64Array;
                                        case "BigUint64Array":
                                            return i.oR.BigUint64Array
                                    }
                                }(n);
                                if (e) return {
                                    $$vscode_array_buffer_reference$$: !0,
                                    index: t.add(n.buffer),
                                    view: {
                                        type: e,
                                        byteLength: n.byteLength,
                                        byteOffset: n.byteOffset
                                    }
                                }
                            }
                            return n
                        };
                    return {
                        message: JSON.stringify(e, n),
                        buffers: t.buffers.map((e => {
                            const t = new Uint8Array(e);
                            return r.KN.wrap(t)
                        }))
                    }
                }
                return {
                    message: JSON.stringify(e),
                    buffers: []
                }
            }

            function a(e, t) {
                const n = t.map((e => {
                        const t = new ArrayBuffer(e.byteLength);
                        return new Uint8Array(t).set(e.buffer), t
                    })),
                    r = t.length ? (e, t) => {
                        if (t && "object" == typeof t && t.$$vscode_array_buffer_reference$$) {
                            const e = t,
                                {
                                    index: r
                                } = e,
                                s = n[r];
                            if (e.view) switch (e.view.type) {
                                case i.oR.Int8Array:
                                    return new Int8Array(s, e.view.byteOffset, e.view.byteLength / Int8Array.BYTES_PER_ELEMENT);
                                case i.oR.Uint8Array:
                                    return new Uint8Array(s, e.view.byteOffset, e.view.byteLength / Uint8Array.BYTES_PER_ELEMENT);
                                case i.oR.Uint8ClampedArray:
                                    return new Uint8ClampedArray(s, e.view.byteOffset, e.view.byteLength / Uint8ClampedArray.BYTES_PER_ELEMENT);
                                case i.oR.Int16Array:
                                    return new Int16Array(s, e.view.byteOffset, e.view.byteLength / Int16Array.BYTES_PER_ELEMENT);
                                case i.oR.Uint16Array:
                                    return new Uint16Array(s, e.view.byteOffset, e.view.byteLength / Uint16Array.BYTES_PER_ELEMENT);
                                case i.oR.Int32Array:
                                    return new Int32Array(s, e.view.byteOffset, e.view.byteLength / Int32Array.BYTES_PER_ELEMENT);
                                case i.oR.Uint32Array:
                                    return new Uint32Array(s, e.view.byteOffset, e.view.byteLength / Uint32Array.BYTES_PER_ELEMENT);
                                case i.oR.Float32Array:
                                    return new Float32Array(s, e.view.byteOffset, e.view.byteLength / Float32Array.BYTES_PER_ELEMENT);
                                case i.oR.Float64Array:
                                    return new Float64Array(s, e.view.byteOffset, e.view.byteLength / Float64Array.BYTES_PER_ELEMENT);
                                case i.oR.BigInt64Array:
                                    return new BigInt64Array(s, e.view.byteOffset, e.view.byteLength / BigInt64Array.BYTES_PER_ELEMENT);
                                case i.oR.BigUint64Array:
                                    return new BigUint64Array(s, e.view.byteOffset, e.view.byteLength / BigUint64Array.BYTES_PER_ELEMENT);
                                default:
                                    throw new Error("Unknown array buffer view type")
                            }
                            return s
                        }
                        return t
                    } : void 0;
                return {
                    message: JSON.parse(e, r),
                    arrayBuffers: n
                }
            }
        },
        Cv2i: (e, t, n) => {
            n.d(t, {
                o: () => o
            });
            var r = n("7icl"),
                i = n("opu4"),
                s = n("yFKF");
            class o {
                constructor() {
                    this.pendingRequests = new Map, this.queue = [], this._onError = new r.Q5, this._onExit = new r.Q5, this.sequence = 1
                }
                get onError() {
                    return this._onError.event
                }
                get onExit() {
                    return this._onExit.event
                }
                onMessage(e) {
                    this.messageCallback && this._onError.fire(new Error("attempt to set more than one 'Message' callback")), this.messageCallback = e
                }
                onEvent(e) {
                    this.eventCallback && this._onError.fire(new Error("attempt to set more than one 'Event' callback")), this.eventCallback = e
                }
                onRequest(e) {
                    this.requestCallback && this._onError.fire(new Error("attempt to set more than one 'Request' callback")), this.requestCallback = e
                }
                sendResponse(e) {
                    e.seq > 0 ? this._onError.fire(new Error(`attempt to send more than one response for command ${e.command}`)) : this.internalSend("response", e)
                }
                sendRequest(e, t, n, r) {
                    const i = {
                        command: e
                    };
                    if (t && Object.keys(t).length > 0 && (i.arguments = t), this.internalSend("request", i), "number" == typeof r) {
                        const t = setTimeout((() => {
                            clearTimeout(t);
                            const n = this.pendingRequests.get(i.seq);
                            n && (this.pendingRequests.delete(i.seq), n({
                                type: "response",
                                seq: 0,
                                request_seq: i.seq,
                                success: !1,
                                command: e,
                                message: (0, s.C$)("vs/workbench/contrib/debug/common/abstractDebugAdapter", 0, "Timeout after {0} ms for '{1}'", r, e)
                            }))
                        }), r)
                    }
                    return n && this.pendingRequests.set(i.seq, n), i.seq
                }
                acceptMessage(e) {
                    this.messageCallback ? this.messageCallback(e) : (this.queue.push(e), 1 === this.queue.length && this.processQueue())
                }
                needsTaskBoundaryBetween(e, t) {
                    return "event" !== e.type || "event" !== t.type
                }
                async processQueue() {
                    let e;
                    for (; this.queue.length;) {
                        if (e && !this.needsTaskBoundaryBetween(this.queue[0], e) || await (0, i.Vs)(0), e = this.queue.shift(), !e) return;
                        switch (e.type) {
                            case "event":
                                this.eventCallback ? .(e);
                                break;
                            case "request":
                                this.requestCallback ? .(e);
                                break;
                            case "response":
                                {
                                    const t = e,
                                        n = this.pendingRequests.get(t.request_seq);n && (this.pendingRequests.delete(t.request_seq), n(t));
                                    break
                                }
                        }
                    }
                }
                internalSend(e, t) {
                    t.type = e, t.seq = this.sequence++, this.sendMessage(t)
                }
                async cancelPendingRequests() {
                    if (0 === this.pendingRequests.size) return Promise.resolve();
                    const e = new Map;
                    this.pendingRequests.forEach(((t, n) => e.set(n, t))), await (0, i.Vs)(500), e.forEach(((e, t) => {
                        e({
                            type: "response",
                            seq: 0,
                            request_seq: t,
                            success: !1,
                            command: "canceled",
                            message: "canceled"
                        }), this.pendingRequests.delete(t)
                    }))
                }
                getPendingRequestIds() {
                    return Array.from(this.pendingRequests.keys())
                }
                dispose() {
                    this.queue = []
                }
            }
        },
        gXH3: (e, t, n) => {
            var r;
            n.d(t, {
                    W: () => r
                }),
                function(e) {
                    e[e.Output = 1] = "Output", e[e.OutputItems = 2] = "OutputItems", e[e.ExecutionState = 3] = "ExecutionState"
                }(r || (r = {}))
        },
        AKLK: (e, t, n) => {
            n.d(t, {
                Z: () => f
            });
            var r = n("yFKF"),
                i = n("K30K"),
                s = n("7eUP"),
                o = n("GkOh"),
                a = n("U0fV"),
                c = n("7icl");
            const l = "vs/workbench/contrib/tasks/common/taskDefinitionRegistry",
                u = {
                    type: "object",
                    additionalProperties: !1,
                    properties: {
                        type: {
                            type: "string",
                            description: (0, r.C$)(l, 0, "The actual task type. Please note that types starting with a '$' are reserved for internal usage.")
                        },
                        required: {
                            type: "array",
                            items: {
                                type: "string"
                            }
                        },
                        properties: {
                            type: "object",
                            description: (0, r.C$)(l, 1, "Additional properties of the task type"),
                            additionalProperties: {
                                $ref: "http://json-schema.org/draft-07/schema#"
                            }
                        },
                        when: {
                            type: "string",
                            markdownDescription: (0, r.C$)(l, 2, "Condition which must be true to enable this type of task. Consider using `shellExecutionSupported`, `processExecutionSupported`, and `customExecutionSupported` as appropriate for this task definition. See the [API documentation](https://code.visualstudio.com/api/extension-guides/task-provider#when-clause) for more information."),
                            default: ""
                        }
                    }
                };
            var h;
            ! function(e) {
                e.from = function(e, t, n) {
                    if (!e) return;
                    const o = (0, i.HD)(e.type) ? e.type : void 0;
                    if (!o || 0 === o.length) return void n.error((0, r.C$)(l, 3, "The task type configuration is missing the required 'taskType' property"));
                    const c = [];
                    if (Array.isArray(e.required))
                        for (const t of e.required)(0, i.HD)(t) && c.push(t);
                    return {
                        extensionId: t.value,
                        taskType: o,
                        required: c,
                        properties: e.properties ? (0, s.I8)(e.properties) : {},
                        when: e.when ? a.Ao.deserialize(e.when) : void 0
                    }
                }
            }(h || (h = {}));
            const d = o.ut.registerExtensionPoint({
                    extensionPoint: "taskDefinitions",
                    activationEventsGenerator: (e, t) => {
                        for (const n of e) n.type && t.push(`onTaskType:${n.type}`)
                    },
                    jsonSchema: {
                        description: (0, r.C$)(l, 4, "Contributes task kinds"),
                        type: "array",
                        items: u
                    }
                }),
                f = new class {
                    constructor() {
                        this._onDefinitionsChanged = new c.Q5, this.onDefinitionsChanged = this._onDefinitionsChanged.event, this.taskTypes = Object.create(null), this.readyPromise = new Promise(((e, t) => {
                            d.setHandler(((t, n) => {
                                this._schema = void 0;
                                try {
                                    for (const e of n.removed) {
                                        const t = e.value;
                                        for (const e of t) this.taskTypes && e.type && this.taskTypes[e.type] && delete this.taskTypes[e.type]
                                    }
                                    for (const e of n.added) {
                                        const t = e.value;
                                        for (const n of t) {
                                            const t = h.from(n, e.description.identifier, e.collector);
                                            t && (this.taskTypes[t.taskType] = t)
                                        }
                                    }(n.removed.length > 0 || n.added.length > 0) && this._onDefinitionsChanged.fire()
                                } catch (e) {}
                                e(void 0)
                            }))
                        }))
                    }
                    onReady() {
                        return this.readyPromise
                    }
                    get(e) {
                        return this.taskTypes[e]
                    }
                    all() {
                        return Object.keys(this.taskTypes).map((e => this.taskTypes[e]))
                    }
                    getJsonSchema() {
                        if (void 0 === this._schema) {
                            const e = [];
                            for (const t of this.all()) {
                                const n = {
                                    type: "object",
                                    additionalProperties: !1
                                };
                                t.required.length > 0 && (n.required = t.required.slice(0)), void 0 !== t.properties ? n.properties = (0, s.I8)(t.properties) : n.properties = Object.create(null), n.properties.type = {
                                    type: "string",
                                    enum: [t.taskType]
                                }, e.push(n)
                            }
                            this._schema = {
                                oneOf: e
                            }
                        }
                        return this._schema
                    }
                }
        },
        "2chr": (e, t, n) => {
            var r, i;
            n.d(t, {
                    Y5: () => i,
                    nc: () => r,
                    u0: () => s
                }),
                function(e) {
                    e.Delimiter = "\0"
                }(r || (r = {})),
                function(e) {
                    e[e.IsSame = 0] = "IsSame", e[e.Disconnected = 1] = "Disconnected", e[e.IsChild = 2] = "IsChild", e[e.IsParent = 3] = "IsParent"
                }(i || (i = {}));
            class s {
                static fromExtHostTestItem(e, t, n = e.parent) {
                    if (e._isRoot) return new s([t]);
                    const r = [e.id];
                    for (let e = n; e && e.id !== t; e = e.parent) r.push(e.id);
                    return r.push(t), new s(r.reverse())
                }
                static isRoot(e) {
                    return !e.includes(r.Delimiter)
                }
                static root(e) {
                    const t = e.indexOf(r.Delimiter);
                    return -1 === t ? e : e.slice(0, t)
                }
                static fromString(e) {
                    return new s(e.split(r.Delimiter))
                }
                static join(e, t) {
                    return new s([...e.path, t])
                }
                static joinToString(e, t) {
                    return e.toString() + r.Delimiter + t
                }
                static parentId(e) {
                    const t = e.lastIndexOf(r.Delimiter);
                    return -1 === t ? void 0 : e.slice(0, t)
                }
                static localId(e) {
                    const t = e.lastIndexOf(r.Delimiter);
                    return -1 === t ? e : e.slice(t + r.Delimiter.length)
                }
                static isChild(e, t) {
                    return t.startsWith(e) && t[e.length] === r.Delimiter
                }
                static compare(e, t) {
                    return e === t ? i.IsSame : s.isChild(e, t) ? i.IsChild : s.isChild(t, e) ? i.IsParent : i.Disconnected
                }
                static getLengthOfCommonPrefix(e, t) {
                    if (0 === e) return 0;
                    let n = 0;
                    for (; n < e - 1;) {
                        for (let r = 1; r < e; r++) {
                            const e = t(r - 1),
                                i = t(r);
                            if (e.path[n] !== i.path[n]) return n
                        }
                        n++
                    }
                    return n
                }
                constructor(e, t = e.length) {
                    if (this.path = e, this.viewEnd = t, 0 === e.length || t < 1) throw new Error("cannot create test with empty path")
                }
                get rootId() {
                    return new s(this.path, 1)
                }
                get parentId() {
                    return this.viewEnd > 1 ? new s(this.path, this.viewEnd - 1) : void 0
                }
                get localId() {
                    return this.path[this.viewEnd - 1]
                }
                get controllerId() {
                    return this.path[0]
                }
                get isRoot() {
                    return 1 === this.viewEnd
                }* idsFromRoot() {
                    for (let e = 1; e <= this.viewEnd; e++) yield new s(this.path, e)
                }* idsToRoot() {
                    for (let e = this.viewEnd; e > 0; e--) yield new s(this.path, e)
                }
                compare(e) {
                    if ("string" == typeof e) return s.compare(this.toString(), e);
                    for (let t = 0; t < e.viewEnd && t < this.viewEnd; t++)
                        if (e.path[t] !== this.path[t]) return i.Disconnected;
                    return e.viewEnd > this.viewEnd ? i.IsChild : e.viewEnd < this.viewEnd ? i.IsParent : i.IsSame
                }
                toJSON() {
                    return this.toString()
                }
                toString() {
                    if (!this.stringifed) {
                        this.stringifed = this.path[0];
                        for (let e = 1; e < this.viewEnd; e++) this.stringifed += r.Delimiter, this.stringifed += this.path[e]
                    }
                    return this.stringifed
                }
            }
        },
        V6Y4: (e, t, n) => {
            n.d(t, {
                $z: () => p,
                Hx: () => _,
                Mh: () => m,
                NU: () => r
            });
            var r, i = n("opu4"),
                s = n("7icl"),
                o = n("RVdl"),
                a = n("/hu5"),
                c = n("Of1J"),
                l = n("2chr"),
                u = n("ziTh");
            ! function(e) {
                e[e.Upsert = 0] = "Upsert", e[e.SetTags = 1] = "SetTags", e[e.UpdateCanResolveChildren = 2] = "UpdateCanResolveChildren", e[e.RemoveChild = 3] = "RemoveChild", e[e.SetProp = 4] = "SetProp", e[e.Bulk = 5] = "Bulk", e[e.DocumentSynced = 6] = "DocumentSynced"
            }(r || (r = {}));
            const h = (e, t) => e === t,
                d = {
                    range: (e, t) => e === t || !(!e || !t) && e.equalsRange(t),
                    busy: h,
                    label: h,
                    description: h,
                    error: h,
                    sortText: h,
                    tags: (e, t) => e.length === t.length && !e.some((e => !t.includes(e)))
                },
                f = Object.entries(d);
            class p extends o.JT {
                get root() {
                    return this.options.root
                }
                constructor(e) {
                    super(), this.options = e, this.debounceSendDiff = this._register(new i.pY((() => this.flushDiff()), 200)), this.diffOpEmitter = this._register(new s.Q5), this.tree = new Map, this.tags = new Map, this.diff = [], this.onDidGenerateDiff = this.diffOpEmitter.event, this.root.canResolveChildren = !0, this.upsertItem(this.root, void 0)
                }
                set resolveHandler(e) {
                    this._resolveHandler = e;
                    for (const e of this.tree.values()) this.updateExpandability(e)
                }
                get resolveHandler() {
                    return this._resolveHandler
                }
                collectDiff() {
                    const e = this.diff;
                    return this.diff = [], e
                }
                pushDiff(e) {
                    switch (e.op) {
                        case c.rq.DocumentSynced:
                            for (const t of this.diff)
                                if (t.op === c.rq.DocumentSynced && t.uri === e.uri) return void(t.docv = e.docv);
                            break;
                        case c.rq.Update:
                            {
                                const t = this.diff[this.diff.length - 1];
                                if (t) {
                                    if (t.op === c.rq.Update && t.item.extId === e.item.extId) return void(0, c.Gn)(t.item, e.item);
                                    if (t.op === c.rq.Add && t.item.item.extId === e.item.extId) return void(0, c.Gn)(t.item, e.item)
                                }
                                break
                            }
                    }
                    this.diff.push(e), this.debounceSendDiff.isScheduled() || this.debounceSendDiff.schedule()
                }
                expand(e, t) {
                    const n = this.tree.get(e);
                    if (n) {
                        if ((void 0 === n.expandLevels || t > n.expandLevels) && (n.expandLevels = t), n.expand === c.Dd.Expandable) {
                            const e = this.resolveChildren(n);
                            return e.isOpen() ? this.expandChildren(n, t - 1) : e.wait().then((() => this.expandChildren(n, t - 1)))
                        }
                        return n.expand === c.Dd.Expanded ? !1 === n.resolveBarrier ? .isOpen() ? n.resolveBarrier.wait().then((() => this.expandChildren(n, t - 1))) : this.expandChildren(n, t - 1) : void 0
                    }
                }
                dispose() {
                    for (const e of this.tree.values()) this.options.getApiFor(e.actual).listener = void 0;
                    this.tree.clear(), this.diff = [], super.dispose()
                }
                onTestItemEvent(e, t) {
                    switch (t.op) {
                        case r.RemoveChild:
                            this.removeItem(l.u0.joinToString(e.fullId, t.id));
                            break;
                        case r.Upsert:
                            this.upsertItem(t.item, e);
                            break;
                        case r.Bulk:
                            for (const n of t.ops) this.onTestItemEvent(e, n);
                            break;
                        case r.SetTags:
                            this.diffTagRefs(t.new, t.old, e.fullId.toString());
                            break;
                        case r.UpdateCanResolveChildren:
                            this.updateExpandability(e);
                            break;
                        case r.SetProp:
                            this.pushDiff({
                                op: c.rq.Update,
                                item: {
                                    extId: e.fullId.toString(),
                                    item: t.update
                                }
                            });
                            break;
                        case r.DocumentSynced:
                            this.documentSynced(e.actual.uri);
                            break;
                        default:
                            (0, a.vE)()
                    }
                }
                documentSynced(e) {
                    e && this.pushDiff({
                        op: c.rq.DocumentSynced,
                        uri: e,
                        docv: this.options.getDocumentVersion(e)
                    })
                }
                upsertItem(e, t) {
                    const n = l.u0.fromExtHostTestItem(e, this.root.id, t ? .actual),
                        i = this.options.getApiFor(e);
                    i.parent && i.parent !== t ? .actual && this.options.getChildren(i.parent).delete(e.id);
                    let s = this.tree.get(n.toString());
                    if (!s) return s = {
                        fullId: n,
                        actual: e,
                        expandLevels: t ? .expandLevels ? t.expandLevels - 1 : void 0,
                        expand: c.Dd.NotExpandable
                    }, e.tags.forEach(this.incrementTagRefs, this), this.tree.set(s.fullId.toString(), s), this.setItemParent(e, t), this.pushDiff({
                        op: c.rq.Add,
                        item: {
                            controllerId: this.options.controllerId,
                            expand: s.expand,
                            item: this.options.toITestItem(e)
                        }
                    }), void this.connectItemAndChildren(e, s, t);
                    if (s.actual === e) return void this.connectItem(e, s, t);
                    if (s.actual.uri ? .toString() !== e.uri ? .toString()) return this.removeItem(n.toString()), this.upsertItem(e, t);
                    const o = this.options.getChildren(s.actual),
                        a = s.actual,
                        u = ((e, t) => {
                            let n;
                            for (const [r, i] of f) i(e[r], t[r]) || (n ? n[r] = t[r] : n = {
                                [r]: t[r]
                            });
                            return n
                        })(this.options.toITestItem(a), this.options.toITestItem(e));
                    this.options.getApiFor(a).listener = void 0, s.actual = e, s.resolveBarrier = void 0, s.expand = c.Dd.NotExpandable, u && (u.hasOwnProperty("tags") && (this.diffTagRefs(e.tags, a.tags, n.toString()), delete u.tags), this.onTestItemEvent(s, {
                        op: r.SetProp,
                        update: u
                    })), this.connectItemAndChildren(e, s, t);
                    for (const [t, r] of o) this.options.getChildren(e).get(r.id) || this.removeItem(l.u0.joinToString(n, r.id));
                    const h = s.expandLevels;
                    void 0 !== h && queueMicrotask((() => {
                        s.expand === c.Dd.Expandable && (s.expandLevels = void 0, this.expand(n.toString(), h))
                    })), this.documentSynced(s.actual.uri)
                }
                diffTagRefs(e, t, n) {
                    const r = new Set(t.map((e => e.id)));
                    for (const t of e) r.delete(t.id) || this.incrementTagRefs(t);
                    this.pushDiff({
                        op: c.rq.Update,
                        item: {
                            extId: n,
                            item: {
                                tags: e.map((e => (0, c.B2)(this.options.controllerId, e.id)))
                            }
                        }
                    }), r.forEach(this.decrementTagRefs, this)
                }
                incrementTagRefs(e) {
                    const t = this.tags.get(e.id);
                    t ? t.refCount++ : (this.tags.set(e.id, {
                        refCount: 1
                    }), this.pushDiff({
                        op: c.rq.AddTag,
                        tag: {
                            id: (0, c.B2)(this.options.controllerId, e.id)
                        }
                    }))
                }
                decrementTagRefs(e) {
                    const t = this.tags.get(e);
                    t && !--t.refCount && (this.tags.delete(e), this.pushDiff({
                        op: c.rq.RemoveTag,
                        id: (0, c.B2)(this.options.controllerId, e)
                    }))
                }
                setItemParent(e, t) {
                    this.options.getApiFor(e).parent = t && t.actual !== this.root ? t.actual : void 0
                }
                connectItem(e, t, n) {
                    this.setItemParent(e, n);
                    const r = this.options.getApiFor(e);
                    r.parent = n ? .actual, r.listener = e => this.onTestItemEvent(t, e), this.updateExpandability(t)
                }
                connectItemAndChildren(e, t, n) {
                    this.connectItem(e, t, n);
                    for (const [n, r] of this.options.getChildren(e)) this.upsertItem(r, t)
                }
                updateExpandability(e) {
                    let t;
                    t = this._resolveHandler ? e.resolveBarrier ? e.resolveBarrier.isOpen() ? c.Dd.Expanded : c.Dd.BusyExpanding : e.actual.canResolveChildren ? c.Dd.Expandable : c.Dd.NotExpandable : c.Dd.NotExpandable, t !== e.expand && (e.expand = t, this.pushDiff({
                        op: c.rq.Update,
                        item: {
                            extId: e.fullId.toString(),
                            expand: t
                        }
                    }), t === c.Dd.Expandable && void 0 !== e.expandLevels && this.resolveChildren(e))
                }
                expandChildren(e, t) {
                    if (t < 0) return;
                    const n = [];
                    for (const [r, s] of this.options.getChildren(e.actual)) {
                        const r = this.expand(l.u0.joinToString(e.fullId, s.id), t);
                        (0, i.J8)(r) && n.push(r)
                    }
                    return n.length ? Promise.all(n).then((() => {})) : void 0
                }
                resolveChildren(e) {
                    if (e.resolveBarrier) return e.resolveBarrier;
                    if (!this._resolveHandler) {
                        const e = new i.U8;
                        return e.open(), e
                    }
                    e.expand = c.Dd.BusyExpanding, this.pushExpandStateUpdate(e);
                    const t = e.resolveBarrier = new i.U8,
                        n = e => {
                            u.error(`Unhandled error in resolveHandler of test controller "${this.options.controllerId}"`, e)
                        };
                    let r;
                    try {
                        r = this._resolveHandler(e.actual === this.root ? void 0 : e.actual)
                    } catch (e) {
                        n(e)
                    }
                    return (0, i.J8)(r) ? r.catch(n).then((() => {
                        t.open(), this.updateExpandability(e)
                    })) : (t.open(), this.updateExpandability(e)), e.resolveBarrier
                }
                pushExpandStateUpdate(e) {
                    this.pushDiff({
                        op: c.rq.Update,
                        item: {
                            extId: e.fullId.toString(),
                            expand: e.expand
                        }
                    })
                }
                removeItem(e) {
                    const t = this.tree.get(e);
                    if (!t) throw new Error("attempting to remove non-existent child");
                    this.pushDiff({
                        op: c.rq.Remove,
                        itemId: e
                    });
                    const n = [t];
                    for (; n.length;) {
                        const e = n.pop();
                        if (e) {
                            this.options.getApiFor(e.actual).listener = void 0;
                            for (const t of e.actual.tags) this.decrementTagRefs(t.id);
                            this.tree.delete(e.fullId.toString());
                            for (const [t, r] of this.options.getChildren(e.actual)) n.push(this.tree.get(l.u0.joinToString(e.fullId, r.id)))
                        }
                    }
                }
                flushDiff() {
                    const e = this.collectDiff();
                    e.length && this.diffOpEmitter.fire(e)
                }
            }
            class g extends Error {
                constructor(e) {
                    super(`Attempted to insert a duplicate test item ID ${e}`)
                }
            }
            class m extends Error {
                constructor(e) {
                    super(`TestItem with ID "${e}" is invalid. Make sure to create it from the createTestItem method.`)
                }
            }
            class b extends Error {
                constructor(e, t, n) {
                    super(`TestItem with ID "${e}" is from controller "${t}" and cannot be added as a child of an item from controller "${n}".`)
                }
            }
            const _ = (e, t, n) => {
                let i = new Map;
                return {
                    get size() {
                        return i.size
                    },
                    forEach(e, t) {
                        for (const n of i.values()) e.call(t, n, this)
                    },
                    [Symbol.iterator]: () => i.entries(),
                    replace(s) {
                        const o = new Map,
                            a = new Set(i.keys()),
                            c = {
                                op: r.Bulk,
                                ops: []
                            };
                        for (const i of s) {
                            if (!(i instanceof n)) throw new m(i.id);
                            const s = t(i).controllerId;
                            if (s !== e.controllerId) throw new b(i.id, s, e.controllerId);
                            if (o.has(i.id)) throw new g(i.id);
                            o.set(i.id, i), a.delete(i.id), c.ops.push({
                                op: r.Upsert,
                                item: i
                            })
                        }
                        for (const e of a.keys()) c.ops.push({
                            op: r.RemoveChild,
                            id: e
                        });
                        e.listener ? .(c), i = o
                    },
                    add(t) {
                        if (!(t instanceof n)) throw new m(t.id);
                        i.set(t.id, t), e.listener ? .({
                            op: r.Upsert,
                            item: t
                        })
                    },
                    delete(t) {
                        i.delete(t) && e.listener ? .({
                            op: r.RemoveChild,
                            id: t
                        })
                    },
                    get: e => i.get(e),
                    toJSON: () => Array.from(i.values())
                }
            }
        },
        "S4z/": (e, t, n) => {
            n.d(t, {
                b: () => r
            });
            const r = "__"
        },
        "3WHm": (e, t, n) => {
            n.d(t, {
                M9: () => p,
                OP: () => d
            });
            var r = n("y5Nw"),
                i = n("PTqS"),
                s = n("RRaN"),
                o = n("oVnE"),
                a = n("yFKF"),
                c = n("Btjc"),
                l = n("LWIF");
            const u = n("gQuC").B.as(l.IP.Configuration),
                h = { ...c.p6,
                    properties: {
                        "workbench.editorAssociations": {
                            type: "object",
                            markdownDescription: (0, a.C$)("vs/workbench/services/editor/common/editorResolverService", 0, 'Configure [glob patterns](https://aka.ms/vscode-glob-patterns) to editors (for example `"*.hex": "hexEditor.hexedit"`). These have precedence over the default behavior.'),
                            additionalProperties: {
                                type: "string"
                            }
                        }
                    }
                };
            var d, f;

            function p(e, t) {
                if (new Set([i.lg.extension, i.lg.webviewPanel, i.lg.vscodeWorkspaceTrust, i.lg.vscodeSettings]).has(t.scheme)) return !1;
                const n = "string" == typeof e && e.indexOf(s.KR.sep) >= 0 ? `${t.scheme}:${t.path}` : (0, o.EZ)(t);
                return (0, r.EQ)("string" == typeof e ? e.toLowerCase() : e, n.toLowerCase())
            }
            u.registerConfiguration(h),
                function(e) {
                    e.builtin = "builtin", e.option = "option", e.exclusive = "exclusive", e.default = "default"
                }(d || (d = {})),
                function(e) {
                    e[e.ABORT = 1] = "ABORT", e[e.NONE = 2] = "NONE"
                }(f || (f = {}))
        },
        "0P4T": (e, t, n) => {
            n.d(t, {
                Q: () => r
            });
            const r = (0, n("OYZR").yh)("extensionService")
        },
        utc1: (e, t, n) => {
            n.d(t, {
                d: () => i,
                y: () => s
            });
            var r = n("PUdK");
            class i {
                constructor() {
                    this._actual = null, this._actualOk = null, this._actualErr = null, this._hasValue = !1, this._value = null, this._hasErr = !1, this._err = null
                }
                get[Symbol.toStringTag]() {
                    return this.toString()
                }
                _ensureActual() {
                    return this._actual || (this._actual = new Promise(((e, t) => {
                        this._actualOk = e, this._actualErr = t, this._hasValue && this._actualOk(this._value), this._hasErr && this._actualErr(this._err)
                    }))), this._actual
                }
                resolveOk(e) {
                    this._hasValue || this._hasErr || (this._hasValue = !0, this._value = e, this._actual && this._actualOk(e))
                }
                resolveErr(e) {
                    this._hasValue || this._hasErr || (this._hasErr = !0, this._err = e, this._actual ? this._actualErr(e) : (0, r.dL)(e))
                }
                then(e, t) {
                    return this._ensureActual().then(e, t)
                } catch (e) {
                    return this._ensureActual().then(void 0, e)
                } finally(e) {
                    return this._ensureActual().finally(e)
                }
            }
            class s extends i {
                constructor() {
                    super(), this._hasErr = !0, this._err = new r.FU
                }
            }
        },
        "43lI": (e, t, n) => {
            n.d(t, {
                CU: () => s,
                IB: () => o,
                ky: () => a,
                uv: () => r
            });
            class r {
                static {
                    this.count = 0
                }
                constructor(e) {
                    this._proxyIdentifierBrand = void 0, this.sid = e, this.nid = ++r.count
                }
            }
            const i = [];

            function s(e) {
                const t = new r(e);
                return i[t.nid] = t, t
            }

            function o(e) {
                return i[e].sid
            }
            class a {
                constructor(e) {
                    this.value = e
                }
            }
        },
        WQBf: (e, t, n) => {
            n.d(t, {
                Qc: () => c,
                R_: () => l
            });
            var r = n("jxI3"),
                i = (n("Ef4y"), n("PTqS"));
            n("yJ/l"), n("OYZR");
            const s = ["W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f"],
                o = new RegExp(`^[${s.join("")}]+`),
                a = 7;

            function c(e) {
                if (e.scheme !== i.lg.vscodeNotebookCell) return;
                const t = e.fragment.indexOf("s");
                if (t < 0) return;
                const n = parseInt(e.fragment.substring(0, t).replace(o, ""), a),
                    s = (0, r.NV)(e.fragment.substring(t + 1)).toString();
                return isNaN(n) ? void 0 : {
                    handle: n,
                    notebook: e.with({
                        scheme: s,
                        fragment: null
                    })
                }
            }

            function l(e, t) {
                const n = t.toString(a),
                    o = `${n.length<s.length?s[n.length-1]:"z"}${n}s${(0,r.oF)(r.KN.fromString(e.scheme),!0,!0)}`;
                return e.with({
                    scheme: i.lg.vscodeNotebookCell,
                    fragment: o
                })
            }
        },
        FwF7: (e, t, n) => {
            var r;
            n.d(t, {
                    a: () => r
                }),
                function(e) {
                    e[e.Information = 1] = "Information", e[e.Warning = 2] = "Warning"
                }(r || (r = {}))
        }
    }
]);
//# sourceMappingURL=https://hrcdn.net/fcore/assets/sourcemaps/defaultVendors-node_modules_vscode__virtual_semver_js-node_modules_vscode_vscode_src_vs_base_-a8fea6-ca090a9a.js.map