"use strict";
(self.webpackChunkhackerrank_lib = self.webpackChunkhackerrank_lib || []).push([
    ["modules-node_modules_app-server_es_ui_component_editors_hr_monaco_editor_utils_js-node_module-d266c7"], {
        "2Qfr": () => {},
        Jrsf: (e, n, t) => {
            t.r(n), t.d(n, {
                defaultCodeshellOpts: () => s,
                fetchUserPreference: () => c,
                getCodeBody: () => d,
                getCodeshellUserOpts: () => l,
                getLocalStorageValue: () => u,
                setLocalStorageValue: () => h,
                setUserPreference: () => p
            });
            var i = t("i7RB"),
                r = t.n(i),
                o = t("zNJu"),
                a = "function" == typeof $ && $.jStorage || o.Z,
                s = {
                    theme: "light",
                    tabSize: 4,
                    intellisense: !0,
                    mode: "normal",
                    keyMap: "sublime",
                    indentUnit: 4
                };

            function l() {
                var e = a.get("codeshellUserOpts"),
                    n = !1;
                if (e) try {
                    e = JSON.parse(e)
                } catch (t) {
                    e = s, n = !0
                } else e = s, n = !0;
                return n && a.set("codeshellUserOpts", JSON.stringify(s)), e
            }

            function d() {
                var e = arguments.length > 1 ? arguments[1] : void 0,
                    n = arguments.length > 2 ? arguments[2] : void 0,
                    t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                if (e.trim() && 0 === t.indexOf(e) && (t = t.substr(e.length)), n.trim()) {
                    var i = t.lastIndexOf(n);
                    i > 0 && (t = t.substr(0, i))
                }
                return t.endsWith("\n") || (t = "".concat(t, "\n")), t
            }

            function c(e) {
                return l()[e]
            }

            function p(e, n) {
                var t, i, o, s = l();
                s[e] = n, "tabSize" === e ? s.indentUnit = n : "mode" === e ? s.keyMap = {
                    vim: "vim",
                    emacs: "emacs",
                    normal: "sublime"
                }[n] : "intellisense" === e ? (o = n, r().set("enableIntellisenseUserPref", o)) : "theme" === e && (t = n, i = {
                    light: "light",
                    dark: "dark",
                    contrast: "dark"
                }, r().set("hacker_editor_theme", i[t] || t)), a.set("codeshellUserOpts", JSON.stringify(s))
            }

            function u(e) {
                return a.get(e)
            }

            function h(e, n) {
                a.set(e, n)
            }
        },
        zNJu: (e, n, t) => {
            t.d(n, {
                Z: () => d
            }), t("ioFf");
            var i = t("L5+t"),
                r = t("5F93"),
                o = t("ziTh");

            function a(e, n) {
                var t = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var i = Object.getOwnPropertySymbols(e);
                    n && (i = i.filter((function(n) {
                        return Object.getOwnPropertyDescriptor(e, n).enumerable
                    }))), t.push.apply(t, i)
                }
                return t
            }
            var s = "undefined" == typeof localStorage ? new class extends Object {
                    setItem(e, n) {
                        this[e] = n
                    }
                    getItem(e) {
                        return this[e]
                    }
                    removeItem(e) {
                        delete this[e]
                    }
                } : localStorage,
                l = new class {
                    constructor(e, n) {
                        var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                        (0, i.Z)(this, "dbName", void 0), (0, i.Z)(this, "namespace", void 0), (0, i.Z)(this, "intermediateStore", {}), (0, i.Z)(this, "persistentStore", void 0), (0, i.Z)(this, "onWindowUnload", void 0), (0, i.Z)(this, "flushIntervalID", void 0);
                        var {
                            namespace: r = "",
                            persistOnUnload: o = !0,
                            flushInterval: a = 3e3
                        } = t;
                        this.dbName = n, this.namespace = r, this.persistentStore = e, !r && n && this.initBaseStore(o, n), this.flushIntervalID = setInterval((() => this.flush()), a)
                    }
                    initBaseStore(e, n) {
                        try {
                            var t = this.persistentStore.getItem(n);
                            if (t) {
                                var i = JSON.parse(t);
                                this.intermediateStore = i
                            }
                        } catch (e) {
                            this.intermediateStore = {}
                        }
                        e && !(0, r.sk)() && window.addEventListener("beforeunload", (() => this.flush()))
                    }
                    flush() {
                        try {
                            this.persistentStore.setItem(this.dbName, JSON.stringify(this.intermediateStore))
                        } catch (e) {
                            o.error(e)
                        }
                    }
                    getKey(e) {
                        return this.namespace ? "".concat(this.namespace, "-").concat(e) : e
                    }
                    setItem(e, n) {
                        this.intermediateStore[this.getKey(e)] = n
                    }
                    getItem(e) {
                        return this.intermediateStore[this.getKey(e)]
                    }
                    set(e, n) {
                        return this.setItem(e, n)
                    }
                    get(e) {
                        return this.getItem(e)
                    }
                    removeItem(e) {
                        delete this.intermediateStore[this.getKey(e)]
                    }
                    deleteKey(e) {
                        return this.removeItem(e)
                    }
                    storageObj() {
                        return function(e) {
                            for (var n = 1; n < arguments.length; n++) {
                                var t = null != arguments[n] ? arguments[n] : {};
                                n % 2 ? a(Object(t), !0).forEach((function(n) {
                                    (0, i.Z)(e, n, t[n])
                                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : a(Object(t)).forEach((function(n) {
                                    Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(t, n))
                                }))
                            }
                            return e
                        }({}, this.intermediateStore)
                    }
                    index() {
                        return Object.keys(this.intermediateStore)
                    }
                    removePrefix(e) {
                        Object.keys(this.intermediateStore).forEach((n => {
                            n.startsWith(e) && delete this.intermediateStore[n]
                        }))
                    }
                    createNamespace(e) {
                        if (!e) throw new Error("Cannot create storage without namespace");
                        var n = Object.create(this);
                        return n.namespace = this.getKey(e), n
                    }
                    remove() {
                        this.namespace && this.removePrefix(this.namespace)
                    }
                }(s, "jStorage");
            "undefined" != typeof window && (window.jStorage = l, window.$ = window.$ || {}, window.$.jStorage = l);
            const d = l
        },
        "OIP+": (e, n, t) => {
            t.d(n, {
                DZ: () => d,
                Dw: () => l,
                Gf: () => f,
                K3: () => m,
                KT: () => p,
                Pd: () => h,
                RY: () => g,
                VV: () => v,
                dE: () => c,
                g7: () => E,
                jE: () => I,
                pI: () => L,
                qC: () => u,
                rF: () => b,
                x_: () => T,
                yq: () => y
            }), t("ioFf"), t("Z2Ku");
            var i = t("L5+t"),
                r = t("mTBN"),
                o = t("nsCh");

            function a(e, n) {
                var t = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var i = Object.getOwnPropertySymbols(e);
                    n && (i = i.filter((function(n) {
                        return Object.getOwnPropertyDescriptor(e, n).enumerable
                    }))), t.push.apply(t, i)
                }
                return t
            }

            function s(e) {
                for (var n = 1; n < arguments.length; n++) {
                    var t = null != arguments[n] ? arguments[n] : {};
                    n % 2 ? a(Object(t), !0).forEach((function(n) {
                        (0, i.Z)(e, n, t[n])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : a(Object(t)).forEach((function(n) {
                        Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(t, n))
                    }))
                }
                return e
            }

            function l(e, n, t) {
                return !n && !t || !(n && !e.startsWith("".concat(n, "\n")) || t && !e.endsWith("\n".concat(t)))
            }

            function d(e, n, t) {
                var i = {
                    head: !1,
                    tail: !1
                };
                return n || t ? (n && !e.startsWith("".concat(n, "\n")) && (i.head = !0), t && !e.endsWith("\n".concat(t)) && (i.tail = !0), i) : i
            }

            function c(e, n, t) {
                var i = {
                    head: !1,
                    tail: !1
                };
                return "string" == typeof n && n.trim() && !e.startsWith(n) && (i.head = !0), "string" == typeof t && t.trim() && !e.endsWith(t) && (i.tail = !0), i
            }

            function p(e, n, t) {
                var i = n;
                return i.trim() && i.startsWith("\n") || "" === e || (i = "\n\n".concat(i)), i.endsWith("\n") || "" === t || (i = "".concat(i, "\n\n")), "".concat(e).concat(i).concat(t)
            }
            var u = function() {
                for (var e = arguments.length, n = new Array(e), t = 0; t < e; t++) n[t] = arguments[t];
                return n.reduce(((e, n) => function() {
                    return e(n(...arguments))
                }), (e => e))
            };

            function h() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                    n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : r.default;
                if (!e) return n;
                var t = {};
                return e.languages.forEach((i => {
                    var r = "string" == typeof e.lang_template[i] ? e.lang_template[i] : "",
                        o = "string" == typeof e.lang_head_template[i] ? e.lang_head_template[i] : "",
                        a = "string" == typeof e.lang_tail_template[i] ? e.lang_tail_template[i] : "";
                    o.trim() || (o = ""), a.trim() || (a = "");
                    var s = !(o || a || r);
                    t[i] = Object.assign({}, n[i], {
                        headEnd: o,
                        tailStart: a
                    }, (!s || e.isReadonlyEditable) && {
                        defaultText: r
                    })
                })), t
            }

            function f(e) {
                return e.displayName || e.name || "Component"
            }

            function m(e) {
                return o.By[e] || ""
            }

            function g() {
                var {
                    value: e
                } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0, t = arguments.length > 2 ? arguments[2] : void 0;
                return r.LSP_LANGUAGES.filter((e => !t.includes(e))).includes(e) ? n ? o.I9.LOADING : o.I9.DISABLED : o.I9.NOT_SUPPORTED
            }

            function b(e, n) {
                var t, {
                    event: i
                } = n;
                switch (i) {
                    case o.Z8.READY:
                        t = o.I9.READY;
                        break;
                    case o.Z8.ERROR:
                    case o.X4.ERROR:
                        t = o.I9.ERROR;
                        break;
                    case o.Z8.CLOSE:
                        t = o.I9.LOADING
                }
                return t
            }

            function v(e) {
                var {
                    client: n,
                    method: t,
                    handler: i
                } = e, r = n[t];
                n[t] = i(n, r)
            }

            function y(e, n) {
                ["info", "warn", "error", "logTrace"].forEach((t => {
                    e[t] = e => {
                        n && n(t, e)
                    }
                }))
            }

            function L(e) {
                return e ? o.L6.map((n => {
                    var t = e("editor.".concat(n.label), n.label),
                        i = n.items.map((t => s(s({}, t), {}, {
                            label: e("editor.".concat(n.id, ".").concat(t.label), t.label)
                        })));
                    return s(s({}, n), {}, {
                        items: i,
                        label: t
                    })
                })) : o.L6
            }
            var S = {
                autocompleteAvailableText: "Autocomplete available for",
                execution_env: "Execution Environment",
                environment: "Environment",
                language: "Language",
                version: "Version",
                time_limit_standard: "Time Limit (Standard)",
                memory_limit_standard: "Memory Limit (Standard)",
                libraries_standard: "Libraries (Standard)",
                time_limit_ml: "Time Limit (ML)",
                memory_limit_ml: "Memory Limit (ML)",
                libraries_ml: "Libraries (ML)",
                comments: "Comments",
                tooltip_env_not_available: "Execution Environment Not Available for this language",
                tooltip_env_available: "Click to view execution environment"
            };

            function E(e, n) {
                return S[e] ? n ? n("editor.".concat(e), S[e]) : S[e] : ""
            }

            function T(e) {
                var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                return {
                    timeTaken: performance.now() - e,
                    totalItems: n.length,
                    startTime: e
                }
            }

            function I(e) {
                var n = !1,
                    t = new Promise(((t, i) => {
                        e.then((e => {
                            t(n ? {
                                isCancelled: !0
                            } : e)
                        }))
                    }));
                return t.cancel = () => {
                    n = !0
                }, t
            }
        },
        nsCh: (e, n, t) => {
            t.d(n, {
                By: () => a,
                EM: () => l,
                I9: () => o,
                Ku: () => f,
                L6: () => d,
                WJ: () => p,
                X4: () => i,
                Z8: () => r,
                f7: () => u,
                hy: () => m,
                kW: () => h,
                nx: () => c,
                ok: () => s
            });
            var i = Object.freeze({
                    CONNECT: "connect",
                    RECONNECT: "reconnect",
                    CLOSE: "close",
                    ERROR: "error"
                }),
                r = Object.freeze({
                    CONNECT: "lspConnect",
                    READY: "lspReady",
                    CLOSE: "lspClose",
                    DISCONNECT: "lspDisconnect",
                    ERROR: "lspError"
                }),
                o = Object.freeze({
                    LOADING: "loading",
                    READY: "ready",
                    ERROR: "error",
                    DISABLED: "disabled",
                    NOT_SUPPORTED: "none"
                }),
                a = {
                    ["autocomplete.".concat(o.LOADING)]: "Autocomplete Loading",
                    ["autocomplete.".concat(o.READY)]: "Autocomplete Ready",
                    ["autocomplete.".concat(o.ERROR)]: "Autocomplete Errored",
                    ["autocomplete.".concat(o.DISABLED)]: "Autocomplete Disabled",
                    ["autocomplete.".concat(o.NOT_SUPPORTED)]: "Autocomplete Not Supported",
                    ["autocomplete.".concat(o.NOT_SUPPORTED, "_tooltip")]: "We do not support Autocomplete for this language yet"
                },
                s = Object.freeze(["textDocument/codeLens", "textDocument/formatting", "textDocument/foldingRange", "textDocument/rangeFormatting", "textDocument/onTypeFormatting", "workspace/executeCommand", "textDocument/inlayHint"]),
                l = Object.freeze({
                    EDITOR_MODE: "mode",
                    THEME: "theme",
                    TAB_SIZE: "tabSize",
                    AUTOCOMPLETE: "intellisense"
                }),
                d = Object.freeze([{
                    id: l.EDITOR_MODE,
                    label: "Editor Mode",
                    items: [{
                        label: "Emacs",
                        value: "emacs"
                    }, {
                        label: "Normal",
                        value: "normal"
                    }, {
                        label: "Vim",
                        value: "vim"
                    }]
                }, {
                    id: l.THEME,
                    label: "Theme",
                    items: [{
                        label: "Light",
                        value: "light"
                    }, {
                        label: "Dark",
                        value: "dark"
                    }, {
                        label: "High Contrast",
                        value: "contrast"
                    }]
                }, {
                    id: l.TAB_SIZE,
                    label: "Tab Spaces",
                    items: [{
                        label: "2 spaces",
                        value: 2
                    }, {
                        label: "4 spaces",
                        value: 4
                    }, {
                        label: "8 spaces",
                        value: 8
                    }]
                }, {
                    id: l.AUTOCOMPLETE,
                    label: "Autocomplete",
                    items: [{
                        label: "Enable",
                        value: !0
                    }, {
                        label: "Disable",
                        value: !1
                    }]
                }]),
                c = Object.freeze({
                    SPACE: 32,
                    ENTER: 13,
                    UP: 38,
                    DOWN: 40,
                    LEFT: 37,
                    RIGHT: 39,
                    ESC: 27,
                    TAB: 9
                }),
                p = Object.freeze({
                    TEXT_DOCUMENT_COMPLETION: "textDocument/completion",
                    COMPLETION_ITEM_RESOLVE: "completionItem/resolve",
                    TEXT_DOCUMENT_CODE_ACTION: "textDocument/codeAction"
                }),
                u = Object.freeze({
                    LINEWISE: "linewise",
                    BLOCKWISE: "blockwise",
                    VISUAL: "VISUAL",
                    VISUAL_LINE: "VISUAL LINE",
                    VISUAL_BLOCK: "VISUAL BLOCK"
                }),
                h = Object.freeze({
                    COMPLETION: "Completion",
                    CODEACTION: "CodeAction"
                }),
                f = Object.freeze({
                    KRACKJACK_COMPLETION_RECEIVE: "KrackJackCompletionReceive",
                    KRACKJACK_CODEACTION: "KrackJackCodeAction"
                }),
                m = Object.freeze(["javascript", "typescript", "css", "html"])
        },
        lTh7: (e, n, t) => {
            t.r(n), t.d(n, {
                AVAILABLE_LANGUAGES: () => i.AVAILABLE_LANGUAGES,
                AutocompleteStatus: () => q,
                BaseEditor: () => P,
                Editor: () => ze,
                KrackJackEditor: () => Se,
                LANGUAGE_OPTIONS: () => C.LANGUAGE_OPTIONS,
                LSP_LANGUAGES: () => C.LSP_LANGUAGES,
                default: () => Xe,
                generateFullCode: () => f.KT,
                hasTemplateChanged: () => f.dE,
                registerAllAvailableLanguages: () => r.hc,
                revertTemplate: () => g.T9,
                withAnalytics: () => qe,
                withExtraLibs: () => $,
                withInput: () => Je,
                withLsp: () => Z,
                withModes: () => Ve,
                withRunCode: () => De,
                withSettings: () => Oe,
                withStatusBar: () => Ae
            });
            var i = t("OyKl"),
                r = t("kGKp"),
                o = (t("ioFf"), t("yt8O"), t("rGqo"), t("Z2Ku"), t("pIFo"), t("KKXr"), t("/0+J")),
                a = t("L5+t"),
                s = t("DTvD"),
                l = t.n(s),
                d = t("4Jew"),
                c = t("rvnw"),
                p = t("LWRp"),
                u = (t("mUEn"), t("vN+2")),
                h = t.n(u),
                f = t("OIP+"),
                m = [{
                    name: "scala",
                    lineCommentChar: "//"
                }, {
                    name: "ada",
                    lineCommentChar: "--"
                }, {
                    name: "d",
                    lineCommentChar: "//"
                }, {
                    name: "fortran",
                    lineCommentChar: "!"
                }, {
                    name: "groovy",
                    lineCommentChar: "//"
                }, {
                    name: "haskell",
                    lineCommentChar: "--"
                }, {
                    name: "julia",
                    lineCommentChar: "#"
                }, {
                    name: "octave",
                    lineCommentChar: "#"
                }, {
                    name: "sbcl",
                    lineCommentChar: ";;;"
                }, {
                    name: "tcl",
                    lineCommentChar: "#"
                }, {
                    name: "ocaml",
                    blockCommentStartChar: "(*",
                    blockCommentEndChar: "*)"
                }, {
                    name: "erlang",
                    lineCommentChar: "%"
                }],
                g = t("Jckq");
            t("098V"), t("MNvU"), t("zWQs"), t("a1Th");
            class b {
                constructor(e, n) {
                    var t = new URL(e, window.location.href).toString(),
                        i = "    const urlString = ".concat(JSON.stringify(t), '\n    const originURL = new URL(urlString)\n    const isValidUrl = (urlString) => { \n      try { return Boolean(new URL(urlString, originURL)) } catch(e){ return false }  \n    }\n    const originalImportScripts = self.importScripts\n\n    self.importScripts = (url) => {\n      if(url.startsWith("blob:") && isValidUrl(url.replace("blob:", ""))){\n        const urlWithoutBlob = url.replace("blob:", "")\n        const { pathname } = new URL(urlWithoutBlob, originURL)\n        url = pathname && pathname.substring(1)\n      }\n      originalImportScripts.call(self, new URL(url, originURL).toString())\n    }\n    importScripts(urlString);\n  '),
                        r = new Blob([i], {
                            type: "application/javascript"
                        }),
                        o = URL.createObjectURL(r);
                    this.worker = new Worker(o, n), URL.revokeObjectURL(o)
                }
                getWorker() {
                    return this.worker
                }
            }
            var v = {
                    editorWorkerService: () => new b(new URL(t.p + t.u("editor"), t.b), {
                        type: void 0,
                        name: "editor"
                    }).getWorker(),
                    typescript: () => new b(new URL(t.p + t.u("typescript"), t.b), {
                        type: void 0,
                        name: "typescript"
                    }).getWorker(),
                    javascript: () => new b(new URL(t.p + t.u("typescript"), t.b), {
                        type: void 0,
                        name: "typescript"
                    }).getWorker(),
                    html: () => new b(new URL(t.p + t.u("html"), t.b), {
                        type: void 0,
                        name: "html"
                    }).getWorker(),
                    css: () => new b(new URL(t.p + t.u("css"), t.b), {
                        type: void 0,
                        name: "css"
                    }).getWorker()
                },
                y = "d11534",
                L = "137C36",
                S = "576871";
            const E = {
                    base: "vs",
                    inherit: !0,
                    rules: [{
                        token: "storage",
                        foreground: "0000ff",
                        fontStyle: "bold"
                    }, {
                        token: "punctuation",
                        foreground: L
                    }, {
                        token: "comment",
                        foreground: L
                    }, {
                        token: "number",
                        foreground: L
                    }, {
                        token: "attribute.value.number",
                        foreground: L
                    }, {
                        token: "attribute.value.unit",
                        foreground: L
                    }, {
                        token: "type.identifier",
                        foreground: "025F59"
                    }, {
                        token: "attribute.name",
                        foreground: y
                    }, {
                        token: "metatag.content.html",
                        foreground: y
                    }, {
                        token: "metatag.html",
                        foreground: S
                    }],
                    colors: {
                        "editor.lineHighlightBorder": "#".concat(S, "70")
                    }
                },
                T = {
                    base: "vs-dark",
                    inherit: !0,
                    rules: [{
                        token: "punctuation",
                        foreground: "ffffff"
                    }, {
                        token: "storage",
                        foreground: "569cd6",
                        fontStyle: "bold"
                    }, {
                        token: "keyword",
                        foreground: "ff636f",
                        fontStyle: "bold"
                    }, {
                        token: "string",
                        foreground: "9ddf6e"
                    }, {
                        token: "identifier",
                        foreground: "63b7fc"
                    }, {
                        token: "comment",
                        foreground: "8c96a6",
                        fontStyle: "italic"
                    }],
                    colors: {
                        "editor.background": "#1d2432",
                        "editorLineNumber.foreground": "#8c96a6"
                    }
                },
                I = {
                    base: "vs-dark",
                    inherit: !0,
                    rules: [{
                        token: "punctuation",
                        foreground: "ffffff"
                    }, {
                        token: "storage",
                        foreground: "569cd6",
                        fontStyle: "bold"
                    }, {
                        token: "keyword",
                        foreground: "ff636f",
                        fontStyle: "bold"
                    }, {
                        token: "string",
                        foreground: "9ddf6e"
                    }, {
                        token: "identifier",
                        foreground: "63b7fc"
                    }, {
                        token: "comment",
                        foreground: "8c96a6",
                        fontStyle: "italic"
                    }],
                    colors: {
                        "editor.background": "#131315",
                        "editorLineNumber.foreground": "#747480",
                        "editorLineNumber.activeForeground": "#FFFFFF"
                    }
                };
            var _ = "d11534",
                x = "137C36",
                k = "576871";
            const w = {
                base: "vs",
                inherit: !0,
                rules: [{
                    token: "storage",
                    foreground: "0000ff",
                    fontStyle: "bold"
                }, {
                    token: "punctuation",
                    foreground: x
                }, {
                    token: "comment",
                    foreground: x
                }, {
                    token: "number",
                    foreground: x
                }, {
                    token: "attribute.value.number",
                    foreground: x
                }, {
                    token: "attribute.value.unit",
                    foreground: x
                }, {
                    token: "type.identifier",
                    foreground: "025F59"
                }, {
                    token: "attribute.name",
                    foreground: _
                }, {
                    token: "metatag.content.html",
                    foreground: _
                }, {
                    token: "metatag.html",
                    foreground: k
                }, {
                    token: "string.sql",
                    foreground: "A31515"
                }],
                colors: {
                    "editor.lineHighlightBorder": "#".concat(k, "70"),
                    "editor.background": "#FFFFFF",
                    "editorLineNumber.foreground": "#B4B4BB",
                    "editorLineNumber.activeForeground": "#0A0A0B"
                }
            };
            var C = t("mTBN");
            const M = {
                base: "hc-black",
                inherit: !0,
                rules: [{
                    token: "punctuation",
                    foreground: "608b4e"
                }, {
                    token: "storage",
                    foreground: "569cd6",
                    fontStyle: "bold"
                }],
                colors: {
                    "editor.lineHighlightBackground": "#282a2e"
                }
            };

            function R(e, n) {
                var t = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var i = Object.getOwnPropertySymbols(e);
                    n && (i = i.filter((function(n) {
                        return Object.getOwnPropertyDescriptor(e, n).enumerable
                    }))), t.push.apply(t, i)
                }
                return t
            }

            function O(e) {
                for (var n = 1; n < arguments.length; n++) {
                    var t = null != arguments[n] ? arguments[n] : {};
                    n % 2 ? R(Object(t), !0).forEach((function(n) {
                        (0, a.Z)(e, n, t[n])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : R(Object(t)).forEach((function(n) {
                        Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(t, n))
                    }))
                }
                return e
            }
            window.monaco = d, window.initServicesPromise = null, window.MonacoEnvironment = {
                getWorker: function(e, n) {
                    var t = v[n];
                    if (t) return t()
                }
            };
            class P extends l().Component {
                constructor(e) {
                    var n;
                    super(e), n = this, (0, a.Z)(this, "editorState", void 0), (0, a.Z)(this, "editor", void 0), (0, a.Z)(this, "editorElement", void 0), (0, a.Z)(this, "oldDecorations", void 0), (0, a.Z)(this, "disposables", void 0), (0, a.Z)(this, "foldingDisposable", void 0), (0, a.Z)(this, "headRange", void 0), (0, a.Z)(this, "tailRange", void 0), (0, a.Z)(this, "foldTimer", void 0), (0, a.Z)(this, "undoStackClearTimer", void 0), (0, a.Z)(this, "createModelPromise", null), (0, a.Z)(this, "runClient", (0, o.Z)((function*() {
                        var {
                            options: e
                        } = n.editorState, {
                            renderLineHighlight: t,
                            stackClearInterval: r
                        } = n.props;
                        window.initServicesPromise || (window.initServicesPromise = (0, f.jE)((0, p.fG)({})));
                        var o = yield window.initServicesPromise;
                        if (window.initServicesPromise = null, null == o || !o.isCancelled) {
                            d.editor.defineTheme("light", E), d.editor.defineTheme("dark", T), d.editor.defineTheme("light-hrds", w), d.editor.defineTheme("dark-hrds", I), d.editor.defineTheme("contrast", M), (() => {
                                for (var e = 0; e < m.length; e++) {
                                    var n = m[e];
                                    d.languages.register({
                                        id: n.name
                                    });
                                    var t = {
                                        lineComment: n.lineCommentChar
                                    };
                                    n.blockCommentStartChar && n.blockCommentEndChar && (t.blockComment = [n.blockCommentStartChar, n.blockCommentEndChar]), d.languages.setLanguageConfiguration(n.name, {
                                        comments: t
                                    })
                                }
                            })(), d.languages.register({
                                id: "octave"
                            }), (0, i.registerRulesForLanguage)("octave", new c.default);
                            var a = d.editor.create(n.editorElement, O(O({}, e), {}, {
                                model: null,
                                codeLens: !1,
                                renderLineHighlight: t
                            }));
                            n.editor = a, n.createModelPromise = (0, f.jE)(n.createModel(""));
                            var s = yield n.createModelPromise;
                            if (null == s || !s.isCancelled) {
                                var {
                                    editorModel: l,
                                    editorModelReference: u
                                } = s;
                                n.editorState.model = l, n.editorState.modelRef = u, n.initializeEditor(), r && (n.undoStackClearTimer = setInterval((() => n.clearUndoStack()), r))
                            }
                        }
                    }))), (0, a.Z)(this, "editorRef", (e => {
                        this.editorElement = e
                    })), this.editorState = {
                        currentValue: this.generateCurrentCode(),
                        options: this.getEditorOptions(),
                        model: null,
                        modelRef: null
                    }, this.oldDecorations = [], this.disposables = [], this.foldingDisposable = null, this.headRange = null, this.tailRange = null, this.foldTimer = null
                }
                componentDidMount() {
                    this.runClient()
                }
                componentDidUpdate(e) {
                    var n = {},
                        {
                            language: t,
                            options: i,
                            cleanUpLsp: r,
                            code: o,
                            tabSize: a,
                            insertSpaces: s,
                            retainValueOnLanguageChange: l
                        } = this.props,
                        {
                            model: d
                        } = this.editorState,
                        c = !0;
                    if (this.editor && this.updateEditorUI(e), e.language !== t) {
                        this.createModelPromise && this.createModelPromise.cancel(), window.editorModelPromise = null, c = !1, r();
                        var p = d.getValue();
                        n.currentValue = l ? p : this.generateCurrentCode(), this.createModelPromise = (0, f.jE)(this.createModel(l ? p : "")), window.editorModelPromise = this.createModelPromise, n.model = this.createModelPromise, n.modelRef = this.createModelPromise
                    } else {
                        var u = null;
                        e.tabSize !== a && ((u = u || {}).tabSize = a), e.insertSpaces !== s && ((u = u || {}).insertSpaces = s), u && this.editorState.model.updateOptions(u)
                    }
                    e.options !== i && (n.options = this.getEditorOptions()), e.code !== o && (n.currentValue = this.generateCurrentCode(), e.language === t && this.addFoldingProvider(!0)), Object.keys(n).length && (this.createModelPromise ? this.createModelPromise.then((e => {
                        if (null == e || !e.isCancelled) {
                            window.editorModelPromise = null, this.createModelPromise = null;
                            var {
                                editorModel: t,
                                editorModelReference: i
                            } = e;
                            n.model = t, n.modelRef = i, this.setEditorState(n, c)
                        }
                    })) : this.setEditorState(n, c))
                }
                componentWillUnmount() {
                    this.foldingDisposable && this.foldingDisposable.dispose(), window.initServicesPromise && window.initServicesPromise.cancel(), this.createModelPromise && this.createModelPromise.cancel(), window.editorModelPromise = null, this.disposables.forEach((e => e.dispose())), this.editor && this.editor.dispose(), this.editorState.modelRef && (this.editorState.modelRef.dispose(), this.editorState.model.dispose()), this.foldTimer && clearTimeout(this.foldTimer), this.undoStackClearTimer && clearInterval(this.undoStackClearTimer)
                }
                clearUndoStack() {
                    var {
                        model: e
                    } = this.editorState, n = [...e._commandManager._undoRedoService._editStacks.values()].pop();
                    (n ? n._past.length : 0) > 100 && (n._past = n._past.slice(-100))
                }
                initializeEditor() {
                    var {
                        editor: e
                    } = this, {
                        model: n,
                        currentValue: t
                    } = this.editorState, {
                        editorDidMount: i,
                        autoFocus: r
                    } = this.props;
                    this.disposables.push(e.onDidChangeModelContent(this.onContentChange.bind(this))), this.disposables.push(e.onDidPaste(this.onPaste.bind(this))), this.disposables.push(d.editor.addKeybindingRules([{
                        keybinding: d.KeyCode.F1,
                        command: null
                    }, {
                        keybinding: d.KeyMod.CtrlCmd | d.KeyMod.Shift | d.KeyCode.KeyP,
                        command: null
                    }])), this.updateCoreData(n, t), this.updateEditorUI(null), r && this.focus(!0), this.addCustomActions(), i(e)
                }
                updateEditorUI() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                    e || (e = {});
                    var {
                        theme: n,
                        width: t,
                        height: i
                    } = this.props;
                    n !== e.theme && d.editor.setTheme(n), t === e.width && i === e.height || this.editor.layout()
                }
                onContentChange(e) {
                    var {
                        onHeadTailType: n,
                        onReadonlyType: t,
                        code: {
                            headEnd: i,
                            tailStart: r
                        },
                        onChange: o,
                        isReadonlyEditable: a,
                        originalHead: s,
                        originalTail: l
                    } = this.props, {
                        currentValue: d
                    } = this.editorState, c = this.editor.getValue(), p = c, u = !0;
                    if (a) {
                        var h = (0, f.DZ)(c, s, l);
                        (h.head || h.tail) && n(h), this.editorState.currentValue = p, this.setReadOnlyRangeData()
                    } else {
                        if (!c.trim() && (i || r) || !(0, f.Dw)(c, i, r)) p = d, u = !1;
                        else if (c == d) return;
                        this.setEditorState({
                            currentValue: p
                        })
                    }
                    u ? o && o(e, p, i, r) : t()
                }
                onPaste(e) {
                    var n = e.range,
                        {
                            model: t
                        } = this.editorState,
                        {
                            tabSize: i,
                            onPaste: r,
                            insertSpaces: o,
                            isReadonlyEditable: a
                        } = this.props,
                        s = t.getValueInRange(n);
                    if (o && s.includes("\t")) {
                        for (var l = "", d = "number" == typeof i ? i : 4, c = 0; c < d; c++) l += " ";
                        s = s.replace(/\t/g, l), this.editor.executeEdits("krackjack", [{
                            range: n,
                            text: s
                        }])
                    }
                    r && r(n, s), a || this.adjustCursor()
                }
                adjustCursor() {
                    setTimeout((() => {
                        var e = this.editor.getPosition();
                        this.headRange && this.headRange.containsPosition(e) ? this.editor.setPosition(new d.Position(this.headRange.endLineNumber + 1, 1)) : this.tailRange && this.tailRange.containsPosition(e) && this.editor.setPosition(new d.Position(this.tailRange.startLineNumber - 1, 1))
                    }), 0)
                }
                addCustomActions() {
                    ["cquery.showReferences", "java.show.references"].forEach((e => {
                        this.editor.addCommand(e, ((e, n, t) => {
                            this.editor.setPosition(new d.Position(t.line + 1, t.character + 1))
                        }))
                    }))
                }
                updateHeadRange(e, n) {
                    var {
                        originalHead: t,
                        isReadonlyEditable: i
                    } = this.props, r = [];
                    if (n ? r = n.split("\n") : t && i && (r = t.split("\n")), r.length) {
                        var o = r.length,
                            a = r[r.length - 1].length + 1;
                        this.headRange = new d.Range(1, 1, o, a)
                    } else this.headRange = null
                }
                updateTailRange(e, n) {
                    var {
                        originalTail: t,
                        isReadonlyEditable: i
                    } = this.props;
                    if (n || t) {
                        var r = [];
                        n ? r = n.split("\n") : t && i && (r = t.split("\n"));
                        var o = e.getLineCount();
                        r.length && (this.tailRange = new d.Range(o - r.length + 1, 1, o, r[r.length - 1].length + 1))
                    } else this.tailRange = null
                }
                setReadOnlyRangeData(e) {
                    var {
                        code: {
                            headEnd: n,
                            tailStart: t
                        },
                        originalHead: i,
                        originalTail: r
                    } = this.props;
                    (n || t || i || r) && (e || (e = this.editorState.model), this.updateHeadRange(e, n), this.updateTailRange(e, t), this.updateReadOnlyUI())
                }
                updateReadOnlyUI() {
                    var e = [];
                    this.headRange && e.push(this.headRange), this.tailRange && e.push(this.tailRange), this.oldDecorations = this.editor.deltaDecorations(this.oldDecorations || [], e.map((e => ({
                        range: e,
                        options: {
                            isWholeLine: !0,
                            className: "read-only",
                            stickiness: d.editor.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges
                        }
                    }))))
                }
                updateCoreData(e) {
                    var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                        t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                        {
                            onCodeFold: i
                        } = this.props;
                    this.editor.setModel(e), t && this.editor.updateOptions(t), n ? this.setValueAndRange(e, n) : i()
                }
                setValueAndRange(e, n) {
                    n && ((0, g.mr)(e, n), this.setReadOnlyRangeData(e), this.addFoldingProvider())
                }
                addFoldingProvider() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                    this.foldingDisposable && this.foldingDisposable.dispose();
                    var {
                        syntax: n,
                        language: t,
                        code: {
                            headEnd: i,
                            tailStart: r
                        },
                        enableHeadTailFolding: o,
                        onCodeFold: a,
                        originalHead: s,
                        originalTail: l
                    } = this.props;
                    if (o && (i || r || s || l)) {
                        var c = 0,
                            p = 0;
                        i ? c = i.split("\n").length : s && (c = s.split("\n").length), r ? p = r.split("\n").length : l && (p = l.split("\n").length), this.foldingDisposable = d.languages.registerFoldingRangeProvider(n || t, {
                            provideFoldingRanges: e => {
                                var n = [];
                                if (c && n.push({
                                        start: 1,
                                        end: c,
                                        kind: d.languages.FoldingRangeKind.Imports
                                    }), p) {
                                    var t = e.getLineCount();
                                    n.push({
                                        start: t - p + 1,
                                        end: t,
                                        kind: d.languages.FoldingRangeKind.Region
                                    })
                                }
                                return n
                            }
                        }), this.foldTimer = setTimeout((() => {
                            this.editor.getAction("editor.foldAll").run(), a()
                        }), e ? 0 : 500)
                    } else a()
                }
                focus() {
                    if (arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && (this.headRange || this.tailRange)) {
                        var e = new d.Position(1, 1);
                        this.headRange && (e = new d.Position(this.headRange.endLineNumber + 1, 1)), this.editor.setPosition(e), setTimeout((() => this.editor.focus()), 1e3)
                    } else setTimeout((() => this.editor.focus()), 0)
                }
                setUndoableValue(e) {
                    var {
                        model: n
                    } = this.editorState, t = n.getLineCount();
                    this.editor.executeEdits("krackjack", [{
                        range: new d.Range(1, 1, t + 1, 1),
                        text: e
                    }]);
                    var i = [...n._commandManager._undoRedoService._editStacks.values()].pop();
                    i && i._past.pop(), this.setReadOnlyRangeData(null), this.resetCursorAndFold()
                }
                resetCursorAndFold() {
                    this.focus(!0);
                    var e = this.editor.getAction("editor.foldAll");
                    "function" == typeof e && e.run()
                }
                stripHeadTail(e) {
                    var {
                        code: {
                            headEnd: n,
                            tailStart: t
                        }
                    } = this.props, i = e;
                    if (n && 0 === e.indexOf(n) && (i = i.substr(n.length)), t) {
                        var r = i.lastIndexOf(t);
                        r > 0 && (i = i.substr(0, r))
                    }
                    return i
                }
                setEditorState(e) {
                    var n = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                        t = this.editorState;
                    this.editorState = O(O({}, t), e), this.rerenderEditor(t, n)
                }
                rerenderEditor(e) {
                    var n = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                        t = this.editorState;
                    if (t.options !== e.options && this.editor.updateOptions(t.options), t.model !== e.model) return this.updateCoreData(t.model, t.currentValue), e.modelRef.dispose(), e.model.dispose(), void(n && this.focus(!0));
                    t.currentValue !== this.editor.getValue() ? this.setUndoableValue(t.currentValue) : t.currentValue !== e.currentValue && this.setReadOnlyRangeData(null)
                }
                generateCurrentCode() {
                    var {
                        code: {
                            headEnd: e,
                            tailStart: n,
                            defaultText: t
                        },
                        shouldFormatCode: i
                    } = this.props;
                    return i ? (0, f.KT)(e, t, n) : "".concat(e).concat(t).concat(n)
                }
                getEditorOptions() {
                    return O({
                        minimap: {
                            enabled: !1
                        },
                        autoIndent: !0,
                        formatOnPaste: !1,
                        fontFamily: "SourceCodePro, monospace",
                        formatOnType: !1,
                        automaticLayout: !0,
                        scrollBeyondLastLine: !1,
                        showFoldingControls: "always",
                        wordBasedSuggestions: !1,
                        contextmenu: !1
                    }, this.props.options)
                }
                createModel(e) {
                    var n = this;
                    return (0, o.Z)((function*() {
                        var {
                            modelUri: t,
                            fileName: i,
                            fileExtension: r,
                            syntax: o,
                            language: a,
                            insertSpaces: s,
                            tabSize: l
                        } = n.props, c = d.Uri.parse("".concat(t, "/").concat(i, ".").concat(r)), p = d.editor.getModel(c);
                        if (p) return p;
                        var u = yield d.editor.createModelReference(c, e);
                        return p = u.object.textEditorModel, monaco.editor.setModelLanguage(p, o || a), p.setEOL(d.editor.EndOfLineSequence.LF), p.updateOptions({
                            tabSize: l,
                            insertSpaces: s,
                            trimAutoWhitespace: !1
                        }), {
                            editorModel: p,
                            editorModelReference: u
                        }
                    }))()
                }
                render() {
                    var {
                        height: e
                    } = this.props;
                    return l().createElement("div", {
                        ref: this.editorRef,
                        className: "hr-monaco-base-editor",
                        style: {
                            height: e
                        }
                    })
                }
            }(0, a.Z)(P, "defaultProps", {
                code: {
                    headEnd: "",
                    tailStart: "",
                    defaultText: ""
                },
                modelUri: C.DEFAULT_MODEL_URI,
                fileName: C.DEFAULT_FILE_NAME_WITHOUT_EXTENSION,
                options: {},
                height: 400,
                theme: "light",
                autoFocus: !0,
                insertSpaces: !0,
                enableHeadTailFolding: !1,
                tabSize: 4,
                cleanUpLsp: h(),
                editorDidMount: h(),
                onCodeFold: h(),
                onChange: h(),
                onPaste: h(),
                onReadonlyType: h(),
                onHeadTailType: h(),
                isReadonlyEditable: !1,
                stackClearInterval: 6e4,
                retainValueOnLanguageChange: !1,
                shouldFormatCode: !0,
                renderLineHighlight: ""
            });
            var A = t("+9dH"),
                N = t("PRvr"),
                D = t("nsCh"),
                U = ["enableAutoComplete", "lspBaseUrl", "lspEndpoint", "onCompletionReceive", "onLspWebsocketChange"];

            function j(e, n) {
                var t = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var i = Object.getOwnPropertySymbols(e);
                    n && (i = i.filter((function(n) {
                        return Object.getOwnPropertyDescriptor(e, n).enumerable
                    }))), t.push.apply(t, i)
                }
                return t
            }

            function B(e) {
                for (var n = 1; n < arguments.length; n++) {
                    var t = null != arguments[n] ? arguments[n] : {};
                    n % 2 ? j(Object(t), !0).forEach((function(n) {
                        (0, a.Z)(e, n, t[n])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : j(Object(t)).forEach((function(n) {
                        Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(t, n))
                    }))
                }
                return e
            }
            var F = ["java", "java8", "java15", "java17", "cpp"];
            const Z = e => {
                var n;
                return n = class extends l().Component {
                    constructor() {
                        var e, n;
                        super(...arguments), e = this, n = this, (0, a.Z)(this, "editor", void 0), (0, a.Z)(this, "disposables", []), (0, a.Z)(this, "thenables", Promise.resolve()), (0, a.Z)(this, "lspClient", void 0), (0, a.Z)(this, "didSaveCallCount", 1), (0, a.Z)(this, "didSaveTimeout", null), (0, a.Z)(this, "editorDidMount", (e => {
                            var {
                                editorDidMount: n
                            } = this.props;
                            n && n(e), this.editor = e, this.disposables.push(e.onDidChangeModel(this.startLspClient)), this.startLspClient()
                        })), (0, a.Z)(this, "onWSConnect", ((e, n) => {
                            var {
                                onLspWebsocketChange: t
                            } = this.props;
                            t(0 === e ? {
                                event: D.X4.CONNECT,
                                eventData: {},
                                language: n
                            } : {
                                event: D.X4.RECONNECT,
                                eventData: {
                                    retryCount: e
                                },
                                language: n
                            })
                        })), (0, a.Z)(this, "onWSMessage", (e => {
                            var {
                                onLspWebsocketMessage: n
                            } = this.props;
                            n && n(e)
                        })), (0, a.Z)(this, "onWSClose", (e => {
                            var {
                                onLspWebsocketChange: n
                            } = this.props;
                            n({
                                event: D.X4.CLOSE,
                                eventData: {},
                                language: e
                            })
                        })), (0, a.Z)(this, "onWSError", (e => {
                            var {
                                onLspWebsocketChange: n
                            } = this.props;
                            n({
                                event: D.X4.ERROR,
                                eventData: {},
                                language: e
                            })
                        })), (0, a.Z)(this, "onWSLog", ((e, n) => {
                            var {
                                onLspLog: t
                            } = this.props;
                            t && t(e, n)
                        })), (0, a.Z)(this, "onLspConnect", (e => {
                            var {
                                onLspWebsocketChange: n
                            } = this.props;
                            n({
                                event: D.Z8.CONNECT,
                                eventData: {},
                                language: e
                            })
                        })), (0, a.Z)(this, "onLspReady", ((e, n, t) => {
                            var {
                                onLspWebsocketChange: i,
                                language: r
                            } = this.props;
                            ["python", "python3"].includes(r) && this.lspClient.languageClient.sendNotification("workspace/didChangeConfiguration", {
                                settings: {
                                    python: {
                                        linting: {
                                            enabled: !0
                                        }
                                    }
                                }
                            }), t && "csharp" === t && this.sendDidSaveNotification(), i({
                                event: D.Z8.READY,
                                eventData: {
                                    responseData: e,
                                    timeTaken: n
                                },
                                language: r
                            })
                        })), (0, a.Z)(this, "onLspClose", (e => {
                            var {
                                onLspWebsocketChange: n
                            } = this.props;
                            n({
                                event: D.Z8.CLOSE,
                                eventData: {},
                                language: e
                            })
                        })), (0, a.Z)(this, "onLspError", (function(n, t) {
                            var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                                {
                                    onLspWebsocketChange: r
                                } = e.props;
                            r({
                                event: D.Z8.ERROR,
                                eventData: {
                                    message: n,
                                    fromServer: i
                                },
                                language: t
                            })
                        })), (0, a.Z)(this, "onLspDisconnect", (e => {
                            var {
                                onLspWebsocketChange: n
                            } = this.props;
                            n({
                                event: D.Z8.DISCONNECT,
                                eventData: {},
                                language: e
                            })
                        })), (0, a.Z)(this, "createLSPClient", (() => {
                            var {
                                language: e
                            } = this.props;
                            if (!D.hy.includes(e) && C.LSP_LANGUAGES.includes(e)) return this.loadLspClient().then((e => {
                                var {
                                    default: n
                                } = e, t = this.getLSPClientConfig();
                                this.lspClient = new n(this.editor, t)
                            }));
                            this.onLspReady()
                        })), (0, a.Z)(this, "startLspClient", (() => {
                            var {
                                enableAutoComplete: e,
                                lspEndpoint: n,
                                lspBaseUrl: t
                            } = this.props;
                            e && t && n && (this.thenables = this.thenables.then(this.stopLspClient).then(this.createLSPClient))
                        })), (0, a.Z)(this, "stopLspClient", (0, o.Z)((function*() {
                            n.lspClient && (yield n.lspClient.dispose(), n.lspClient = null), n.prevListener && (n.prevListener.dispose(), n.prevListener = null)
                        }))), (0, a.Z)(this, "proxyLspInitialize", ((n, t) => function(i, r) {
                            try {
                                for (var o = performance.now(), a = arguments.length, s = new Array(a > 2 ? a - 2 : 0), l = 2; l < a; l++) s[l - 2] = arguments[l];
                                return t.apply(n, [i, r, ...s]).then((t => {
                                    var i = (performance.now() - o).toFixed(1),
                                        r = n.clientOptions.documentSelector[0];
                                    return e.onLspReady(t, i, r)
                                }))
                            } catch (e) {
                                return Promise.reject()
                            }
                        })), (0, a.Z)(this, "proxyLspSendRequest", ((n, t) => {
                            var i, {
                                onCompletionReceive: r,
                                language: o,
                                isReadonlyEditable: a
                            } = this.props;
                            return function(s, l) {
                                var d;
                                try {
                                    for (var c = arguments.length, p = new Array(c > 2 ? c - 2 : 0), u = 2; u < c; u++) p[u - 2] = arguments[u];
                                    d = t.apply(n, [s, l, ...p])
                                } catch (e) {
                                    return Promise.reject()
                                }
                                if ("object" == typeof s && s.method) {
                                    if (s.method !== D.WJ.TEXT_DOCUMENT_COMPLETION && (s.method !== D.WJ.COMPLETION_ITEM_RESOLVE || a) && s.method !== D.WJ.TEXT_DOCUMENT_CODE_ACTION) return d;
                                    if (s.method === D.WJ.COMPLETION_ITEM_RESOLVE) return d.then((e => B(B({}, e), {}, {
                                        additionalTextEdits: void 0
                                    })));
                                    if (s.method === D.WJ.TEXT_DOCUMENT_COMPLETION) {
                                        var h = performance.now();
                                        return i && (i.dispose(), i = null), d.then((e => {
                                            var n = e.items || e,
                                                t = (0, f.x_)(h, n);
                                            r && r(t, D.kW.COMPLETION, D.Ku.KRACKJACK_COMPLETION_RECEIVE)
                                        })).catch((() => {
                                            i && (i.dispose(), i = null, e.prevListener = i)
                                        })), e.prevListener = i, a ? d : d.then((e => (e.items || e).map((e => B(B({}, e), {}, {
                                            additionalTextEdits: void 0
                                        })))))
                                    }
                                    if (s.method === D.WJ.TEXT_DOCUMENT_CODE_ACTION) {
                                        var m = performance.now();
                                        if (F.includes(o)) return d.then((e => {
                                            var n = (0, f.x_)(m, e);
                                            r && r(n, D.kW.CODEACTION, D.Ku.KRACKJACK_CODEACTION)
                                        })).catch((() => {})), d
                                    }
                                }
                            }
                        })), (0, a.Z)(this, "sendDidSaveNotification", (() => {
                            var {
                                fileName: e,
                                language: n,
                                modelUri: t
                            } = this.props;
                            if (this.didSaveCallCount > 3 || "csharp" !== n) return clearTimeout(this.didSaveTimeout), this.didSaveTimeout = null, void(this.didSaveCallCount = 1);
                            var i = "".concat(t, "/").concat((0, g.UO)(e, n));
                            this.lspClient.languageClient.sendNotification("textDocument/didSave", {
                                textDocument: {
                                    uri: i
                                },
                                text: this.editor.getValue()
                            }), this.didSaveTimeout = setTimeout(this.sendDidSaveNotification, 2e3 * this.didSaveCallCount), this.didSaveCallCount += 1
                        }))
                    }
                    componentDidUpdate(e) {
                        if (this.editor) {
                            var {
                                enableAutoComplete: n,
                                language: t
                            } = this.props, {
                                language: i,
                                enableAutoComplete: r
                            } = e;
                            n || (this.thenables = this.thenables.then(this.stopLspClient)), n && !r && t === i && (this.thenables = this.thenables.then(this.createLSPClient))
                        }
                    }
                    componentWillUnmount() {
                        this.didSaveTimeout && clearTimeout(this.didSaveTimeout), this.thenables.then(this.stopLspClient), this.disposables.forEach((e => e.dispose()))
                    }
                    loadLspClient() {
                        return Promise.all([t.e("modules-node_modules_krackjack_es_lsp_client_js"), t.e("lsp_client")]).then(t.bind(t, "kgwS"))
                    }
                    getLSPClientConfig() {
                        var {
                            userId: e,
                            lspEndpoint: n,
                            lspBaseUrl: t,
                            modelUri: i,
                            language: r,
                            syntax: o,
                            onCompletionReceive: a,
                            isReadonlyEditable: s,
                            fileName: l,
                            dbSchema: d
                        } = this.props;
                        return {
                            userId: e,
                            lspBaseUrl: t,
                            lspEndpoint: n,
                            modelUri: i,
                            language: o || r,
                            selectedLanguage: r,
                            isReadonlyEditable: s,
                            fileName: l,
                            dbSchema: d,
                            proxyInitialize: this.proxyLspInitialize,
                            proxySendRequest: a ? this.proxyLspSendRequest : null,
                            onLspError: this.onLspError,
                            onLspClose: this.onLspClose,
                            onLspConnect: this.onLspConnect,
                            onLspDisconnect: this.onLspDisconnect,
                            onConnect: this.onWSConnect,
                            onMessage: this.onWSMessage,
                            onClose: this.onWSClose,
                            onError: this.onWSError,
                            onLspLog: this.onWSLog
                        }
                    }
                    render() {
                        var n = this.props,
                            {
                                enableAutoComplete: t,
                                lspBaseUrl: i,
                                lspEndpoint: r,
                                onCompletionReceive: o,
                                onLspWebsocketChange: a
                            } = n,
                            s = (0, N.Z)(n, U);
                        return l().createElement(e, (0, A.Z)({}, s, {
                            editorDidMount: this.editorDidMount,
                            cleanUpLsp: this.stopLspClient
                        }))
                    }
                }, (0, a.Z)(n, "displayName", "withLsp(".concat((0, f.Gf)(e), ")")), (0, a.Z)(n, "defaultProps", {
                    editorDidMount: h(),
                    enableAutoComplete: !1,
                    lspBaseUrl: "hrc.suggest.hackerrank.com",
                    lspEndpoint: "",
                    onCompletionReceive: null,
                    modelUri: "file:///workspace",
                    syntax: "",
                    dbSchema: "",
                    onLspWebsocketChange: h()
                }), n
            };
            var W = t("NbpS"),
                J = t("urCt"),
                H = t("ueDI"),
                V = t("upBI"),
                Y = t("vKNY"),
                G = t("+XdK"),
                K = Object.freeze({
                    [D.I9.LOADING]: {
                        Icon: W.Z,
                        className: "loading"
                    },
                    [D.I9.READY]: {
                        Icon: J.Z,
                        className: "ready"
                    },
                    [D.I9.ERROR]: {
                        Icon: H.Z,
                        className: "error"
                    },
                    [D.I9.DISABLED]: {
                        Icon: V.Z,
                        className: "disabled"
                    },
                    [D.I9.NOT_SUPPORTED]: {
                        Icon: V.Z,
                        className: "alert"
                    }
                });

            function q(e) {
                var {
                    status: n,
                    language: t,
                    showAutocompleteStatus: i,
                    tooltipPosition: r,
                    t: o
                } = e, a = {
                    height: "1em",
                    width: "1em"
                }, s = K[n], d = o("autocomplete.".concat(n), {
                    language: t
                }), c = o("autocomplete.".concat(n, "_tooltip"), {
                    language: t
                });
                return l().createElement("span", {
                    className: "autocomplete-status",
                    "data-lsp-state": n,
                    "aria-atomic": "true",
                    role: "status"
                }, i ? l().createElement(G.ZP, {
                    content: c,
                    align: r,
                    id: "autocomplete-tooltip"
                }, l().createElement("i", {
                    className: "autocomplete-status--".concat(s.className)
                }, l().createElement(s.Icon, (0, A.Z)({}, a, {
                    "aria-label": "".concat(s.className, " icon"),
                    role: "button",
                    tabIndex: 0,
                    "aria-describedby": "autocomplete-tooltip"
                })))) : null, l().createElement("span", {
                    className: "autocomplete-status__text".concat(i ? " autocomplete-status__text--".concat(s.className) : "")
                }, d), !i && l().createElement(G.ZP, {
                    content: c,
                    align: r,
                    id: "autocomplete-tooltip"
                }, l().createElement(Y.Z, (0, A.Z)({}, a, {
                    tabIndex: 0,
                    "aria-label": "Info icon",
                    role: "button",
                    "aria-describedby": "autocomplete-tooltip"
                }))))
            }
            q.defaultProps = {
                status: D.I9.NOT_SUPPORTED,
                t: f.K3,
                showAutocompleteStatus: !1,
                tooltipPosition: "bottom"
            };
            var z = t("vnq4");
            const X = {
                "net.d.ts": "\ndeclare module 'node:net' {\n    export * from 'net';\n}\n\ndeclare module 'net' {\n    import * as stream from 'node:stream';\n    import EventEmitter = require('node:events');\n    import * as dns from 'node:dns';\n\n    type LookupFunction = (\n        hostname: string,\n        options: dns.LookupOneOptions,\n        callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void,\n    ) => void;\n\n    interface AddressInfo {\n        address: string;\n        family: string;\n        port: number;\n    }\n\n    interface SocketConstructorOpts {\n        fd?: number;\n        allowHalfOpen?: boolean;\n        readable?: boolean;\n        writable?: boolean;\n    }\n\n    interface OnReadOpts {\n        buffer: Uint8Array | (() => Uint8Array);\n        /**\n         * This function is called for every chunk of incoming data.\n         * Two arguments are passed to it: the number of bytes written to buffer and a reference to buffer.\n         * Return false from this function to implicitly pause() the socket.\n         */\n        callback(bytesWritten: number, buf: Uint8Array): boolean;\n    }\n\n    interface ConnectOpts {\n        /**\n         * If specified, incoming data is stored in a single buffer and passed to the supplied callback when data arrives on the socket.\n         * Note: this will cause the streaming functionality to not provide any data, however events like 'error', 'end', and 'close' will\n         * still be emitted as normal and methods like pause() and resume() will also behave as expected.\n         */\n        onread?: OnReadOpts;\n    }\n\n    interface TcpSocketConnectOpts extends ConnectOpts {\n        port: number;\n        host?: string;\n        localAddress?: string;\n        localPort?: number;\n        hints?: number;\n        family?: number;\n        lookup?: LookupFunction;\n    }\n\n    interface IpcSocketConnectOpts extends ConnectOpts {\n        path: string;\n    }\n\n    type SocketConnectOpts = TcpSocketConnectOpts | IpcSocketConnectOpts;\n\n    class Socket extends stream.Duplex {\n        constructor(options?: SocketConstructorOpts);\n\n        // Extended base methods\n        write(buffer: Uint8Array | string, cb?: (err?: Error) => void): boolean;\n        write(str: Uint8Array | string, encoding?: BufferEncoding, cb?: (err?: Error) => void): boolean;\n\n        connect(options: SocketConnectOpts, connectionListener?: () => void): this;\n        connect(port: number, host: string, connectionListener?: () => void): this;\n        connect(port: number, connectionListener?: () => void): this;\n        connect(path: string, connectionListener?: () => void): this;\n\n        setEncoding(encoding?: BufferEncoding): this;\n        pause(): this;\n        resume(): this;\n        setTimeout(timeout: number, callback?: () => void): this;\n        setNoDelay(noDelay?: boolean): this;\n        setKeepAlive(enable?: boolean, initialDelay?: number): this;\n        address(): AddressInfo | {};\n        unref(): this;\n        ref(): this;\n\n        /** @deprecated since v14.6.0 - Use ".concat("`writableLength`", ' instead. */\n        readonly bufferSize: number;\n        readonly bytesRead: number;\n        readonly bytesWritten: number;\n        readonly connecting: boolean;\n        readonly destroyed: boolean;\n        readonly localAddress: string;\n        readonly localPort: number;\n        readonly remoteAddress?: string;\n        readonly remoteFamily?: string;\n        readonly remotePort?: number;\n\n        // Extended base methods\n        end(cb?: () => void): void;\n        end(buffer: Uint8Array | string, cb?: () => void): void;\n        end(str: Uint8Array | string, encoding?: BufferEncoding, cb?: () => void): void;\n\n        /**\n         * events.EventEmitter\n         *   1. close\n         *   2. connect\n         *   3. data\n         *   4. drain\n         *   5. end\n         *   6. error\n         *   7. lookup\n         *   8. timeout\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "close", listener: (had_error: boolean) => void): this;\n        addListener(event: "connect", listener: () => void): this;\n        addListener(event: "data", listener: (data: Buffer) => void): this;\n        addListener(event: "drain", listener: () => void): this;\n        addListener(event: "end", listener: () => void): this;\n        addListener(event: "error", listener: (err: Error) => void): this;\n        addListener(event: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        addListener(event: "timeout", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "close", had_error: boolean): boolean;\n        emit(event: "connect"): boolean;\n        emit(event: "data", data: Buffer): boolean;\n        emit(event: "drain"): boolean;\n        emit(event: "end"): boolean;\n        emit(event: "error", err: Error): boolean;\n        emit(event: "lookup", err: Error, address: string, family: string | number, host: string): boolean;\n        emit(event: "timeout"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "close", listener: (had_error: boolean) => void): this;\n        on(event: "connect", listener: () => void): this;\n        on(event: "data", listener: (data: Buffer) => void): this;\n        on(event: "drain", listener: () => void): this;\n        on(event: "end", listener: () => void): this;\n        on(event: "error", listener: (err: Error) => void): this;\n        on(event: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        on(event: "timeout", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "close", listener: (had_error: boolean) => void): this;\n        once(event: "connect", listener: () => void): this;\n        once(event: "data", listener: (data: Buffer) => void): this;\n        once(event: "drain", listener: () => void): this;\n        once(event: "end", listener: () => void): this;\n        once(event: "error", listener: (err: Error) => void): this;\n        once(event: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        once(event: "timeout", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "close", listener: (had_error: boolean) => void): this;\n        prependListener(event: "connect", listener: () => void): this;\n        prependListener(event: "data", listener: (data: Buffer) => void): this;\n        prependListener(event: "drain", listener: () => void): this;\n        prependListener(event: "end", listener: () => void): this;\n        prependListener(event: "error", listener: (err: Error) => void): this;\n        prependListener(event: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        prependListener(event: "timeout", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "close", listener: (had_error: boolean) => void): this;\n        prependOnceListener(event: "connect", listener: () => void): this;\n        prependOnceListener(event: "data", listener: (data: Buffer) => void): this;\n        prependOnceListener(event: "drain", listener: () => void): this;\n        prependOnceListener(event: "end", listener: () => void): this;\n        prependOnceListener(event: "error", listener: (err: Error) => void): this;\n        prependOnceListener(event: "lookup", listener: (err: Error, address: string, family: string | number, host: string) => void): this;\n        prependOnceListener(event: "timeout", listener: () => void): this;\n    }\n\n    interface ListenOptions {\n        port?: number;\n        host?: string;\n        backlog?: number;\n        path?: string;\n        exclusive?: boolean;\n        readableAll?: boolean;\n        writableAll?: boolean;\n        /**\n         * @default false\n         */\n        ipv6Only?: boolean;\n    }\n\n    interface ServerOpts {\n        /**\n         * Indicates whether half-opened TCP connections are allowed. __Default:__ ', "`false`", ".\n         */\n        allowHalfOpen?: boolean;\n\n        /**\n         * Indicates whether the socket should be paused on incoming connections. __Default:__ ", "`false`", '.\n         */\n        pauseOnConnect?: boolean;\n    }\n\n    // https://github.com/nodejs/node/blob/master/lib/net.js\n    class Server extends EventEmitter {\n        constructor(connectionListener?: (socket: Socket) => void);\n        constructor(options?: ServerOpts, connectionListener?: (socket: Socket) => void);\n\n        listen(port?: number, hostname?: string, backlog?: number, listeningListener?: () => void): this;\n        listen(port?: number, hostname?: string, listeningListener?: () => void): this;\n        listen(port?: number, backlog?: number, listeningListener?: () => void): this;\n        listen(port?: number, listeningListener?: () => void): this;\n        listen(path: string, backlog?: number, listeningListener?: () => void): this;\n        listen(path: string, listeningListener?: () => void): this;\n        listen(options: ListenOptions, listeningListener?: () => void): this;\n        listen(handle: any, backlog?: number, listeningListener?: () => void): this;\n        listen(handle: any, listeningListener?: () => void): this;\n        close(callback?: (err?: Error) => void): this;\n        address(): AddressInfo | string | null;\n        getConnections(cb: (error: Error | null, count: number) => void): void;\n        ref(): this;\n        unref(): this;\n        maxConnections: number;\n        connections: number;\n        listening: boolean;\n\n        /**\n         * events.EventEmitter\n         *   1. close\n         *   2. connection\n         *   3. error\n         *   4. listening\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "close", listener: () => void): this;\n        addListener(event: "connection", listener: (socket: Socket) => void): this;\n        addListener(event: "error", listener: (err: Error) => void): this;\n        addListener(event: "listening", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "close"): boolean;\n        emit(event: "connection", socket: Socket): boolean;\n        emit(event: "error", err: Error): boolean;\n        emit(event: "listening"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "close", listener: () => void): this;\n        on(event: "connection", listener: (socket: Socket) => void): this;\n        on(event: "error", listener: (err: Error) => void): this;\n        on(event: "listening", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "close", listener: () => void): this;\n        once(event: "connection", listener: (socket: Socket) => void): this;\n        once(event: "error", listener: (err: Error) => void): this;\n        once(event: "listening", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "close", listener: () => void): this;\n        prependListener(event: "connection", listener: (socket: Socket) => void): this;\n        prependListener(event: "error", listener: (err: Error) => void): this;\n        prependListener(event: "listening", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "close", listener: () => void): this;\n        prependOnceListener(event: "connection", listener: (socket: Socket) => void): this;\n        prependOnceListener(event: "error", listener: (err: Error) => void): this;\n        prependOnceListener(event: "listening", listener: () => void): this;\n    }\n\n    interface TcpNetConnectOpts extends TcpSocketConnectOpts, SocketConstructorOpts {\n        timeout?: number;\n    }\n\n    interface IpcNetConnectOpts extends IpcSocketConnectOpts, SocketConstructorOpts {\n        timeout?: number;\n    }\n\n    type NetConnectOpts = TcpNetConnectOpts | IpcNetConnectOpts;\n\n    function createServer(connectionListener?: (socket: Socket) => void): Server;\n    function createServer(options?: ServerOpts, connectionListener?: (socket: Socket) => void): Server;\n    function connect(options: NetConnectOpts, connectionListener?: () => void): Socket;\n    function connect(port: number, host?: string, connectionListener?: () => void): Socket;\n    function connect(path: string, connectionListener?: () => void): Socket;\n    function createConnection(options: NetConnectOpts, connectionListener?: () => void): Socket;\n    function createConnection(port: number, host?: string, connectionListener?: () => void): Socket;\n    function createConnection(path: string, connectionListener?: () => void): Socket;\n    function isIP(input: string): number;\n    function isIPv4(input: string): boolean;\n    function isIPv6(input: string): boolean;\n}'),
                "process.d.ts": '\ndeclare module \'node:process\' {\n    export = process;\n}\n\ndeclare module \'process\' {\n    import * as tty from \'node:tty\';\n\n    global {\n        var process: NodeJS.Process;\n\n        namespace NodeJS {\n            // this namespace merge is here because these are specifically used\n            // as the type for process.stdin, process.stdout, and process.stderr.\n            // they can\'t live in tty.d.ts because we need to disambiguate the imported name.\n            interface ReadStream extends tty.ReadStream {}\n            interface WriteStream extends tty.WriteStream {}\n\n            interface MemoryUsage {\n                rss: number;\n                heapTotal: number;\n                heapUsed: number;\n                external: number;\n                arrayBuffers: number;\n            }\n\n            interface CpuUsage {\n                user: number;\n                system: number;\n            }\n\n            interface ProcessRelease {\n                name: string;\n                sourceUrl?: string;\n                headersUrl?: string;\n                libUrl?: string;\n                lts?: string;\n            }\n\n            interface ProcessVersions extends Dict<string> {\n                http_parser: string;\n                node: string;\n                v8: string;\n                ares: string;\n                uv: string;\n                zlib: string;\n                modules: string;\n                openssl: string;\n            }\n\n            type Platform = \'aix\'\n                | \'android\'\n                | \'darwin\'\n                | \'freebsd\'\n                | \'linux\'\n                | \'openbsd\'\n                | \'sunos\'\n                | \'win32\'\n                | \'cygwin\'\n                | \'netbsd\';\n\n            type Signals =\n                "SIGABRT" | "SIGALRM" | "SIGBUS" | "SIGCHLD" | "SIGCONT" | "SIGFPE" | "SIGHUP" | "SIGILL" | "SIGINT" | "SIGIO" |\n                "SIGIOT" | "SIGKILL" | "SIGPIPE" | "SIGPOLL" | "SIGPROF" | "SIGPWR" | "SIGQUIT" | "SIGSEGV" | "SIGSTKFLT" |\n                "SIGSTOP" | "SIGSYS" | "SIGTERM" | "SIGTRAP" | "SIGTSTP" | "SIGTTIN" | "SIGTTOU" | "SIGUNUSED" | "SIGURG" |\n                "SIGUSR1" | "SIGUSR2" | "SIGVTALRM" | "SIGWINCH" | "SIGXCPU" | "SIGXFSZ" | "SIGBREAK" | "SIGLOST" | "SIGINFO";\n\n            type MultipleResolveType = \'resolve\' | \'reject\';\n\n            type BeforeExitListener = (code: number) => void;\n            type DisconnectListener = () => void;\n            type ExitListener = (code: number) => void;\n            type RejectionHandledListener = (promise: Promise<any>) => void;\n            type UncaughtExceptionListener = (error: Error) => void;\n            type UnhandledRejectionListener = (reason: {} | null | undefined, promise: Promise<any>) => void;\n            type WarningListener = (warning: Error) => void;\n            type MessageListener = (message: any, sendHandle: any) => void;\n            type SignalsListener = (signal: Signals) => void;\n            type NewListenerListener = (type: string | symbol, listener: (...args: any[]) => void) => void;\n            type RemoveListenerListener = (type: string | symbol, listener: (...args: any[]) => void) => void;\n            type MultipleResolveListener = (type: MultipleResolveType, promise: Promise<any>, value: any) => void;\n\n            interface Socket extends ReadWriteStream {\n                isTTY?: true;\n            }\n\n            // Alias for compatibility\n            interface ProcessEnv extends Dict<string> {}\n\n            interface HRTime {\n                (time?: [number, number]): [number, number];\n                bigint(): bigint;\n            }\n\n            interface ProcessReport {\n                /**\n                 * Directory where the report is written.\n                 * working directory of the Node.js process.\n                 * @default \'\' indicating that reports are written to the current\n                 */\n                directory: string;\n\n                /**\n                 * Filename where the report is written.\n                 * The default value is the empty string.\n                 * @default \'\' the output filename will be comprised of a timestamp,\n                 * PID, and sequence number.\n                 */\n                filename: string;\n\n                /**\n                 * Returns a JSON-formatted diagnostic report for the running process.\n                 * The report\'s JavaScript stack trace is taken from err, if present.\n                 */\n                getReport(err?: Error): string;\n\n                /**\n                 * If true, a diagnostic report is generated on fatal errors,\n                 * such as out of memory errors or failed C++ assertions.\n                 * @default false\n                 */\n                reportOnFatalError: boolean;\n\n                /**\n                 * If true, a diagnostic report is generated when the process\n                 * receives the signal specified by process.report.signal.\n                 * @defaul false\n                 */\n                reportOnSignal: boolean;\n\n                /**\n                 * If true, a diagnostic report is generated on uncaught exception.\n                 * @default false\n                 */\n                reportOnUncaughtException: boolean;\n\n                /**\n                 * The signal used to trigger the creation of a diagnostic report.\n                 * @default \'SIGUSR2\'\n                 */\n                signal: Signals;\n\n                /**\n                 * Writes a diagnostic report to a file. If filename is not provided, the default filename\n                 * includes the date, time, PID, and a sequence number.\n                 * The report\'s JavaScript stack trace is taken from err, if present.\n                 *\n                 * @param fileName Name of the file where the report is written.\n                 * This should be a relative path, that will be appended to the directory specified in\n                 * '.concat("`process.report.directory`", ", or the current working directory of the Node.js process,\n                 * if unspecified.\n                 * @param error A custom error used for reporting the JavaScript stack.\n                 * @return Filename of the generated report.\n                 */\n                writeReport(fileName?: string): string;\n                writeReport(error?: Error): string;\n                writeReport(fileName?: string, err?: Error): string;\n            }\n\n            interface ResourceUsage {\n                fsRead: number;\n                fsWrite: number;\n                involuntaryContextSwitches: number;\n                ipcReceived: number;\n                ipcSent: number;\n                majorPageFault: number;\n                maxRSS: number;\n                minorPageFault: number;\n                sharedMemorySize: number;\n                signalsCount: number;\n                swappedOut: number;\n                systemCPUTime: number;\n                unsharedDataSize: number;\n                unsharedStackSize: number;\n                userCPUTime: number;\n                voluntaryContextSwitches: number;\n            }\n\n            interface Process extends EventEmitter {\n                /**\n                 * Can also be a tty.WriteStream, not typed due to limitations.\n                 */\n                stdout: WriteStream & {\n                    fd: 1;\n                };\n                /**\n                 * Can also be a tty.WriteStream, not typed due to limitations.\n                 */\n                stderr: WriteStream & {\n                    fd: 2;\n                };\n                stdin: ReadStream & {\n                    fd: 0;\n                };\n                openStdin(): Socket;\n                argv: string[];\n                argv0: string;\n                execArgv: string[];\n                execPath: string;\n                abort(): never;\n                chdir(directory: string): void;\n                cwd(): string;\n                debugPort: number;\n                emitWarning(warning: string | Error, name?: string, ctor?: Function): void;\n                env: ProcessEnv;\n                exit(code?: number): never;\n                exitCode?: number;\n                getgid(): number;\n                setgid(id: number | string): void;\n                getuid(): number;\n                setuid(id: number | string): void;\n                geteuid(): number;\n                seteuid(id: number | string): void;\n                getegid(): number;\n                setegid(id: number | string): void;\n                getgroups(): number[];\n                setgroups(groups: ReadonlyArray<string | number>): void;\n                setUncaughtExceptionCaptureCallback(cb: ((err: Error) => void) | null): void;\n                hasUncaughtExceptionCaptureCallback(): boolean;\n                version: string;\n                versions: ProcessVersions;\n                config: {\n                    target_defaults: {\n                        cflags: any[];\n                        default_configuration: string;\n                        defines: string[];\n                        include_dirs: string[];\n                        libraries: string[];\n                    };\n                    variables: {\n                        clang: number;\n                        host_arch: string;\n                        node_install_npm: boolean;\n                        node_install_waf: boolean;\n                        node_prefix: string;\n                        node_shared_openssl: boolean;\n                        node_shared_v8: boolean;\n                        node_shared_zlib: boolean;\n                        node_use_dtrace: boolean;\n                        node_use_etw: boolean;\n                        node_use_openssl: boolean;\n                        target_arch: string;\n                        v8_no_strict_aliasing: number;\n                        v8_use_snapshot: boolean;\n                        visibility: string;\n                    };\n                };\n                kill(pid: number, signal?: string | number): true;\n                pid: number;\n                ppid: number;\n                title: string;\n                arch: string;\n                platform: Platform;\n                /** @deprecated since v14.0.0 - use ", "`require.main`", " instead. */\n                mainModule?: Module;\n                memoryUsage(): MemoryUsage;\n                cpuUsage(previousValue?: CpuUsage): CpuUsage;\n                nextTick(callback: Function, ...args: any[]): void;\n                release: ProcessRelease;\n                features: {\n                    inspector: boolean;\n                    debug: boolean;\n                    uv: boolean;\n                    ipv6: boolean;\n                    tls_alpn: boolean;\n                    tls_sni: boolean;\n                    tls_ocsp: boolean;\n                    tls: boolean;\n                };\n                /**\n                 * @deprecated since v14.0.0 - Calling process.umask() with no argument causes\n                 * the process-wide umask to be written twice. This introduces a race condition between threads,\n                 * and is a potential security vulnerability. There is no safe, cross-platform alternative API.\n                 */\n                umask(): number;\n                /**\n                 * Can only be set if not in worker thread.\n                 */\n                umask(mask: string | number): number;\n                uptime(): number;\n                hrtime: HRTime;\n                domain: Domain;\n\n                // Worker\n                send?(message: any, sendHandle?: any, options?: { swallowErrors?: boolean}, callback?: (error: Error | null) => void): boolean;\n                disconnect(): void;\n                connected: boolean;\n\n                /**\n                 * The ", "`process.allowedNodeEnvironmentFlags`", " property is a special,\n                 * read-only ", "`Set`", " of flags allowable within the [", "`NODE_OPTIONS`", "][]\n                 * environment variable.\n                 */\n                allowedNodeEnvironmentFlags: ReadonlySet<string>;\n\n                /**\n                 * Only available with ", "`--experimental - report`", '\n                 */\n                report?: ProcessReport;\n\n                resourceUsage(): ResourceUsage;\n\n                traceDeprecation: boolean;\n\n                /* EventEmitter */\n                addListener(event: "beforeExit", listener: BeforeExitListener): this;\n                addListener(event: "disconnect", listener: DisconnectListener): this;\n                addListener(event: "exit", listener: ExitListener): this;\n                addListener(event: "rejectionHandled", listener: RejectionHandledListener): this;\n                addListener(event: "uncaughtException", listener: UncaughtExceptionListener): this;\n                addListener(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;\n                addListener(event: "unhandledRejection", listener: UnhandledRejectionListener): this;\n                addListener(event: "warning", listener: WarningListener): this;\n                addListener(event: "message", listener: MessageListener): this;\n                addListener(event: Signals, listener: SignalsListener): this;\n                addListener(event: "newListener", listener: NewListenerListener): this;\n                addListener(event: "removeListener", listener: RemoveListenerListener): this;\n                addListener(event: "multipleResolves", listener: MultipleResolveListener): this;\n\n                emit(event: "beforeExit", code: number): boolean;\n                emit(event: "disconnect"): boolean;\n                emit(event: "exit", code: number): boolean;\n                emit(event: "rejectionHandled", promise: Promise<any>): boolean;\n                emit(event: "uncaughtException", error: Error): boolean;\n                emit(event: "uncaughtExceptionMonitor", error: Error): boolean;\n                emit(event: "unhandledRejection", reason: any, promise: Promise<any>): boolean;\n                emit(event: "warning", warning: Error): boolean;\n                emit(event: "message", message: any, sendHandle: any): this;\n                emit(event: Signals, signal: Signals): boolean;\n                emit(event: "newListener", eventName: string | symbol, listener: (...args: any[]) => void): this;\n                emit(event: "removeListener", eventName: string, listener: (...args: any[]) => void): this;\n                emit(event: "multipleResolves", listener: MultipleResolveListener): this;\n\n                on(event: "beforeExit", listener: BeforeExitListener): this;\n                on(event: "disconnect", listener: DisconnectListener): this;\n                on(event: "exit", listener: ExitListener): this;\n                on(event: "rejectionHandled", listener: RejectionHandledListener): this;\n                on(event: "uncaughtException", listener: UncaughtExceptionListener): this;\n                on(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;\n                on(event: "unhandledRejection", listener: UnhandledRejectionListener): this;\n                on(event: "warning", listener: WarningListener): this;\n                on(event: "message", listener: MessageListener): this;\n                on(event: Signals, listener: SignalsListener): this;\n                on(event: "newListener", listener: NewListenerListener): this;\n                on(event: "removeListener", listener: RemoveListenerListener): this;\n                on(event: "multipleResolves", listener: MultipleResolveListener): this;\n                on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n                once(event: "beforeExit", listener: BeforeExitListener): this;\n                once(event: "disconnect", listener: DisconnectListener): this;\n                once(event: "exit", listener: ExitListener): this;\n                once(event: "rejectionHandled", listener: RejectionHandledListener): this;\n                once(event: "uncaughtException", listener: UncaughtExceptionListener): this;\n                once(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;\n                once(event: "unhandledRejection", listener: UnhandledRejectionListener): this;\n                once(event: "warning", listener: WarningListener): this;\n                once(event: "message", listener: MessageListener): this;\n                once(event: Signals, listener: SignalsListener): this;\n                once(event: "newListener", listener: NewListenerListener): this;\n                once(event: "removeListener", listener: RemoveListenerListener): this;\n                once(event: "multipleResolves", listener: MultipleResolveListener): this;\n\n                prependListener(event: "beforeExit", listener: BeforeExitListener): this;\n                prependListener(event: "disconnect", listener: DisconnectListener): this;\n                prependListener(event: "exit", listener: ExitListener): this;\n                prependListener(event: "rejectionHandled", listener: RejectionHandledListener): this;\n                prependListener(event: "uncaughtException", listener: UncaughtExceptionListener): this;\n                prependListener(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;\n                prependListener(event: "unhandledRejection", listener: UnhandledRejectionListener): this;\n                prependListener(event: "warning", listener: WarningListener): this;\n                prependListener(event: "message", listener: MessageListener): this;\n                prependListener(event: Signals, listener: SignalsListener): this;\n                prependListener(event: "newListener", listener: NewListenerListener): this;\n                prependListener(event: "removeListener", listener: RemoveListenerListener): this;\n                prependListener(event: "multipleResolves", listener: MultipleResolveListener): this;\n\n                prependOnceListener(event: "beforeExit", listener: BeforeExitListener): this;\n                prependOnceListener(event: "disconnect", listener: DisconnectListener): this;\n                prependOnceListener(event: "exit", listener: ExitListener): this;\n                prependOnceListener(event: "rejectionHandled", listener: RejectionHandledListener): this;\n                prependOnceListener(event: "uncaughtException", listener: UncaughtExceptionListener): this;\n                prependOnceListener(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;\n                prependOnceListener(event: "unhandledRejection", listener: UnhandledRejectionListener): this;\n                prependOnceListener(event: "warning", listener: WarningListener): this;\n                prependOnceListener(event: "message", listener: MessageListener): this;\n                prependOnceListener(event: Signals, listener: SignalsListener): this;\n                prependOnceListener(event: "newListener", listener: NewListenerListener): this;\n                prependOnceListener(event: "removeListener", listener: RemoveListenerListener): this;\n                prependOnceListener(event: "multipleResolves", listener: MultipleResolveListener): this;\n\n                listeners(event: "beforeExit"): BeforeExitListener[];\n                listeners(event: "disconnect"): DisconnectListener[];\n                listeners(event: "exit"): ExitListener[];\n                listeners(event: "rejectionHandled"): RejectionHandledListener[];\n                listeners(event: "uncaughtException"): UncaughtExceptionListener[];\n                listeners(event: "uncaughtExceptionMonitor"): UncaughtExceptionListener[];\n                listeners(event: "unhandledRejection"): UnhandledRejectionListener[];\n                listeners(event: "warning"): WarningListener[];\n                listeners(event: "message"): MessageListener[];\n                listeners(event: Signals): SignalsListener[];\n                listeners(event: "newListener"): NewListenerListener[];\n                listeners(event: "removeListener"): RemoveListenerListener[];\n                listeners(event: "multipleResolves"): MultipleResolveListener[];\n            }\n\n            interface Global {\n                process: Process;\n            }\n        }\n    }\n\n    export = process;\n}'),
                "tty.d.ts": '\ndeclare module \'node:tty\' {\n    export * from \'tty\';\n}\n\ndeclare module \'tty\' {\n    import * as net from \'node:net\';\n\n    function isatty(fd: number): boolean;\n    class ReadStream extends net.Socket {\n        constructor(fd: number, options?: net.SocketConstructorOpts);\n        isRaw: boolean;\n        setRawMode(mode: boolean): this;\n        isTTY: boolean;\n    }\n    /**\n     * -1 - to the left from cursor\n     *  0 - the entire line\n     *  1 - to the right from cursor\n     */\n    type Direction = -1 | 0 | 1;\n    class WriteStream extends net.Socket {\n        constructor(fd: number);\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: "resize", listener: () => void): this;\n\n        emit(event: string | symbol, ...args: any[]): boolean;\n        emit(event: "resize"): boolean;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: "resize", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: "resize", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: "resize", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: "resize", listener: () => void): this;\n\n        /**\n         * Clears the current line of this WriteStream in a direction identified by '.concat("`dir`", ".\n         */\n        clearLine(dir: Direction, callback?: () => void): boolean;\n        /**\n         * Clears this ", "`WriteStream`", " from the current cursor down.\n         */\n        clearScreenDown(callback?: () => void): boolean;\n        /**\n         * Moves this WriteStream's cursor to the specified position.\n         */\n        cursorTo(x: number, y?: number, callback?: () => void): boolean;\n        cursorTo(x: number, callback: () => void): boolean;\n        /**\n         * Moves this WriteStream's cursor relative to its current position.\n         */\n        moveCursor(dx: number, dy: number, callback?: () => void): boolean;\n        /**\n         * @default ", "`process.env`", "\n         */\n        getColorDepth(env?: {}): number;\n        hasColors(depth?: number): boolean;\n        hasColors(env?: {}): boolean;\n        hasColors(depth: number, env?: {}): boolean;\n        getWindowSize(): [number, number];\n        columns: number;\n        rows: number;\n        isTTY: boolean;\n    }\n}"),
                "fs.d.ts": "declare module \"fs\" {\n    import * as stream from \"stream\";\n    import * as events from \"events\";\n    import { URL } from \"url\";\n\n    /**\n     * Valid types for path values in \"fs\".\n     */\n    type PathLike = string | Buffer | URL;\n\n    type NoParamCallback = (err: NodeJS.ErrnoException | null) => void;\n\n    interface StatsBase<T> {\n        isFile(): boolean;\n        isDirectory(): boolean;\n        isBlockDevice(): boolean;\n        isCharacterDevice(): boolean;\n        isSymbolicLink(): boolean;\n        isFIFO(): boolean;\n        isSocket(): boolean;\n\n        dev: T;\n        ino: T;\n        mode: T;\n        nlink: T;\n        uid: T;\n        gid: T;\n        rdev: T;\n        size: T;\n        blksize: T;\n        blocks: T;\n        atimeMs: T;\n        mtimeMs: T;\n        ctimeMs: T;\n        birthtimeMs: T;\n        atime: Date;\n        mtime: Date;\n        ctime: Date;\n        birthtime: Date;\n    }\n\n    interface Stats extends StatsBase<number> {\n    }\n\n    class Stats {\n    }\n\n    class Dirent {\n        isFile(): boolean;\n        isDirectory(): boolean;\n        isBlockDevice(): boolean;\n        isCharacterDevice(): boolean;\n        isSymbolicLink(): boolean;\n        isFIFO(): boolean;\n        isSocket(): boolean;\n        name: string;\n    }\n\n    /**\n     * A class representing a directory stream.\n     */\n    class Dir {\n        readonly path: string;\n\n        /**\n         * Asynchronously iterates over the directory via 'readdir(3)' until all entries have been read.\n         */\n        [Symbol.asyncIterator](): AsyncIterableIterator<Dirent>;\n\n        /**\n         * Asynchronously close the directory's underlying resource handle.\n         * Subsequent reads will result in errors.\n         */\n        close(): Promise<void>;\n        close(cb: NoParamCallback): void;\n\n        /**\n         * Synchronously close the directory's underlying resource handle.\n         * Subsequent reads will result in errors.\n         */\n        closeSync(): void;\n\n        /**\n         * Asynchronously read the next directory entry via 'readdir(3)' as an 'Dirent'.\n         * After the read is completed, a value is returned that will be resolved with an 'Dirent', or 'null' if there are no more directory entries to read.\n         * Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms.\n         */\n        read(): Promise<Dirent | null>;\n        read(cb: (err: NodeJS.ErrnoException | null, dirEnt: Dirent | null) => void): void;\n\n        /**\n         * Synchronously read the next directory entry via 'readdir(3)' as a 'Dirent'.\n         * If there are no more directory entries to read, null will be returned.\n         * Directory entries returned by this function are in no particular order as provided by the operating system's underlying directory mechanisms.\n         */\n        readSync(): Dirent;\n    }\n\n    interface FSWatcher extends events.EventEmitter {\n        close(): void;\n\n        /**\n         * events.EventEmitter\n         *   1. change\n         *   2. error\n         */\n        addListener(event: string, listener: (...args: any[]) => void): this;\n        addListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        addListener(event: \"error\", listener: (error: Error) => void): this;\n        addListener(event: \"close\", listener: () => void): this;\n\n        on(event: string, listener: (...args: any[]) => void): this;\n        on(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        on(event: \"error\", listener: (error: Error) => void): this;\n        on(event: \"close\", listener: () => void): this;\n\n        once(event: string, listener: (...args: any[]) => void): this;\n        once(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        once(event: \"error\", listener: (error: Error) => void): this;\n        once(event: \"close\", listener: () => void): this;\n\n        prependListener(event: string, listener: (...args: any[]) => void): this;\n        prependListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        prependListener(event: \"error\", listener: (error: Error) => void): this;\n        prependListener(event: \"close\", listener: () => void): this;\n\n        prependOnceListener(event: string, listener: (...args: any[]) => void): this;\n        prependOnceListener(event: \"change\", listener: (eventType: string, filename: string | Buffer) => void): this;\n        prependOnceListener(event: \"error\", listener: (error: Error) => void): this;\n        prependOnceListener(event: \"close\", listener: () => void): this;\n    }\n\n    class ReadStream extends stream.Readable {\n        close(): void;\n        bytesRead: number;\n        path: string | Buffer;\n        pending: boolean;\n\n        /**\n         * events.EventEmitter\n         *   1. open\n         *   2. close\n         *   3. ready\n         */\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        addListener(event: \"end\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"open\", listener: (fd: number) => void): this;\n        addListener(event: \"pause\", listener: () => void): this;\n        addListener(event: \"readable\", listener: () => void): this;\n        addListener(event: \"ready\", listener: () => void): this;\n        addListener(event: \"resume\", listener: () => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        on(event: \"end\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"open\", listener: (fd: number) => void): this;\n        on(event: \"pause\", listener: () => void): this;\n        on(event: \"readable\", listener: () => void): this;\n        on(event: \"ready\", listener: () => void): this;\n        on(event: \"resume\", listener: () => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        once(event: \"end\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"open\", listener: (fd: number) => void): this;\n        once(event: \"pause\", listener: () => void): this;\n        once(event: \"readable\", listener: () => void): this;\n        once(event: \"ready\", listener: () => void): this;\n        once(event: \"resume\", listener: () => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        prependListener(event: \"end\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"open\", listener: (fd: number) => void): this;\n        prependListener(event: \"pause\", listener: () => void): this;\n        prependListener(event: \"readable\", listener: () => void): this;\n        prependListener(event: \"ready\", listener: () => void): this;\n        prependListener(event: \"resume\", listener: () => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"data\", listener: (chunk: Buffer | string) => void): this;\n        prependOnceListener(event: \"end\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"open\", listener: (fd: number) => void): this;\n        prependOnceListener(event: \"pause\", listener: () => void): this;\n        prependOnceListener(event: \"readable\", listener: () => void): this;\n        prependOnceListener(event: \"ready\", listener: () => void): this;\n        prependOnceListener(event: \"resume\", listener: () => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n\n    class WriteStream extends stream.Writable {\n        close(): void;\n        bytesWritten: number;\n        path: string | Buffer;\n        pending: boolean;\n\n        /**\n         * events.EventEmitter\n         *   1. open\n         *   2. close\n         *   3. ready\n         */\n        addListener(event: \"close\", listener: () => void): this;\n        addListener(event: \"drain\", listener: () => void): this;\n        addListener(event: \"error\", listener: (err: Error) => void): this;\n        addListener(event: \"finish\", listener: () => void): this;\n        addListener(event: \"open\", listener: (fd: number) => void): this;\n        addListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: \"ready\", listener: () => void): this;\n        addListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        on(event: \"close\", listener: () => void): this;\n        on(event: \"drain\", listener: () => void): this;\n        on(event: \"error\", listener: (err: Error) => void): this;\n        on(event: \"finish\", listener: () => void): this;\n        on(event: \"open\", listener: (fd: number) => void): this;\n        on(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        on(event: \"ready\", listener: () => void): this;\n        on(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        once(event: \"close\", listener: () => void): this;\n        once(event: \"drain\", listener: () => void): this;\n        once(event: \"error\", listener: (err: Error) => void): this;\n        once(event: \"finish\", listener: () => void): this;\n        once(event: \"open\", listener: (fd: number) => void): this;\n        once(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        once(event: \"ready\", listener: () => void): this;\n        once(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependListener(event: \"close\", listener: () => void): this;\n        prependListener(event: \"drain\", listener: () => void): this;\n        prependListener(event: \"error\", listener: (err: Error) => void): this;\n        prependListener(event: \"finish\", listener: () => void): this;\n        prependListener(event: \"open\", listener: (fd: number) => void): this;\n        prependListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: \"ready\", listener: () => void): this;\n        prependListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n        prependOnceListener(event: \"close\", listener: () => void): this;\n        prependOnceListener(event: \"drain\", listener: () => void): this;\n        prependOnceListener(event: \"error\", listener: (err: Error) => void): this;\n        prependOnceListener(event: \"finish\", listener: () => void): this;\n        prependOnceListener(event: \"open\", listener: (fd: number) => void): this;\n        prependOnceListener(event: \"pipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: \"ready\", listener: () => void): this;\n        prependOnceListener(event: \"unpipe\", listener: (src: stream.Readable) => void): this;\n        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n    }\n\n    /**\n     * Asynchronous rename(2) - Change the name or location of a file or directory.\n     * @param oldPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * @param newPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function rename(oldPath: PathLike, newPath: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace rename {\n        /**\n         * Asynchronous rename(2) - Change the name or location of a file or directory.\n         * @param oldPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         * @param newPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(oldPath: PathLike, newPath: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous rename(2) - Change the name or location of a file or directory.\n     * @param oldPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * @param newPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function renameSync(oldPath: PathLike, newPath: PathLike): void;\n\n    /**\n     * Asynchronous truncate(2) - Truncate a file to a specified length.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param len If not specified, defaults to '0'.\n     */\n    function truncate(path: PathLike, len: number | undefined | null, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronous truncate(2) - Truncate a file to a specified length.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function truncate(path: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace truncate {\n        /**\n         * Asynchronous truncate(2) - Truncate a file to a specified length.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param len If not specified, defaults to '0'.\n         */\n        function __promisify__(path: PathLike, len?: number | null): Promise<void>;\n    }\n\n    /**\n     * Synchronous truncate(2) - Truncate a file to a specified length.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param len If not specified, defaults to '0'.\n     */\n    function truncateSync(path: PathLike, len?: number | null): void;\n\n    /**\n     * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n     * @param fd A file descriptor.\n     * @param len If not specified, defaults to '0'.\n     */\n    function ftruncate(fd: number, len: number | undefined | null, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n     * @param fd A file descriptor.\n     */\n    function ftruncate(fd: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace ftruncate {\n        /**\n         * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n         * @param fd A file descriptor.\n         * @param len If not specified, defaults to '0'.\n         */\n        function __promisify__(fd: number, len?: number | null): Promise<void>;\n    }\n\n    /**\n     * Synchronous ftruncate(2) - Truncate a file to a specified length.\n     * @param fd A file descriptor.\n     * @param len If not specified, defaults to '0'.\n     */\n    function ftruncateSync(fd: number, len?: number | null): void;\n\n    /**\n     * Asynchronous chown(2) - Change ownership of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function chown(path: PathLike, uid: number, gid: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace chown {\n        /**\n         * Asynchronous chown(2) - Change ownership of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous chown(2) - Change ownership of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function chownSync(path: PathLike, uid: number, gid: number): void;\n\n    /**\n     * Asynchronous fchown(2) - Change ownership of a file.\n     * @param fd A file descriptor.\n     */\n    function fchown(fd: number, uid: number, gid: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fchown {\n        /**\n         * Asynchronous fchown(2) - Change ownership of a file.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number, uid: number, gid: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fchown(2) - Change ownership of a file.\n     * @param fd A file descriptor.\n     */\n    function fchownSync(fd: number, uid: number, gid: number): void;\n\n    /**\n     * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function lchown(path: PathLike, uid: number, gid: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lchown {\n        /**\n         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function lchownSync(path: PathLike, uid: number, gid: number): void;\n\n    /**\n     * Asynchronous chmod(2) - Change permissions of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function chmod(path: PathLike, mode: string | number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace chmod {\n        /**\n         * Asynchronous chmod(2) - Change permissions of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(path: PathLike, mode: string | number): Promise<void>;\n    }\n\n    /**\n     * Synchronous chmod(2) - Change permissions of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function chmodSync(path: PathLike, mode: string | number): void;\n\n    /**\n     * Asynchronous fchmod(2) - Change permissions of a file.\n     * @param fd A file descriptor.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function fchmod(fd: number, mode: string | number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fchmod {\n        /**\n         * Asynchronous fchmod(2) - Change permissions of a file.\n         * @param fd A file descriptor.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(fd: number, mode: string | number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fchmod(2) - Change permissions of a file.\n     * @param fd A file descriptor.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function fchmodSync(fd: number, mode: string | number): void;\n\n    /**\n     * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function lchmod(path: PathLike, mode: string | number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lchmod {\n        /**\n         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function __promisify__(path: PathLike, mode: string | number): Promise<void>;\n    }\n\n    /**\n     * Synchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n     */\n    function lchmodSync(path: PathLike, mode: string | number): void;\n\n    /**\n     * Asynchronous stat(2) - Get file status.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function stat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;\n    function stat(path: PathLike, options: StatOptions & { bigint?: false } | undefined, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;\n    function stat(path: PathLike, options: StatOptions & { bigint: true }, callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void): void;\n    function stat(path: PathLike, options: StatOptions | undefined, callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace stat {\n        /**\n         * Asynchronous stat(2) - Get file status.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function __promisify__(path: PathLike, options?: StatOptions & { bigint?: false }): Promise<Stats>;\n        function __promisify__(path: PathLike, options: StatOptions & { bigint: true }): Promise<BigIntStats>;\n        function __promisify__(path: PathLike, options?: StatOptions): Promise<Stats | BigIntStats>;\n    }\n\n    /**\n     * Synchronous stat(2) - Get file status.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function statSync(path: PathLike, options?: StatOptions & { bigint?: false }): Stats;\n    function statSync(path: PathLike, options: StatOptions & { bigint: true }): BigIntStats;\n    function statSync(path: PathLike, options?: StatOptions): Stats | BigIntStats;\n\n    /**\n     * Asynchronous fstat(2) - Get file status.\n     * @param fd A file descriptor.\n     */\n    function fstat(fd: number, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;\n    function fstat(fd: number, options: StatOptions & { bigint?: false } | undefined, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;\n    function fstat(fd: number, options: StatOptions & { bigint: true }, callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void): void;\n    function fstat(fd: number, options: StatOptions | undefined, callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fstat {\n        /**\n         * Asynchronous fstat(2) - Get file status.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number, options?: StatOptions & { bigint?: false }): Promise<Stats>;\n        function __promisify__(fd: number, options: StatOptions & { bigint: true }): Promise<BigIntStats>;\n        function __promisify__(fd: number, options?: StatOptions): Promise<Stats | BigIntStats>;\n    }\n\n    /**\n     * Synchronous fstat(2) - Get file status.\n     * @param fd A file descriptor.\n     */\n    function fstatSync(fd: number, options?: StatOptions & { bigint?: false }): Stats;\n    function fstatSync(fd: number, options: StatOptions & { bigint: true }): BigIntStats;\n    function fstatSync(fd: number, options?: StatOptions): Stats | BigIntStats;\n\n    /**\n     * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function lstat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;\n    function lstat(path: PathLike, options: StatOptions & { bigint?: false } | undefined, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;\n    function lstat(path: PathLike, options: StatOptions & { bigint: true }, callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void): void;\n    function lstat(path: PathLike, options: StatOptions | undefined, callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace lstat {\n        /**\n         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function __promisify__(path: PathLike, options?: StatOptions & { bigint?: false }): Promise<Stats>;\n        function __promisify__(path: PathLike, options: StatOptions & { bigint: true }): Promise<BigIntStats>;\n        function __promisify__(path: PathLike, options?: StatOptions): Promise<Stats | BigIntStats>;\n    }\n\n    /**\n     * Synchronous lstat(2) - Get file status. Does not dereference symbolic links.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function lstatSync(path: PathLike, options?: StatOptions & { bigint?: false }): Stats;\n    function lstatSync(path: PathLike, options: StatOptions & { bigint: true }): BigIntStats;\n    function lstatSync(path: PathLike, options?: StatOptions): Stats | BigIntStats;\n\n    /**\n     * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n     * @param existingPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param newPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function link(existingPath: PathLike, newPath: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace link {\n        /**\n         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n         * @param existingPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param newPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function __promisify__(existingPath: PathLike, newPath: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n     * @param existingPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param newPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function linkSync(existingPath: PathLike, newPath: PathLike): void;\n\n    /**\n     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n     * @param target A path to an existing file. If a URL is provided, it must use the 'file:' protocol.\n     * @param path A path to the new symlink. If a URL is provided, it must use the 'file:' protocol.\n     * @param type May be set to ''dir'', ''file'', or ''junction'' (default is ''file'') and is only available on Windows (ignored on other platforms).\n     * When using ''junction'', the 'target' argument will automatically be normalized to an absolute path.\n     */\n    function symlink(target: PathLike, path: PathLike, type: symlink.Type | undefined | null, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n     * @param target A path to an existing file. If a URL is provided, it must use the 'file:' protocol.\n     * @param path A path to the new symlink. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function symlink(target: PathLike, path: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace symlink {\n        /**\n         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n         * @param target A path to an existing file. If a URL is provided, it must use the 'file:' protocol.\n         * @param path A path to the new symlink. If a URL is provided, it must use the 'file:' protocol.\n         * @param type May be set to ''dir'', ''file'', or ''junction'' (default is ''file'') and is only available on Windows (ignored on other platforms).\n         * When using ''junction'', the 'target' argument will automatically be normalized to an absolute path.\n         */\n        function __promisify__(target: PathLike, path: PathLike, type?: string | null): Promise<void>;\n\n        type Type = \"dir\" | \"file\" | \"junction\";\n    }\n\n    /**\n     * Synchronous symlink(2) - Create a new symbolic link to an existing file.\n     * @param target A path to an existing file. If a URL is provided, it must use the 'file:' protocol.\n     * @param path A path to the new symlink. If a URL is provided, it must use the 'file:' protocol.\n     * @param type May be set to ''dir'', ''file'', or ''junction'' (default is ''file'') and is only available on Windows (ignored on other platforms).\n     * When using ''junction'', the 'target' argument will automatically be normalized to an absolute path.\n     */\n    function symlinkSync(target: PathLike, path: PathLike, type?: symlink.Type | null): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readlink(\n        path: PathLike,\n        options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, linkString: string) => void\n    ): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readlink(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\", callback: (err: NodeJS.ErrnoException | null, linkString: Buffer) => void): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readlink(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException | null, linkString: string | Buffer) => void): void;\n\n    /**\n     * Asynchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function readlink(path: PathLike, callback: (err: NodeJS.ErrnoException | null, linkString: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace readlink {\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n    }\n\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readlinkSync(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readlinkSync(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n\n    /**\n     * Synchronous readlink(2) - read value of a symbolic link.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readlinkSync(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function realpath(\n        path: PathLike,\n        options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void\n    ): void;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function realpath(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\", callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer) => void): void;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function realpath(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer) => void): void;\n\n    /**\n     * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function realpath(path: PathLike, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace realpath {\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        function native(\n            path: PathLike,\n            options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null,\n            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void\n        ): void;\n        function native(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\", callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer) => void): void;\n        function native(path: PathLike, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer) => void): void;\n        function native(path: PathLike, callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void): void;\n    }\n\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function realpathSync(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function realpathSync(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n\n    /**\n     * Synchronous realpath(3) - return the canonicalized absolute pathname.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function realpathSync(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\n\n    namespace realpathSync {\n        function native(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n        function native(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n        function native(path: PathLike, options?: { encoding?: string | null } | string | null): string | Buffer;\n    }\n\n    /**\n     * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function unlink(path: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace unlink {\n        /**\n         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function __promisify__(path: PathLike): Promise<void>;\n    }\n\n    /**\n     * Synchronous unlink(2) - delete a name and possibly the file it refers to.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function unlinkSync(path: PathLike): void;\n\n    interface RmDirOptions {\n        /**\n         * If an 'EBUSY', 'EMFILE', 'ENFILE', 'ENOTEMPTY', or\n         * 'EPERM' error is encountered, Node.js will retry the operation with a linear\n         * backoff wait of 'retryDelay' ms longer on each try. This option represents the\n         * number of retries. This option is ignored if the 'recursive' option is not\n         * 'true'.\n         * @default 0\n         */\n        maxRetries?: number;\n        /**\n         * If 'true', perform a recursive directory removal. In\n         * recursive mode, errors are not reported if 'path' does not exist, and\n         * operations are retried on failure.\n         * @experimental\n         * @default false\n         */\n        recursive?: boolean;\n        /**\n         * The amount of time in milliseconds to wait between retries.\n         * This option is ignored if the 'recursive' option is not 'true'.\n         * @default 100\n         */\n        retryDelay?: number;\n    }\n\n    /**\n     * Asynchronous rmdir(2) - delete a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function rmdir(path: PathLike, callback: NoParamCallback): void;\n    function rmdir(path: PathLike, options: RmDirOptions, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace rmdir {\n        /**\n         * Asynchronous rmdir(2) - delete a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function __promisify__(path: PathLike, options?: RmDirOptions): Promise<void>;\n    }\n\n    /**\n     * Synchronous rmdir(2) - delete a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function rmdirSync(path: PathLike, options?: RmDirOptions): void;\n\n    interface MakeDirectoryOptions {\n        /**\n         * Indicates whether parent folders should be created.\n         * If a folder was created, the path to the first created folder will be returned.\n         * @default false\n         */\n        recursive?: boolean;\n        /**\n         * A file mode. If a string is passed, it is parsed as an octal integer. If not specified\n         * @default 0o777\n         */\n        mode?: number | string;\n    }\n\n    /**\n     * Asynchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n     */\n    function mkdir(path: PathLike, options: MakeDirectoryOptions & { recursive: true }, callback: (err: NodeJS.ErrnoException | null, path?: string) => void): void;\n\n    /**\n     * Asynchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n     */\n    function mkdir(path: PathLike, options: number | string | (MakeDirectoryOptions & { recursive?: false; }) | null | undefined, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n     */\n    function mkdir(path: PathLike, options: number | string | MakeDirectoryOptions | null | undefined, callback: (err: NodeJS.ErrnoException | null, path?: string) => void): void;\n\n    /**\n     * Asynchronous mkdir(2) - create a directory with a mode of '0o777'.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function mkdir(path: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace mkdir {\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n         */\n        function __promisify__(path: PathLike, options: MakeDirectoryOptions & { recursive: true; }): Promise<string | undefined>;\n\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n         */\n        function __promisify__(path: PathLike, options?: number | string | (MakeDirectoryOptions & { recursive?: false; }) | null): Promise<void>;\n\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n         */\n        function __promisify__(path: PathLike, options?: number | string | MakeDirectoryOptions | null): Promise<string | undefined>;\n    }\n\n    /**\n     * Synchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n     */\n    function mkdirSync(path: PathLike, options: MakeDirectoryOptions & { recursive: true; }): string | undefined;\n\n    /**\n     * Synchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n     */\n    function mkdirSync(path: PathLike, options?: number | string | (MakeDirectoryOptions & { recursive?: false; }) | null): void;\n\n    /**\n     * Synchronous mkdir(2) - create a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n     */\n    function mkdirSync(path: PathLike, options?: number | string | MakeDirectoryOptions | null): string | undefined;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function mkdtemp(prefix: string, options: { encoding?: BufferEncoding | null } | BufferEncoding | undefined | null, callback: (err: NodeJS.ErrnoException | null, folder: string) => void): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function mkdtemp(prefix: string, options: \"buffer\" | { encoding: \"buffer\" }, callback: (err: NodeJS.ErrnoException | null, folder: Buffer) => void): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function mkdtemp(prefix: string, options: { encoding?: string | null } | string | undefined | null, callback: (err: NodeJS.ErrnoException | null, folder: string | Buffer) => void): void;\n\n    /**\n     * Asynchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     */\n    function mkdtemp(prefix: string, callback: (err: NodeJS.ErrnoException | null, folder: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace mkdtemp {\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(prefix: string, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(prefix: string, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n    }\n\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function mkdtempSync(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): string;\n\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function mkdtempSync(prefix: string, options: { encoding: \"buffer\" } | \"buffer\"): Buffer;\n\n    /**\n     * Synchronously creates a unique temporary directory.\n     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function mkdtempSync(prefix: string, options?: { encoding?: string | null } | string | null): string | Buffer;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readdir(\n        path: PathLike,\n        options: { encoding: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, files: string[]) => void,\n    ): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readdir(path: PathLike, options: { encoding: \"buffer\"; withFileTypes?: false } | \"buffer\", callback: (err: NodeJS.ErrnoException | null, files: Buffer[]) => void): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readdir(\n        path: PathLike,\n        options: { encoding?: string | null; withFileTypes?: false } | string | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, files: string[] | Buffer[]) => void,\n    ): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function readdir(path: PathLike, callback: (err: NodeJS.ErrnoException | null, files: string[]) => void): void;\n\n    /**\n     * Asynchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options If called with 'withFileTypes: true' the result data will be an array of Dirent.\n     */\n    function readdir(path: PathLike, options: { encoding?: string | null; withFileTypes: true }, callback: (err: NodeJS.ErrnoException | null, files: Dirent[]) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace readdir {\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | null): Promise<string[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(path: PathLike, options: \"buffer\" | { encoding: \"buffer\"; withFileTypes?: false }): Promise<Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function __promisify__(path: PathLike, options?: { encoding?: string | null; withFileTypes?: false } | string | null): Promise<string[] | Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options If called with 'withFileTypes: true' the result data will be an array of Dirent\n         */\n        function __promisify__(path: PathLike, options: { encoding?: string | null; withFileTypes: true }): Promise<Dirent[]>;\n    }\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readdirSync(path: PathLike, options?: { encoding: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | null): string[];\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readdirSync(path: PathLike, options: { encoding: \"buffer\"; withFileTypes?: false } | \"buffer\"): Buffer[];\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n     */\n    function readdirSync(path: PathLike, options?: { encoding?: string | null; withFileTypes?: false } | string | null): string[] | Buffer[];\n\n    /**\n     * Synchronous readdir(3) - read a directory.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param options If called with 'withFileTypes: true' the result data will be an array of Dirent.\n     */\n    function readdirSync(path: PathLike, options: { encoding?: string | null; withFileTypes: true }): Dirent[];\n\n    /**\n     * Asynchronous close(2) - close a file descriptor.\n     * @param fd A file descriptor.\n     */\n    function close(fd: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace close {\n        /**\n         * Asynchronous close(2) - close a file descriptor.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous close(2) - close a file descriptor.\n     * @param fd A file descriptor.\n     */\n    function closeSync(fd: number): void;\n\n    /**\n     * Asynchronous open(2) - open and possibly create a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to '0o666'.\n     */\n    function open(path: PathLike, flags: string | number, mode: string | number | undefined | null, callback: (err: NodeJS.ErrnoException | null, fd: number) => void): void;\n\n    /**\n     * Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be '0o666'.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     */\n    function open(path: PathLike, flags: string | number, callback: (err: NodeJS.ErrnoException | null, fd: number) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace open {\n        /**\n         * Asynchronous open(2) - open and possibly create a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to '0o666'.\n         */\n        function __promisify__(path: PathLike, flags: string | number, mode?: string | number | null): Promise<number>;\n    }\n\n    /**\n     * Synchronous open(2) - open and possibly create a file, returning a file descriptor..\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to '0o666'.\n     */\n    function openSync(path: PathLike, flags: string | number, mode?: string | number | null): number;\n\n    /**\n     * Asynchronously change file timestamps of the file referenced by the supplied path.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function utimes(path: PathLike, atime: string | number | Date, mtime: string | number | Date, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace utimes {\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied path.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function __promisify__(path: PathLike, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n    }\n\n    /**\n     * Synchronously change file timestamps of the file referenced by the supplied path.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function utimesSync(path: PathLike, atime: string | number | Date, mtime: string | number | Date): void;\n\n    /**\n     * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function futimes(fd: number, atime: string | number | Date, mtime: string | number | Date, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace futimes {\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function __promisify__(fd: number, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n    }\n\n    /**\n     * Synchronously change file timestamps of the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param atime The last access time. If a string is provided, it will be coerced to number.\n     * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n     */\n    function futimesSync(fd: number, atime: string | number | Date, mtime: string | number | Date): void;\n\n    /**\n     * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n     * @param fd A file descriptor.\n     */\n    function fsync(fd: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fsync {\n        /**\n         * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n     * @param fd A file descriptor.\n     */\n    function fsyncSync(fd: number): void;\n\n    /**\n     * Asynchronously writes 'buffer' to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to '0'.\n     * @param length The number of bytes to write. If not supplied, defaults to 'buffer.length - offset'.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     */\n    function write<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number | undefined | null,\n        length: number | undefined | null,\n        position: number | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,\n    ): void;\n\n    /**\n     * Asynchronously writes 'buffer' to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to '0'.\n     * @param length The number of bytes to write. If not supplied, defaults to 'buffer.length - offset'.\n     */\n    function write<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number | undefined | null,\n        length: number | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,\n    ): void;\n\n    /**\n     * Asynchronously writes 'buffer' to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to '0'.\n     */\n    function write<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void\n    ): void;\n\n    /**\n     * Asynchronously writes 'buffer' to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     */\n    function write<TBuffer extends NodeJS.ArrayBufferView>(fd: number, buffer: TBuffer, callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void): void;\n\n    /**\n     * Asynchronously writes 'string' to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     * @param encoding The expected string encoding.\n     */\n    function write(\n        fd: number,\n        string: any,\n        position: number | undefined | null,\n        encoding: string | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void,\n    ): void;\n\n    /**\n     * Asynchronously writes 'string' to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     */\n    function write(fd: number, string: any, position: number | undefined | null, callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void): void;\n\n    /**\n     * Asynchronously writes 'string' to the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     */\n    function write(fd: number, string: any, callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace write {\n        /**\n         * Asynchronously writes 'buffer' to the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param offset The part of the buffer to be written. If not supplied, defaults to '0'.\n         * @param length The number of bytes to write. If not supplied, defaults to 'buffer.length - offset'.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         */\n        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(\n            fd: number,\n            buffer?: TBuffer,\n            offset?: number,\n            length?: number,\n            position?: number | null,\n        ): Promise<{ bytesWritten: number, buffer: TBuffer }>;\n\n        /**\n         * Asynchronously writes 'string' to the file referenced by the supplied file descriptor.\n         * @param fd A file descriptor.\n         * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         * @param encoding The expected string encoding.\n         */\n        function __promisify__(fd: number, string: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;\n    }\n\n    /**\n     * Synchronously writes 'buffer' to the file referenced by the supplied file descriptor, returning the number of bytes written.\n     * @param fd A file descriptor.\n     * @param offset The part of the buffer to be written. If not supplied, defaults to '0'.\n     * @param length The number of bytes to write. If not supplied, defaults to 'buffer.length - offset'.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     */\n    function writeSync(fd: number, buffer: NodeJS.ArrayBufferView, offset?: number | null, length?: number | null, position?: number | null): number;\n\n    /**\n     * Synchronously writes 'string' to the file referenced by the supplied file descriptor, returning the number of bytes written.\n     * @param fd A file descriptor.\n     * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n     * @param encoding The expected string encoding.\n     */\n    function writeSync(fd: number, string: any, position?: number | null, encoding?: string | null): number;\n\n    /**\n     * Asynchronously reads data from the file referenced by the supplied file descriptor.\n     * @param fd A file descriptor.\n     * @param buffer The buffer that the data will be written to.\n     * @param offset The offset in the buffer at which to start writing.\n     * @param length The number of bytes to read.\n     * @param position The offset from the beginning of the file from which data should be read. If 'null', data will be read from the current position.\n     */\n    function read<TBuffer extends NodeJS.ArrayBufferView>(\n        fd: number,\n        buffer: TBuffer,\n        offset: number,\n        length: number,\n        position: number | null,\n        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,\n    ): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace read {\n        /**\n         * @param fd A file descriptor.\n         * @param buffer The buffer that the data will be written to.\n         * @param offset The offset in the buffer at which to start writing.\n         * @param length The number of bytes to read.\n         * @param position The offset from the beginning of the file from which data should be read. If 'null', data will be read from the current position.\n         */\n        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(\n            fd: number,\n            buffer: TBuffer,\n            offset: number,\n            length: number,\n            position: number | null\n        ): Promise<{ bytesRead: number, buffer: TBuffer }>;\n    }\n\n    interface ReadSyncOptions {\n        /**\n         * @default 0\n         */\n        offset?: number;\n        /**\n         * @default 'length of buffer'\n         */\n        length?: number;\n        /**\n         * @default null\n         */\n        position?: number | null;\n    }\n\n    /**\n     * Synchronously reads data from the file referenced by the supplied file descriptor, returning the number of bytes read.\n     * @param fd A file descriptor.\n     * @param buffer The buffer that the data will be written to.\n     * @param offset The offset in the buffer at which to start writing.\n     * @param length The number of bytes to read.\n     * @param position The offset from the beginning of the file from which data should be read. If 'null', data will be read from the current position.\n     */\n    function readSync(fd: number, buffer: NodeJS.ArrayBufferView, offset: number, length: number, position: number | null): number;\n\n    /**\n     * Similar to the above 'fs.readSync' function, this version takes an optional 'options' object.\n     * If no 'options' object is specified, it will default with the above values.\n     */\n    function readSync(fd: number, buffer: NodeJS.ArrayBufferView, opts?: ReadSyncOptions): number;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options An object that may contain an optional flag.\n     * If a flag is not provided, it defaults to ''r''.\n     */\n    function readFile(path: PathLike | number, options: { encoding?: null; flag?: string; } | undefined | null, callback: (err: NodeJS.ErrnoException | null, data: Buffer) => void): void;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to ''r''.\n     */\n    function readFile(path: PathLike | number, options: { encoding: string; flag?: string; } | string, callback: (err: NodeJS.ErrnoException | null, data: string) => void): void;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to ''r''.\n     */\n    function readFile(\n        path: PathLike | number,\n        options: { encoding?: string | null; flag?: string; } | string | undefined | null,\n        callback: (err: NodeJS.ErrnoException | null, data: string | Buffer) => void,\n    ): void;\n\n    /**\n     * Asynchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     */\n    function readFile(path: PathLike | number, callback: (err: NodeJS.ErrnoException | null, data: Buffer) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace readFile {\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to ''r''.\n         */\n        function __promisify__(path: PathLike | number, options?: { encoding?: null; flag?: string; } | null): Promise<Buffer>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n         * If a flag is not provided, it defaults to ''r''.\n         */\n        function __promisify__(path: PathLike | number, options: { encoding: string; flag?: string; } | string): Promise<string>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n         * If a flag is not provided, it defaults to ''r''.\n         */\n        function __promisify__(path: PathLike | number, options?: { encoding?: string | null; flag?: string; } | string | null): Promise<string | Buffer>;\n    }\n\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options An object that may contain an optional flag. If a flag is not provided, it defaults to ''r''.\n     */\n    function readFileSync(path: PathLike | number, options?: { encoding?: null; flag?: string; } | null): Buffer;\n\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to ''r''.\n     */\n    function readFileSync(path: PathLike | number, options: { encoding: string; flag?: string; } | string): string;\n\n    /**\n     * Synchronously reads the entire contents of a file.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.\n     * If a flag is not provided, it defaults to ''r''.\n     */\n    function readFileSync(path: PathLike | number, options?: { encoding?: string | null; flag?: string; } | string | null): string | Buffer;\n\n    type WriteFileOptions = { encoding?: string | null; mode?: number | string; flag?: string; } | string | null;\n\n    /**\n     * Asynchronously writes data to a file, replacing the file if it already exists.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If 'encoding' is not supplied, the default of ''utf8'' is used.\n     * If 'mode' is not supplied, the default of '0o666' is used.\n     * If 'mode' is a string, it is parsed as an octal integer.\n     * If 'flag' is not supplied, the default of ''w'' is used.\n     */\n    function writeFile(path: PathLike | number, data: any, options: WriteFileOptions, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronously writes data to a file, replacing the file if it already exists.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     */\n    function writeFile(path: PathLike | number, data: any, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace writeFile {\n        /**\n         * Asynchronously writes data to a file, replacing the file if it already exists.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If 'encoding' is not supplied, the default of ''utf8'' is used.\n         * If 'mode' is not supplied, the default of '0o666' is used.\n         * If 'mode' is a string, it is parsed as an octal integer.\n         * If 'flag' is not supplied, the default of ''w'' is used.\n         */\n        function __promisify__(path: PathLike | number, data: any, options?: WriteFileOptions): Promise<void>;\n    }\n\n    /**\n     * Synchronously writes data to a file, replacing the file if it already exists.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If 'encoding' is not supplied, the default of ''utf8'' is used.\n     * If 'mode' is not supplied, the default of '0o666' is used.\n     * If 'mode' is a string, it is parsed as an octal integer.\n     * If 'flag' is not supplied, the default of ''w'' is used.\n     */\n    function writeFileSync(path: PathLike | number, data: any, options?: WriteFileOptions): void;\n\n    /**\n     * Asynchronously append data to a file, creating the file if it does not exist.\n     * @param file A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If 'encoding' is not supplied, the default of ''utf8'' is used.\n     * If 'mode' is not supplied, the default of '0o666' is used.\n     * If 'mode' is a string, it is parsed as an octal integer.\n     * If 'flag' is not supplied, the default of ''a'' is used.\n     */\n    function appendFile(file: PathLike | number, data: any, options: WriteFileOptions, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronously append data to a file, creating the file if it does not exist.\n     * @param file A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     */\n    function appendFile(file: PathLike | number, data: any, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace appendFile {\n        /**\n         * Asynchronously append data to a file, creating the file if it does not exist.\n         * @param file A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If 'encoding' is not supplied, the default of ''utf8'' is used.\n         * If 'mode' is not supplied, the default of '0o666' is used.\n         * If 'mode' is a string, it is parsed as an octal integer.\n         * If 'flag' is not supplied, the default of ''a'' is used.\n         */\n        function __promisify__(file: PathLike | number, data: any, options?: WriteFileOptions): Promise<void>;\n    }\n\n    /**\n     * Synchronously append data to a file, creating the file if it does not exist.\n     * @param file A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.\n     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.\n     * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n     * If 'encoding' is not supplied, the default of ''utf8'' is used.\n     * If 'mode' is not supplied, the default of '0o666' is used.\n     * If 'mode' is a string, it is parsed as an octal integer.\n     * If 'flag' is not supplied, the default of ''a'' is used.\n     */\n    function appendFileSync(file: PathLike | number, data: any, options?: WriteFileOptions): void;\n\n    /**\n     * Watch for changes on 'filename'. The callback 'listener' will be called each time the file is accessed.\n     */\n    function watchFile(filename: PathLike, options: { persistent?: boolean; interval?: number; } | undefined, listener: (curr: Stats, prev: Stats) => void): void;\n\n    /**\n     * Watch for changes on 'filename'. The callback 'listener' will be called each time the file is accessed.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function watchFile(filename: PathLike, listener: (curr: Stats, prev: Stats) => void): void;\n\n    /**\n     * Stop watching for changes on 'filename'.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function unwatchFile(filename: PathLike, listener?: (curr: Stats, prev: Stats) => void): void;\n\n    /**\n     * Watch for changes on 'filename', where 'filename' is either a file or a directory, returning an 'FSWatcher'.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If 'encoding' is not supplied, the default of ''utf8'' is used.\n     * If 'persistent' is not supplied, the default of 'true' is used.\n     * If 'recursive' is not supplied, the default of 'false' is used.\n     */\n    function watch(\n        filename: PathLike,\n        options: { encoding?: BufferEncoding | null, persistent?: boolean, recursive?: boolean } | BufferEncoding | undefined | null,\n        listener?: (event: string, filename: string) => void,\n    ): FSWatcher;\n\n    /**\n     * Watch for changes on 'filename', where 'filename' is either a file or a directory, returning an 'FSWatcher'.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If 'encoding' is not supplied, the default of ''utf8'' is used.\n     * If 'persistent' is not supplied, the default of 'true' is used.\n     * If 'recursive' is not supplied, the default of 'false' is used.\n     */\n    function watch(filename: PathLike, options: { encoding: \"buffer\", persistent?: boolean, recursive?: boolean } | \"buffer\", listener?: (event: string, filename: Buffer) => void): FSWatcher;\n\n    /**\n     * Watch for changes on 'filename', where 'filename' is either a file or a directory, returning an 'FSWatcher'.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.\n     * If 'encoding' is not supplied, the default of ''utf8'' is used.\n     * If 'persistent' is not supplied, the default of 'true' is used.\n     * If 'recursive' is not supplied, the default of 'false' is used.\n     */\n    function watch(\n        filename: PathLike,\n        options: { encoding?: string | null, persistent?: boolean, recursive?: boolean } | string | null,\n        listener?: (event: string, filename: string | Buffer) => void,\n    ): FSWatcher;\n\n    /**\n     * Watch for changes on 'filename', where 'filename' is either a file or a directory, returning an 'FSWatcher'.\n     * @param filename A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function watch(filename: PathLike, listener?: (event: string, filename: string) => any): FSWatcher;\n\n    /**\n     * Asynchronously tests whether or not the given path exists by checking with the file system.\n     * @deprecated\n     * @param path A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function exists(path: PathLike, callback: (exists: boolean) => void): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace exists {\n        /**\n         * @param path A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(path: PathLike): Promise<boolean>;\n    }\n\n    /**\n     * Synchronously tests whether or not the given path exists by checking with the file system.\n     * @param path A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function existsSync(path: PathLike): boolean;\n\n    namespace constants {\n        // File Access Constants\n\n        /** Constant for fs.access(). File is visible to the calling process. */\n        const F_OK: number;\n\n        /** Constant for fs.access(). File can be read by the calling process. */\n        const R_OK: number;\n\n        /** Constant for fs.access(). File can be written by the calling process. */\n        const W_OK: number;\n\n        /** Constant for fs.access(). File can be executed by the calling process. */\n        const X_OK: number;\n\n        // File Copy Constants\n\n        /** Constant for fs.copyFile. Flag indicating the destination file should not be overwritten if it already exists. */\n        const COPYFILE_EXCL: number;\n\n        /**\n         * Constant for fs.copyFile. copy operation will attempt to create a copy-on-write reflink.\n         * If the underlying platform does not support copy-on-write, then a fallback copy mechanism is used.\n         */\n        const COPYFILE_FICLONE: number;\n\n        /**\n         * Constant for fs.copyFile. Copy operation will attempt to create a copy-on-write reflink.\n         * If the underlying platform does not support copy-on-write, then the operation will fail with an error.\n         */\n        const COPYFILE_FICLONE_FORCE: number;\n\n        // File Open Constants\n\n        /** Constant for fs.open(). Flag indicating to open a file for read-only access. */\n        const O_RDONLY: number;\n\n        /** Constant for fs.open(). Flag indicating to open a file for write-only access. */\n        const O_WRONLY: number;\n\n        /** Constant for fs.open(). Flag indicating to open a file for read-write access. */\n        const O_RDWR: number;\n\n        /** Constant for fs.open(). Flag indicating to create the file if it does not already exist. */\n        const O_CREAT: number;\n\n        /** Constant for fs.open(). Flag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists. */\n        const O_EXCL: number;\n\n        /**\n         * Constant for fs.open(). Flag indicating that if path identifies a terminal device,\n         * opening the path shall not cause that terminal to become the controlling terminal for the process\n         * (if the process does not already have one).\n         */\n        const O_NOCTTY: number;\n\n        /** Constant for fs.open(). Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero. */\n        const O_TRUNC: number;\n\n        /** Constant for fs.open(). Flag indicating that data will be appended to the end of the file. */\n        const O_APPEND: number;\n\n        /** Constant for fs.open(). Flag indicating that the open should fail if the path is not a directory. */\n        const O_DIRECTORY: number;\n\n        /**\n         * constant for fs.open().\n         * Flag indicating reading accesses to the file system will no longer result in\n         * an update to the atime information associated with the file.\n         * This flag is available on Linux operating systems only.\n         */\n        const O_NOATIME: number;\n\n        /** Constant for fs.open(). Flag indicating that the open should fail if the path is a symbolic link. */\n        const O_NOFOLLOW: number;\n\n        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O. */\n        const O_SYNC: number;\n\n        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O with write operations waiting for data integrity. */\n        const O_DSYNC: number;\n\n        /** Constant for fs.open(). Flag indicating to open the symbolic link itself rather than the resource it is pointing to. */\n        const O_SYMLINK: number;\n\n        /** Constant for fs.open(). When set, an attempt will be made to minimize caching effects of file I/O. */\n        const O_DIRECT: number;\n\n        /** Constant for fs.open(). Flag indicating to open the file in nonblocking mode when possible. */\n        const O_NONBLOCK: number;\n\n        // File Type Constants\n\n        /** Constant for fs.Stats mode property for determining a file's type. Bit mask used to extract the file type code. */\n        const S_IFMT: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a regular file. */\n        const S_IFREG: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a directory. */\n        const S_IFDIR: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a character-oriented device file. */\n        const S_IFCHR: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a block-oriented device file. */\n        const S_IFBLK: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a FIFO/pipe. */\n        const S_IFIFO: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a symbolic link. */\n        const S_IFLNK: number;\n\n        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a socket. */\n        const S_IFSOCK: number;\n\n        // File Mode Constants\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by owner. */\n        const S_IRWXU: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by owner. */\n        const S_IRUSR: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by owner. */\n        const S_IWUSR: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by owner. */\n        const S_IXUSR: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by group. */\n        const S_IRWXG: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by group. */\n        const S_IRGRP: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by group. */\n        const S_IWGRP: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by group. */\n        const S_IXGRP: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by others. */\n        const S_IRWXO: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by others. */\n        const S_IROTH: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by others. */\n        const S_IWOTH: number;\n\n        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by others. */\n        const S_IXOTH: number;\n\n        /**\n         * When set, a memory file mapping is used to access the file. This flag\n         * is available on Windows operating systems only. On other operating systems,\n         * this flag is ignored.\n         */\n        const UV_FS_O_FILEMAP: number;\n    }\n\n    /**\n     * Asynchronously tests a user's permissions for the file specified by path.\n     * @param path A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function access(path: PathLike, mode: number | undefined, callback: NoParamCallback): void;\n\n    /**\n     * Asynchronously tests a user's permissions for the file specified by path.\n     * @param path A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function access(path: PathLike, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace access {\n        /**\n         * Asynchronously tests a user's permissions for the file specified by path.\n         * @param path A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         */\n        function __promisify__(path: PathLike, mode?: number): Promise<void>;\n    }\n\n    /**\n     * Synchronously tests a user's permissions for the file specified by path.\n     * @param path A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function accessSync(path: PathLike, mode?: number): void;\n\n    /**\n     * Returns a new 'ReadStream' object.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function createReadStream(path: PathLike, options?: string | {\n        flags?: string;\n        encoding?: string;\n        fd?: number;\n        mode?: number;\n        autoClose?: boolean;\n        /**\n         * @default false\n         */\n        emitClose?: boolean;\n        start?: number;\n        end?: number;\n        highWaterMark?: number;\n    }): ReadStream;\n\n    /**\n     * Returns a new 'WriteStream' object.\n     * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n     * URL support is _experimental_.\n     */\n    function createWriteStream(path: PathLike, options?: string | {\n        flags?: string;\n        encoding?: string;\n        fd?: number;\n        mode?: number;\n        autoClose?: boolean;\n        emitClose?: boolean;\n        start?: number;\n        highWaterMark?: number;\n    }): WriteStream;\n\n    /**\n     * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n     * @param fd A file descriptor.\n     */\n    function fdatasync(fd: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace fdatasync {\n        /**\n         * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n         * @param fd A file descriptor.\n         */\n        function __promisify__(fd: number): Promise<void>;\n    }\n\n    /**\n     * Synchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n     * @param fd A file descriptor.\n     */\n    function fdatasyncSync(fd: number): void;\n\n    /**\n     * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\n     * No arguments other than a possible exception are given to the callback function.\n     * Node.js makes no guarantees about the atomicity of the copy operation.\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n     * to remove the destination.\n     * @param src A path to the source file.\n     * @param dest A path to the destination file.\n     */\n    function copyFile(src: PathLike, dest: PathLike, callback: NoParamCallback): void;\n    /**\n     * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\n     * No arguments other than a possible exception are given to the callback function.\n     * Node.js makes no guarantees about the atomicity of the copy operation.\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n     * to remove the destination.\n     * @param src A path to the source file.\n     * @param dest A path to the destination file.\n     * @param flags An integer that specifies the behavior of the copy operation. The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.\n     */\n    function copyFile(src: PathLike, dest: PathLike, flags: number, callback: NoParamCallback): void;\n\n    // NOTE: This namespace provides design-time support for util.promisify. Exported members do not exist at runtime.\n    namespace copyFile {\n        /**\n         * Asynchronously copies src to dest. By default, dest is overwritten if it already exists.\n         * No arguments other than a possible exception are given to the callback function.\n         * Node.js makes no guarantees about the atomicity of the copy operation.\n         * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n         * to remove the destination.\n         * @param src A path to the source file.\n         * @param dest A path to the destination file.\n         * @param flags An optional integer that specifies the behavior of the copy operation.\n         * The only supported flag is fs.constants.COPYFILE_EXCL,\n         * which causes the copy operation to fail if dest already exists.\n         */\n        function __promisify__(src: PathLike, dst: PathLike, flags?: number): Promise<void>;\n    }\n\n    /**\n     * Synchronously copies src to dest. By default, dest is overwritten if it already exists.\n     * Node.js makes no guarantees about the atomicity of the copy operation.\n     * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n     * to remove the destination.\n     * @param src A path to the source file.\n     * @param dest A path to the destination file.\n     * @param flags An optional integer that specifies the behavior of the copy operation.\n     * The only supported flag is fs.constants.COPYFILE_EXCL, which causes the copy operation to fail if dest already exists.\n     */\n    function copyFileSync(src: PathLike, dest: PathLike, flags?: number): void;\n\n    /**\n     * Write an array of ArrayBufferViews to the file specified by fd using writev().\n     * position is the offset from the beginning of the file where this data should be written.\n     * It is unsafe to use fs.writev() multiple times on the same file without waiting for the callback. For this scenario, use fs.createWriteStream().\n     * On Linux, positional writes don't work when the file is opened in append mode.\n     * The kernel ignores the position argument and always appends the data to the end of the file.\n     */\n    function writev(\n        fd: number,\n        buffers: ReadonlyArray<NodeJS.ArrayBufferView>,\n        cb: (err: NodeJS.ErrnoException | null, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void\n    ): void;\n    function writev(\n        fd: number,\n        buffers: ReadonlyArray<NodeJS.ArrayBufferView>,\n        position: number,\n        cb: (err: NodeJS.ErrnoException | null, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void\n    ): void;\n\n    interface WriteVResult {\n        bytesWritten: number;\n        buffers: NodeJS.ArrayBufferView[];\n    }\n\n    namespace writev {\n        function __promisify__(fd: number, buffers: ReadonlyArray<NodeJS.ArrayBufferView>, position?: number): Promise<WriteVResult>;\n    }\n\n    /**\n     * See 'writev'.\n     */\n    function writevSync(fd: number, buffers: ReadonlyArray<NodeJS.ArrayBufferView>, position?: number): number;\n\n    function readv(\n        fd: number,\n        buffers: ReadonlyArray<NodeJS.ArrayBufferView>,\n        cb: (err: NodeJS.ErrnoException | null, bytesRead: number, buffers: NodeJS.ArrayBufferView[]) => void\n    ): void;\n    function readv(\n        fd: number,\n        buffers: ReadonlyArray<NodeJS.ArrayBufferView>,\n        position: number,\n        cb: (err: NodeJS.ErrnoException | null, bytesRead: number, buffers: NodeJS.ArrayBufferView[]) => void\n    ): void;\n\n    interface ReadVResult {\n        bytesRead: number;\n        buffers: NodeJS.ArrayBufferView[];\n    }\n\n    namespace readv {\n        function __promisify__(fd: number, buffers: ReadonlyArray<NodeJS.ArrayBufferView>, position?: number): Promise<ReadVResult>;\n    }\n\n    /**\n     * See 'readv'.\n     */\n    function readvSync(fd: number, buffers: ReadonlyArray<NodeJS.ArrayBufferView>, position?: number): number;\n\n    interface OpenDirOptions {\n        encoding?: BufferEncoding;\n        /**\n         * Number of directory entries that are buffered\n         * internally when reading from the directory. Higher values lead to better\n         * performance but higher memory usage.\n         * @default 32\n         */\n        bufferSize?: number;\n    }\n\n    function opendirSync(path: string, options?: OpenDirOptions): Dir;\n\n    function opendir(path: string, cb: (err: NodeJS.ErrnoException | null, dir: Dir) => void): void;\n    function opendir(path: string, options: OpenDirOptions, cb: (err: NodeJS.ErrnoException | null, dir: Dir) => void): void;\n\n    namespace opendir {\n        function __promisify__(path: string, options?: OpenDirOptions): Promise<Dir>;\n    }\n\n    namespace promises {\n        interface FileHandle {\n            /**\n             * Gets the file descriptor for this file handle.\n             */\n            readonly fd: number;\n\n            /**\n             * Asynchronously append data to a file, creating the file if it does not exist. The underlying file will _not_ be closed automatically.\n             * The 'FileHandle' must have been opened for appending.\n             * @param data The data to write. If something other than a 'Buffer' or 'Uint8Array' is provided, the value is coerced to a string.\n             * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n             * If 'encoding' is not supplied, the default of ''utf8'' is used.\n             * If 'mode' is not supplied, the default of '0o666' is used.\n             * If 'mode' is a string, it is parsed as an octal integer.\n             * If 'flag' is not supplied, the default of ''a'' is used.\n             */\n            appendFile(data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n            /**\n             * Asynchronous fchown(2) - Change ownership of a file.\n             */\n            chown(uid: number, gid: number): Promise<void>;\n\n            /**\n             * Asynchronous fchmod(2) - Change permissions of a file.\n             * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n             */\n            chmod(mode: string | number): Promise<void>;\n\n            /**\n             * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n             */\n            datasync(): Promise<void>;\n\n            /**\n             * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n             */\n            sync(): Promise<void>;\n\n            /**\n             * Asynchronously reads data from the file.\n             * The 'FileHandle' must have been opened for reading.\n             * @param buffer The buffer that the data will be written to.\n             * @param offset The offset in the buffer at which to start writing.\n             * @param length The number of bytes to read.\n             * @param position The offset from the beginning of the file from which data should be read. If 'null', data will be read from the current position.\n             */\n            read<TBuffer extends Uint8Array>(buffer: TBuffer, offset?: number | null, length?: number | null, position?: number | null): Promise<{ bytesRead: number, buffer: TBuffer }>;\n\n            /**\n             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n             * The 'FileHandle' must have been opened for reading.\n             * @param options An object that may contain an optional flag.\n             * If a flag is not provided, it defaults to ''r''.\n             */\n            readFile(options?: { encoding?: null, flag?: string | number } | null): Promise<Buffer>;\n\n            /**\n             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n             * The 'FileHandle' must have been opened for reading.\n             * @param options An object that may contain an optional flag.\n             * If a flag is not provided, it defaults to ''r''.\n             */\n            readFile(options: { encoding: BufferEncoding, flag?: string | number } | BufferEncoding): Promise<string>;\n\n            /**\n             * Asynchronously reads the entire contents of a file. The underlying file will _not_ be closed automatically.\n             * The 'FileHandle' must have been opened for reading.\n             * @param options An object that may contain an optional flag.\n             * If a flag is not provided, it defaults to ''r''.\n             */\n            readFile(options?: { encoding?: string | null, flag?: string | number } | string | null): Promise<string | Buffer>;\n\n            /**\n             * Asynchronous fstat(2) - Get file status.\n             */\n            stat(opts?: StatOptions & { bigint?: false }): Promise<Stats>;\n            stat(opts: StatOptions & { bigint: true }): Promise<BigIntStats>;\n            stat(opts?: StatOptions): Promise<Stats | BigIntStats>;\n\n            /**\n             * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n             * @param len If not specified, defaults to '0'.\n             */\n            truncate(len?: number): Promise<void>;\n\n            /**\n             * Asynchronously change file timestamps of the file.\n             * @param atime The last access time. If a string is provided, it will be coerced to number.\n             * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n             */\n            utimes(atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n\n            /**\n             * Asynchronously writes 'buffer' to the file.\n             * The 'FileHandle' must have been opened for writing.\n             * @param buffer The buffer that the data will be written to.\n             * @param offset The part of the buffer to be written. If not supplied, defaults to '0'.\n             * @param length The number of bytes to write. If not supplied, defaults to 'buffer.length - offset'.\n             * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n             */\n            write<TBuffer extends Uint8Array>(buffer: TBuffer, offset?: number | null, length?: number | null, position?: number | null): Promise<{ bytesWritten: number, buffer: TBuffer }>;\n\n            /**\n             * Asynchronously writes 'string' to the file.\n             * The 'FileHandle' must have been opened for writing.\n             * It is unsafe to call 'write()' multiple times on the same file without waiting for the 'Promise'\n             * to be resolved (or rejected). For this scenario, 'fs.createWriteStream' is strongly recommended.\n             * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n             * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n             * @param encoding The expected string encoding.\n             */\n            write(data: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;\n\n            /**\n             * Asynchronously writes data to a file, replacing the file if it already exists. The underlying file will _not_ be closed automatically.\n             * The 'FileHandle' must have been opened for writing.\n             * It is unsafe to call 'writeFile()' multiple times on the same file without waiting for the 'Promise' to be resolved (or rejected).\n             * @param data The data to write. If something other than a 'Buffer' or 'Uint8Array' is provided, the value is coerced to a string.\n             * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n             * If 'encoding' is not supplied, the default of ''utf8'' is used.\n             * If 'mode' is not supplied, the default of '0o666' is used.\n             * If 'mode' is a string, it is parsed as an octal integer.\n             * If 'flag' is not supplied, the default of ''w'' is used.\n             */\n            writeFile(data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n            /**\n             * See 'fs.writev' promisified version.\n             */\n            writev(buffers: ReadonlyArray<NodeJS.ArrayBufferView>, position?: number): Promise<WriteVResult>;\n\n            /**\n             * See 'fs.readv' promisified version.\n             */\n            readv(buffers: ReadonlyArray<NodeJS.ArrayBufferView>, position?: number): Promise<ReadVResult>;\n\n            /**\n             * Asynchronous close(2) - close a 'FileHandle'.\n             */\n            close(): Promise<void>;\n        }\n\n        /**\n         * Asynchronously tests a user's permissions for the file specified by path.\n         * @param path A path to a file or directory. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         */\n        function access(path: PathLike, mode?: number): Promise<void>;\n\n        /**\n         * Asynchronously copies 'src' to 'dest'. By default, 'dest' is overwritten if it already exists.\n         * Node.js makes no guarantees about the atomicity of the copy operation.\n         * If an error occurs after the destination file has been opened for writing, Node.js will attempt\n         * to remove the destination.\n         * @param src A path to the source file.\n         * @param dest A path to the destination file.\n         * @param flags An optional integer that specifies the behavior of the copy operation. The only\n         * supported flag is 'fs.constants.COPYFILE_EXCL', which causes the copy operation to fail if\n         * 'dest' already exists.\n         */\n        function copyFile(src: PathLike, dest: PathLike, flags?: number): Promise<void>;\n\n        /**\n         * Asynchronous open(2) - open and possibly create a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not\n         * supplied, defaults to '0o666'.\n         */\n        function open(path: PathLike, flags: string | number, mode?: string | number): Promise<FileHandle>;\n\n        /**\n         * Asynchronously reads data from the file referenced by the supplied 'FileHandle'.\n         * @param handle A 'FileHandle'.\n         * @param buffer The buffer that the data will be written to.\n         * @param offset The offset in the buffer at which to start writing.\n         * @param length The number of bytes to read.\n         * @param position The offset from the beginning of the file from which data should be read. If\n         * 'null', data will be read from the current position.\n         */\n        function read<TBuffer extends Uint8Array>(\n            handle: FileHandle,\n            buffer: TBuffer,\n            offset?: number | null,\n            length?: number | null,\n            position?: number | null,\n        ): Promise<{ bytesRead: number, buffer: TBuffer }>;\n\n        /**\n         * Asynchronously writes 'buffer' to the file referenced by the supplied 'FileHandle'.\n         * It is unsafe to call 'fsPromises.write()' multiple times on the same file without waiting for the 'Promise'\n         * to be resolved (or rejected). For this scenario, 'fs.createWriteStream' is strongly recommended.\n         * @param handle A 'FileHandle'.\n         * @param buffer The buffer that the data will be written to.\n         * @param offset The part of the buffer to be written. If not supplied, defaults to '0'.\n         * @param length The number of bytes to write. If not supplied, defaults to 'buffer.length - offset'.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         */\n        function write<TBuffer extends Uint8Array>(\n            handle: FileHandle,\n            buffer: TBuffer,\n            offset?: number | null,\n            length?: number | null, position?: number | null): Promise<{ bytesWritten: number, buffer: TBuffer }>;\n\n        /**\n         * Asynchronously writes 'string' to the file referenced by the supplied 'FileHandle'.\n         * It is unsafe to call 'fsPromises.write()' multiple times on the same file without waiting for the 'Promise'\n         * to be resolved (or rejected). For this scenario, 'fs.createWriteStream' is strongly recommended.\n         * @param handle A 'FileHandle'.\n         * @param string A string to write. If something other than a string is supplied it will be coerced to a string.\n         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.\n         * @param encoding The expected string encoding.\n         */\n        function write(handle: FileHandle, string: any, position?: number | null, encoding?: string | null): Promise<{ bytesWritten: number, buffer: string }>;\n\n        /**\n         * Asynchronous rename(2) - Change the name or location of a file or directory.\n         * @param oldPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         * @param newPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         */\n        function rename(oldPath: PathLike, newPath: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous truncate(2) - Truncate a file to a specified length.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param len If not specified, defaults to '0'.\n         */\n        function truncate(path: PathLike, len?: number): Promise<void>;\n\n        /**\n         * Asynchronous ftruncate(2) - Truncate a file to a specified length.\n         * @param handle A 'FileHandle'.\n         * @param len If not specified, defaults to '0'.\n         */\n        function ftruncate(handle: FileHandle, len?: number): Promise<void>;\n\n        /**\n         * Asynchronous rmdir(2) - delete a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function rmdir(path: PathLike, options?: RmDirOptions): Promise<void>;\n\n        /**\n         * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.\n         * @param handle A 'FileHandle'.\n         */\n        function fdatasync(handle: FileHandle): Promise<void>;\n\n        /**\n         * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.\n         * @param handle A 'FileHandle'.\n         */\n        function fsync(handle: FileHandle): Promise<void>;\n\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n         */\n        function mkdir(path: PathLike, options: MakeDirectoryOptions & { recursive: true; }): Promise<string | undefined>;\n\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n         */\n        function mkdir(path: PathLike, options?: number | string | (MakeDirectoryOptions & { recursive?: false; }) | null): Promise<void>;\n\n        /**\n         * Asynchronous mkdir(2) - create a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders\n         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to '0o777'.\n         */\n        function mkdir(path: PathLike, options?: number | string | MakeDirectoryOptions | null): Promise<string | undefined>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function readdir(path: PathLike, options?: { encoding?: BufferEncoding | null; withFileTypes?: false } | BufferEncoding | null): Promise<string[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function readdir(path: PathLike, options: { encoding: \"buffer\"; withFileTypes?: false } | \"buffer\"): Promise<Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function readdir(path: PathLike, options?: { encoding?: string | null; withFileTypes?: false } | string | null): Promise<string[] | Buffer[]>;\n\n        /**\n         * Asynchronous readdir(3) - read a directory.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options If called with 'withFileTypes: true' the result data will be an array of Dirent.\n         */\n        function readdir(path: PathLike, options: { encoding?: string | null; withFileTypes: true }): Promise<Dirent[]>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function readlink(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function readlink(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous readlink(2) - read value of a symbolic link.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function readlink(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        /**\n         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.\n         * @param target A path to an existing file. If a URL is provided, it must use the 'file:' protocol.\n         * @param path A path to the new symlink. If a URL is provided, it must use the 'file:' protocol.\n         * @param type May be set to ''dir'', ''file'', or ''junction'' (default is ''file'') and is only available on Windows (ignored on other platforms).\n         * When using ''junction'', the 'target' argument will automatically be normalized to an absolute path.\n         */\n        function symlink(target: PathLike, path: PathLike, type?: string | null): Promise<void>;\n\n        /**\n         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function lstat(path: PathLike, opts?: StatOptions & { bigint?: false }): Promise<Stats>;\n        function lstat(path: PathLike, opts: StatOptions & { bigint: true }): Promise<BigIntStats>;\n        function lstat(path: PathLike, opts?: StatOptions): Promise<Stats | BigIntStats>;\n\n        /**\n         * Asynchronous stat(2) - Get file status.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function stat(path: PathLike, opts?: StatOptions & { bigint?: false }): Promise<Stats>;\n        function stat(path: PathLike, opts: StatOptions & { bigint: true }): Promise<BigIntStats>;\n        function stat(path: PathLike, opts?: StatOptions): Promise<Stats | BigIntStats>;\n\n        /**\n         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.\n         * @param existingPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param newPath A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function link(existingPath: PathLike, newPath: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function unlink(path: PathLike): Promise<void>;\n\n        /**\n         * Asynchronous fchmod(2) - Change permissions of a file.\n         * @param handle A 'FileHandle'.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function fchmod(handle: FileHandle, mode: string | number): Promise<void>;\n\n        /**\n         * Asynchronous chmod(2) - Change permissions of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function chmod(path: PathLike, mode: string | number): Promise<void>;\n\n        /**\n         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.\n         */\n        function lchmod(path: PathLike, mode: string | number): Promise<void>;\n\n        /**\n         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function lchown(path: PathLike, uid: number, gid: number): Promise<void>;\n\n        /**\n         * Asynchronous fchown(2) - Change ownership of a file.\n         * @param handle A 'FileHandle'.\n         */\n        function fchown(handle: FileHandle, uid: number, gid: number): Promise<void>;\n\n        /**\n         * Asynchronous chown(2) - Change ownership of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         */\n        function chown(path: PathLike, uid: number, gid: number): Promise<void>;\n\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied path.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function utimes(path: PathLike, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n\n        /**\n         * Asynchronously change file timestamps of the file referenced by the supplied 'FileHandle'.\n         * @param handle A 'FileHandle'.\n         * @param atime The last access time. If a string is provided, it will be coerced to number.\n         * @param mtime The last modified time. If a string is provided, it will be coerced to number.\n         */\n        function futimes(handle: FileHandle, atime: string | number | Date, mtime: string | number | Date): Promise<void>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function realpath(path: PathLike, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function realpath(path: PathLike, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronous realpath(3) - return the canonicalized absolute pathname.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function realpath(path: PathLike, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required 'prefix' to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function mkdtemp(prefix: string, options?: { encoding?: BufferEncoding | null } | BufferEncoding | null): Promise<string>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required 'prefix' to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function mkdtemp(prefix: string, options: { encoding: \"buffer\" } | \"buffer\"): Promise<Buffer>;\n\n        /**\n         * Asynchronously creates a unique temporary directory.\n         * Generates six random characters to be appended behind a required 'prefix' to create a unique temporary directory.\n         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, ''utf8'' is used.\n         */\n        function mkdtemp(prefix: string, options?: { encoding?: string | null } | string | null): Promise<string | Buffer>;\n\n        /**\n         * Asynchronously writes data to a file, replacing the file if it already exists.\n         * It is unsafe to call 'fsPromises.writeFile()' multiple times on the same file without waiting for the 'Promise' to be resolved (or rejected).\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         * If a 'FileHandle' is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a 'Buffer' or 'Uint8Array' is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If 'encoding' is not supplied, the default of ''utf8'' is used.\n         * If 'mode' is not supplied, the default of '0o666' is used.\n         * If 'mode' is a string, it is parsed as an octal integer.\n         * If 'flag' is not supplied, the default of ''w'' is used.\n         */\n        function writeFile(path: PathLike | FileHandle, data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n        /**\n         * Asynchronously append data to a file, creating the file if it does not exist.\n         * @param file A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * URL support is _experimental_.\n         * If a 'FileHandle' is provided, the underlying file will _not_ be closed automatically.\n         * @param data The data to write. If something other than a 'Buffer' or 'Uint8Array' is provided, the value is coerced to a string.\n         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.\n         * If 'encoding' is not supplied, the default of ''utf8'' is used.\n         * If 'mode' is not supplied, the default of '0o666' is used.\n         * If 'mode' is a string, it is parsed as an octal integer.\n         * If 'flag' is not supplied, the default of ''a'' is used.\n         */\n        function appendFile(path: PathLike | FileHandle, data: any, options?: { encoding?: string | null, mode?: string | number, flag?: string | number } | string | null): Promise<void>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * If a 'FileHandle' is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to ''r''.\n         */\n        function readFile(path: PathLike | FileHandle, options?: { encoding?: null, flag?: string | number } | null): Promise<Buffer>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * If a 'FileHandle' is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to ''r''.\n         */\n        function readFile(path: PathLike | FileHandle, options: { encoding: BufferEncoding, flag?: string | number } | BufferEncoding): Promise<string>;\n\n        /**\n         * Asynchronously reads the entire contents of a file.\n         * @param path A path to a file. If a URL is provided, it must use the 'file:' protocol.\n         * If a 'FileHandle' is provided, the underlying file will _not_ be closed automatically.\n         * @param options An object that may contain an optional flag.\n         * If a flag is not provided, it defaults to ''r''.\n         */\n        function readFile(path: PathLike | FileHandle, options?: { encoding?: string | null, flag?: string | number } | string | null): Promise<string | Buffer>;\n\n        function opendir(path: string, options?: OpenDirOptions): Promise<Dir>;\n    }\n\n    interface BigIntStats extends StatsBase<bigint> {\n    }\n\n    class BigIntStats {\n        atimeNs: bigint;\n        mtimeNs: bigint;\n        ctimeNs: bigint;\n        birthtimeNs: bigint;\n    }\n\n    interface BigIntOptions {\n        bigint: true;\n    }\n\n    interface StatOptions {\n        bigint: boolean;\n    }\n}",
                "stream.d.ts": 'declare module \'stream\' {\n    import EventEmitter = require(\'events\');\n\n    class internal extends EventEmitter {\n        pipe<T extends NodeJS.WritableStream>(destination: T, options?: { end?: boolean; }): T;\n    }\n\n    namespace internal {\n        class Stream extends internal {\n            constructor(opts?: ReadableOptions);\n        }\n\n        interface ReadableOptions {\n            highWaterMark?: number;\n            encoding?: string;\n            objectMode?: boolean;\n            read?(this: Readable, size: number): void;\n            destroy?(this: Readable, error: Error | null, callback: (error: Error | null) => void): void;\n            autoDestroy?: boolean;\n        }\n\n        class Readable extends Stream implements NodeJS.ReadableStream {\n            /**\n             * A utility method for creating Readable Streams out of iterators.\n             */\n            static from(iterable: Iterable<any> | AsyncIterable<any>, options?: ReadableOptions): Readable;\n\n            readable: boolean;\n            readonly readableEncoding: BufferEncoding | null;\n            readonly readableEnded: boolean;\n            readonly readableFlowing: boolean | null;\n            readonly readableHighWaterMark: number;\n            readonly readableLength: number;\n            readonly readableObjectMode: boolean;\n            destroyed: boolean;\n            constructor(opts?: ReadableOptions);\n            _read(size: number): void;\n            read(size?: number): any;\n            setEncoding(encoding: string): this;\n            pause(): this;\n            resume(): this;\n            isPaused(): boolean;\n            unpipe(destination?: NodeJS.WritableStream): this;\n            unshift(chunk: any, encoding?: BufferEncoding): void;\n            wrap(oldStream: NodeJS.ReadableStream): this;\n            push(chunk: any, encoding?: string): boolean;\n            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;\n            destroy(error?: Error): void;\n\n            /**\n             * Event emitter\n             * The defined events on documents including:\n             * 1. close\n             * 2. data\n             * 3. end\n             * 4. error\n             * 5. pause\n             * 6. readable\n             * 7. resume\n             */\n            addListener(event: "close", listener: () => void): this;\n            addListener(event: "data", listener: (chunk: any) => void): this;\n            addListener(event: "end", listener: () => void): this;\n            addListener(event: "error", listener: (err: Error) => void): this;\n            addListener(event: "pause", listener: () => void): this;\n            addListener(event: "readable", listener: () => void): this;\n            addListener(event: "resume", listener: () => void): this;\n            addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            emit(event: "close"): boolean;\n            emit(event: "data", chunk: any): boolean;\n            emit(event: "end"): boolean;\n            emit(event: "error", err: Error): boolean;\n            emit(event: "pause"): boolean;\n            emit(event: "readable"): boolean;\n            emit(event: "resume"): boolean;\n            emit(event: string | symbol, ...args: any[]): boolean;\n\n            on(event: "close", listener: () => void): this;\n            on(event: "data", listener: (chunk: any) => void): this;\n            on(event: "end", listener: () => void): this;\n            on(event: "error", listener: (err: Error) => void): this;\n            on(event: "pause", listener: () => void): this;\n            on(event: "readable", listener: () => void): this;\n            on(event: "resume", listener: () => void): this;\n            on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            once(event: "close", listener: () => void): this;\n            once(event: "data", listener: (chunk: any) => void): this;\n            once(event: "end", listener: () => void): this;\n            once(event: "error", listener: (err: Error) => void): this;\n            once(event: "pause", listener: () => void): this;\n            once(event: "readable", listener: () => void): this;\n            once(event: "resume", listener: () => void): this;\n            once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependListener(event: "close", listener: () => void): this;\n            prependListener(event: "data", listener: (chunk: any) => void): this;\n            prependListener(event: "end", listener: () => void): this;\n            prependListener(event: "error", listener: (err: Error) => void): this;\n            prependListener(event: "pause", listener: () => void): this;\n            prependListener(event: "readable", listener: () => void): this;\n            prependListener(event: "resume", listener: () => void): this;\n            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependOnceListener(event: "close", listener: () => void): this;\n            prependOnceListener(event: "data", listener: (chunk: any) => void): this;\n            prependOnceListener(event: "end", listener: () => void): this;\n            prependOnceListener(event: "error", listener: (err: Error) => void): this;\n            prependOnceListener(event: "pause", listener: () => void): this;\n            prependOnceListener(event: "readable", listener: () => void): this;\n            prependOnceListener(event: "resume", listener: () => void): this;\n            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            removeListener(event: "close", listener: () => void): this;\n            removeListener(event: "data", listener: (chunk: any) => void): this;\n            removeListener(event: "end", listener: () => void): this;\n            removeListener(event: "error", listener: (err: Error) => void): this;\n            removeListener(event: "pause", listener: () => void): this;\n            removeListener(event: "readable", listener: () => void): this;\n            removeListener(event: "resume", listener: () => void): this;\n            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            [Symbol.asyncIterator](): AsyncIterableIterator<any>;\n        }\n\n        interface WritableOptions {\n            highWaterMark?: number;\n            decodeStrings?: boolean;\n            defaultEncoding?: string;\n            objectMode?: boolean;\n            emitClose?: boolean;\n            write?(this: Writable, chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            writev?(this: Writable, chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            destroy?(this: Writable, error: Error | null, callback: (error: Error | null) => void): void;\n            final?(this: Writable, callback: (error?: Error | null) => void): void;\n            autoDestroy?: boolean;\n        }\n\n        class Writable extends Stream implements NodeJS.WritableStream {\n            readonly writable: boolean;\n            readonly writableEnded: boolean;\n            readonly writableFinished: boolean;\n            readonly writableHighWaterMark: number;\n            readonly writableLength: number;\n            readonly writableObjectMode: boolean;\n            readonly writableCorked: number;\n            destroyed: boolean;\n            constructor(opts?: WritableOptions);\n            _write(chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            _writev?(chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            _destroy(error: Error | null, callback: (error?: Error | null) => void): void;\n            _final(callback: (error?: Error | null) => void): void;\n            write(chunk: any, cb?: (error: Error | null | undefined) => void): boolean;\n            write(chunk: any, encoding: string, cb?: (error: Error | null | undefined) => void): boolean;\n            setDefaultEncoding(encoding: string): this;\n            end(cb?: () => void): void;\n            end(chunk: any, cb?: () => void): void;\n            end(chunk: any, encoding: string, cb?: () => void): void;\n            cork(): void;\n            uncork(): void;\n            destroy(error?: Error): void;\n\n            /**\n             * Event emitter\n             * The defined events on documents including:\n             * 1. close\n             * 2. drain\n             * 3. error\n             * 4. finish\n             * 5. pipe\n             * 6. unpipe\n             */\n            addListener(event: "close", listener: () => void): this;\n            addListener(event: "drain", listener: () => void): this;\n            addListener(event: "error", listener: (err: Error) => void): this;\n            addListener(event: "finish", listener: () => void): this;\n            addListener(event: "pipe", listener: (src: Readable) => void): this;\n            addListener(event: "unpipe", listener: (src: Readable) => void): this;\n            addListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            emit(event: "close"): boolean;\n            emit(event: "drain"): boolean;\n            emit(event: "error", err: Error): boolean;\n            emit(event: "finish"): boolean;\n            emit(event: "pipe", src: Readable): boolean;\n            emit(event: "unpipe", src: Readable): boolean;\n            emit(event: string | symbol, ...args: any[]): boolean;\n\n            on(event: "close", listener: () => void): this;\n            on(event: "drain", listener: () => void): this;\n            on(event: "error", listener: (err: Error) => void): this;\n            on(event: "finish", listener: () => void): this;\n            on(event: "pipe", listener: (src: Readable) => void): this;\n            on(event: "unpipe", listener: (src: Readable) => void): this;\n            on(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            once(event: "close", listener: () => void): this;\n            once(event: "drain", listener: () => void): this;\n            once(event: "error", listener: (err: Error) => void): this;\n            once(event: "finish", listener: () => void): this;\n            once(event: "pipe", listener: (src: Readable) => void): this;\n            once(event: "unpipe", listener: (src: Readable) => void): this;\n            once(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependListener(event: "close", listener: () => void): this;\n            prependListener(event: "drain", listener: () => void): this;\n            prependListener(event: "error", listener: (err: Error) => void): this;\n            prependListener(event: "finish", listener: () => void): this;\n            prependListener(event: "pipe", listener: (src: Readable) => void): this;\n            prependListener(event: "unpipe", listener: (src: Readable) => void): this;\n            prependListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            prependOnceListener(event: "close", listener: () => void): this;\n            prependOnceListener(event: "drain", listener: () => void): this;\n            prependOnceListener(event: "error", listener: (err: Error) => void): this;\n            prependOnceListener(event: "finish", listener: () => void): this;\n            prependOnceListener(event: "pipe", listener: (src: Readable) => void): this;\n            prependOnceListener(event: "unpipe", listener: (src: Readable) => void): this;\n            prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;\n\n            removeListener(event: "close", listener: () => void): this;\n            removeListener(event: "drain", listener: () => void): this;\n            removeListener(event: "error", listener: (err: Error) => void): this;\n            removeListener(event: "finish", listener: () => void): this;\n            removeListener(event: "pipe", listener: (src: Readable) => void): this;\n            removeListener(event: "unpipe", listener: (src: Readable) => void): this;\n            removeListener(event: string | symbol, listener: (...args: any[]) => void): this;\n        }\n\n        interface DuplexOptions extends ReadableOptions, WritableOptions {\n            allowHalfOpen?: boolean;\n            readableObjectMode?: boolean;\n            writableObjectMode?: boolean;\n            readableHighWaterMark?: number;\n            writableHighWaterMark?: number;\n            writableCorked?: number;\n            read?(this: Duplex, size: number): void;\n            write?(this: Duplex, chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            writev?(this: Duplex, chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            final?(this: Duplex, callback: (error?: Error | null) => void): void;\n            destroy?(this: Duplex, error: Error | null, callback: (error: Error | null) => void): void;\n        }\n\n        // Note: Duplex extends both Readable and Writable.\n        class Duplex extends Readable implements Writable {\n            readonly writable: boolean;\n            readonly writableEnded: boolean;\n            readonly writableFinished: boolean;\n            readonly writableHighWaterMark: number;\n            readonly writableLength: number;\n            readonly writableObjectMode: boolean;\n            readonly writableCorked: number;\n            constructor(opts?: DuplexOptions);\n            _write(chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            _writev?(chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            _destroy(error: Error | null, callback: (error: Error | null) => void): void;\n            _final(callback: (error?: Error | null) => void): void;\n            write(chunk: any, encoding?: string, cb?: (error: Error | null | undefined) => void): boolean;\n            write(chunk: any, cb?: (error: Error | null | undefined) => void): boolean;\n            setDefaultEncoding(encoding: string): this;\n            end(cb?: () => void): void;\n            end(chunk: any, cb?: () => void): void;\n            end(chunk: any, encoding?: string, cb?: () => void): void;\n            cork(): void;\n            uncork(): void;\n        }\n\n        type TransformCallback = (error?: Error | null, data?: any) => void;\n\n        interface TransformOptions extends DuplexOptions {\n            read?(this: Transform, size: number): void;\n            write?(this: Transform, chunk: any, encoding: string, callback: (error?: Error | null) => void): void;\n            writev?(this: Transform, chunks: Array<{ chunk: any, encoding: string }>, callback: (error?: Error | null) => void): void;\n            final?(this: Transform, callback: (error?: Error | null) => void): void;\n            destroy?(this: Transform, error: Error | null, callback: (error: Error | null) => void): void;\n            transform?(this: Transform, chunk: any, encoding: string, callback: TransformCallback): void;\n            flush?(this: Transform, callback: TransformCallback): void;\n        }\n\n        class Transform extends Duplex {\n            constructor(opts?: TransformOptions);\n            _transform(chunk: any, encoding: string, callback: TransformCallback): void;\n            _flush(callback: TransformCallback): void;\n        }\n\n        class PassThrough extends Transform { }\n\n        interface FinishedOptions {\n            error?: boolean;\n            readable?: boolean;\n            writable?: boolean;\n        }\n        function finished(stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream, options: FinishedOptions, callback: (err?: NodeJS.ErrnoException | null) => void): () => void;\n        function finished(stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream, callback: (err?: NodeJS.ErrnoException | null) => void): () => void;\n        namespace finished {\n            function __promisify__(stream: NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream, options?: FinishedOptions): Promise<void>;\n        }\n\n        function pipeline<T extends NodeJS.WritableStream>(stream1: NodeJS.ReadableStream, stream2: T, callback?: (err: NodeJS.ErrnoException | null) => void): T;\n        function pipeline<T extends NodeJS.WritableStream>(stream1: NodeJS.ReadableStream, stream2: NodeJS.ReadWriteStream, stream3: T, callback?: (err: NodeJS.ErrnoException | null) => void): T;\n        function pipeline<T extends NodeJS.WritableStream>(\n            stream1: NodeJS.ReadableStream,\n            stream2: NodeJS.ReadWriteStream,\n            stream3: NodeJS.ReadWriteStream,\n            stream4: T,\n            callback?: (err: NodeJS.ErrnoException | null) => void,\n        ): T;\n        function pipeline<T extends NodeJS.WritableStream>(\n            stream1: NodeJS.ReadableStream,\n            stream2: NodeJS.ReadWriteStream,\n            stream3: NodeJS.ReadWriteStream,\n            stream4: NodeJS.ReadWriteStream,\n            stream5: T,\n            callback?: (err: NodeJS.ErrnoException | null) => void,\n        ): T;\n        function pipeline(\n            streams: ReadonlyArray<NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream>,\n            callback?: (err: NodeJS.ErrnoException | null) => void,\n        ): NodeJS.WritableStream;\n        function pipeline(\n            stream1: NodeJS.ReadableStream,\n            stream2: NodeJS.ReadWriteStream | NodeJS.WritableStream,\n            ...streams: Array<NodeJS.ReadWriteStream | NodeJS.WritableStream | ((err: NodeJS.ErrnoException | null) => void)>,\n        ): NodeJS.WritableStream;\n        namespace pipeline {\n            function __promisify__(stream1: NodeJS.ReadableStream, stream2: NodeJS.WritableStream): Promise<void>;\n            function __promisify__(stream1: NodeJS.ReadableStream, stream2: NodeJS.ReadWriteStream, stream3: NodeJS.WritableStream): Promise<void>;\n            function __promisify__(stream1: NodeJS.ReadableStream, stream2: NodeJS.ReadWriteStream, stream3: NodeJS.ReadWriteStream, stream4: NodeJS.WritableStream): Promise<void>;\n            function __promisify__(\n                stream1: NodeJS.ReadableStream,\n                stream2: NodeJS.ReadWriteStream,\n                stream3: NodeJS.ReadWriteStream,\n                stream4: NodeJS.ReadWriteStream,\n                stream5: NodeJS.WritableStream,\n            ): Promise<void>;\n            function __promisify__(streams: ReadonlyArray<NodeJS.ReadableStream | NodeJS.WritableStream | NodeJS.ReadWriteStream>): Promise<void>;\n            function __promisify__(\n                stream1: NodeJS.ReadableStream,\n                stream2: NodeJS.ReadWriteStream | NodeJS.WritableStream,\n                ...streams: Array<NodeJS.ReadWriteStream | NodeJS.WritableStream>,\n            ): Promise<void>;\n        }\n\n        interface Pipe {\n            close(): void;\n            hasRef(): boolean;\n            ref(): void;\n            unref(): void;\n        }\n    }\n\n    export = internal;\n}',
                "node:axios": "declare module 'node:axios' {\n    import axios from 'axios';\n    export default axios;\n}\n\ndeclare module 'axios' {\n    import { AxiosRequestConfig, AxiosResponse } from 'axios';\n    export default axios;\n}",
                "node-require.d.ts": "\n    declare function require(moduleName: string): any;\n  "
            };
            var Q = ["language"];

            function $(e) {
                var n = function(n) {
                    var {
                        language: t
                    } = n, i = (0, N.Z)(n, Q), r = (0, s.useRef)([]);
                    return (0, s.useEffect)((() => {
                        if (["typescript"].includes(t)) {
                            var e = r.current;
                            Object.keys(X).forEach((n => {
                                var t = X[n];
                                e.push(d.languages.typescript.typescriptDefaults.addExtraLib(t, n))
                            }))
                        }
                        return () => {
                            r.current.forEach((e => e.dispose())), r.current = []
                        }
                    }), [t]), l().createElement(e, (0, A.Z)({}, i, {
                        language: t
                    }))
                };
                return n.displayName = "withExtraLibs(".concat((0, z.G)(e), ")"), n
            }
            const ee = $;
            var ne = t("50DI"),
                te = t.n(ne),
                ie = t("CmRW"),
                re = t("6mht"),
                oe = t("6+HK");

            function ae(e, n) {
                var t = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var i = Object.getOwnPropertySymbols(e);
                    n && (i = i.filter((function(n) {
                        return Object.getOwnPropertyDescriptor(e, n).enumerable
                    }))), t.push.apply(t, i)
                }
                return t
            }

            function se(e) {
                for (var n = 1; n < arguments.length; n++) {
                    var t = null != arguments[n] ? arguments[n] : {};
                    n % 2 ? ae(Object(t), !0).forEach((function(n) {
                        (0, a.Z)(e, n, t[n])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ae(Object(t)).forEach((function(n) {
                        Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(t, n))
                    }))
                }
                return e
            }
            var le = e => {
                    var n = se(se({}, e.innerProps), {}, {
                        role: "option",
                        "aria-disabled": e.isDisabled
                    });
                    return l().createElement(oe.y.Option, (0, A.Z)({}, e, {
                        innerProps: n
                    }))
                },
                de = e => {
                    var n = se(se({}, e.innerProps), {}, {
                        id: e.selectProps.menuId,
                        role: "listbox",
                        "aria-expanded": !0
                    });
                    return l().createElement("div", n, l().createElement(oe.y.MenuList, e))
                },
                ce = e => {
                    var n = se(se({}, e), {}, {
                        role: e.selectProps.isSearchable ? "combobox" : "listbox",
                        "aria-owns": e.selectProps.menuId,
                        "aria-autocomplete": "list",
                        "aria-expanded": e.selectProps.menuIsOpen ? "true" : "false"
                    });
                    return l().createElement(oe.y.Input, n)
                };
            const pe = function(e) {
                return l().createElement(re.ZP, (0, A.Z)({
                    components: {
                        Option: le,
                        MenuList: de,
                        Input: ce
                    }
                }, e))
            };
            var ue = t("TBNV"),
                he = {
                    ada: {
                        Language: "Ada",
                        Version: "GNU Ada compiler 4.9",
                        Time_Standard: 3,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    bash: {
                        Language: "Bash",
                        Version: "Version 5.2.32",
                        Time_Standard: 1,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    brainfuck: {
                        Language: "Brainf**k",
                        Version: "brainfuck",
                        Time_Standard: "",
                        MEMORY_LIMIT_Standard: "",
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    c: {
                        Language: "C",
                        Version: "GCC 8.3.0, C11 standard",
                        Time_Standard: 2,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "Newtonsoft json library",
                        Time_ML: 2,
                        MEMORY_LIMIT_ML: 512,
                        Libraries_ML: "liblinear@2.21, libsvm@3.23",
                        Comments: "N/A"
                    },
                    csharp: {
                        Language: "C#",
                        Version: ".NET 6.0.2, C# 10.0",
                        Time_Standard: 3,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "Newtonsoft.Json@13.0.1, System.Reactive@5.0.0",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    cpp: {
                        Language: "C++",
                        Version: "G++ 8.3.0, C++11 standard",
                        Time_Standard: 2,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "Math library-lm json library libcurl",
                        Time_ML: 2,
                        MEMORY_LIMIT_ML: 512,
                        Libraries_ML: "liblinear@2.21, libsvm@3.23, Boost C++ Libraries",
                        Comments: "N/A"
                    },
                    cpp14: {
                        Language: "C++14",
                        Version: "G++ 8.3.0, C++14 standard",
                        Time_Standard: 2,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "Math library-lm json library libcurl",
                        Time_ML: 2,
                        MEMORY_LIMIT_ML: 512,
                        Libraries_ML: "liblinear@2.21, libsvm@3.23, Boost C++ Libraries",
                        Comments: "N/A"
                    },
                    cpp20: {
                        Language: "C++20",
                        Version: "G++ 8.3.0, C++20 standard",
                        Time_Standard: 2,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "Math library-lm json library libcurl",
                        Time_ML: 2,
                        MEMORY_LIMIT_ML: 512,
                        Libraries_ML: "liblinear@2.21, libsvm@3.23, Boost C++ Libraries",
                        Comments: "N/A"
                    },
                    cpp23: {
                        Language: "C++23",
                        Version: "G++ 14.2.0, C++23 standard",
                        Time_Standard: 2,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "Math library-lm json library libcurl",
                        Time_ML: 2,
                        MEMORY_LIMIT_ML: 512,
                        Libraries_ML: "liblinear@2.21, libsvm@3.23, Boost C++ Libraries",
                        Comments: "N/A"
                    },
                    clojure: {
                        Language: "Clojure",
                        Version: "clojure 1.9.0",
                        Time_Standard: 8,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "algo.generic@0.1.3, alog.monads@0.1.6, core.logic@0.8.11, core.specs.alpha@0.1.10, tools.macro@0.1.2, data.avl@0.1.0, data.int-map@0.2.4, data.json@0.2.6, data.priority-map@0.0.10, data.xml@0.0.8, spec.alpha@0.2.176",
                        Time_ML: 8,
                        MEMORY_LIMIT_ML: 512,
                        Libraries_ML: "stanford-nlp@3.2.0, weka@3-6-10, java-ml@0.1.7, Jama@1.0.3",
                        Comments: "N/A"
                    },
                    cobol: {
                        Language: "Cobol",
                        Version: "(OpenCOBOL) 2.2.0",
                        Time_Standard: 3,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    coffeescript: {
                        Language: "CoffeeScript",
                        Version: "Node.js v14.15.4",
                        Time_Standard: 10,
                        MEMORY_LIMIT_Standard: 1024,
                        Libraries: "axios@0.21.1, babel-cli@6.26.0, babel-preset-latest@6.24.1, bignumber.js@9.0.1, jquery@3.5.1, loadash@4.17.20, request@2.88.2, typescript@4.1.3, underscore@1.12.0",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    sbcl: {
                        Language: "Common Lisp (SBCL)",
                        Version: "SBCL 1.4.2",
                        Time_Standard: 12,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    d: {
                        Language: "D",
                        Version: "Version 2.084.0",
                        Time_Standard: 3,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    dart: {
                        Language: "Dart",
                        Version: "Dart SDK version: 2.18.7",
                        Time_Standard: 12,
                        MEMORY_LIMIT_Standard: 768,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    db2: {
                        Language: "DB2",
                        Version: "DB2 v10.5.0.1",
                        Time_Standard: 60,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    elixir: {
                        Language: "Elixir",
                        Version: "Version 1.8.2 (compiled with Erlang/OTP 21)",
                        Time_Standard: 12,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    erlang: {
                        Language: "Erlang",
                        Version: "Erlang/OTP 21 [erts-10.4.4]",
                        Time_Standard: 12,
                        MEMORY_LIMIT_Standard: 1024,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "Have your main function in module solution"
                    },
                    fsharp: {
                        Language: "F#",
                        Version: "F# Compiler for F# 4.1, Mono compiler v5.2",
                        Time_Standard: 4,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    fortran: {
                        Language: "Fortran",
                        Version: "GNU Fortran 5.5",
                        Time_Standard: 5,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    octave: {
                        Language: "GNU Octave",
                        Version: "Version 8.3.0",
                        Time_Standard: 5,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "control, dataframe, linear-algebra, optim, signal, statistics, struct",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    go: {
                        Language: "Go",
                        Version: "1.22.5",
                        Time_Standard: 4,
                        MEMORY_LIMIT_Standard: 1024,
                        Libraries: "encoding/json, encoding/csv, encoding/xml, strings, math, container/heap, container/list, net/http",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    groovy: {
                        Language: "Groovy",
                        Version: "v2.5.5",
                        Time_Standard: 5,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "JVM: 1.8.0_121\n",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "Have your entry point inside an object named solution"
                    },
                    haskell: {
                        Language: "Haskell",
                        Version: "ghc 8.6.5, lts-14.7",
                        Time_Standard: 5,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "base-prelude@1.3, logict@0.7.0.2, pipes@4.3.13, hashtables@1.2.3.4, random@1.1, text@1.2.3.1, vector@0.12.0.3, aeson@1.4.6.0, lens@4.17.1, lens-aeson@1.0.2, split@0.2.3.3, bytestring@0.10.8.2, array@0.5.3.0, arrow-list, regex-applicative@0.3.3.1, regex-base@0.93.2, regex-compat@0.95.1, regex-pcre-builtin@0.94.5.8.8.35, regex-posix@0.95.2, regex-tdfa@1.2.3.2, parsec@3.1.14.0, unordered-containers@0.2.10.0, attoparsec@0.13.2.3, comonad@5.0.6, deepseq@1.4.4.0, dlist@0.8.0.7, either@5.0.1.1, matrix@0.3.6.1, MemoTrie@0.6.10, threads@0.5.1.6, monad-memo@0.5.1, io-memoize@1.1.1.0, array-memoize@0.6.0, base-unicode-symbols@0.2.3, basic-prelude@0.7.0, bifunctors@5.5.6",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    java: {
                        Language: "Java",
                        Version: "Sun Java 1.7.0_80",
                        Time_Standard: 4,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "TestNG@6.14.3, JSON Simple@1.1.1, Tagsoup@1.2.1, Google/Gson@2.8.5, HTTPCore@4.4.12, HTTPCore5@5.0-beta8, HTTPAsyncClient@4.1.4, HTTPClient@4.5.10, HTTPClient5@5.0-beta5, XMLResolver@1.2, Jing@20091111, JUnit@4.13-beta-1, Hamcrest@2.1-rc3, Commons Lang3@3.9, Commons Logging@1.2",
                        Time_ML: 50,
                        MEMORY_LIMIT_ML: 2048,
                        Libraries_ML: "stanford-nlp@3.2.0, weka@3-6-10, java-ml@0.1.7, Jama@1.0.3, ajt@2.11",
                        Comments: "N/A"
                    },
                    java15: {
                        Language: "Java 15",
                        Version: "OpenJDK 15.0.2",
                        Time_Standard: 4,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "TestNG@6.14.3, JSON Simple@1.1.1, Tagsoup@1.2.1, Google/Gson@2.8.5, HTTPCore@4.4.12, HTTPCore5@5.0-beta8, HTTPAsyncClient@4.1.4, HTTPClient@4.5.10, HTTPClient5@5.0-beta5, XMLResolver@1.2, Jing@20091111, JUnit@4.13-beta-1, Hamcrest@2.1-rc3, Commons Lang3@3.9, Commons Logging@1.2, JavaFX Base@15-linux",
                        Time_ML: 50,
                        MEMORY_LIMIT_ML: 2048,
                        Libraries_ML: "stanford-nlp@3.2.0, weka@3-6-10, java-ml@0.1.7, Jama@1.0.3, ajt@2.11",
                        Comments: "N/A"
                    },
                    java17: {
                        Language: "Java 17",
                        Version: "OpenJDK 17.0.2",
                        Time_Standard: 4,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "TestNG@7.4.0, JSON Simple@1.1.1, Tagsoup@1.2.1, Google/Gson@2.8.8, HTTPCore@4.4.15, HTTPCore5@5.0-beta8, HTTPAsyncClient@4.1.4, HTTPClient@4.5.13, HTTPClient5@5.0-beta5, XMLResolver@1.2, Jing@20091111, JUnit@4.13-beta-1, Hamcrest@2.2, Commons Lang3@3.9, Commons Logging@1.2, JavaFX Base@17-linux",
                        Time_ML: 50,
                        MEMORY_LIMIT_ML: 2048,
                        Libraries_ML: "stanford-corenlp-full@2013-06-20, stanford-classifier@2013-06-20, weka@3-6-10, java-ml@0.1.7, Jama@1.0.3, weka-packages@LibSVM1.0.5",
                        Comments: "N/A"
                    },
                    java21: {
                        Language: "Java 21",
                        Version: "OpenJDK 21.0.4",
                        Time_Standard: 4,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "TestNG@7.4.0, JSON Simple@1.1.1, Tagsoup@1.2.1, Google/Gson@2.8.8, HTTPCore@4.4.15, HTTPCore5@5.0-beta8, HTTPAsyncClient@4.1.4, HTTPClient@4.5.13, HTTPClient5@5.0-beta5, XMLResolver@1.2, Jing@20091111, JUnit@4.13-beta-1, Hamcrest@2.2, Commons Lang3@3.9, Commons Logging@1.2, JavaFX Base@17-linux",
                        Time_ML: 50,
                        MEMORY_LIMIT_ML: 2048,
                        Libraries_ML: "stanford-corenlp-full@2013-06-20, stanford-classifier@2013-06-20, weka@3-6-10, java-ml@0.1.7, Jama@1.0.3, weka-packages@LibSVM1.0.5",
                        Comments: "N/A"
                    },
                    java8: {
                        Language: "Java 8",
                        Version: "OpenJDK 1.8.0_342",
                        Time_Standard: 4,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "TestNG@7.9.0, JSON Simple@1.1.1, Tagsoup@1.2.1, Google/Gson@2.8.5, HTTPCore@4.4.16, HTTPCore5@5.2.5, HTTPAsyncClient@4.1.5, HTTPClient@4.5.14, HTTPClient5@5.3.1, XMLResolver@1.2, Jing@20091111, JUnit@4.13.2, Hamcrest@3.0, Commons Lang3@3.9, Commons Logging@1.3.4",
                        Time_ML: 50,
                        MEMORY_LIMIT_ML: 2048,
                        Libraries_ML: "stanford-nlp@3.2.0, weka@3-6-10, java-ml@0.1.7, Jama@1.0.3, ajt@2.11",
                        Comments: "N/A"
                    },
                    javascript: {
                        Language: "Javascript",
                        Version: "node.js v20.15.1",
                        Time_Standard: 10,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "axios@0.27.2, babel-cli@6.26.0, babel-preset-latest@6.24.1, bignumber.js@9.1.0, coffeescript@2.7.0, jquery@3.6.0, loadash@4.17.21, node-fetch@2.6.11, request@2.88.2, typescript@4.7.4, underscore@1.13.4",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    julia: {
                        Language: "Julia",
                        Version: "Version 1.2.0",
                        Time_Standard: 10,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    kotlin: {
                        Language: "Kotlin",
                        Version: "Kotlin 1.9.0",
                        Time_Standard: 4,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "Google Gson",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    lolcode: {
                        Language: "LOLCode",
                        Version: "Version 1.2 with lci v0.10.5",
                        Time_Standard: 5,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    lua: {
                        Language: "Lua",
                        Version: "Lua 5.3.3",
                        Time_Standard: 12,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    tsql: {
                        Language: "Microsoft SQL",
                        Version: "Microsoft SQL Server 2022 - 16.0.4025.1 (X64)",
                        Time_Standard: 60,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    mysql: {
                        Language: "MySQL",
                        Version: "Version 8.0.33",
                        Time_Standard: 60,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    nim: {
                        Language: "Nim",
                        Version: "Version 0.20.2",
                        Time_Standard: 5,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    objectivec: {
                        Language: "Objective-C",
                        Version: "Apple LLVM version 9.1.0, Target SDK: MacOSX10.13",
                        Time_Standard: 2,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "Foundation Framework",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    ocaml: {
                        Language: "OCaml",
                        Version: "ocamlopt, version 4.09",
                        Time_Standard: 3,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "Jane Street OCaml core libraries\n async@0.11.0, cohttp@2.4.0, cohttp-async@2.4.0, core@0.11.3, core_extended@0.11.0, xmlm@1.3.0, yojson@1.7.0",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    oracle: {
                        Language: "Oracle \n (PL/SQL supported)",
                        Version: "11g Express, Release 11.2.0.2.0 - 64bit",
                        Time_Standard: 60,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    pascal: {
                        Language: "Pascal",
                        Version: "Version 3.0.4",
                        Time_Standard: 2,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    perl: {
                        Language: "Perl",
                        Version: "Perl (v5.26.3)",
                        Time_Standard: 9,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "JSON::XS@4.02, XML::Parser@2.44, Set::Scalar@1.29, Math::SparseVector@0.03 & Math::SparseMatrix@0.03",
                        Time_ML: 10,
                        MEMORY_LIMIT_ML: 512,
                        Libraries_ML: "PDL & Text::NSP",
                        Comments: "N/A"
                    },
                    php: {
                        Language: "PHP",
                        Version: "PHP 8.2",
                        Time_Standard: 9,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "rmccue/requests@v2.0.6",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    pgsql: {
                        Language: "PostgreSQL",
                        Version: "Version 14.3",
                        Time_Standard: 60,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    pypy: {
                        Language: "PyPy",
                        Version: "PyPy2.7 v6.0.0",
                        Time_Standard: 3,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "requests[security]@2.22.0, beautifulsoup4@4.8.1, pycryptodome@3.9.4, cryptography@2.8, pyyaml@5.2",
                        Time_ML: 4,
                        MEMORY_LIMIT_ML: 1024,
                        Libraries_ML: "numpy@1.16.5, sympy@1.4, nltk@3.4.5",
                        Comments: "N/A"
                    },
                    pypy3: {
                        Language: "PyPy 3",
                        Version: "PyPy3.6 v6.0.0",
                        Time_Standard: 4,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "requests[security]@2.22.0, beautifulsoup4@4.8.1, pycryptodome@3.9.4, cryptography@2.8, pyyaml@5.2",
                        Time_ML: 4,
                        MEMORY_LIMIT_ML: 1024,
                        Libraries_ML: "numpy@1.17.4, sympy@1.4, nltk@3.4.5",
                        Comments: "N/A"
                    },
                    python: {
                        Language: "Python",
                        Version: "Python 2.7.15",
                        Time_Standard: 10,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "requests[security]@2.22.0, beautifulsoup4@4.8.1, pycrypto@2.6.1, cryptography@2.8, python-dateutil@2.8.1, urllib3@1.25.7, pyyaml@5.2",
                        Time_ML: 10,
                        MEMORY_LIMIT_ML: 1024,
                        Libraries_ML: "requests[security]@2.22.0, beautifulsoup4@4.8.1, pycrypto@2.6.1, cryptography@2.8, python-dateutil@2.8.1, urllib3@1.25.7, pyyaml@5.2, numpy@1.16.5, scipy@1.2.2, sympy@1.4, scikit-learn@0.20.4, nltk@3.4.5, pandas@0.24.2, statsmodels@0.10.2",
                        Comments: "N/A"
                    },
                    python3: {
                        Language: "Python 3",
                        Version: "Python 3.12.4",
                        Time_Standard: 10,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "requests[security]@2.25.1, beautifulsoup4@4.9.3, pycrypto@2.6.1, cryptography@3.4.7, python-dateutil@2.8.1, urllib3@1.26.4, pyyaml@5.4.1",
                        Time_ML: 10,
                        MEMORY_LIMIT_ML: 1024,
                        Libraries_ML: "requests[security]@2.31.0, beautifulsoup4@4.12.2, pycrypto@2.6.1, cryptography@40.0.2, python-dateutil@2.8.2, urllib3@2.0.2, pyyaml@6.0, numpy@1.26.0, scipy@1.14.0, sympy@1.13.1, scikit-learn@1.5.1, nltk@3.8.1, pandas@2.2.2, statsmodels@0.14.1, pyspark@3.4.0, matplotlib@3.9.1",
                        Comments: "N/A"
                    },
                    r: {
                        Language: "R",
                        Version: "Version 4.4.1",
                        Time_Standard: 10,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "base64enc@0.1-3, bit64@4.0.5, caret@6.0-94, class@7.3-22, cluster@2.1.6, codetools@0.2-20, data.table@1.16.0, deepnet@0.2.1, digest@0.6.37, dplyr@1.1.4, e1071@1.7-14, evaluate@0.24.0, fBasics@4041.97, fastcluster@1.2.6, foreach@1.5.2, Formula@1.2-5, glmnet@4.1-8, iterators@1.0.14, lattice@0.22-6, latticeExtra@0.6-30, lubridate@1.9.3, Matrix@1.7-0, neuralnet@1.44.2, numDeriv@2016.8-1.1, plyr@1.8.9, psy@1.2, pwt@7.1-1, randomForest@4.7-1.1, readr@2.1.5, reshape2@1.4.4, rjson@0.2.22, scales@1.3.0, spatial@7.3-17, sqldf@0.4-11, statmod@1.5.0, stringr@1.5.1, survival@3.7-0, timeDate@4032.109, xgboost@1.7.8.1, xts@0.14.0, zoo@1.8-12",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    racket: {
                        Language: "Racket",
                        Version: "Version 7.2",
                        Time_Standard: 10,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    ruby: {
                        Language: "Ruby",
                        Version: "Ruby 3.2.2",
                        Time_Standard: 10,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "xml-simple@1.1.5, http@4.2.0, faraday@0.17.1, rest-client@2.1.0, httpclient@2.8.3, httparty@0.17.1",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    rust: {
                        Language: "Rust",
                        Version: "Version 1.59.0",
                        Time_Standard: 5,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "num@0.2.1, serde@1.0.104, serde_json@1.0.40, serde_derive, rustc-serialize@0.3.24, regex@1.3.4, time@0.3.9, text_io@0.1.8, rand@0.7.3",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    scala: {
                        Language: "Scala",
                        Version: "scala 2.13.11",
                        Time_Standard: 7,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "Have your entry point inside an object named Solution json-simple example\n \n Same as java8 packages\n \n scalaz-core_2.12@7.3.0-M27, cats-macros_2.12@2.0.0, cats-kernel_2.12@2.0.0, cats-core_2.12@2.0.0, cats-free_2.12@2.0.0, ajt@2.11, jama@1.0.3",
                        Time_ML: 7,
                        MEMORY_LIMIT_ML: 512,
                        Libraries_ML: "stanford-nlp@3.2.0, weka@3-6-10, java-ml@0.1.7, Jama@1.0.3",
                        Comments: "N/A"
                    },
                    smalltalk: {
                        Language: "Smalltalk",
                        Version: "GNU Smalltalk 3.2.5",
                        Time_Standard: 5,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    swift: {
                        Language: "Swift",
                        Version: "Swift v5.10.1",
                        Time_Standard: 2,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "Foundation Framework",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    tcl: {
                        Language: "Tcl",
                        Version: "Version 8.6 with tclsh",
                        Time_Standard: 5,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    text: {
                        Language: "Text",
                        Version: "",
                        Time_Standard: "",
                        MEMORY_LIMIT_Standard: "",
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    typescript: {
                        Language: "TypeScript",
                        Version: "Node.js v20.15.1, Target: ES2020, Module: CommonJS",
                        Time_Standard: 10,
                        MEMORY_LIMIT_Standard: 1536,
                        Libraries: "axios@1.7.7, babel-cli@6.26.0, babel-preset-latest@6.24.1, bignumber.js@9.1.2, coffeescript@2.7.0, jquery@3.7.1, lodash@4.17.21,node-fetch@2.6.11, readline@1.3.0, request@2.88.2, typescript@5.6.2, underscore@1.13.6, @babel/preset-typescript@7.24.7, @types/jquery@3.5.30, @types/lodash@4.17.7, @types/node-fetch@2.6.11, @types/node@20.14.1, @types/request@2.48.12, @types/underscore@1.11.15",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    verilog: {
                        Language: "Verilog",
                        Version: "Icarus Verilog 11.0",
                        Time_Standard: 4,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    visualbasic: {
                        Language: "Visual Basic (VB.NET)",
                        Version: "Mono compiler v6.4.0.198, .NET Framework 4.7.2",
                        Time_Standard: 5,
                        MEMORY_LIMIT_Standard: 512,
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    },
                    whitespace: {
                        Language: "Whitespace",
                        Version: "",
                        Time_Standard: "",
                        MEMORY_LIMIT_Standard: "",
                        Libraries: "",
                        Time_ML: "",
                        MEMORY_LIMIT_ML: "",
                        Libraries_ML: "",
                        Comments: "N/A"
                    }
                },
                fe = e => {
                    var {
                        language: n,
                        display: t,
                        closeModal: i,
                        t: r
                    } = e;
                    if (!he[n.value]) return null;
                    var {
                        Language: o = "",
                        Version: a = "",
                        Time_Standard: s = "",
                        MEMORY_LIMIT_Standard: d = "",
                        Libraries: c = "",
                        Time_ML: p = "",
                        MEMORY_LIMIT_ML: u = "",
                        Libraries_ML: h = "",
                        Comments: m = ""
                    } = he[n.value], g = c.split(",").map((e => e.trim())), b = g.length - 7, v = g.slice(0, 7).join(", "), y = g.slice(7).join(", "), L = h.split(",").map((e => e.trim())), S = L.length - 7, E = L.slice(0, 7).join(", "), T = L.slice(7).join(", "), I = e => {
                        var n;
                        return "string" != typeof e || !(!e || 0 === (null == e || null === (n = e.trim()) || void 0 === n ? void 0 : n.length))
                    };
                    return l().createElement(ue.Z, {
                        open: t,
                        onClose: i,
                        title: (0, f.g7)("execution_env", r),
                        className: "execution-env-modal"
                    }, l().createElement("table", {
                        className: "execution-env-table",
                        role: "presentation"
                    }, l().createElement("tbody", null, l().createElement("tr", null, l().createElement("th", null, (0, f.g7)("language", r)), l().createElement("td", null, o)), I(a) && l().createElement("tr", null, l().createElement("th", null, (0, f.g7)("version", r)), l().createElement("td", null, a)), I(s) && l().createElement("tr", null, l().createElement("th", null, (0, f.g7)("time_limit_standard", r)), l().createElement("td", null, "".concat(s, " secs"))), I(d) && l().createElement("tr", null, l().createElement("th", null, (0, f.g7)("memory_limit_standard", r)), l().createElement("td", null, "".concat(d, " MB"))), I(v) && l().createElement("tr", null, l().createElement("th", null, (0, f.g7)("libraries_standard", r)), l().createElement("td", null, v, " ", b > 0 && l().createElement(G.ZP, {
                        content: y,
                        align: "bottom-right",
                        style: {
                            width: "325px"
                        }
                    }, l().createElement("span", {
                        className: "extra-lib-display"
                    }, "+".concat(b))))), I(p) && l().createElement("tr", null, l().createElement("th", null, (0, f.g7)("time_limit_ml", r)), l().createElement("td", null, "".concat(p, " secs"))), I(u) && l().createElement("tr", null, l().createElement("th", null, (0, f.g7)("memory_limit_ml", r)), l().createElement("td", null, "".concat(u, " MB"))), I(E) && l().createElement("tr", null, l().createElement("th", null, (0, f.g7)("libraries_ml", r)), l().createElement("td", null, E, " ", S > 0 && l().createElement(G.ZP, {
                        content: T,
                        align: "bottom-right",
                        style: {
                            width: "200px"
                        }
                    }, l().createElement("span", {
                        className: "extra-lib-display"
                    }, "+".concat(S))))), l().createElement("tr", null, l().createElement("th", null, (0, f.g7)("comments", r)), l().createElement("td", null, m)))))
                },
                me = ["hideEditor", "defaultLanguage", "languageOptions", "customToolBar", "toolbarLeftItems", "itemsBeforeLanguageSelector", "toolbarStatus", "languageSelectClassName", "renderSettings", "renderBeforeEditor", "renderAfterEditor", "loaderComponent", "loaderProps", "showPane", "languageSelectStyles", "languageOnLeft", "autoCompleteClassName", "showAutocompleteStatus", "dbSchema", "t"];

            function ge(e, n) {
                var t = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var i = Object.getOwnPropertySymbols(e);
                    n && (i = i.filter((function(n) {
                        return Object.getOwnPropertyDescriptor(e, n).enumerable
                    }))), t.push.apply(t, i)
                }
                return t
            }

            function be(e) {
                for (var n = 1; n < arguments.length; n++) {
                    var t = null != arguments[n] ? arguments[n] : {};
                    n % 2 ? ge(Object(t), !0).forEach((function(n) {
                        (0, a.Z)(e, n, t[n])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ge(Object(t)).forEach((function(n) {
                        Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(t, n))
                    }))
                }
                return e
            }
            var ve = (0, f.qC)(Z, ee)(P);

            function ye() {
                var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                    t = arguments.length > 1 ? arguments[1] : void 0,
                    i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                    r = (0, f.Pd)(be(be({}, t), {}, {
                        isReadonlyEditable: i
                    })),
                    o = function() {
                        var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                            n = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null) || C.default;
                        return (e && e.length ? e : Object.keys(n)).map((e => ({
                            label: n[e].label,
                            value: e
                        })))
                    }(r, t ? t.languages : null);
                return {
                    language: null !== (e = o.find((e => e.value === n))) && void 0 !== e ? e : null == o ? void 0 : o[0],
                    languages: o,
                    languageOptions: r
                }
            }
            class Le extends l().Component {
                constructor() {
                    super(...arguments), (0, a.Z)(this, "state", {}), (0, a.Z)(this, "editor", void 0), (0, a.Z)(this, "setLanguage", (e => {
                        if (e && !Array.isArray(e)) {
                            var {
                                language: n
                            } = this.state, {
                                onLanguageChange: t
                            } = this.props, {
                                value: i
                            } = e;
                            n && n.value === i || t(i, n.value)
                        }
                    })), (0, a.Z)(this, "editorDidMount", (e => {
                        this.editor = e;
                        var {
                            editorDidMount: n
                        } = this.props;
                        n && n(e)
                    })), (0, a.Z)(this, "onCodeFold", (() => {
                        this.setState({
                            renderLoading: !1
                        })
                    })), (0, a.Z)(this, "onLspWebsocketChange", (e => {
                        var {
                            lspState: n
                        } = this.state, {
                            enableAutoComplete: t,
                            onLspWebsocketChange: i
                        } = this.props;
                        if (t) {
                            var r = (0, f.rF)(n, e);
                            r && r !== n && this.setState({
                                lspState: r
                            }), i(e)
                        } else i(e)
                    })), (0, a.Z)(this, "closeModal", (() => {
                        this.setState({
                            showExecutionEnvModal: !1
                        })
                    })), (0, a.Z)(this, "executionEnvironmentInfoButton", (() => {
                        var {
                            language: e,
                            showExecutionEnvModal: n
                        } = this.state, {
                            t
                        } = this.props, i = (0, f.g7)("tooltip_env_not_available", t), r = !0;
                        return he[e.value] && (i = (0, f.g7)("tooltip_env_available", t), r = !1), l().createElement("div", {
                            className: "execution-env"
                        }, l().createElement(G.ZP, {
                            content: i,
                            align: "bottom"
                        }, l().createElement("button", {
                            className: "info-icon-text",
                            onClick: () => this.setState({
                                showExecutionEnvModal: !0
                            }),
                            "aria-label": i,
                            disabled: r
                        }, l().createElement("span", null, l().createElement(Y.Z, (0, A.Z)({}, {
                            height: "1em",
                            width: "1em"
                        }, {
                            "aria-hidden": "true",
                            focusable: "false"
                        })), " ", (0, f.g7)("environment", t)))), l().createElement(fe, {
                            display: n,
                            language: e,
                            closeModal: this.closeModal,
                            t
                        }))
                    }))
                }
                static getDerivedStateFromProps(e, n) {
                    if (!n || !n.language) {
                        var t = ye(e.defaultLanguage, e.languageOptions, e.isReadonlyEditable);
                        return t.lspState = (0, f.RY)(t.language, e.enableAutoComplete, e.lspDisabledLanguages), t.prevAutoComplete = e.enableAutoComplete, t.originalLangOptions = e.languageOptions, t.renderLoading = !0, t.showExecutionEnvModal = e.showExecutionEnvModal, t.previousLangFromProps = e.defaultLanguage, t
                    }
                    if (e.defaultLanguage !== n.previousLangFromProps || e.languageOptions !== n.originalLangOptions) {
                        var i = ye(e.defaultLanguage, e.languageOptions, e.isReadonlyEditable);
                        return e.defaultLanguage !== n.previousLangFromProps && (i.lspState = (0, f.RY)(i.language, e.enableAutoComplete, e.lspDisabledLanguages)), i.showExecutionEnvModal = e.showExecutionEnvModal, i.prevAutoComplete = e.enableAutoComplete, i.originalLangOptions = e.languageOptions, i.previousLangFromProps = e.defaultLanguage, i.renderLoading = !(e.defaultLanguage === n.previousLangFromProps), i
                    }
                    return e.enableAutoComplete !== n.prevAutoComplete ? (n.lspState = (0, f.RY)(n.language, e.enableAutoComplete, e.lspDisabledLanguages), n.prevAutoComplete = e.enableAutoComplete, n) : n
                }
                componentDidUpdate(e) {
                    !this.props.hideEditor && e.hideEditor && this.editor && this.editor.layout()
                }
                componentWillUnmount() {
                    this.closeModal()
                }
                renderToolbarItems(e) {
                    var n = this.props[e];
                    return n && n.length ? l().createElement("div", {
                        className: "toolbar-custom-items"
                    }, n.map((e => {
                        if ("string" != typeof e.type) return e.type;
                        var n = e.attrs || {};
                        return l().createElement(ie.kq, (0, A.Z)({
                            key: e.label
                        }, n, {
                            className: e.classList,
                            tabIndex: "0",
                            onClick: e.callback,
                            ariaRole: e.type
                        }), e.label || e.text)
                    }))) : null
                }
                renderEditor() {
                    var {
                        language: e,
                        languageOptions: n,
                        renderLoading: t
                    } = this.state, i = this.props, {
                        hideEditor: r,
                        defaultLanguage: o,
                        languageOptions: a,
                        customToolBar: s,
                        toolbarLeftItems: d,
                        itemsBeforeLanguageSelector: c,
                        toolbarStatus: p,
                        languageSelectClassName: u,
                        renderSettings: h,
                        renderBeforeEditor: f,
                        renderAfterEditor: m,
                        loaderComponent: g,
                        loaderProps: b,
                        showPane: v,
                        languageSelectStyles: y,
                        languageOnLeft: L,
                        autoCompleteClassName: S,
                        showAutocompleteStatus: E,
                        dbSchema: T,
                        t: I
                    } = i, _ = (0, N.Z)(i, me), x = n[e.value], k = "hr-monaco-editor-parent".concat(r || t ? " hr-monaco-editor-hide" : "");
                    return "mysql" !== e.value || T || (x.lsp = "sql"), l().createElement("div", {
                        className: k
                    }, l().createElement(ve, (0, A.Z)({}, _, {
                        language: e.value,
                        syntax: x.syntax || "",
                        code: x,
                        lspEndpoint: x.lsp,
                        fileExtension: x.extension,
                        editorDidMount: this.editorDidMount,
                        onCodeFold: this.onCodeFold,
                        onLspWebsocketChange: this.onLspWebsocketChange,
                        dbSchema: T
                    })))
                }
                renderLoadingDiv() {
                    var {
                        loaderComponent: e,
                        loaderProps: n
                    } = this.props;
                    return l().createElement("div", {
                        className: "hr-monaco-loading-language",
                        style: {
                            height: this.props.height,
                            width: this.props.width
                        }
                    }, e ? l().createElement(e, n) : l().createElement("p", null, l().createElement("span", {
                        className: "hr-monaco-loading-text"
                    }, " Loading Code ")))
                }
                renderLanguageSelector() {
                    var {
                        language: e,
                        languages: n
                    } = this.state, {
                        languageSelectClassName: t,
                        languageSelectStyles: i,
                        t: r,
                        customSelect: o = null
                    } = this.props, a = "".concat(t, " select-language");
                    return e && 1 === n.length ? l().createElement("span", {
                        className: a
                    }, l().createElement("span", {
                        className: "select-language__label"
                    }, r("language"), ": "), e.label) : l().createElement(s.Fragment, null, l().createElement("label", {
                        className: "select-language__label",
                        id: "select-language-label",
                        htmlFor: "select-language-input",
                        "aria-label": r("select_your_coding_language")
                    }, r("language")), o ? o({
                        value: e,
                        options: n,
                        onChange: this.setLanguage
                    }) : l().createElement(pe, {
                        className: a,
                        value: e,
                        options: n,
                        onChange: this.setLanguage,
                        isClearable: !1,
                        styles: i,
                        isDisabled: !e || n.length <= 1,
                        inputId: "select-language-input",
                        "aria-labelledby": "select-language-label",
                        menuId: "select-language-menu"
                    }))
                }
                renderAutoCompleteStatus() {
                    var {
                        language: e,
                        lspState: n
                    } = this.state, {
                        autoCompleteClassName: t,
                        loaderComponent: i,
                        t: r,
                        showAutocompleteStatus: o
                    } = this.props;
                    return l().createElement(s.Fragment, null, l().createElement(q, {
                        status: n,
                        language: e.label,
                        className: t,
                        loaderComponent: i,
                        showAutocompleteStatus: o,
                        t: r
                    }), l().createElement("span", {
                        className: "divider"
                    }))
                }
                render() {
                    var {
                        renderLoading: e
                    } = this.state, {
                        renderSettings: n,
                        renderBeforeEditor: t,
                        renderAfterEditor: i,
                        toolbarStatus: r,
                        languageOnLeft: o,
                        showAutocompleteStatus: a,
                        showExecutionEnvInfoIcon: s
                    } = this.props, d = this.renderLanguageSelector();
                    return l().createElement("div", {
                        className: "hr-monaco-editor"
                    }, l().createElement("div", {
                        className: "editor-toolbar"
                    }, l().createElement("div", {
                        className: "toolbar-left"
                    }, o && d, r && l().createElement("div", null, r), this.renderToolbarItems("toolbarLeftItems"), s && this.executionEnvironmentInfoButton()), l().createElement("div", {
                        className: "toolbar-right"
                    }, a && this.renderAutoCompleteStatus(), this.renderToolbarItems("itemsBeforeLanguageSelector"), !o && d, this.renderToolbarItems("customToolBar"), n && n())), t && t(), this.renderEditor(), e && this.renderLoadingDiv(), i && i())
                }
            }(0, a.Z)(Le, "defaultProps", {
                showPane: !1,
                languageOptions: null,
                customToolBar: [],
                toolbarLeftItems: [],
                itemsBeforeLanguageSelector: [],
                toolbarStatus: "",
                hideEditor: !1,
                height: 500,
                languageSelectClassName: "",
                renderSettings: h(),
                editorDidMount: h(),
                onLanguageChange: h(),
                renderBeforeEditor: h(),
                renderAfterEditor: h(),
                loaderComponent: null,
                loaderProps: {},
                languageSelectStyles: {},
                languageOnLeft: !1,
                showAutocompleteStatus: !1,
                lspDisabledLanguages: [],
                onLspWebsocketChange: h(),
                showExecutionEnvModal: !1,
                showExecutionEnvInfoIcon: !1,
                renderLineHighlight: "",
                t: te()
            });
            const Se = Le;
            var Ee = t("TSYQ"),
                Te = t.n(Ee),
                Ie = t("pt8c"),
                _e = t("RSe9"),
                xe = t("fC43");
            class ke extends s.PureComponent {
                constructor() {
                    super(...arguments), (0, a.Z)(this, "onClick", (() => {
                        var {
                            setting: e,
                            item: n,
                            onSelect: t
                        } = this.props;
                        t(e.id, n.value)
                    }))
                }
                render() {
                    var {
                        value: e,
                        item: n,
                        setting: t
                    } = this.props, i = e === n.value, r = Te()("settings-button", {
                        "ui-btn-primary ": i,
                        "ui-btn-default": !i
                    });
                    return l().createElement(ie.ZP, {
                        key: n.label,
                        ariaRole: "radio",
                        "aria-checked": i,
                        tabIndex: i ? "0" : "-1",
                        className: r,
                        onClick: this.onClick,
                        "aria-label": "".concat(n.label, " ").concat(t.label)
                    }, n.label)
                }
            }
            var we = t("ziTh"),
                Ce = ["text", "label", "type", "classList", "callback"],
                Me = ["mode", "showModes", "showIntellisense", "theme", "showTheme", "customSetting", "onChangeSettings", "onToggleSettingsPane", "tabSize", "defaultLanguage", "lspDisabledLanguages", "enableAutoComplete"],
                Re = Math.pow(2, 24);
            const Oe = e => {
                var n;
                return n = class extends s.PureComponent {
                    constructor(e) {
                        super(e), (0, a.Z)(this, "id", void 0), (0, a.Z)(this, "deprecationWarned", !1), (0, a.Z)(this, "editor", void 0), (0, a.Z)(this, "container", void 0), (0, a.Z)(this, "containerRefCb", void 0), (0, a.Z)(this, "preferencePane", void 0), (0, a.Z)(this, "editorDidMount", (e => {
                            this.editor = e, this.props.editorDidMount(e)
                        })), (0, a.Z)(this, "containerRefCb", (e => {
                            this.container = e
                        })), (0, a.Z)(this, "onSelectSetting", ((e, n) => {
                            var t = this.state[e];
                            t !== n && this.setState({
                                [e]: n
                            }, (() => {
                                this.props.onChangeSettings(e, n, t)
                            }))
                        })), (0, a.Z)(this, "toggleSettingsPane", (() => {
                            this.setState({
                                showPane: !this.state.showPane
                            }, (() => {
                                var {
                                    onToggleSettingsPane: e
                                } = this.props, {
                                    showPane: n
                                } = this.state;
                                e(n), n ? this.addListeners() : (this.removeListeners(), this.container.querySelector(".settings-toggle").focus())
                            }))
                        })), (0, a.Z)(this, "handleKeyNav", (e => {
                            var n = this.preferencePane.current;
                            this.state.showPane && n && (e.which !== D.nx.ESC ? e.which === D.nx.TAB ? (0, xe.ZP)(n, "[tabindex='0']")(e) : e.which === D.nx.UP || e.which === D.nx.LEFT ? this.moveButtonFocus(e, -1) : e.which !== D.nx.DOWN && e.which !== D.nx.RIGHT || this.moveButtonFocus(e, 1) : this.toggleSettingsPane())
                        })), (0, a.Z)(this, "handleClickOutSide", (e => {
                            var n = this.container;
                            n && !n.contains(e.target) && this.toggleSettingsPane()
                        })), (0, a.Z)(this, "renderSettings", (() => {
                            var {
                                showPane: e
                            } = this.state, n = Te()("settings-toggle", {
                                "settings-toggle--active": e
                            });
                            return l().createElement("div", {
                                ref: this.containerRefCb,
                                className: "hr-monaco-settings-editor"
                            }, l().createElement(_e.Z, {
                                Icon: Ie.Z,
                                btnText: "More",
                                tabIndex: "0",
                                className: n,
                                onClick: this.toggleSettingsPane,
                                "aria-haspopup": "true",
                                "aria-expanded": e,
                                "aria-label": "Editor Settings",
                                title: "Editor Settings",
                                tooltip: !1
                            }), this.renderPane())
                        }));
                        var {
                            theme: n,
                            tabSize: t,
                            mode: i,
                            enableAutoComplete: r,
                            defaultLanguage: o,
                            useRandomId: s
                        } = e;
                        this.id = "kj-editor-".concat(s ? Math.floor(Math.random() * Re).toString(32) : ""), this.state = {
                            theme: n,
                            prevTheme: n,
                            tabSize: t,
                            intellisense: r,
                            mode: i,
                            showPane: !1,
                            currentLanguage: o
                        }, this.preferencePane = l().createRef()
                    }
                    static getDerivedStateFromProps(e, n) {
                        return e.theme === n.prevTheme ? null : {
                            theme: e.theme,
                            prevTheme: e.theme
                        }
                    }
                    componentWillUnmount() {
                        this.removeListeners()
                    }
                    getIntellisenseTooltipText() {
                        var {
                            lspDisabledLanguages: e,
                            t: n
                        } = this.props, t = C.LSP_LANGUAGES.filter((n => e.indexOf(n) < 0)).map((e => C.default[e].label)).join(", "), i = (0, f.g7)("autocompleteAvailableText", n);
                        return "".concat(i, " ").concat(t)
                    }
                    focus() {
                        this.editor && this.editor.focus()
                    }
                    moveButtonFocus(e, n) {
                        var t, i = e.target.parentElement.children;
                        (t = 1 === n ? e.target === i[i.length - 1] ? i[0] : e.target.nextSibling : e.target === i[0] ? i[i.length - 1] : e.target.previousSibling) && (e.preventDefault(), t.focus())
                    }
                    removeListeners() {
                        window.removeEventListener("click", this.handleClickOutSide), document.removeEventListener("keydown", this.handleKeyNav)
                    }
                    addListeners() {
                        window.addEventListener("click", this.handleClickOutSide), document.addEventListener("keydown", this.handleKeyNav)
                    }
                    renderCustomSettings() {
                        var {
                            renderCustomSettings: e
                        } = this.props;
                        return "function" != typeof e ? null : l().createElement("div", {
                            className: "formgroup horizontal"
                        }, e())
                    }
                    getCustomSettingsContent() {
                        this.deprecationWarned || (we.warn("Deprecation Warning: customSetting prop is deprecated, use renderCustomSetting prop"), this.deprecationWarned = !0);
                        var {
                            customSetting: e
                        } = this.props;
                        return e.length ? l().createElement("div", null, e.map(((e, n) => {
                            var {
                                text: t,
                                label: i,
                                type: r,
                                classList: o,
                                callback: a
                            } = e, s = (0, N.Z)(e, Ce), d = "link" === r ? "a" : r;
                            return l().createElement("div", {
                                key: n,
                                className: "formgroup horizontal"
                            }, i && l().createElement("label", {
                                className: "hr-monaco-formgroup-label"
                            }, i), l().createElement(d, (0, A.Z)({
                                tabIndex: "0",
                                className: o,
                                onClick: a
                            }, s), t))
                        }))) : null
                    }
                    renderSetting(e) {
                        var {
                            showTheme: n,
                            showModes: t,
                            showIntellisense: i,
                            lspDisabledLanguages: r,
                            defaultLanguage: o
                        } = this.props;
                        if (D.EM.THEME === e.id && !n) return null;
                        if (D.EM.EDITOR_MODE === e.id && !t) return null;
                        if (D.EM.AUTOCOMPLETE === e.id && (!i || !C.LSP_LANGUAGES.includes(o) || r.includes(o))) return null;
                        var a = "".concat(this.id, "-").concat(e.id),
                            s = this.state[e.id],
                            d = D.EM.AUTOCOMPLETE === e.id,
                            c = d ? this.getIntellisenseTooltipText() : "";
                        return l().createElement("div", {
                            key: e.id,
                            "data-automation": "krakjack-".concat(e.id, "-setting"),
                            className: "formgroup horizontal",
                            role: "radiogroup",
                            "aria-labelledby": a
                        }, l().createElement("label", {
                            className: "hr-monaco-formgroup-label ",
                            id: a
                        }, e.label, d && l().createElement(G.ZP, {
                            content: c,
                            align: "bottom",
                            "data-automation": "autocomplete-tooltip"
                        }, l().createElement("span", {
                            tabIndex: 0,
                            "aria-label": "Info icon",
                            role: "button"
                        }, l().createElement(Y.Z, null)))), l().createElement("div", {
                            className: "inline"
                        }, l().createElement("div", {
                            className: "ui-btn-group"
                        }, e.items.map((n => l().createElement(ke, {
                            setting: e,
                            value: s,
                            key: n.value,
                            item: n,
                            role: "radio",
                            onSelect: this.onSelectSetting
                        }))))))
                    }
                    renderPane() {
                        var {
                            showPane: e
                        } = this.state, {
                            renderCustomSettings: n,
                            t
                        } = this.props, i = (0, f.pI)(t);
                        return e ? l().createElement("div", {
                            className: "hr-monaco-pref-pane",
                            role: "region",
                            ref: this.preferencePane
                        }, l().createElement("div", {
                            className: "pref-pane-arrow"
                        }), i.map((e => this.renderSetting(e))), n ? this.renderCustomSettings() : this.getCustomSettingsContent()) : null
                    }
                    render() {
                        var n = this.props,
                            {
                                mode: t,
                                showModes: i,
                                showIntellisense: r,
                                theme: o,
                                showTheme: a,
                                customSetting: s,
                                onChangeSettings: d,
                                onToggleSettingsPane: c,
                                tabSize: p,
                                defaultLanguage: u,
                                lspDisabledLanguages: h,
                                enableAutoComplete: f
                            } = n,
                            m = (0, N.Z)(n, Me),
                            {
                                theme: g,
                                tabSize: b,
                                intellisense: v,
                                mode: y,
                                showPane: L
                            } = this.state,
                            S = !1;
                        return v === f && !v || h.includes(u) || !C.LSP_LANGUAGES.includes(u) || (S = v), l().createElement(e, (0, A.Z)({}, m, {
                            defaultLanguage: u,
                            theme: g,
                            tabSize: b,
                            mode: y,
                            enableAutoComplete: S,
                            lspDisabledLanguages: h,
                            showPane: L,
                            renderSettings: this.renderSettings,
                            editorDidMount: this.editorDidMount,
                            intellisense: v
                        }))
                    }
                }, (0, a.Z)(n, "displayName", "withSettings(".concat((0, f.Gf)(e), ")")), (0, a.Z)(n, "defaultProps", {
                    mode: "normal",
                    showModes: !0,
                    showIntellisense: !0,
                    theme: "light",
                    tabSize: 4,
                    enableAutoComplete: !1,
                    showTheme: !0,
                    customSetting: [],
                    editorDidMount: h(),
                    onChangeSettings: h(),
                    onToggleSettingsPane: h(),
                    lspDisabledLanguages: [],
                    useRandomId: !0,
                    SettingsIcon: Ie.Z
                }), n
            };
            var Pe = ["enablePositionInfo", "initialStatusMessage", "statusBarChildren"];
            const Ae = e => {
                var n;
                return n = class extends l().Component {
                    constructor(e) {
                        super(e), (0, a.Z)(this, "disposable", void 0), (0, a.Z)(this, "input", void 0), (0, a.Z)(this, "cmdInputOptions", void 0), (0, a.Z)(this, "onCmdKeyDown", (e => {
                            var {
                                cmdInputOptions: n,
                                cmdInputOnclose: t
                            } = this;
                            n && n.onKeyDown && n.onKeyDown(e, e.target.value, (() => {
                                e.preventDefault(), e.stopPropagation(), this.toggleCommandInput(!1), this.editor.focus()
                            })) || ((e.keyCode === D.nx.ESC || n && !1 !== n.closeOnEnter && e.keyCode === D.nx.ENTER) && (this.input.blur(), e.preventDefault(), e.stopPropagation(), this.toggleCommandInput(!1), this.editor.focus()), e.keyCode === D.nx.ENTER && t && t(e.target.value, e))
                        })), (0, a.Z)(this, "onCmdKeyUp", (e => {
                            this.cmdInputOptions && this.cmdInputOptions.onKeyUp && this.cmdInputOptions.onKeyUp(e, e.target.value, (() => {
                                this.toggleCommandInput(!1)
                            }))
                        })), (0, a.Z)(this, "setStatusMessage", (e => {
                            e !== this.state.statusMessage && this.setState({
                                statusMessage: e
                            })
                        })), (0, a.Z)(this, "commandInputRef", (e => {
                            this.input = e
                        })), (0, a.Z)(this, "toggleCommandInput", ((e, n, t) => {
                            this.setState({
                                enableCommandInput: e
                            }), this.cmdInputOnclose = n, this.cmdInputOptions = t
                        })), (0, a.Z)(this, "editorDidMount", (e => {
                            var {
                                editorDidMount: n
                            } = this.props;
                            this.editor = e, n(e), this.setState({
                                position: e.getPosition()
                            }), this.disposable = e.onDidChangeCursorPosition((e => {
                                var {
                                    position: n
                                } = e;
                                this.setState({
                                    position: n
                                })
                            }))
                        })), this.state = {
                            position: null,
                            statusMessage: e.initialStatusMessage,
                            enableCommandInput: !1
                        }
                    }
                    componentDidUpdate(e, n) {
                        var {
                            enableCommandInput: t
                        } = this.state;
                        n.enableCommandInput !== t && t && this.input && (this.input.focus(), this.cmdInputOptions && this.cmdInputOptions.selectValueOnOpen && this.input.select())
                    }
                    componentWillUnmount() {
                        this.disposable && this.disposable.dispose()
                    }
                    render() {
                        var n = this.props,
                            {
                                enablePositionInfo: t,
                                initialStatusMessage: i,
                                statusBarChildren: r
                            } = n,
                            o = (0, N.Z)(n, Pe),
                            {
                                position: a,
                                statusMessage: s,
                                enableCommandInput: d
                            } = this.state;
                        return l().createElement("div", {
                            className: "hr-monaco-editor-with-statusbar"
                        }, l().createElement(e, (0, A.Z)({}, o, {
                            editorDidMount: this.editorDidMount,
                            setStatusMessage: this.setStatusMessage,
                            toggleCommandInput: this.toggleCommandInput
                        })), l().createElement("div", {
                            className: "hr-monaco-editor-statusbar"
                        }, l().createElement("div", {
                            style: {
                                display: "flex"
                            }
                        }, (s || d) && l().createElement("div", {
                            className: "statusbar-message-container"
                        }, l().createElement("div", {
                            className: "statusbar-message"
                        }, s), d && l().createElement("input", {
                            ref: this.commandInputRef,
                            className: "statusbar-command-input",
                            type: "text",
                            onKeyDown: this.onCmdKeyDown,
                            onKeyUp: this.onCmdKeyUp,
                            defaultValue: ""
                        })), r && l().createElement("div", {
                            className: "statusbar-children"
                        }, r)), t && a && l().createElement("div", {
                            className: "statusbar-position"
                        }, "Line: ", a.lineNumber, " Col: ", a.column)))
                    }
                }, (0, a.Z)(n, "displayName", "withStatusBar(".concat((0, f.Gf)(e), ")")), (0, a.Z)(n, "defaultProps", {
                    enablePositionInfo: !0,
                    initialStatusMessage: "",
                    editorDidMount: h(),
                    statusBarChildren: void 0
                }), n
            };
            var Ne = ["showSubmit", "showCompileTest", "compileButtonText", "submitButtonText", "onCompileTest", "onSubmitCode", "compileTestBlocked", "submitBlocked", "submitButtonSubText"];

            function De(e) {
                class n extends s.Component {
                    constructor(e) {
                        super(e), (0, a.Z)(this, "currentLanguage", void 0), (0, a.Z)(this, "editor", void 0), (0, a.Z)(this, "onCompileTest", (e => {
                            e.persist();
                            var {
                                onCompileTest: n
                            } = this.props;
                            n({
                                language: this.currentLanguage,
                                code: this.editor.getValue()
                            }, e)
                        })), (0, a.Z)(this, "onSubmitCode", (e => {
                            e.persist();
                            var {
                                onSubmitCode: n
                            } = this.props;
                            n({
                                language: this.currentLanguage,
                                code: this.editor.getValue()
                            }, e)
                        })), (0, a.Z)(this, "onLanguageChange", ((e, n) => {
                            this.currentLanguage = e, this.props.onLanguageChange(e, n)
                        })), (0, a.Z)(this, "editorDidMount", (e => {
                            this.editor = e, this.props.editorDidMount(e)
                        })), this.currentLanguage = e.defaultLanguage
                    }
                    renderButtons() {
                        var {
                            submitButtonProps: e,
                            compileButtonProps: n,
                            compileButtonText: t,
                            submitButtonText: i,
                            showSubmit: r,
                            showCompileTest: o,
                            compileTestBlocked: a,
                            submitBlocked: s
                        } = this.props;
                        return l().createElement("div", {
                            className: "pmR pmL pmB plT run-code-wrapper"
                        }, r && l().createElement(ie.KM, (0, A.Z)({}, e, {
                            onClick: this.onSubmitCode,
                            disabled: !!s || void 0,
                            className: "pull-right hr-monaco-submit"
                        }), i), o && l().createElement(ie.kq, (0, A.Z)({}, n, {
                            onClick: this.onCompileTest,
                            disabled: !!a || void 0,
                            className: "pull-right msR hr-monaco-compile hr-monaco__run-code"
                        }), t))
                    }
                    render() {
                        var n = this.props,
                            {
                                showSubmit: t,
                                showCompileTest: i,
                                compileButtonText: r,
                                submitButtonText: o,
                                onCompileTest: a,
                                onSubmitCode: s,
                                compileTestBlocked: d,
                                submitBlocked: c,
                                submitButtonSubText: p
                            } = n,
                            u = (0, N.Z)(n, Ne);
                        return l().createElement("div", null, l().createElement(e, (0, A.Z)({}, u, {
                            editorDidMount: this.editorDidMount,
                            onLanguageChange: this.onLanguageChange
                        })), p ? l().createElement("div", {
                            className: "hr-monaco-btn-wrapper"
                        }, this.renderButtons(), l().createElement("span", {
                            className: "hr-monaco-sub-text"
                        }, p)) : this.renderButtons())
                    }
                }
                return (0, a.Z)(n, "displayName", "withRunCode(".concat((0, f.Gf)(e), ")")), (0, a.Z)(n, "defaultProps", {
                    showSubmit: !0,
                    showCompileTest: !0,
                    submitButtonProps: {},
                    compileButtonProps: {},
                    compileButtonText: "Run Code",
                    submitButtonText: "Submit Code",
                    submitButtonSubText: "",
                    onLanguageChange: h(),
                    editorDidMount: h(),
                    compileTestBlocked: !1,
                    submitBlocked: !1
                }), n
            }
            var Ue = t("4ZbX");
            class je extends l().Component {
                constructor(e) {
                    super(e), (0, a.Z)(this, "input", void 0), (0, a.Z)(this, "inputRefCb", (e => {
                        this.input = e
                    })), (0, a.Z)(this, "onChange", (e => {
                        var {
                            onChange: n
                        } = this.props, {
                            value: t
                        } = e.target;
                        n(t);
                        var i = "",
                            r = /^(\s)+/.test(t),
                            o = /(\s)+$/.test(t);
                        r && o ? i = "* Leading and trailing spaces detected in custom input" : r ? i = "* Leading spaces detected in custom input" : o && (i = "* Trailing spaces detected in custom input"), this.setState({
                            value: t,
                            warningText: i
                        })
                    })), this.state = {
                        value: e.defaultValue || "",
                        warningText: ""
                    }
                }
                componentDidMount() {
                    this.input && this.input.focus()
                }
                getValue() {
                    return this.state.value
                }
                render() {
                    var {
                        value: e,
                        warningText: n
                    } = this.state, {
                        className: t,
                        showWarning: i
                    } = this.props;
                    return l().createElement("div", null, l().createElement(Ue.ZP, {
                        type: "textarea",
                        inputRef: this.inputRefCb,
                        className: t,
                        rows: "5",
                        value: e,
                        onChange: this.onChange,
                        autoComplete: "off",
                        autoCorrect: "off",
                        autoCapitalize: "off",
                        spellCheck: "false"
                    }), i && n && l().createElement("span", {
                        className: "block hr-monaco-input-warning"
                    }, n))
                }
            }(0, a.Z)(je, "defaultProps", {
                defaultValue: "",
                className: "",
                showWarning: !1,
                onChange: h()
            });
            var Be = t("PQcE"),
                Fe = ["onCheckboxToggle", "CheckBoxComponent", "InputComponent", "inputProps", "customInputWrapperClass", "showStraySpaceWarning", "onUploadClick", "showCustomInput", "showUploadCode"];

            function Ze(e, n) {
                var t = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var i = Object.getOwnPropertySymbols(e);
                    n && (i = i.filter((function(n) {
                        return Object.getOwnPropertyDescriptor(e, n).enumerable
                    }))), t.push.apply(t, i)
                }
                return t
            }

            function We(e) {
                for (var n = 1; n < arguments.length; n++) {
                    var t = null != arguments[n] ? arguments[n] : {};
                    n % 2 ? Ze(Object(t), !0).forEach((function(n) {
                        (0, a.Z)(e, n, t[n])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : Ze(Object(t)).forEach((function(n) {
                        Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(t, n))
                    }))
                }
                return e
            }

            function Je(e) {
                class n extends l().Component {
                    constructor(e) {
                        super(e), (0, a.Z)(this, "onCompileTest", void 0), (0, a.Z)(this, "onSubmitCode", void 0), (0, a.Z)(this, "inputRef", void 0), (0, a.Z)(this, "inputRefCb", (e => {
                            this.inputRef = e
                        })), (0, a.Z)(this, "onInputChange", (e => {
                            this.setState({
                                input: e
                            });
                            var {
                                inputProps: n
                            } = this.props;
                            n.onChange && n.onChange(e)
                        })), (0, a.Z)(this, "toggleInput", (e => {
                            this.setState({
                                showInput: e.target.checked
                            }), this.props.onCheckboxToggle(e)
                        })), this.state = {
                            input: "",
                            showInput: !1
                        }, this.onCompileTest = this.addInputToCallback.bind(this, "onCompileTest"), this.onSubmitCode = this.addInputToCallback.bind(this, "onSubmitCode")
                    }
                    addInputToCallback(e, n, t) {
                        var i = this.props[e],
                            {
                                showInput: r
                            } = this.state,
                            o = n;
                        r && (o = We(We({}, o), {}, {
                            custominput: this.inputRef.getValue()
                        })), i(o, t)
                    }
                    render() {
                        var {
                            showInput: n
                        } = this.state, t = this.props, {
                            onCheckboxToggle: i,
                            CheckBoxComponent: r,
                            InputComponent: o,
                            inputProps: a,
                            customInputWrapperClass: s,
                            showStraySpaceWarning: d,
                            onUploadClick: c,
                            showCustomInput: p,
                            showUploadCode: u
                        } = t, h = (0, N.Z)(t, Fe), f = p || u;
                        return l().createElement("div", {
                            className: "hr-monaco-editor-with-input"
                        }, l().createElement(e, (0, A.Z)({}, h, {
                            onCompileTest: this.onCompileTest,
                            onSubmitCode: this.onSubmitCode
                        })), f && l().createElement("div", {
                            className: "pmR pmL pmB hr-monaco-custom-input-wrapper ".concat(s)
                        }, u && l().createElement("div", null, l().createElement(ie.kq, {
                            className: "upload-file mlR",
                            "data-analytics": "Upload File",
                            type: "button",
                            onClick: c
                        }, l().createElement("i", {
                            className: "icon-upload ui-icon-upload"
                        }), "Upload Code as File")), p && l().createElement("div", {
                            className: "checkBoxWrapper"
                        }, l().createElement(Be.Z, {
                            label: "Test against custom input",
                            checked: n,
                            onChange: this.toggleInput
                        }), n && l().createElement(o, (0, A.Z)({
                            ref: this.inputRefCb
                        }, a, {
                            onChange: this.onInputChange,
                            showWarning: d,
                            className: "custominput auto-width"
                        })))))
                    }
                }
                return (0, a.Z)(n, "displayName", "withInput(".concat((0, f.Gf)(e), ")")), (0, a.Z)(n, "defaultProps", {
                    inputProps: {
                        defaultValue: ""
                    },
                    onUploadClick: h(),
                    onCheckboxToggle: h(),
                    onCompileTest: h(),
                    onSubmitCode: h(),
                    CheckBoxComponent: Be.Z,
                    InputComponent: je,
                    showCustomInput: !0,
                    showUploadCode: !0,
                    customInputWrapperClass: "flex",
                    showStraySpaceWarning: !0
                }), n
            }
            t("OG14");
            var He = ["mode", "toggleCommandInput"];
            const Ve = e => {
                var n;
                return n = class extends s.PureComponent {
                    constructor() {
                        super(...arguments), (0, a.Z)(this, "editor", void 0), (0, a.Z)(this, "keyBuffer", void 0), (0, a.Z)(this, "currentMacro", void 0), (0, a.Z)(this, "currentMode", void 0), (0, a.Z)(this, "vimMode", void 0), (0, a.Z)(this, "emacsMode", void 0), (0, a.Z)(this, "isRecording", void 0), (0, a.Z)(this, "disposable", void 0), (0, a.Z)(this, "editorDidMount", (e => {
                            this.editor = e, this.setMode(this.props.mode), this.props.editorDidMount(e)
                        }))
                    }
                    componentDidUpdate(e) {
                        e.mode !== this.props.mode && this.setMode(this.props.mode)
                    }
                    componentWillUnmount() {
                        this.unbindModes()
                    }
                    unbindModes() {
                        this.vimMode && (this.vimMode.dispose(), this.vimMode = null, this.keyBuffer = "", this.currentMacro = "", this.currentMode = "", this.props.setStatusMessage(""), this.props.toggleCommandInput(!1)), this.emacsMode && (this.emacsMode.dispose(), this.emacsMode = null, this.props.setStatusMessage(""))
                    }
                    setMode(e) {
                        this.unbindModes(), this.keyBuffer = "", this.currentMacro = "", this.currentMode = "", "vim" === e ? t.e("monacovim").then(t.bind(t, "iH6r")).then((n => {
                            var {
                                VimMode: t
                            } = n;
                            this.addExtension(t), this.vimMode = new t(this.editor), this.addListeners(this.vimMode), this.vimMode && (this.vimMode.attach(), this.props.onMountMode(e, this.vimMode, n))
                        })) : "emacs" === e ? t.e("monacoemacs").then(t.bind(t, "VrTg")).then((n => {
                            var {
                                EmacsExtension: t
                            } = n, i = new t(this.editor);
                            i.onDidMarkChange((e => {
                                this.props.setStatusMessage(e ? "Mark Set!" : "Mark Unset")
                            })), i.onDidChangeKey((e => {
                                this.props.setStatusMessage(e || "EMACS")
                            })), this.props.setStatusMessage("EMACS"), i.start(), this.emacsMode = i, this.props.onMountMode(e, i, n)
                        })) : this.props.onMountMode(e)
                    }
                    addExtension(e) {
                        e.defineExtension("openDialog", ((e, n, t) => {
                            if (e.includes("recording")) {
                                var i = e.search(/\[([a-zA-Z0-9])\]/);
                                if (!(i > -1)) return void(this.currentMacro = "");
                                this.currentMacro = e[i + 1], this.isRecording = !0, this.updateStatusBar()
                            } else e.includes("<input") && (this.props.setStatusMessage(e.includes("regex") ? "/" : ":"), this.props.toggleCommandInput(!0, n, t))
                        })), e.defineExtension("closeDialog", (() => {
                            this.keyBuffer = ""
                        }))
                    }
                    updateStatusBar() {
                        var {
                            setStatusMessage: e
                        } = this.props, n = "--".concat(this.currentMode, "--");
                        this.keyBuffer && (n += " , ".concat(this.keyBuffer)), this.currentMacro && (n += " , [recording](".concat(this.currentMacro, ")")), e(n)
                    }
                    addAction() {
                        this.editor && (this.disposable = this.editor.addAction({
                            id: "extension.vim",
                            label: "Toggle VIM Mode",
                            run: () => {
                                this.vimMode ? (this.vimMode.dispose(), this.props.setStatusMessage(""), this.props.toggleCommandInput(!1)) : this.setMode(this.props.mode)
                            }
                        }))
                    }
                    removeAction() {
                        this.disposable && this.disposable.dispose()
                    }
                    addListeners(e) {
                        this.currentMode = "", e.on("vim-mode-change", (e => {
                            if ("object" == typeof e && e.mode) {
                                var {
                                    mode: n,
                                    subMode: t
                                } = e;
                                this.currentMode = "visual" === n ? (0, g.FA)(t) : n.toUpperCase(), this.updateStatusBar()
                            }
                        })), e.on("vim-keypress", (e => {
                            "string" == typeof e && (this.keyBuffer += e, "q" === e && this.isRecording && (this.currentMacro = "", this.keyBuffer = "", this.isRecording = !1), this.updateStatusBar())
                        })), e.on("vim-command-done", (() => {
                            this.keyBuffer = "", this.updateStatusBar()
                        }))
                    }
                    render() {
                        var n = this.props,
                            {
                                mode: t,
                                toggleCommandInput: i
                            } = n,
                            r = (0, N.Z)(n, He);
                        return l().createElement(e, (0, A.Z)({}, r, {
                            editorDidMount: this.editorDidMount
                        }))
                    }
                }, (0, a.Z)(n, "displayName", "withModes(".concat((0, f.Gf)(e), ")")), (0, a.Z)(n, "defaultProps", {
                    mode: "normal",
                    editorDidMount: h(),
                    setStatusMessage: h(),
                    toggleCommandInput: h(),
                    onMountMode: h()
                }), n
            };
            var Ye = t("DzJC"),
                Ge = t.n(Ye),
                Ke = ["completionFuncInterval", "onAnalytics"];
            const qe = e => {
                var n;
                return n = class extends s.PureComponent {
                    constructor(e) {
                        var n;
                        super(e), n = this, (0, a.Z)(this, "callBacks", void 0), (0, a.Z)(this, "currentLanguage", void 0), (0, a.Z)(this, "totalCharsTyped", void 0), (0, a.Z)(this, "editor", void 0), (0, a.Z)(this, "focusLogged", void 0), (0, a.Z)(this, "suggestionEnabled", void 0), (0, a.Z)(this, "disposables", void 0), (0, a.Z)(this, "throttledCompletion", void 0), (0, a.Z)(this, "throttledCodeAction", void 0), (0, a.Z)(this, "popupOpened", void 0), (0, a.Z)(this, "completionEvents", void 0), (0, a.Z)(this, "codeActionEvents", void 0), (0, a.Z)(this, "editorDidMount", (e => {
                            this.props.editorDidMount(e), this.editor = e, this.attachEditorEvents()
                        })), (0, a.Z)(this, "onAnalytics", (function(e, t, i) {
                            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                                o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null,
                                a = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null,
                                s = {
                                    event_type: e,
                                    event_name: t
                                };
                            void 0 !== i && (s.event_value = i), void 0 !== r && (s.integer_event_value = r), o && (s.metadata = o), n.props.onAnalytics(s, a)
                        })), (0, a.Z)(this, "onCompletionReceive", ((e, n, t) => {
                            t === D.Ku.KRACKJACK_COMPLETION_RECEIVE && (this.completionEvents.push(e), this.throttledCompletion(n, t)), t === D.Ku.KRACKJACK_CODEACTION && (this.codeActionEvents.push(e), this.throttledCodeAction(n, t)), this.props.onCompletionReceive(e)
                        })), (0, a.Z)(this, "reduceCompletionEvents", ((e, n) => {
                            var t = n === D.Ku.KRACKJACK_COMPLETION_RECEIVE ? this.completionEvents : this.codeActionEvents;
                            if (t.length) {
                                var i = t.reduce(((e, n) => (e.timeTaken += n.timeTaken, e.totalItems += n.totalItems, e)), {
                                        timeTaken: 0,
                                        totalItems: 0
                                    }),
                                    r = t.map((e => ({
                                        startTime: e.startTime,
                                        timeTaken: e.timeTaken
                                    })));
                                this.onAnalytics(e, n, void 0, void 0, {
                                    averageTimeTaken: i.timeTaken / t.length,
                                    averageItems: i.totalItems / t.length,
                                    currentTime: Date.now(),
                                    eventCount: t.length
                                }, {
                                    eventTimes: r
                                }), n === D.Ku.KRACKJACK_COMPLETION_RECEIVE && (this.completionEvents = []), n === D.Ku.KRACKJACK_CODEACTION && (this.codeActionEvents = [])
                            }
                        })), (0, a.Z)(this, "onLanguageChange", ((e, n) => {
                            var {
                                onLanguageChange: t,
                                languageOptions: i
                            } = this.props;
                            this.currentLanguage = e, this.completionEvents = [], this.codeActionEvents = [], t(e, n), i.languages.includes(e) ? this.onAnalytics("change", "KrackJackChangeLanguage", this.currentLanguage) : this.onAnalytics("change", "KrackJackChangeLanguageError", this.currentLanguage, void 0, {
                                availableLangugages: i.languages,
                                oldLanguage: n
                            }), this.setInitialData()
                        })), (0, a.Z)(this, "onKeyDown", (e => {
                            if (this.totalCharsTyped += 1, this.suggestionEnabled) {
                                if (e.keyCode === d.KeyCode.Enter) {
                                    var n = this.editor.getContribution("editor.contrib.suggestController").widget._value;
                                    if (n && n._ctxSuggestWidgetVisible.get()) {
                                        var t = n._ctxSuggestWidgetVisible._service._domNode,
                                            i = t.querySelectorAll(".monaco-list-row").length,
                                            r = t.querySelector(".monaco-list-row.focused");
                                        r && this.onAnalytics("change", "KrackJackAutoCompleteSelect", void 0, void 0, {
                                            currentTotal: i,
                                            index: parseInt(r.dataset.index, 10)
                                        })
                                    }
                                }
                            } else this.attachSuggestionEvents()
                        })), (0, a.Z)(this, "onFocus", (() => {
                            this.focusLogged || (this.focusLogged = !0, this.onAnalytics("focus", "KrackJackUserIsInsideTheEditor"))
                        })), (0, a.Z)(this, "onSubmitCode", ((e, n) => {
                            var {
                                onSubmitCode: t
                            } = this.props;
                            t(e, n), this.onAnalytics("change", "KrackJackTotalCharactersTypedBeforeSubmit", this.totalCharsTyped)
                        })), (0, a.Z)(this, "onToggleSettingsPane", (e => {
                            var {
                                onToggleSettingsPane: n
                            } = this.props;
                            n(e), this.onAnalytics("Click", "KrackJackShowPreferences", e ? "Opened" : "Closed")
                        })), (0, a.Z)(this, "onShowSuggestion", (() => {
                            this.popupOpened || (this.popupOpened = !0, this.onAnalytics("change", "KrackJackAutoCompletePopUp", "shown"))
                        })), (0, a.Z)(this, "onHideSuggestion", (() => {
                            this.popupOpened && (this.popupOpened = !1, this.onAnalytics("change", "KrackJackAutoCompletePopUp", "closed"))
                        })), (0, a.Z)(this, "onSelectSuggestion", (e => {
                            this.onAnalytics("change", "KrackJackAutoCompleteSelect", void 0, void 0, {
                                currentTotal: e.model.items.length,
                                index: e.index
                            })
                        })), (0, a.Z)(this, "onChangeSettings", ((e, n, t) => {
                            var {
                                onChangeSettings: i
                            } = this.props;
                            i(e, n, t);
                            var r = e,
                                o = n;
                            switch (e) {
                                case "theme":
                                    r = "EditorTheme";
                                    break;
                                case "tabSize":
                                    r = "EditorSpace", o = "".concat(n);
                                    break;
                                case "mode":
                                    r = "EditorMode", o = n[0].toUpperCase() + n.substring(1);
                                    break;
                                case "intellisense":
                                    r = "AutoComplete", o = n ? "on" : "off"
                            }
                            this.onAnalytics("Click", "KrackJack".concat(r), o)
                        })), (0, a.Z)(this, "onPaste", ((e, n) => {
                            this.props.onPaste(e, n), this.onAnalytics("Change", "KrackJackPaste", n.length)
                        })), (0, a.Z)(this, "onReadonlyType", (() => {
                            this.onAnalytics("Change", "KrackJackReadonlyType")
                        })), (0, a.Z)(this, "onLspWebsocketChange", (e => {
                            var {
                                event: n,
                                eventData: t
                            } = e, i = {
                                [D.X4.CONNECT]: ["Connect", "LspWebsocketConnect"],
                                [D.X4.RECONNECT]: ["Reconnect", "LspWebsocketReconnect", void 0, t.retryCount],
                                [D.X4.ERROR]: ["Error", "LspWebsocketConnectError"],
                                [D.X4.CLOSE]: ["Close", "LspWebsocketClose"],
                                [D.Z8.CONNECT]: ["Connect", "LspClientConnect"],
                                [D.Z8.DISCONNECT]: ["Disconnect", "LspClientDisconnect"],
                                [D.Z8.ERROR]: ["Error", "LspClientError", void 0, void 0, t],
                                [D.Z8.CLOSE]: ["Close", "LspClientClose"],
                                [D.Z8.READY]: ["Initialize", "LspClientInitialize", void 0, void 0, t]
                            };
                            if (Array.isArray(i[n])) {
                                var r = i[n];
                                this.onAnalytics(...r)
                            }
                            this.props.onLspWebsocketChange(e)
                        })), this.currentLanguage = e.defaultLanguage || "", this.setInitialData(), this.disposables = [], this.completionEvents = [], this.codeActionEvents = [], this.throttledCompletion = Ge()((function() {
                            return n.reduceCompletionEvents(...arguments)
                        }), e.completionFuncInterval, {
                            leading: !1,
                            trailing: !0
                        }), this.throttledCodeAction = Ge()((function() {
                            return n.reduceCompletionEvents(...arguments)
                        }), e.completionFuncInterval, {
                            leading: !1,
                            trailing: !0
                        }), this.popupOpened = !1
                    }
                    setInitialData() {
                        this.totalCharsTyped = 0, this.focusLogged = !1, this.suggestionEnabled = !1
                    }
                    componentWillUnmount() {
                        this.throttledCompletion.flush(), this.throttledCodeAction.flush(), this.disposables.forEach((e => e.dispose()))
                    }
                    attachEditorEvents() {
                        this.disposables.push(this.editor.onKeyDown(this.onKeyDown)), this.disposables.push(this.editor.onDidFocusEditorText(this.onFocus))
                    }
                    attachSuggestionEvents() {
                        var e = this.editor.getContribution("editor.contrib.suggestController").widget._value;
                        if (e) {
                            this.suggestionEnabled = !0;
                            var {
                                disposables: n
                            } = this;
                            n.push(e.onDidShow(this.onShowSuggestion)), n.push(e.onDidHide(this.onHideSuggestion)), n.push(e.onDidSelect(this.onSelectSuggestion))
                        }
                    }
                    render() {
                        var n = this.props,
                            {
                                completionFuncInterval: t,
                                onAnalytics: i
                            } = n,
                            r = (0, N.Z)(n, Ke);
                        return l().createElement(e, (0, A.Z)({}, r, {
                            editorDidMount: this.editorDidMount,
                            onSubmitCode: this.onSubmitCode,
                            onLanguageChange: this.onLanguageChange,
                            onChangeSettings: this.onChangeSettings,
                            onToggleSettingsPane: this.onToggleSettingsPane,
                            onCompletionReceive: this.onCompletionReceive,
                            onPaste: this.onPaste,
                            onLspWebsocketChange: this.onLspWebsocketChange,
                            onReadonlyType: this.onReadonlyType
                        }))
                    }
                }, (0, a.Z)(n, "displayName", "withMetrics(".concat((0, f.Gf)(e), ")")), (0, a.Z)(n, "defaultProps", {
                    completionFuncInterval: 5e3,
                    editorDidMount: h(),
                    onAnalytics: h(),
                    onLanguageChange: h(),
                    onSubmitCode: h(),
                    onChangeSettings: h(),
                    onToggleSettingsPane: h(),
                    onCompletionReceive: h(),
                    onPaste: h(),
                    onLspWebsocketChange: h()
                }), n
            };
            var ze = (0, f.qC)(qe, Je, De, Oe, Ae, Ve)(Se);
            const Xe = ze
        },
        mTBN: (e, n, t) => {
            t.r(n), t.d(n, {
                DEFAULT_FILE_NAME_WITHOUT_EXTENSION: () => a,
                DEFAULT_MODEL_URI: () => s,
                LANGUAGE_OPTIONS: () => i,
                LSP_LANGUAGES: () => r,
                default: () => o
            });
            var i = {
                    c: {
                        mime: "text/x-csrc",
                        label: "C",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tail starts here */",
                        fold: "brace",
                        defaultText: "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n\nint main() {\n\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */    \n    return 0;\n}\n",
                        suffix: "clang",
                        langId: 1,
                        lsp: "c",
                        extension: "c"
                    },
                    cpp: {
                        mime: "text/x-c++src",
                        label: "C++11",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tail starts here */",
                        fold: "brace",
                        defaultText: "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   \n    return 0;\n}\n",
                        suffix: "clang",
                        langId: 2,
                        lsp: "cpp",
                        extension: "cpp"
                    },
                    java: {
                        mime: "text/x-java",
                        label: "Java 7",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tail starts here */",
                        fold: "brace",
                        defaultText: "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */\n    }\n}",
                        suffix: "java",
                        langId: 3,
                        lsp: "java",
                        extension: "java"
                    },
                    csharp: {
                        mime: "text/x-csharp",
                        label: "C#",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tail starts here */",
                        fold: "brace",
                        defaultText: "using System;\nusing System.Collections.Generic;\nusing System.IO;\nclass Solution {\n    static void Main(String[] args) {\n        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution */\n    }\n}",
                        suffix: "csharp",
                        langId: 9,
                        lsp: "csharp",
                        extension: "cs"
                    },
                    haskell: {
                        mime: "text/x-haskell",
                        label: "Haskell",
                        headEnd: "-- Head ends here",
                        tailStart: "-- Tail starts here",
                        fold: "indent",
                        defaultText: "-- Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "",
                        langId: 12,
                        extension: "hs"
                    },
                    php: {
                        mime: "text/x-php",
                        label: "PHP",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tail starts here */",
                        fold: "brace",
                        defaultText: '<?php\n$_fp = fopen("php://stdin", "r");\n/* Enter your code here. Read input from STDIN. Print output to STDOUT */\n\n?>',
                        suffix: "php",
                        langId: 7,
                        lsp: "php",
                        extension: "php"
                    },
                    python: {
                        mime: "text/x-python",
                        label: "Python 2",
                        headEnd: "# Head ends here",
                        tailStart: "# Tail starts here",
                        fold: "indent",
                        defaultText: "# Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "python",
                        langId: 5,
                        lsp: "python",
                        extension: "py"
                    },
                    perl: {
                        mime: "text/x-perl",
                        label: "Perl",
                        headEnd: "# Head ends here",
                        tailStart: "# Tail starts here",
                        fold: "brace",
                        defaultText: "# Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "",
                        langId: 6,
                        extension: "pl"
                    },
                    ruby: {
                        mime: "text/x-ruby",
                        label: "Ruby",
                        headEnd: "# Head ends here",
                        tailStart: "# Tail starts here",
                        fold: "indent",
                        defaultText: "# Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "ruby",
                        langId: 8,
                        extension: "rb",
                        lsp: "ruby"
                    },
                    bash: {
                        mime: "text/x-sh",
                        label: "BASH",
                        headEnd: "# Head ends here",
                        tailStart: "# Tail starts here",
                        fold: "brace",
                        defaultText: "",
                        suffix: "",
                        langId: 14,
                        extension: "sh",
                        syntax: "shell",
                        lsp: "bash"
                    },
                    oracle: {
                        mime: "text/x-plsql",
                        label: "Oracle (PL/SQL enabled)",
                        fold: "indent",
                        defaultText: "",
                        suffix: "",
                        langId: 11,
                        extension: "sql",
                        syntax: "sql",
                        lsp: "sql",
                        headEnd: "",
                        tailStart: ""
                    },
                    mysql: {
                        mime: "text/x-plsql",
                        label: "MySQL",
                        fold: "indent",
                        defaultText: "",
                        suffix: "",
                        langId: 10,
                        extension: "sql",
                        lsp: "mysql",
                        headEnd: "",
                        tailStart: ""
                    },
                    sql: {
                        mime: "text/x-plsql",
                        label: "SQL",
                        fold: "indent",
                        defaultText: "",
                        suffix: "",
                        syntax: "mysql",
                        extension: "sql",
                        lsp: "sql",
                        headEnd: "",
                        tailStart: ""
                    },
                    pgsql: {
                        mime: "text/x-plsql",
                        label: "PostgreSQL",
                        fold: "indent",
                        defaultText: "",
                        suffix: "",
                        langId: 78,
                        extension: "sql",
                        lsp: "sql",
                        headEnd: "",
                        tailStart: ""
                    },
                    clojure: {
                        mime: "text/x-scheme",
                        label: "Clojure",
                        headEnd: "; Head ends here",
                        tailStart: "; Tail starts here",
                        fold: "indent",
                        defaultText: "; Enter your code here. Read input from STDIN. Print output to STDOUT\n;",
                        suffix: "",
                        langId: 13,
                        extension: "clj"
                    },
                    scala: {
                        mime: "text/x-scala",
                        label: "Scala",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tail starts here */",
                        fold: "brace",
                        defaultText: "object Solution {\n\n    def main(args: Array[String]) {\n        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution\n*/\n    }\n}",
                        suffix: "",
                        langId: 15,
                        lsp: "scala",
                        extension: "scala"
                    },
                    code: {
                        mime: "text/plain",
                        label: "Generic",
                        fold: "brace",
                        suffix: "",
                        extension: "txt",
                        defaultText: "",
                        headEnd: "",
                        tailStart: ""
                    },
                    text: {
                        mime: "text/plain",
                        label: "Plain Text",
                        fold: "indent",
                        defaultText: "",
                        suffix: "",
                        langId: 28,
                        extension: "txt",
                        headEnd: "",
                        tailStart: ""
                    },
                    markdown: {
                        mime: "text/markdown",
                        label: "Markdown",
                        fold: "indent",
                        defaultText: "",
                        suffix: "",
                        langId: 80,
                        extension: "md",
                        headEnd: "",
                        tailStart: ""
                    },
                    brainfuck: {
                        mime: "text/plain",
                        label: "Brainf**k",
                        fold: "indent",
                        suffix: "",
                        langId: 19,
                        extension: "bf",
                        defaultText: "",
                        headEnd: "",
                        tailStart: ""
                    },
                    javascript: {
                        mime: "text/javascript",
                        label: "JavaScript (Node.js)",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tail starts here */",
                        fold: "brace",
                        defaultText: 'function processData(input) {\n    //Enter your code here\n} \n\nprocess.stdin.resume();\nprocess.stdin.setEncoding("ascii");\n_input = "";\nprocess.stdin.on("data", function (input) {\n    _input += input;\n});\n\nprocess.stdin.on("end", function () {\n   processData(_input);\n});\n',
                        suffix: "tern",
                        langId: 20,
                        lsp: "javascript",
                        extension: "js"
                    },
                    typescript: {
                        mime: "text/typescript",
                        label: "TypeScript",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tail starts here */",
                        fold: "brace",
                        defaultText: "'use strict';\n\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf-8');\nlet inputString: string = '';\nlet inputLines: string[] = [];\nlet currentLine: number = 0;\nprocess.stdin.on('data', function(inputStdin: string): void {\n    inputString += inputStdin;\n});\n\nprocess.stdin.on('end', function(): void {\n    inputLines = inputString.split('\\n');\n    inputString = '';\n    main();\n});\n\nfunction readLine(): string {\n    return inputLines[currentLine++];\n}\n\nfunction main() {\n    // Enter your code here\n}",
                        suffix: "",
                        langId: 66,
                        lsp: "typescript",
                        extension: "ts"
                    },
                    d: {
                        mime: "text/x-d",
                        label: "D",
                        fold: "brace",
                        defaultText: "/* Enter your code here. Read input from STDIN. Print output to STDOUT */",
                        suffix: "",
                        langId: 22,
                        extension: "d",
                        headEnd: "",
                        tailStart: ""
                    },
                    go: {
                        mime: "text/x-go",
                        label: "Go",
                        fold: "brace",
                        defaultText: 'package main\nimport "fmt"\n\nfunc main() {\n //Enter your code here. Read input from STDIN. Print output to STDOUT\n}',
                        suffix: "go",
                        langId: 21,
                        lsp: "go",
                        extension: "go",
                        headEnd: "",
                        tailStart: ""
                    },
                    lua: {
                        mime: "text/x-lua",
                        label: "Lua",
                        headEnd: "-- Head ends here",
                        tailStart: "-- Tail starts here",
                        fold: "indent",
                        defaultText: "-- Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "",
                        langId: 18,
                        extension: "lua"
                    },
                    erlang: {
                        mime: "text/x-erlang",
                        label: "Erlang",
                        fold: "indent",
                        defaultText: "% Enter your code here. Read input from STDIN. Print output to STDOUT\n% Your class should be named solution\n\n-module(solution).\n-export([main/0]).\n\nmain() ->\n\t.\n",
                        suffix: "",
                        langId: 16,
                        extension: "erl",
                        headEnd: "",
                        tailStart: ""
                    },
                    sbcl: {
                        mime: "text/x-common-lisp",
                        label: "Common Lisp (SBCL)",
                        headEnd: "; Head ends here",
                        tailStart: "; Tail starts here",
                        fold: "indent",
                        defaultText: ";; Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "",
                        langId: 26,
                        extension: "sbcl"
                    },
                    ocaml: {
                        mime: "text/x-ocaml",
                        label: "OCaml",
                        fold: "indent",
                        defaultText: "(* Enter your code here. Read input from STDIN. Print output to STDOUT *)",
                        suffix: "",
                        langId: 23,
                        extension: "ml",
                        headEnd: "",
                        tailStart: ""
                    },
                    pascal: {
                        mime: "text/x-pascal",
                        label: "Pascal",
                        headEnd: "{ Head ends here }",
                        tailStart: "{ Tail starts here }",
                        fold: "indent",
                        defaultText: "(* Enter your code here. Read input from STDIN. Print output to STDOUT *)",
                        suffix: "",
                        langId: 25,
                        extension: "pas"
                    },
                    python3: {
                        mime: "text/x-python",
                        label: "Python 3",
                        headEnd: "# Head ends here",
                        tailStart: "# Tail starts here",
                        fold: "indent",
                        defaultText: "# Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "python3",
                        langId: 30,
                        lsp: "python3",
                        extension: "py",
                        syntax: "python"
                    },
                    groovy: {
                        mime: "text/x-groovy",
                        label: "Groovy",
                        headEnd: "// Head ends here",
                        tailStart: "// Tail starts here",
                        fold: "brace",
                        defaultText: "//Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "",
                        langId: 31,
                        extension: "groovy"
                    },
                    text_pseudo: {
                        mime: "text/plain",
                        label: "Plain Text",
                        fold: "indent",
                        suffix: "",
                        langId: 7,
                        extension: "txt",
                        defaultText: "",
                        headEnd: "",
                        tailStart: ""
                    },
                    objectivec: {
                        mime: "text/x-csrc",
                        label: "Objective-C",
                        headEnd: "// Head ends here",
                        tailStart: "// Tail starts here",
                        fold: "brace",
                        defaultText: "//Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "clang",
                        langId: 32,
                        extension: "m",
                        syntax: "objective-c"
                    },
                    fsharp: {
                        mime: "text/x-fsharp",
                        label: "F#",
                        headEnd: "// Head ends here",
                        tailStart: "// Tail starts here",
                        fold: "indent",
                        defaultText: "//Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "",
                        langId: 33,
                        extension: "fs"
                    },
                    visualbasic: {
                        mime: "text/x-vb",
                        label: "VB.NET",
                        headEnd: "' Head ends here",
                        tailStart: "' Tail starts here",
                        fold: "indent",
                        defaultText: "'Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "",
                        langId: 37,
                        extension: "vb",
                        syntax: "vb"
                    },
                    cobol: {
                        mime: "text/x-cobol",
                        label: "COBOL",
                        headEnd: "* Head ends here",
                        tailStart: "* Tail starts here",
                        fold: "indent",
                        defaultText: "*Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "",
                        langId: 36,
                        extension: "cobol"
                    },
                    tsql: {
                        mime: "text/x-plsql",
                        label: "MS SQL Server",
                        suffix: "",
                        langId: 42,
                        extension: "tsql",
                        syntax: "sql",
                        defaultText: "",
                        lsp: "sql",
                        headEnd: "",
                        tailStart: ""
                    },
                    lolcode: {
                        label: "LOLCODE",
                        headEnd: "BTW Head ends here",
                        tailStart: "BTW Tail starts here",
                        fold: "indent",
                        defaultText: "BTW Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "",
                        langId: 38,
                        extension: "lolcode"
                    },
                    smalltalk: {
                        mime: "text/x-stsrc",
                        label: "Smalltalk",
                        headEnd: '" Head ends here"',
                        tailStart: '" Tail starts here"',
                        fold: "indent",
                        defaultText: '"Enter your code here. Read input from STDIN. Print output to STDOUT"',
                        suffix: "",
                        langId: 39,
                        extension: "st",
                        syntax: "st"
                    },
                    tcl: {
                        mime: "text/x-tcl",
                        label: "Tcl",
                        headEnd: "# Head ends here",
                        tailStart: "# Tail starts here",
                        fold: "brace",
                        defaultText: "# Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "",
                        langId: 40,
                        extension: "tcl"
                    },
                    html: {
                        mime: "text/html",
                        label: "HTML",
                        headEnd: "\x3c!-- Head ends here --\x3e",
                        tailStart: "\x3c!-- Tail starts here --\x3e",
                        fold: "tag",
                        defaultText: "\x3c!-- Enter your code here --\x3e",
                        suffix: "",
                        extension: "html"
                    },
                    css: {
                        mime: "text/css",
                        label: "CSS",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tails starts here */",
                        fold: "brace",
                        defaultText: "/* Enter your code here*/",
                        suffix: "",
                        extension: "css"
                    },
                    java8: {
                        mime: "text/x-java",
                        label: "Java 8",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tail starts here */",
                        fold: "brace",
                        defaultText: "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */\n    }\n}",
                        suffix: "java",
                        langId: 43,
                        lsp: "java",
                        extension: "java",
                        syntax: "java"
                    },
                    db2: {
                        mime: "text/x-plsql",
                        label: "DB2",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tail starts here */",
                        fold: "indent",
                        suffix: "",
                        langId: 44,
                        extension: "db2",
                        syntax: "sql",
                        lsp: "sql",
                        defaultText: ""
                    },
                    octave: {
                        mime: "text/x-octave",
                        label: "Octave",
                        headEnd: "# Head ends here",
                        tailStart: "# Tail starts here ",
                        fold: "indent",
                        defaultText: "# Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "",
                        langId: 46,
                        extension: "octave"
                    },
                    r: {
                        mime: "text/x-rsrc",
                        label: "R",
                        headEnd: "# Head ends here",
                        tailStart: "# Tail starts here ",
                        fold: "brace",
                        defaultText: "# Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "",
                        langId: 24,
                        extension: "r"
                    },
                    xquery: {
                        mime: "application/xquery",
                        label: "XQuery",
                        headEnd: "(: Head ends here :)",
                        tailStart: "(: Tail starts here :)",
                        fold: "indent",
                        defaultText: "(: Enter your code here. Read input from STDIN. Print output to STDOUT :)",
                        suffix: "",
                        langId: 48,
                        extension: "xquery"
                    },
                    racket: {
                        mime: "text/x-scheme",
                        label: "Racket",
                        headEnd: "; Head ends here",
                        tailStart: "; Tail starts here",
                        fold: "brace",
                        defaultText: "#lang racket\n; Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "",
                        langId: 49,
                        extension: "rkt"
                    },
                    xml: {
                        mime: "text/xml",
                        label: "XML",
                        headEnd: "\x3c!-- Head ends here --\x3e",
                        tailStart: "\x3c!-- Tail starts here --\x3e",
                        fold: "tag",
                        defaultText: "\x3c!-- Enter your code here --\x3e",
                        suffix: "",
                        extension: "xml"
                    },
                    rust: {
                        mime: "text/x-rustsrc",
                        label: "Rust",
                        headEnd: "// Head ends here",
                        tailStart: "// Tail starts here",
                        fold: "brace",
                        defaultText: "// Enter your code here ",
                        suffix: "",
                        langId: 50,
                        extension: "rs"
                    },
                    swift: {
                        mime: "text/x-swift",
                        label: "Swift",
                        tailStart: "// Tail starts here",
                        fold: "brace",
                        defaultText: "import Foundation\n\n// Enter your code here ",
                        suffix: "swift",
                        langId: 51,
                        extension: "swift",
                        lsp: "swift",
                        headEnd: ""
                    },
                    fortran: {
                        mime: "text/x-fortran",
                        label: "Fortran",
                        headEnd: "! Head ends here",
                        tailStart: "! Tail starts here",
                        fold: "indent",
                        defaultText: "! Enter your code here ",
                        suffix: "",
                        langId: 54,
                        extension: "fortran"
                    },
                    elixir: {
                        mime: "text/elixir",
                        label: "Elixir",
                        headEnd: "# Head ends here",
                        tailStart: "# Tail starts here",
                        fold: "indent",
                        defaultText: "defmodule Solution do\n#Enter your code here. Read input from STDIN. Print output to STDOUT\nend",
                        suffix: "",
                        langId: 52,
                        extension: "ex"
                    },
                    ada: {
                        mime: "text/x-adasrc",
                        label: "Ada",
                        headEnd: "-- Head ends here",
                        tailStart: "-- Tail starts here",
                        fold: "indent",
                        defaultText: "with Ada.Text_IO, Ada.Integer_Text_IO;\nuse Ada;\n\nprocedure Solution is\n-- Enter your code here. Read input from STDIN. Print output to STDOUT\n\n\nend Solution",
                        suffix: "",
                        langId: 53,
                        extension: "ada"
                    },
                    nim: {
                        mime: "text/nim",
                        label: "Nim",
                        headEnd: "# Head ends here",
                        tailStart: "# Tail starts here",
                        fold: "indent",
                        defaultText: "# Enter your code here ",
                        suffix: "",
                        extension: "nim"
                    },
                    julia: {
                        mime: "text/x-julia",
                        label: "Julia",
                        headEnd: "# Head ends here",
                        tailStart: "# Tail starts here",
                        fold: "indent",
                        defaultText: "# Enter your code here ",
                        suffix: "",
                        langId: 57,
                        extension: "julia"
                    },
                    pypy: {
                        mime: "text/x-python",
                        label: "Pypy 2",
                        headEnd: "# Head ends here",
                        tailStart: "# Tail starts here",
                        fold: "indent",
                        defaultText: "# Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "",
                        langId: 61,
                        extension: "py",
                        syntax: "python"
                    },
                    pypy3: {
                        mime: "text/x-python",
                        label: "Pypy 3",
                        headEnd: "# Head ends here",
                        tailStart: "# Tail starts here",
                        fold: "indent",
                        defaultText: "# Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "",
                        langId: 62,
                        extension: "py",
                        syntax: "python"
                    },
                    cpp14: {
                        mime: "text/x-c++src",
                        label: "C++14",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tail starts here */",
                        fold: "brace",
                        defaultText: "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   \n    return 0;\n}\n",
                        suffix: "clang",
                        langId: 58,
                        lsp: "cpp",
                        extension: "cpp",
                        syntax: "cpp"
                    },
                    coffeescript: {
                        mime: "text/x-coffeescript",
                        label: "CoffeeScript",
                        headEnd: "# Head ends here",
                        tailStart: "# Tail starts here",
                        fold: "indent",
                        defaultText: "# Enter your code here",
                        suffix: "",
                        langId: 59,
                        extension: "coffeescript"
                    },
                    kotlin: {
                        mime: "text/x-kotlin",
                        label: "Kotlin",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tail starts here */",
                        fold: "brace",
                        defaultText: "import java.io.*\nimport java.util.*\n\nfun main(args: Array<String>) {\n        /* Enter your code here. Read input from STDIN. Print output to STDOUT. */\n}",
                        suffix: "",
                        lsp: "kotlin",
                        langId: 71,
                        extension: "kt"
                    },
                    dart: {
                        mime: "text/x-dart",
                        label: "Dart",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tail starts here */",
                        fold: "brace",
                        defaultText: "// Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "",
                        lsp: "dart",
                        langId: 27,
                        extension: "dart"
                    },
                    whitespace: {
                        label: "Whitespace",
                        headEnd: "Head ends here",
                        tailStart: "Tail starts here",
                        fold: "indent",
                        defaultText: "Enter your code here. Read input from STDIN. Print output to STDOUT",
                        suffix: "",
                        extension: "ws"
                    },
                    java15: {
                        mime: "text/x-java",
                        label: "Java 15",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tail starts here */",
                        fold: "brace",
                        defaultText: "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */\n    }\n}",
                        suffix: "java",
                        langId: 75,
                        lsp: "java15",
                        extension: "java",
                        syntax: "java"
                    },
                    java17: {
                        mime: "text/x-java",
                        label: "Java 17",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tail starts here */",
                        fold: "brace",
                        defaultText: "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */\n    }\n}",
                        suffix: "java",
                        langId: 79,
                        lsp: "java17",
                        extension: "java",
                        syntax: "java"
                    },
                    java21: {
                        mime: "text/x-java",
                        label: "Java 21",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tail starts here */",
                        fold: "brace",
                        defaultText: "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */\n    }\n}",
                        suffix: "java",
                        langId: 81,
                        lsp: "java21",
                        extension: "java",
                        syntax: "java"
                    },
                    cpp20: {
                        mime: "text/x-c++src",
                        label: "C++20",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tail starts here */",
                        fold: "brace",
                        defaultText: "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   \n    return 0;\n}\n",
                        suffix: "clang",
                        langId: 76,
                        lsp: "cpp",
                        extension: "cpp",
                        syntax: "cpp"
                    },
                    cpp23: {
                        mime: "text/x-c++src",
                        label: "C++23",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tail starts here */",
                        fold: "brace",
                        defaultText: "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   \n    return 0;\n}\n",
                        suffix: "clang",
                        langId: 80,
                        lsp: "cpp23",
                        extension: "cpp",
                        syntax: "cpp"
                    },
                    verilog: {
                        mime: "text/x-verilog",
                        label: "Verilog",
                        headEnd: "/* Head ends here */",
                        tailStart: "/* Tail starts here */",
                        fold: "indent",
                        defaultText: "module main;\n  initial\n    begin\n      /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n      \n      $finish;\n    end\nendmodule",
                        suffix: "",
                        langId: 77,
                        extension: "v"
                    }
                },
                r = Object.keys(i).filter((e => void 0 !== i[e].lsp));
            const o = i;
            var a = "file",
                s = "file:///workspace"
        },
        Jckq: (e, n, t) => {
            t.d(n, {
                FA: () => l,
                T9: () => a,
                UO: () => d,
                mr: () => s
            });
            var i = t("4Jew"),
                r = t("mTBN"),
                o = t("nsCh");

            function a(e, n, t, r) {
                var o = [];
                if (r.head) {
                    var a = n.endsWith("\n") ? n : "".concat(n, "\n");
                    o.push({
                        range: new i.Range(1, 1, 1, 1),
                        text: a
                    })
                }
                if (r.tail) {
                    var s = n.startsWith("\n") ? t : "\n".concat(t),
                        l = e.getModel().getLineCount() + 1;
                    o.push({
                        range: new i.Range(l, 1, l, 1),
                        text: s
                    })
                }
                0 !== o.length && e.executeEdits("krackjack", o)
            }

            function s(e, n) {
                e.applyEdits([{
                    range: e.getFullModelRange(),
                    text: n,
                    forceMoveMarkers: !0
                }])
            }

            function l(e) {
                return {
                    [o.f7.LINEWISE]: o.f7.VISUAL_LINE,
                    [o.f7.BLOCKWISE]: o.f7.VISUAL_BLOCK
                }[e] || o.f7.VISUAL
            }
            var d = (e, n) => {
                var t = r.default[n].extension,
                    i = e || r.DEFAULT_FILE_NAME_WITHOUT_EXTENSION;
                return "".concat(i, ".").concat(t)
            }
        },
        upBI: (e, n, t) => {
            t.d(n, {
                Z: () => l
            });
            var i = t("+9dH"),
                r = t("gSVb"),
                o = t("PRvr"),
                a = t("DTvD"),
                s = t.n(a);
            t("kRiR");
            const l = e => {
                var {
                    className: n = ""
                } = e, t = (0, o.Z)(e, ["className"]);
                return t = (0, r.Z)({}, t, {
                    className: "".concat(n, " ui-svg-icon")
                }), s().createElement("svg", (0, i.Z)({
                    viewBox: "0 0 24 24",
                    width: "1em",
                    height: "1em"
                }, t, {
                    fill: "currentColor"
                }), s().createElement("path", {
                    d: "M23 17.5L14.6 3.3c-.4-.7-1.1-1.2-1.9-1.4-.8-.2-1.6-.1-2.3.3-.4.2-.8.6-1 1L1 17.5c-.8 1.4-.3 3.3 1.1 4.1.4.3.9.4 1.4.4h17c.8 0 1.6-.3 2.1-.9.6-.6.9-1.3.9-2.1-.1-.5-.2-1.1-.5-1.5zm-1.8 2.2c-.2.2-.5.3-.7.3h-17c-.2 0-.3 0-.5-.1-.5-.3-.6-.9-.4-1.4l8.5-14.1c.1-.1.2-.3.3-.3.5-.3 1.1-.1 1.4.3l8.5 14.1c.1.1.1.3.1.5.1.3-.1.5-.2.7z"
                }), s().createElement("path", {
                    d: "M12 8c-.6 0-1 .4-1 1v4c0 .6.4 1 1 1s1-.4 1-1V9c0-.6-.4-1-1-1zm.7 8.3c-.4-.4-1.1-.4-1.4 0-.1.1-.2.2-.2.3 0 .1-.1.2-.1.4 0 .3.1.5.3.7.2.2.4.3.7.3s.5-.1.7-.3c.1-.1.2-.2.2-.3 0-.1.1-.2.1-.4s0-.3-.1-.4c0-.1-.1-.2-.2-.3z"
                }))
            }
        },
        ueDI: (e, n, t) => {
            t.d(n, {
                Z: () => l
            });
            var i = t("+9dH"),
                r = t("gSVb"),
                o = t("PRvr"),
                a = t("DTvD"),
                s = t.n(a);
            t("kRiR");
            const l = e => {
                var {
                    className: n = ""
                } = e, t = (0, o.Z)(e, ["className"]);
                return t = (0, r.Z)({}, t, {
                    className: "".concat(n, " ui-svg-icon")
                }), s().createElement("svg", (0, i.Z)({
                    viewBox: "0 0 24 24",
                    width: "1em",
                    height: "1em"
                }, t, {
                    fill: "currentColor"
                }), s().createElement("path", {
                    d: "M12 1C5.9 1 1 5.9 1 12s4.9 11 11 11 11-4.9 11-11S18.1 1 12 1zm0 20c-5 0-9-4-9-9s4-9 9-9 9 4 9 9-4 9-9 9z"
                }), s().createElement("path", {
                    d: "M15.7 8.3c-.4-.4-1-.4-1.4 0L12 10.6 9.7 8.3c-.4-.4-1-.4-1.4 0s-.4 1 0 1.4l2.3 2.3-2.3 2.3c-.4.4-.4 1 0 1.4.2.2.4.3.7.3s.5-.1.7-.3l2.3-2.3 2.3 2.3c.2.2.5.3.7.3s.5-.1.7-.3c.4-.4.4-1 0-1.4L13.4 12l2.3-2.3c.4-.4.4-1 0-1.4z"
                }))
            }
        },
        NbpS: (e, n, t) => {
            t.d(n, {
                Z: () => l
            });
            var i = t("+9dH"),
                r = t("gSVb"),
                o = t("PRvr"),
                a = t("DTvD"),
                s = t.n(a);
            t("kRiR");
            const l = e => {
                var {
                    className: n = ""
                } = e, t = (0, o.Z)(e, ["className"]);
                return t = (0, r.Z)({}, t, {
                    className: "".concat(n, " ui-svg-icon")
                }), s().createElement("svg", (0, i.Z)({
                    viewBox: "0 0 100 100",
                    width: "1em",
                    height: "1em"
                }, t, {
                    fill: "currentColor"
                }), s().createElement("path", {
                    d: "M25.885 65.414a19.77 19.77 0 00-5.791 13.98v7.675H14.15V95h71.7v-7.931h-5.944v-7.675a19.77 19.77 0 00-5.79-13.98L60.741 52.041a2.887 2.887 0 010-4.082l13.373-13.373a19.77 19.77 0 005.791-13.98v-7.675h5.944V5h-71.7v7.931h5.944v7.675a19.77 19.77 0 005.79 13.98L39.259 47.96a2.887 2.887 0 010 4.082L25.885 65.414zM44.18 43.037L30.807 29.664a12.725 12.725 0 01-3.752-9.058v-8.645h45.89v8.645c0 3.422-1.332 6.639-3.752 9.058L55.82 43.037A9.783 9.783 0 0052.936 50a9.783 9.783 0 002.885 6.963l13.372 13.374c1.572 1.571 2.63 3.5 3.216 5.582C69.474 73.637 54.443 62.124 50 62.124c-4.444 0-19.474 11.513-22.41 13.795.588-2.083 1.645-4.01 3.217-5.583L44.18 56.963c3.839-3.839 3.84-10.086 0-13.926z"
                }))
            }
        },
        pt8c: (e, n, t) => {
            t.d(n, {
                Z: () => l
            });
            var i = t("+9dH"),
                r = t("gSVb"),
                o = t("PRvr"),
                a = t("DTvD"),
                s = t.n(a);
            t("kRiR");
            const l = e => {
                var {
                    className: n = ""
                } = e, t = (0, o.Z)(e, ["className"]);
                return t = (0, r.Z)({}, t, {
                    className: "".concat(n, " ui-svg-icon")
                }), s().createElement("svg", (0, i.Z)({
                    viewBox: "0 0 36 36",
                    width: "1em",
                    height: "1em"
                }, t, {
                    fill: "currentColor"
                }), s().createElement("path", {
                    d: "M18 0c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4zm0 14c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4zm0 14c2.2 0 4 1.8 4 4s-1.8 4-4 4-4-1.8-4-4 1.8-4 4-4z",
                    fillRule: "evenodd",
                    clipRule: "evenodd"
                }))
            }
        },
        XlNQ: (e, n, t) => {
            t.d(n, {
                Z: () => l
            });
            var i = t("+9dH"),
                r = t("gSVb"),
                o = t("PRvr"),
                a = t("DTvD"),
                s = t.n(a);
            t("kRiR");
            const l = e => {
                var {
                    className: n = ""
                } = e, t = (0, o.Z)(e, ["className"]);
                return t = (0, r.Z)({}, t, {
                    className: "".concat(n, " ui-svg-icon")
                }), s().createElement("svg", (0, i.Z)({
                    width: "1em",
                    height: "1em",
                    viewBox: "0 0 24 24"
                }, t, {
                    fill: "currentColor"
                }), s().createElement("path", {
                    d: "M4 12a1 1 0 011-1h14a1 1 0 110 2H5a1 1 0 01-1-1z"
                }))
            }
        },
        PQcE: (e, n, t) => {
            t.d(n, {
                Z: () => g
            });
            var i = t("+9dH"),
                r = t("PRvr"),
                o = t("L5+t"),
                a = t("DTvD"),
                s = t.n(a),
                l = t("TSYQ"),
                d = t.n(l),
                c = t("37OS"),
                p = t.n(c),
                u = t("XlNQ"),
                h = t("Toq2"),
                f = ["className", "indeterminate", "label", "theme", "error", "variant", "inputRef"];
            class m extends a.Component {
                constructor(e) {
                    super(e), (0, o.Z)(this, "toggleCheckbox", (e => {
                        e.persist(), this.setState((e => ({
                            checked: !e.checked
                        })), (() => {
                            this.props.onChange(e)
                        }))
                    })), this.state = {
                        checked: !!e.checked
                    }
                }
                componentWillReceiveProps(e) {
                    var {
                        checked: n
                    } = e;
                    null != n && n !== this.state.checked && this.setState({
                        checked: n
                    })
                }
                render() {
                    var e = this.props,
                        {
                            className: n,
                            indeterminate: t,
                            label: o,
                            theme: a,
                            error: l,
                            variant: c,
                            inputRef: p
                        } = e,
                        m = (0, r.Z)(e, f),
                        {
                            checked: g
                        } = this.state;
                    delete m.checked;
                    var b = s().createElement("div", {
                        className: "checkbox-wrap"
                    }, s().createElement("input", (0, i.Z)({
                        type: "checkbox",
                        className: "checkbox-input",
                        checked: g
                    }, m, {
                        onChange: this.toggleCheckbox,
                        ref: p
                    })), s().createElement("span", {
                        className: d()("custom-holder", c, {
                            error: l
                        })
                    }, t ? s().createElement(u.Z, {
                        className: "checkbox__minus-icon"
                    }) : s().createElement(h.Z, {
                        className: "checkbox__check-icon"
                    })));
                    return s().createElement("div", {
                        className: d()("ui-checkbox", a, {
                            indeterminate: !!t,
                            checked: g
                        }, n)
                    }, o ? s().createElement("label", {
                        className: "label-wrap"
                    }, b, s().createElement("div", {
                        className: "label"
                    }, o)) : b)
                }
            }(0, o.Z)(m, "defaultProps", {
                indeterminate: !1,
                onChange: p(),
                theme: "theme-m",
                variant: "inset",
                error: !1
            });
            const g = m
        },
        "4ZbX": (e, n, t) => {
            t.d(n, {
                Kx: () => v,
                ZP: () => b
            });
            var i = t("+9dH"),
                r = t("PRvr"),
                o = t("L5+t"),
                a = t("DTvD"),
                s = t.n(a),
                l = t("TSYQ"),
                d = t.n(l),
                c = t("4zxa"),
                p = t("vKNY"),
                u = t("VQj3"),
                h = t("+XdK"),
                f = ["className", "error", "inputRef", "placeholder", "id", "type", "showToggleIcon", "variant"],
                m = ["type"];
            class g extends a.PureComponent {
                constructor() {
                    super(), (0, o.Z)(this, "input", void 0), (0, o.Z)(this, "tooltip", void 0), this.state = {
                        showPassword: !1
                    }
                }
                renderInput() {
                    var e = this.props,
                        {
                            className: n,
                            error: t,
                            inputRef: o,
                            placeholder: a,
                            id: l,
                            type: c,
                            showToggleIcon: p,
                            variant: u
                        } = e,
                        h = (0, r.Z)(e, f),
                        m = "textarea" === c,
                        g = "password" === c,
                        b = "outset" === u,
                        v = m ? "textarea" : "input";
                    return s().createElement(v, (0, i.Z)({
                        ref: o,
                        id: l,
                        type: (() => {
                            if (!m) return g ? this.state.showPassword ? "text" : "password" : c
                        })(),
                        className: d()("input", {
                            error: !!t,
                            "text-area": m,
                            outset: b,
                            "toggle-icon": p
                        }, n),
                        placeholder: a,
                        "aria-label": a,
                        "aria-invalid": !!t
                    }, h))
                }
                render() {
                    var {
                        icon: e,
                        iconAlignment: n,
                        wrapperClass: t,
                        hintMessage: i,
                        loading: r,
                        error: o,
                        theme: a,
                        size: l,
                        id: c,
                        type: f,
                        showToggleIcon: m,
                        enableTooltipKeyDownEventPropagation: g,
                        renderWithTooltip: b = !0
                    } = this.props, v = "tooltip-".concat(c), y = s().createElement("span", null, i), L = "textarea" === f, S = "password" === f, E = "string" == typeof e && s().createElement("i", {
                        className: d()(e, "input-icon")
                    }), T = L ? {} : {
                        ["align-icon-".concat(n)]: e,
                        "has-icon": e,
                        "has-loader": r
                    };
                    return s().createElement("div", {
                        className: d()("custom-input", a, "size-".concat(l))
                    }, s().createElement("div", {
                        className: d()("input-wrap", T, t)
                    }, b ? s().createElement(h.ZP, {
                        enableKeyEventPropagation: g,
                        id: v,
                        align: "right",
                        content: y,
                        disabled: !i
                    }, this.renderInput()) : this.renderInput(), !L && e && !(r && "right" === n) && (E || s().createElement(e, {
                        className: "input-icon"
                    })), !L && r && s().createElement(u.Z, {
                        className: "input-loading",
                        diameter: 24
                    }), S && m && !r && s().createElement("button", {
                        type: "button",
                        className: "input-toggle",
                        onClick: () => this.setState({
                            showPassword: !this.state.showPassword
                        })
                    }, s().createElement("i", {
                        className: this.state.showPassword ? "ui-icon-hide" : "ui-icon-show"
                    }))), o && "string" == typeof o && s().createElement("div", {
                        className: "d-flex align-items-start error-message",
                        role: "alert"
                    }, s().createElement(p.Z, {
                        className: "error-icon"
                    }), o), o && s().isValidElement(o) && s().createElement("div", {
                        className: "error-message",
                        role: "alert"
                    }, o))
                }
            }(0, o.Z)(g, "defaultProps", {
                iconAlignment: "left",
                hintMessage: "",
                error: !1,
                icon: "",
                loading: !1,
                theme: "theme-old",
                size: "medium",
                type: "text",
                variant: "inset",
                showToggleIcon: !1
            });
            var b = (0, c.xD)("input")(g),
                v = (0, c.xD)("input")((function(e) {
                    var {
                        type: n
                    } = e, t = (0, r.Z)(e, m);
                    return s().createElement(g, (0, i.Z)({
                        type: "textarea"
                    }, t))
                }))
        },
        "6mht": (e, n, t) => {
            t.d(n, {
                qV: () => R,
                d_: () => P,
                JN: () => O,
                Ml: () => A,
                ZP: () => M
            }), t("ioFf"), t("SRfc"), t("yt8O"), t("rGqo");
            var i = t("PRvr"),
                r = t("+9dH"),
                o = t("L5+t"),
                a = t("DTvD"),
                s = t.n(a),
                l = t("TSYQ"),
                d = t.n(l),
                c = t("6+HK"),
                p = t("KD+3"),
                u = t("hwBa"),
                h = t("2grx"),
                f = t("rorp"),
                m = ["value"],
                g = {
                    DropdownIndicator: null
                },
                b = e => ({
                    label: e,
                    value: e
                });
            class v extends a.Component {
                constructor() {
                    var e;
                    super(...arguments), e = this, (0, o.Z)(this, "state", {
                        inputValue: ""
                    }), (0, o.Z)(this, "handleInputChange", (e => {
                        this.setState({
                            inputValue: e
                        })
                    })), (0, o.Z)(this, "handleKeyDown", (e => {
                        var {
                            inputValue: n
                        } = this.state, {
                            onChange: t,
                            value: i
                        } = this.props, r = i || [];
                        if (n) switch (e.key) {
                            case "Enter":
                            case "Tab":
                                t([...r, b(n)]), this.setState({
                                    inputValue: ""
                                }), e.preventDefault()
                        }
                    })), (0, o.Z)(this, "handleBlur", (function() {
                        var {
                            inputValue: n
                        } = e.state, {
                            onBlur: t,
                            onChange: i,
                            value: r
                        } = e.props, o = r || [];
                        t && t(...arguments), n && (i([...o, b(n)]), e.setState({
                            inputValue: ""
                        }))
                    }))
                }
                render() {
                    var {
                        inputValue: e
                    } = this.state, n = this.props, {
                        value: t
                    } = n, o = (0, i.Z)(n, m);
                    return s().createElement(h.default, (0, r.Z)({}, o, {
                        isMulti: !0,
                        components: g,
                        inputValue: e,
                        menuIsOpen: !1,
                        onInputChange: this.handleInputChange,
                        onKeyDown: this.handleKeyDown,
                        onBlur: this.handleBlur,
                        value: t
                    }))
                }
            }
            const y = v;
            var L = t("uAgT"),
                S = (t("2Qfr"), ["error", "variant", "className", "accessibilityMode"]);

            function E(e, n) {
                var t = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var i = Object.getOwnPropertySymbols(e);
                    n && (i = i.filter((function(n) {
                        return Object.getOwnPropertyDescriptor(e, n).enumerable
                    }))), t.push.apply(t, i)
                }
                return t
            }

            function T(e) {
                for (var n = 1; n < arguments.length; n++) {
                    var t = null != arguments[n] ? arguments[n] : {};
                    n % 2 ? E(Object(t), !0).forEach((function(n) {
                        (0, o.Z)(e, n, t[n])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : E(Object(t)).forEach((function(n) {
                        Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(t, n))
                    }))
                }
                return e
            }
            var I = /react-select-(\d+)/;

            function _(e) {
                var {
                    isSelected: n
                } = e;
                return s().createElement(c.y.Option, (0, r.Z)({}, e, {
                    innerProps: T(T({}, e.innerProps), {}, {
                        "aria-selected": n,
                        role: "option"
                    })
                }))
            }

            function x(e) {
                var {
                    selectProps: {
                        "aria-label": n
                    },
                    options: t
                } = e, i = (0, a.useRef)(null);
                return (0, a.useEffect)((() => {
                    i.current && (i.current.tabIndex = 0, t.length > 0 && i.current.setAttribute("role", "group"))
                }), [t.length]), 0 === t.length ? s().createElement(c.y.MenuList, (0, r.Z)({}, e, {
                    innerRef: i
                })) : s().createElement("div", {
                    role: "listbox",
                    "aria-label": "".concat(n, " Menu list")
                }, s().createElement(c.y.MenuList, (0, r.Z)({}, e, {
                    innerRef: i
                })))
            }

            function k(e) {
                var {
                    id: n,
                    selectProps: {
                        menuIsOpen: t
                    }
                } = e, i = n.match(I), o = i ? i[1] : void 0, a = o ? "react-select-".concat(o, "-menu") : void 0;
                return s().createElement(c.y.Input, (0, r.Z)({}, e, {
                    "aria-expanded": t,
                    role: "combobox"
                }, a ? {
                    "aria-controls": a
                } : null))
            }

            function w(e) {
                var n = (0, a.useRef)(null),
                    [t, i] = (0, a.useState)(void 0);
                return (0, a.useEffect)((() => {
                    if (n.current) {
                        var e = n.current.closest(".custom-select");
                        if (e) {
                            var t = e.querySelector('input[type="text"]');
                            if (t) {
                                var r = t.getAttribute("id").match(I),
                                    o = r ? r[1] : void 0;
                                o && i(o)
                            }
                        }
                    }
                }), []), s().createElement(c.y.Menu, (0, r.Z)({}, e, {
                    innerRef: n,
                    innerProps: T(T({}, e.innerProps), t ? {
                        id: "react-select-".concat(t, "-menu")
                    } : null)
                }))
            }

            function C(e) {
                return function(n) {
                    var {
                        error: t,
                        variant: o = "inset",
                        className: a,
                        accessibilityMode: l = !1
                    } = n, c = (0, i.Z)(n, S);
                    return s().createElement("div", {
                        className: d()("custom-select", a)
                    }, s().createElement(e, (0, r.Z)({
                        styles: (0, L.Z)(t, o)
                    }, c, l ? {
                        components: {
                            MenuList: x,
                            Input: k,
                            Menu: w,
                            Option: _
                        }
                    } : null)))
                }
            }
            var M = C(p.default),
                R = C(u.default),
                O = C(h.default),
                P = C(f.default),
                A = C(y)
        },
        uAgT: (e, n, t) => {
            t.d(n, {
                Z: () => s
            }), t("ioFf");
            var i = t("L5+t"),
                r = t("FJMr");

            function o(e, n) {
                var t = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var i = Object.getOwnPropertySymbols(e);
                    n && (i = i.filter((function(n) {
                        return Object.getOwnPropertyDescriptor(e, n).enumerable
                    }))), t.push.apply(t, i)
                }
                return t
            }

            function a(e) {
                for (var n = 1; n < arguments.length; n++) {
                    var t = null != arguments[n] ? arguments[n] : {};
                    n % 2 ? o(Object(t), !0).forEach((function(n) {
                        (0, i.Z)(e, n, t[n])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : o(Object(t)).forEach((function(n) {
                        Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(t, n))
                    }))
                }
                return e
            }
            const s = (e, n) => {
                var t = "outset" === n;
                return {
                    control: (n, i) => {
                        var {
                            isFocused: o,
                            hasValue: s,
                            isMulti: l
                        } = i;
                        return a(a({}, n), {}, {
                            border: 0,
                            borderRadius: 0,
                            height: l ? "inherit" : r.inputHeight,
                            backgroundColor: t ? "var(--color-white)" : "var(--color-shade-lighter)",
                            boxShadow: e ? "inset 0 1px 4px rgba(var(--color-shade-medium-2-rgb), 0.5), 0 2px 0 ".concat(r.colorError) : o ? t ? "0px 3px 10px rgba(var(--color-shade-medium-2-rgb), 0.6), 0 2px 0 ".concat(r.colorShadeDark) : "inset 0 1px 4px rgba(var(--color-shade-medium-2-rgb), 0.5), 0 2px 0 ".concat(r.colorShadeDark) : s ? t ? "0px 3px 10px rgba(var(--color-shade-medium-2-rgb), 0.6), 0 0 0 transparent" : "inset 0 1px 4px var(--color-shade-medium-2), 0 0 0 transparent" : t ? "0px 3px 10px rgba(var(--color-shade-medium-2-rgb), 0.6), 0 0 0 transparent" : "inset 0 1px 4px rgba(var(--color-shade-medium-2-rgb), 0.5), 0 0 0 transparent"
                        })
                    },
                    valueContainer: (e, n) => {
                        var {
                            isMulti: t
                        } = n;
                        return a(a({}, e), {}, {
                            padding: t ? "4px 8px" : e.padding
                        })
                    },
                    menu: e => a(a({}, e), {}, {
                        boxShadow: "none",
                        borderRadius: 0,
                        borderBottomRightRadius: r.borderRadiusS,
                        borderBottomLeftRadius: r.borderRadiusS,
                        margin: 0
                    }),
                    menuList: e => a(a({}, e), {}, {
                        padding: 0,
                        borderBottomRightRadius: r.borderRadiusS,
                        borderBottomLeftRadius: r.borderRadiusS,
                        boxShadow: "0 3px 10px 0 rgba(115, 143, 147, 0.3)"
                    }),
                    indicatorSeparator: (e, n) => {
                        var {
                            selectProps: t,
                            hasValue: i
                        } = n;
                        return a(a({}, e), {}, {
                            display: t.isClearable && i ? "inline-block" : "none",
                            backgroundColor: "var(--color-shade-medium)"
                        })
                    },
                    clearIndicator: e => a(a({}, e), {}, {
                        transform: "scale(0.8)",
                        padding: r.spaceXs,
                        cursor: "pointer",
                        color: "var(--color-text-medium-dark)",
                        ":hover": {
                            color: "var(--color-text-dark)"
                        }
                    }),
                    dropdownIndicator: e => a(a({}, e), {}, {
                        transform: "scale(0.8)",
                        padding: r.spaceXs,
                        cursor: "pointer",
                        color: "var(--color-text-medium-dark)",
                        ":hover": {
                            color: "var(--color-text-dark)"
                        }
                    }),
                    option: (e, n) => {
                        var {
                            isSelected: t,
                            isFocused: i
                        } = n;
                        return a(a({}, e), {}, {
                            color: "var(--color-text-dark)",
                            cursor: "pointer",
                            backgroundColor: t ? "var(--color-shade-medium)" : i ? "var(--color-shade-light)" : "var(--color-white)",
                            ":active": {
                                backgroundColor: "var(--color-white)"
                            },
                            ":last-child": {
                                borderBottomLeftRadius: r.borderRadiusS,
                                borderBottomRightRadius: r.borderRadiusS
                            }
                        })
                    },
                    noOptionsMessage: e => a(a({}, e), {}, {
                        color: "var(--color-text-dark-faded)",
                        backgroundColor: "var(--color-white)"
                    }),
                    placeholder: e => a(a({}, e), {}, {
                        color: "var(--color-shade-dark)"
                    }),
                    singleValue: e => a(a({}, e), {}, {
                        color: "var(--color-shade-darker)"
                    }),
                    multiValue: e => a(a({}, e), {}, {
                        borderRadius: r.borderRadiusS,
                        backgroundColor: "var(--card-shadow-2)",
                        boxShadow: "0 2px 3px 0 var(--color-multivalue-box-shadow)",
                        color: r.colorSecondary,
                        marginBottom: r.spaceXs
                    }),
                    multiValueLabel: e => a(a({}, e), {}, {
                        color: "var(--color-shade-darker)"
                    }),
                    multiValueRemove: e => a(a({}, e), {}, {
                        cursor: "pointer",
                        transform: "scale(0.8)",
                        color: "var(--color-text-medium-dark)",
                        ":hover": {
                            color: "var(--color-text-dark)"
                        }
                    }),
                    input: e => a(a({}, e), {}, {
                        color: "var(--color-shade-darker)",
                        'input[type = "text"]': {
                            marginBottom: "0",
                            boxShadow: "none",
                            transition: "none"
                        },
                        'input[type = "text"]:focus': {
                            boxShadow: "none"
                        }
                    })
                }
            }
        }
    }
]);
//# sourceMappingURL=https://hrcdn.net/fcore/assets/sourcemaps/modules-node_modules_app-server_es_ui_component_editors_hr_monaco_editor_utils_js-node_module-d266c7-9e981769.js.map