(self.webpackChunkhackerrank_lib = self.webpackChunkhackerrank_lib || []).push([
    ["defaultVendors-node_modules_react-oauth_google_dist_index_esm_js-node_modules_dom-scroll-into-8d4ea9"], {
        EdAj: (t, e, s) => {
            "use strict";
            s.d(e, {
                Nq: () => c,
                _7: () => h,
                rg: () => o
            });
            var i = s("DTvD"),
                n = s.n(i);
            const r = (0, i.createContext)(null);

            function o({
                clientId: t,
                onScriptLoadSuccess: e,
                onScriptLoadError: s,
                children: o
            }) {
                const a = function(t = {}) {
                        const {
                            onScriptLoadSuccess: e,
                            onScriptLoadError: s
                        } = t, [n, r] = (0, i.useState)(!1), o = (0, i.useRef)(e);
                        o.current = e;
                        const a = (0, i.useRef)(s);
                        return a.current = s, (0, i.useEffect)((() => {
                            const t = document.createElement("script");
                            return t.src = "https://accounts.google.com/gsi/client", t.async = !0, t.defer = !0, t.onload = () => {
                                var t;
                                r(!0), null === (t = o.current) || void 0 === t || t.call(o)
                            }, t.onerror = () => {
                                var t;
                                r(!1), null === (t = a.current) || void 0 === t || t.call(a)
                            }, document.body.appendChild(t), () => {
                                document.body.removeChild(t)
                            }
                        }), []), n
                    }({
                        onScriptLoadSuccess: e,
                        onScriptLoadError: s
                    }),
                    c = (0, i.useMemo)((() => ({
                        clientId: t,
                        scriptLoadedSuccessfully: a
                    })), [t, a]);
                return n().createElement(r.Provider, {
                    value: c
                }, o)
            }

            function a() {
                const t = (0, i.useContext)(r);
                if (!t) throw new Error("Google OAuth components must be used within GoogleOAuthProvider");
                return t
            }

            function c({
                flow: t = "implicit",
                scope: e = "",
                onSuccess: s,
                onError: n,
                ...r
            }) {
                const {
                    clientId: o,
                    scriptLoadedSuccessfully: c
                } = a(), h = (0, i.useRef)(), l = (0, i.useRef)(s);
                l.current = s;
                const u = (0, i.useRef)(n);
                u.current = n, (0, i.useEffect)((() => {
                    var s;
                    if (!c) return;
                    const i = "implicit" === t ? "initTokenClient" : "initCodeClient",
                        n = null === (s = window.google) || void 0 === s ? void 0 : s.accounts.oauth2[i]({
                            client_id: o,
                            scope: `openid profile email ${e}`,
                            callback: t => {
                                var e, s;
                                if (t.error) return null === (e = u.current) || void 0 === e ? void 0 : e.call(u, t);
                                null === (s = l.current) || void 0 === s || s.call(l, t)
                            },
                            ...r
                        });
                    h.current = n
                }), [o, c, t, e]);
                const d = (0, i.useCallback)((t => h.current.requestAccessToken(t)), []),
                    p = (0, i.useCallback)((() => h.current.requestCode()), []);
                return "implicit" === t ? d : p
            }

            function h({
                onSuccess: t,
                onError: e,
                promptMomentNotification: s,
                cancel_on_tap_outside: n,
                hosted_domain: r
            }) {
                const {
                    clientId: o,
                    scriptLoadedSuccessfully: c
                } = a(), h = (0, i.useRef)(t);
                h.current = t;
                const l = (0, i.useRef)(e);
                l.current = e;
                const u = (0, i.useRef)(s);
                u.current = s, (0, i.useEffect)((() => {
                    var t, e;
                    if (c) return null === (t = window.google) || void 0 === t || t.accounts.id.initialize({
                        client_id: o,
                        callback: t => {
                            var e;
                            if (!t.clientId || !t.credential) return null === (e = l.current) || void 0 === e ? void 0 : e.call(l);
                            h.current(t)
                        },
                        hosted_domain: r,
                        cancel_on_tap_outside: n
                    }), null === (e = window.google) || void 0 === e || e.accounts.id.prompt(u.current), () => {
                        var t;
                        null === (t = window.google) || void 0 === t || t.accounts.id.cancel()
                    }
                }), [o, c, n, r])
            }
        },
        S9lL: (t, e, s) => {
            t.exports = s("zt9T")
        },
        zt9T: (t, e, s) => {
            var i = s("jB5C");
            t.exports = function(t, e, s) {
                s = s || {}, 9 === e.nodeType && (e = i.getWindow(e));
                var n = s.allowHorizontalScroll,
                    r = s.onlyScrollIfNeeded,
                    o = s.alignWithTop,
                    a = s.alignWithLeft;
                n = void 0 === n || n;
                var c, h, l, u, d, p, f, g, m, y, b = i.isWindow(e),
                    v = i.offset(t),
                    S = i.outerHeight(t),
                    w = i.outerWidth(t);
                b ? (f = e, y = i.height(f), m = i.width(f), g = {
                    left: i.scrollLeft(f),
                    top: i.scrollTop(f)
                }, d = {
                    left: v.left - g.left,
                    top: v.top - g.top
                }, p = {
                    left: v.left + w - (g.left + m),
                    top: v.top + S - (g.top + y)
                }, u = g) : (c = i.offset(e), h = e.clientHeight, l = e.clientWidth, u = {
                    left: e.scrollLeft,
                    top: e.scrollTop
                }, d = {
                    left: v.left - (c.left + (parseFloat(i.css(e, "borderLeftWidth")) || 0)),
                    top: v.top - (c.top + (parseFloat(i.css(e, "borderTopWidth")) || 0))
                }, p = {
                    left: v.left + w - (c.left + l + (parseFloat(i.css(e, "borderRightWidth")) || 0)),
                    top: v.top + S - (c.top + h + (parseFloat(i.css(e, "borderBottomWidth")) || 0))
                }), d.top < 0 || p.top > 0 ? !0 === o ? i.scrollTop(e, u.top + d.top) : !1 === o ? i.scrollTop(e, u.top + p.top) : d.top < 0 ? i.scrollTop(e, u.top + d.top) : i.scrollTop(e, u.top + p.top) : r || ((o = void 0 === o || !!o) ? i.scrollTop(e, u.top + d.top) : i.scrollTop(e, u.top + p.top)), n && (d.left < 0 || p.left > 0 ? !0 === a ? i.scrollLeft(e, u.left + d.left) : !1 === a ? i.scrollLeft(e, u.left + p.left) : d.left < 0 ? i.scrollLeft(e, u.left + d.left) : i.scrollLeft(e, u.left + p.left) : r || ((a = void 0 === a || !!a) ? i.scrollLeft(e, u.left + d.left) : i.scrollLeft(e, u.left + p.left)))
            }
        },
        jB5C: t => {
            function e(t, e) {
                var s = t["page" + (e ? "Y" : "X") + "Offset"],
                    i = "scroll" + (e ? "Top" : "Left");
                if ("number" != typeof s) {
                    var n = t.document;
                    "number" != typeof(s = n.documentElement[i]) && (s = n.body[i])
                }
                return s
            }

            function s(t) {
                return e(t)
            }

            function i(t) {
                return e(t, !0)
            }

            function n(t) {
                var e = function(t) {
                        var e, s, i, n = t.ownerDocument,
                            r = n.body,
                            o = n && n.documentElement;
                        return s = (e = t.getBoundingClientRect()).left, i = e.top, {
                            left: s -= o.clientLeft || r.clientLeft || 0,
                            top: i -= o.clientTop || r.clientTop || 0
                        }
                    }(t),
                    n = t.ownerDocument,
                    r = n.defaultView || n.parentWindow;
                return e.left += s(r), e.top += i(r), e
            }
            var r, o = new RegExp("^(" + /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source + ")(?!px)[a-z%]+$", "i"),
                a = /^(top|right|bottom|left)$/,
                c = "currentStyle",
                h = "runtimeStyle",
                l = "left";

            function u(t, e) {
                for (var s = 0; s < t.length; s++) e(t[s])
            }

            function d(t) {
                return "border-box" === r(t, "boxSizing")
            }
            "undefined" != typeof window && (r = window.getComputedStyle ? function(t, e, s) {
                var i = "",
                    n = t.ownerDocument;
                return (s = s || n.defaultView.getComputedStyle(t, null)) && (i = s.getPropertyValue(e) || s[e]), i
            } : function(t, e) {
                var s = t[c] && t[c][e];
                if (o.test(s) && !a.test(e)) {
                    var i = t.style,
                        n = i[l],
                        r = t[h][l];
                    t[h][l] = t[c][l], i[l] = "fontSize" === e ? "1em" : s || 0, s = i.pixelLeft + "px", i[l] = n, t[h][l] = r
                }
                return "" === s ? "auto" : s
            });
            var p = ["margin", "border", "padding"],
                f = -1,
                g = 2,
                m = 1;

            function y(t, e, s) {
                var i, n, o, a = 0;
                for (n = 0; n < e.length; n++)
                    if (i = e[n])
                        for (o = 0; o < s.length; o++) {
                            var c;
                            c = "border" === i ? i + s[o] + "Width" : i + s[o], a += parseFloat(r(t, c)) || 0
                        }
                return a
            }

            function b(t) {
                return null != t && t == t.window
            }
            var v = {};

            function S(t, e, s) {
                if (b(t)) return "width" === e ? v.viewportWidth(t) : v.viewportHeight(t);
                if (9 === t.nodeType) return "width" === e ? v.docWidth(t) : v.docHeight(t);
                var i = "width" === e ? ["Left", "Right"] : ["Top", "Bottom"],
                    n = "width" === e ? t.offsetWidth : t.offsetHeight,
                    o = (r(t), d(t)),
                    a = 0;
                (null == n || n <= 0) && (n = void 0, (null == (a = r(t, e)) || Number(a) < 0) && (a = t.style[e] || 0), a = parseFloat(a) || 0), void 0 === s && (s = o ? m : f);
                var c = void 0 !== n || o,
                    h = n || a;
                return s === f ? c ? h - y(t, ["border", "padding"], i) : a : c ? h + (s === m ? 0 : s === g ? -y(t, ["border"], i) : y(t, ["margin"], i)) : a + y(t, p.slice(s), i)
            }
            u(["Width", "Height"], (function(t) {
                v["doc" + t] = function(e) {
                    var s = e.document;
                    return Math.max(s.documentElement["scroll" + t], s.body["scroll" + t], v["viewport" + t](s))
                }, v["viewport" + t] = function(e) {
                    var s = "client" + t,
                        i = e.document,
                        n = i.body,
                        r = i.documentElement[s];
                    return "CSS1Compat" === i.compatMode && r || n && n[s] || r
                }
            }));
            var w = {
                position: "absolute",
                visibility: "hidden",
                display: "block"
            };

            function k(t) {
                var e, s = arguments;
                return 0 !== t.offsetWidth ? e = S.apply(void 0, s) : function(t, i, n) {
                    var r, o = {},
                        a = t.style;
                    for (r in i) o[r] = a[r], a[r] = i[r];
                    for (r in function() {
                            e = S.apply(void 0, s)
                        }.call(t), i) a[r] = o[r]
                }(t, w), e
            }

            function T(t, e, s) {
                if ("object" != typeof e) {
                    if (void 0 === s) return r(t, e);
                    "number" == typeof s && (s += "px"), t.style[e] = s
                } else
                    for (var i in e) T(t, i, e[i])
            }

            function I(t, e) {
                for (var s in e) t[s] = e[s];
                return t
            }
            u(["width", "height"], (function(t) {
                var e = t.charAt(0).toUpperCase() + t.slice(1);
                v["outer" + e] = function(e, s) {
                    return e && k(e, t, s ? 0 : m)
                };
                var s = "width" === t ? ["Left", "Right"] : ["Top", "Bottom"];
                v[t] = function(e, i) {
                    return void 0 === i ? e && k(e, t, f) : e ? (r(e), d(e) && (i += y(e, ["padding", "border"], s)), T(e, t, i)) : void 0
                }
            }));
            var x = t.exports = {
                getWindow: function(t) {
                    var e = t.ownerDocument || t;
                    return e.defaultView || e.parentWindow
                },
                offset: function(t, e) {
                    if (void 0 === e) return n(t);
                    ! function(t, e) {
                        "static" === T(t, "position") && (t.style.position = "relative");
                        var s, i, r = n(t),
                            o = {};
                        for (i in e) s = parseFloat(T(t, i)) || 0, o[i] = s + e[i] - r[i];
                        T(t, o)
                    }(t, e)
                },
                isWindow: b,
                each: u,
                css: T,
                clone: function(t) {
                    var e = {};
                    for (var s in t) e[s] = t[s];
                    if (t.overflow)
                        for (s in t) e.overflow[s] = t.overflow[s];
                    return e
                },
                mix: I,
                scrollLeft: function(t, e) {
                    if (b(t)) {
                        if (void 0 === e) return s(t);
                        window.scrollTo(e, i(t))
                    } else {
                        if (void 0 === e) return t.scrollLeft;
                        t.scrollLeft = e
                    }
                },
                scrollTop: function(t, e) {
                    if (b(t)) {
                        if (void 0 === e) return i(t);
                        window.scrollTo(s(t), e)
                    } else {
                        if (void 0 === e) return t.scrollTop;
                        t.scrollTop = e
                    }
                },
                merge: function() {
                    for (var t = {}, e = 0; e < arguments.length; e++) x.mix(t, arguments[e]);
                    return t
                },
                viewportWidth: 0,
                viewportHeight: 0
            };
            I(x, v)
        },
        MjPQ: function(t, e, s) {
            var i, n, r;
            ! function(o, a) {
                "use strict";
                n = [s("9fj9")], void 0 === (r = "function" == typeof(i = function(t) {
                    var e = /(^|@)\S+:\d+/,
                        s = /^\s*at .*(\S+:\d+|\(native\))/m,
                        i = /^(eval@)?(\[native code])?$/;
                    return {
                        parse: function(t) {
                            if (void 0 !== t.stacktrace || void 0 !== t["opera#sourceloc"]) return this.parseOpera(t);
                            if (t.stack && t.stack.match(s)) return this.parseV8OrIE(t);
                            if (t.stack) return this.parseFFOrSafari(t);
                            throw new Error("Cannot parse given Error object")
                        },
                        extractLocation: function(t) {
                            if (-1 === t.indexOf(":")) return [t];
                            var e = /(.+?)(?::(\d+))?(?::(\d+))?$/.exec(t.replace(/[()]/g, ""));
                            return [e[1], e[2] || void 0, e[3] || void 0]
                        },
                        parseV8OrIE: function(e) {
                            return e.stack.split("\n").filter((function(t) {
                                return !!t.match(s)
                            }), this).map((function(e) {
                                e.indexOf("(eval ") > -1 && (e = e.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, ""));
                                var s = e.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, ""),
                                    i = s.match(/ (\(.+\)$)/);
                                s = i ? s.replace(i[0], "") : s;
                                var n = this.extractLocation(i ? i[1] : s),
                                    r = i && s || void 0,
                                    o = ["eval", "<anonymous>"].indexOf(n[0]) > -1 ? void 0 : n[0];
                                return new t({
                                    functionName: r,
                                    fileName: o,
                                    lineNumber: n[1],
                                    columnNumber: n[2],
                                    source: e
                                })
                            }), this)
                        },
                        parseFFOrSafari: function(e) {
                            return e.stack.split("\n").filter((function(t) {
                                return !t.match(i)
                            }), this).map((function(e) {
                                if (e.indexOf(" > eval") > -1 && (e = e.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1")), -1 === e.indexOf("@") && -1 === e.indexOf(":")) return new t({
                                    functionName: e
                                });
                                var s = /((.*".+"[^@]*)?[^@]*)(?:@)/,
                                    i = e.match(s),
                                    n = i && i[1] ? i[1] : void 0,
                                    r = this.extractLocation(e.replace(s, ""));
                                return new t({
                                    functionName: n,
                                    fileName: r[0],
                                    lineNumber: r[1],
                                    columnNumber: r[2],
                                    source: e
                                })
                            }), this)
                        },
                        parseOpera: function(t) {
                            return !t.stacktrace || t.message.indexOf("\n") > -1 && t.message.split("\n").length > t.stacktrace.split("\n").length ? this.parseOpera9(t) : t.stack ? this.parseOpera11(t) : this.parseOpera10(t)
                        },
                        parseOpera9: function(e) {
                            for (var s = /Line (\d+).*script (?:in )?(\S+)/i, i = e.message.split("\n"), n = [], r = 2, o = i.length; r < o; r += 2) {
                                var a = s.exec(i[r]);
                                a && n.push(new t({
                                    fileName: a[2],
                                    lineNumber: a[1],
                                    source: i[r]
                                }))
                            }
                            return n
                        },
                        parseOpera10: function(e) {
                            for (var s = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i, i = e.stacktrace.split("\n"), n = [], r = 0, o = i.length; r < o; r += 2) {
                                var a = s.exec(i[r]);
                                a && n.push(new t({
                                    functionName: a[3] || void 0,
                                    fileName: a[2],
                                    lineNumber: a[1],
                                    source: i[r]
                                }))
                            }
                            return n
                        },
                        parseOpera11: function(s) {
                            return s.stack.split("\n").filter((function(t) {
                                return !!t.match(e) && !t.match(/^Error created at/)
                            }), this).map((function(e) {
                                var s, i = e.split("@"),
                                    n = this.extractLocation(i.pop()),
                                    r = i.shift() || "",
                                    o = r.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^)]*\)/g, "") || void 0;
                                r.match(/\(([^)]*)\)/) && (s = r.replace(/^[^(]+\(([^)]*)\)$/, "$1"));
                                var a = void 0 === s || "[arguments not available]" === s ? void 0 : s.split(",");
                                return new t({
                                    functionName: o,
                                    args: a,
                                    fileName: n[0],
                                    lineNumber: n[1],
                                    columnNumber: n[2],
                                    source: e
                                })
                            }), this)
                        }
                    }
                }) ? i.apply(e, n) : i) || (t.exports = r)
            }()
        },
        SKAX: (t, e, s) => {
            var i = s("JC6p"),
                n = s("lQqw")(i);
            t.exports = n
        },
        "2GsC": t => {
            t.exports = function(t, e, s, i) {
                for (var n = s - 1, r = t.length; ++n < r;)
                    if (i(t[n], e)) return n;
                return -1
            }
        },
        "W6/K": (t, e, s) => {
            var i = s("eUgh"),
                n = s("R/W3"),
                r = s("2GsC"),
                o = s("sEf8"),
                a = s("Q1l4"),
                c = Array.prototype.splice;
            t.exports = function(t, e, s, h) {
                var l = h ? r : n,
                    u = -1,
                    d = e.length,
                    p = t;
                for (t === e && (e = a(e)), s && (p = i(t, o(s))); ++u < d;)
                    for (var f = 0, g = e[u], m = s ? s(g) : g;
                        (f = l(p, m, f, h)) > -1;) p !== t && c.call(p, f, 1), c.call(t, f, 1);
                return t
            }
        },
        R5Y4: t => {
            var e = Math.ceil,
                s = Math.max;
            t.exports = function(t, i, n, r) {
                for (var o = -1, a = s(e((i - t) / (n || 1)), 0), c = Array(a); a--;) c[r ? a : ++o] = t, t += n;
                return c
            }
        },
        lQqw: (t, e, s) => {
            var i = s("MMmD");
            t.exports = function(t, e) {
                return function(s, n) {
                    if (null == s) return s;
                    if (!i(s)) return t(s, n);
                    for (var r = s.length, o = e ? r : -1, a = Object(s);
                        (e ? o-- : ++o < r) && !1 !== n(a[o], o, a););
                    return s
                }
            }
        },
        HLqC: (t, e, s) => {
            var i = s("R5Y4"),
                n = s("mv/X"),
                r = s("ZCgT");
            t.exports = function(t) {
                return function(e, s, o) {
                    return o && "number" != typeof o && n(e, s, o) && (s = o = void 0), e = r(e), void 0 === s ? (s = e, e = 0) : s = r(s), o = void 0 === o ? e < s ? 1 : -1 : r(o), i(e, s, o, t)
                }
            }
        },
        "mVx/": (t, e, s) => {
            var i = s("XKAG")(s("JELi"));
            t.exports = i
        },
        JELi: (t, e, s) => {
            var i = s("KwMD"),
                n = s("ut/Y"),
                r = s("Sxd8"),
                o = Math.max,
                a = Math.min;
            t.exports = function(t, e, s) {
                var c = null == t ? 0 : t.length;
                if (!c) return -1;
                var h = c - 1;
                return void 0 !== s && (h = r(s), h = s < 0 ? o(c + h, 0) : a(h, c - 1)), i(t, n(e, 3), h, !0)
            }
        },
        "Y+p1": (t, e, s) => {
            var i = s("wF/u");
            t.exports = function(t, e) {
                return i(t, e)
            }
        },
        J2iB: t => {
            t.exports = function(t) {
                return null == t
            }
        },
        hzCD: (t, e, s) => {
            var i = s("EA7m")(s("0Q2g"));
            t.exports = i
        },
        "0Q2g": (t, e, s) => {
            var i = s("W6/K");
            t.exports = function(t, e) {
                return t && t.length && e && e.length ? i(t, e) : t
            }
        },
        WjpJ: (t, e, s) => {
            var i = s("HLqC")();
            t.exports = i
        },
        qPyV: (t, e, s) => {
            var i = s("ut/Y"),
                n = s("LGYb");
            t.exports = function(t, e) {
                return t && t.length ? n(t, i(e, 2)) : []
            }
        },
        qCJc: (t, e, s) => {
            "use strict";
            e.Z = o;
            var i = r(s("DTvD")),
                n = r(s("17x9"));

            function r(t) {
                return t && t.__esModule ? t : {
                    default: t
                }
            }

            function o(t) {
                var e = (t.width || 36) + "px",
                    s = (t.height || 30) + "px",
                    n = parseInt(s.replace("px", "")) / 2 + "px",
                    r = t.isOpen || !1,
                    o = t.strokeWidth || 2,
                    a = "-" + o / 2 + "px",
                    c = t.animationDuration || "0.4",
                    h = function(t, e, s) {
                        return "translate3d(0," + (t ? n : e) + ",0) rotate(" + (t ? s + "deg" : "0") + ")"
                    },
                    l = {
                        container: {
                            width: e,
                            height: s,
                            position: "relative",
                            transform: "rotate(" + (t.rotate || 0) + "deg)"
                        },
                        lineBase: {
                            display: "block",
                            height: o + "px",
                            width: "100%",
                            background: t.color || "#000",
                            transitionTimingFunction: "ease",
                            transitionDuration: c + "s",
                            borderRadius: (t.borderRadius || 0) + "px",
                            transformOrigin: "center",
                            position: "absolute"
                        },
                        firstLine: {
                            transform: h(r, 0, 45),
                            marginTop: a
                        },
                        secondLine: {
                            transitionTimingFunction: "ease-out",
                            transitionDuration: c / 4 + "s",
                            opacity: r ? "0" : "1",
                            top: n,
                            marginTop: a
                        },
                        thirdLine: {
                            transform: h(r, s, -45),
                            marginTop: a
                        }
                    };
                return i.default.createElement("div", {
                    style: l.container,
                    onClick: t.menuClicked
                }, i.default.createElement("span", {
                    style: Object.assign({}, l.lineBase, l.firstLine)
                }), i.default.createElement("span", {
                    style: Object.assign({}, l.lineBase, l.secondLine)
                }), i.default.createElement("span", {
                    style: Object.assign({}, l.lineBase, l.thirdLine)
                }))
            }
            o.propTypes = {
                isOpen: n.default.bool.isRequired,
                menuClicked: n.default.func.isRequired,
                width: n.default.number,
                height: n.default.number,
                strokeWidth: n.default.number,
                rotate: n.default.number,
                color: n.default.string,
                borderRadius: n.default.number,
                animationDuration: n.default.number
            }
        },
        LlRK: (t, e, s) => {
            "use strict";
            var i, n = Object.assign || function(t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var s = arguments[e];
                        for (var i in s) Object.prototype.hasOwnProperty.call(s, i) && (t[i] = s[i])
                    }
                    return t
                },
                r = function() {
                    function t(t, e) {
                        for (var s = 0; s < e.length; s++) {
                            var i = e[s];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                    }
                    return function(e, s, i) {
                        return s && t(e.prototype, s), i && t(e, i), e
                    }
                }(),
                o = s("DTvD"),
                a = (i = o) && i.__esModule ? i : {
                    default: i
                };

            function c(t, e) {
                if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !e || "object" != typeof e && "function" != typeof e ? t : e
            }
            var h = 3600,
                l = 86400,
                u = 7 * l,
                d = 30 * l,
                p = 365 * l,
                f = function(t) {
                    function e() {
                        var t, s, i;
                        ! function(t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, e);
                        for (var n = arguments.length, r = Array(n), o = 0; o < n; o++) r[o] = arguments[o];
                        return s = i = c(this, (t = Object.getPrototypeOf(e)).call.apply(t, [this].concat(r))), i.isStillMounted = !1, i.tick = function(t) {
                            if (i.isStillMounted && i.props.live) {
                                var e = new Date(i.props.date).valueOf(),
                                    s = Date.now(),
                                    n = Math.round(Math.abs(s - e) / 1e3),
                                    r = n < 60 ? 1e3 : n < h ? 6e4 : n < l ? 36e5 : 0,
                                    o = Math.min(Math.max(r, 1e3 * i.props.minPeriod), 1e3 * i.props.maxPeriod);
                                o && (i.timeoutId = setTimeout(i.tick, o)), t || i.forceUpdate()
                            }
                        }, c(i, s)
                    }
                    return function(t, e) {
                        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                        t.prototype = Object.create(e && e.prototype, {
                            constructor: {
                                value: t,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                    }(e, t), r(e, [{
                        key: "componentDidMount",
                        value: function() {
                            this.isStillMounted = !0, this.props.live && this.tick(!0)
                        }
                    }, {
                        key: "componentDidUpdate",
                        value: function(t) {
                            this.props.live === t.live && this.props.date === t.date || (!this.props.live && this.timeoutId && clearTimeout(this.timeoutId), this.tick())
                        }
                    }, {
                        key: "componentWillUnmount",
                        value: function() {
                            this.isStillMounted = !1, this.timeoutId && (clearTimeout(this.timeoutId), this.timeoutId = void 0)
                        }
                    }, {
                        key: "render",
                        value: function() {
                            var t = this.props,
                                e = t.date,
                                s = (t.formatter, t.component),
                                i = (t.live, t.minPeriod, t.maxPeriod, t.title),
                                r = function(t, e) {
                                    var s = {};
                                    for (var i in t) e.indexOf(i) >= 0 || Object.prototype.hasOwnProperty.call(t, i) && (s[i] = t[i]);
                                    return s
                                }(t, ["date", "formatter", "component", "live", "minPeriod", "maxPeriod", "title"]),
                                o = new Date(e).valueOf(),
                                c = Date.now(),
                                f = Math.round(Math.abs(c - o) / 1e3),
                                g = o < c ? "ago" : "from now",
                                m = function(t, e) {
                                    if (Array.isArray(t)) return t;
                                    if (Symbol.iterator in Object(t)) return function(t, e) {
                                        var s = [],
                                            i = !0,
                                            n = !1,
                                            r = void 0;
                                        try {
                                            for (var o, a = t[Symbol.iterator](); !(i = (o = a.next()).done) && (s.push(o.value), !e || s.length !== e); i = !0);
                                        } catch (t) {
                                            n = !0, r = t
                                        } finally {
                                            try {
                                                !i && a.return && a.return()
                                            } finally {
                                                if (n) throw r
                                            }
                                        }
                                        return s
                                    }(t, e);
                                    throw new TypeError("Invalid attempt to destructure non-iterable instance")
                                }(f < 60 ? [Math.round(f), "second"] : f < h ? [Math.round(f / 60), "minute"] : f < l ? [Math.round(f / h), "hour"] : f < u ? [Math.round(f / l), "day"] : f < d ? [Math.round(f / u), "week"] : f < p ? [Math.round(f / d), "month"] : [Math.round(f / p), "year"], 2),
                                y = m[0],
                                b = m[1],
                                v = void 0 === i ? "string" == typeof e ? e : new Date(e).toISOString().substr(0, 16).replace("T", " ") : i;
                            return "time" === s && (r.dateTime = new Date(e).toISOString()), a.default.createElement(s, n({}, r, {
                                title: v
                            }), this.props.formatter(y, b, g, o))
                        }
                    }]), e
                }(o.Component);
            f.displayName = "TimeAgo", f.defaultProps = {
                live: !0,
                component: "time",
                minPeriod: 0,
                maxPeriod: 1 / 0,
                formatter: function(t, e, s) {
                    return 1 !== t && (e += "s"), t + " " + e + " " + s
                }
            }, e.Z = f
        },
        peh1: (t, e) => {
            "use strict";

            function s(t, e) {
                return t === e
            }

            function i(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : s,
                    i = null,
                    n = null;
                return function() {
                    return function(t, e, s) {
                        if (null === e || null === s || e.length !== s.length) return !1;
                        for (var i = e.length, n = 0; n < i; n++)
                            if (!t(e[n], s[n])) return !1;
                        return !0
                    }(e, i, arguments) || (n = t.apply(null, arguments)), i = arguments, n
                }
            }

            function n(t) {
                for (var e = arguments.length, s = Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++) s[n - 1] = arguments[n];
                return function() {
                    for (var e = arguments.length, n = Array(e), r = 0; r < e; r++) n[r] = arguments[r];
                    var o = 0,
                        a = n.pop(),
                        c = function(t) {
                            var e = Array.isArray(t[0]) ? t[0] : t;
                            if (!e.every((function(t) {
                                    return "function" == typeof t
                                }))) {
                                var s = e.map((function(t) {
                                    return typeof t
                                })).join(", ");
                                throw new Error("Selector creators expect all input-selectors to be functions, instead received the following types: [" + s + "]")
                            }
                            return e
                        }(n),
                        h = t.apply(void 0, [function() {
                            return o++, a.apply(null, arguments)
                        }].concat(s)),
                        l = i((function() {
                            for (var t = [], e = c.length, s = 0; s < e; s++) t.push(c[s].apply(null, arguments));
                            return h.apply(null, t)
                        }));
                    return l.resultFunc = a, l.recomputations = function() {
                        return o
                    }, l.resetRecomputations = function() {
                        return o = 0
                    }, l
                }
            }
            e.PW = i, e.wN = n;
            e.P1 = n(i)
        },
        "9fj9": function(t, e) {
            var s, i, n;
            ! function(r, o) {
                "use strict";
                i = [], void 0 === (n = "function" == typeof(s = function() {
                    function t(t) {
                        return t.charAt(0).toUpperCase() + t.substring(1)
                    }

                    function e(t) {
                        return function() {
                            return this[t]
                        }
                    }
                    var s = ["isConstructor", "isEval", "isNative", "isToplevel"],
                        i = ["columnNumber", "lineNumber"],
                        n = ["fileName", "functionName", "source"],
                        r = s.concat(i, n, ["args"], ["evalOrigin"]);

                    function o(e) {
                        if (e)
                            for (var s = 0; s < r.length; s++) void 0 !== e[r[s]] && this["set" + t(r[s])](e[r[s]])
                    }
                    o.prototype = {
                        getArgs: function() {
                            return this.args
                        },
                        setArgs: function(t) {
                            if ("[object Array]" !== Object.prototype.toString.call(t)) throw new TypeError("Args must be an Array");
                            this.args = t
                        },
                        getEvalOrigin: function() {
                            return this.evalOrigin
                        },
                        setEvalOrigin: function(t) {
                            if (t instanceof o) this.evalOrigin = t;
                            else {
                                if (!(t instanceof Object)) throw new TypeError("Eval Origin must be an Object or StackFrame");
                                this.evalOrigin = new o(t)
                            }
                        },
                        toString: function() {
                            var t = this.getFileName() || "",
                                e = this.getLineNumber() || "",
                                s = this.getColumnNumber() || "",
                                i = this.getFunctionName() || "";
                            return this.getIsEval() ? t ? "[eval] (" + t + ":" + e + ":" + s + ")" : "[eval]:" + e + ":" + s : i ? i + " (" + t + ":" + e + ":" + s + ")" : t + ":" + e + ":" + s
                        }
                    }, o.fromString = function(t) {
                        var e = t.indexOf("("),
                            s = t.lastIndexOf(")"),
                            i = t.substring(0, e),
                            n = t.substring(e + 1, s).split(","),
                            r = t.substring(s + 1);
                        if (0 === r.indexOf("@")) var a = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(r, ""),
                            c = a[1],
                            h = a[2],
                            l = a[3];
                        return new o({
                            functionName: i,
                            args: n || void 0,
                            fileName: c,
                            lineNumber: h || void 0,
                            columnNumber: l || void 0
                        })
                    };
                    for (var a = 0; a < s.length; a++) o.prototype["get" + t(s[a])] = e(s[a]), o.prototype["set" + t(s[a])] = function(t) {
                        return function(e) {
                            this[t] = Boolean(e)
                        }
                    }(s[a]);
                    for (var c = 0; c < i.length; c++) o.prototype["get" + t(i[c])] = e(i[c]), o.prototype["set" + t(i[c])] = function(t) {
                        return function(e) {
                            if (s = e, isNaN(parseFloat(s)) || !isFinite(s)) throw new TypeError(t + " must be a Number");
                            var s;
                            this[t] = Number(e)
                        }
                    }(i[c]);
                    for (var h = 0; h < n.length; h++) o.prototype["get" + t(n[h])] = e(n[h]), o.prototype["set" + t(n[h])] = function(t) {
                        return function(e) {
                            this[t] = String(e)
                        }
                    }(n[h]);
                    return o
                }) ? s.apply(e, i) : s) || (t.exports = n)
            }()
        },
        qusI: (t, e, s) => {
            var i = s("rXkm"),
                n = s("M9NC"),
                r = s("MkIK"),
                o = s("tsFD"),
                a = s("5IHH"),
                c = s("v6/7"),
                h = s("RcYT"),
                l = s("XyaU"),
                u = Object.prototype.hasOwnProperty;
            t.exports = function(t) {
                if (null == t) return !0;
                if (a(t) && (o(t) || "string" == typeof t || "function" == typeof t.splice || c(t) || l(t) || r(t))) return !t.length;
                var e = n(t);
                if ("[object Map]" == e || "[object Set]" == e) return !t.size;
                if (h(t)) return !i(t).length;
                for (var s in t)
                    if (u.call(t, s)) return !1;
                return !0
            }
        },
        QLWO: (t, e, s) => {
            "use strict";
            s.d(e, {
                ZP: () => Ls
            });
            var i = s("crp1");
            class n {
                constructor() {
                    this.idx = 1, this.backDict = {}
                }
                getKey(t) {
                    let e = !1;
                    return this.backDict[t] || (e = !0, this.backDict[t] = this.idx++), [this.backDict[t], e]
                }
            }
            class r {
                constructor(t, e) {
                    this.app = t, this.isDictDisabled = e, this.dict = new n
                }
                sendSetAttribute(t, e, s) {
                    if (this.isDictDisabled) {
                        const i = [12, t, e, s];
                        return this.app.send(i)
                    } {
                        const i = [51, t, this.applyDict(e), this.applyDict(s)];
                        return this.app.send(i)
                    }
                }
                applyDict(t) {
                    const [e, s] = this.dict.getKey(t);
                    return s && this.app.send([50, e, t]), e
                }
                clear() {
                    this.dict = new n
                }
            }
            class o {
                constructor(t, e) {
                    this.app = t, this.startParams = e, this.conditions = [], this.hasStarted = !1, this.createConditionFromFilter = t => {
                        if (t.value.length) {
                            const e = c(t);
                            if (e.type) return e
                        }
                    }, this.durationInt = null
                }
                setConditions(t) {
                    this.conditions = t
                }
                async fetchConditions(t, e) {
                    try {
                        const s = await fetch(`${this.app.options.ingestPoint}/v1/web/conditions/${t}`, {
                                method: "GET",
                                headers: {
                                    Authorization: `Bearer ${e}`
                                }
                            }),
                            {
                                conditions: i
                            } = await s.json(),
                            n = [];
                        i.forEach((t => {
                            t.filters.forEach((e => {
                                let s;
                                "fetch" === e.type ? (s = {
                                    type: "network_request",
                                    subConditions: [],
                                    name: t.name
                                }, e.filters.forEach((t => {
                                    const e = this.createConditionFromFilter(t);
                                    e && s.subConditions.push(e)
                                }))) : s = this.createConditionFromFilter(e), s && ("session_duration" === s.type && this.processDuration(s.value[0], t.name), n.push({ ...s,
                                    name: t.name
                                }))
                            }))
                        })), this.conditions = n
                    } catch (t) {
                        this.app.debug.error("Critical: cannot fetch start conditions")
                    }
                }
                trigger(t) {
                    if (!this.hasStarted) try {
                        this.hasStarted = !0, this.app.start(this.startParams, void 0, t)
                    } catch (t) {
                        this.app.debug.error(t)
                    }
                }
                processMessage(t) {
                    if (!this.hasStarted) switch (t[0]) {
                        case 78:
                            this.jsExceptionEvent(t);
                            break;
                        case 27:
                            this.customEvent(t);
                            break;
                        case 68:
                            this.clickEvent(t);
                            break;
                        case 122:
                            this.pageLocationEvent(t);
                            break;
                        case 83:
                            this.networkRequest(t)
                    }
                }
                processFlags(t) {
                    const e = this.conditions.filter((t => "feature_flag" === t.type));
                    e.length && e.forEach((e => {
                        const s = a[e.operator];
                        s && t.find((t => s(t.key, e.value))) && this.trigger(e.name)
                    }))
                }
                processDuration(t, e) {
                    this.durationInt = setInterval((() => {
                        performance.now() > t && this.trigger(e)
                    }), 1e3), this.app.attachStopCallback((() => {
                        this.durationInt && clearInterval(this.durationInt)
                    }))
                }
                networkRequest(t) {
                    const e = this.conditions.filter((t => "network_request" === t.type));
                    e.length && e.forEach((e => {
                        const s = e.subConditions.filter((t => "isAny" !== t.operator));
                        s.length ? s.every((e => {
                            let s;
                            switch (e.key) {
                                case "url":
                                    s = t[3];
                                    break;
                                case "status":
                                    s = t[6];
                                    break;
                                case "method":
                                    s = t[2];
                                    break;
                                case "duration":
                                    s = t[8]
                            }
                            const i = a[e.operator];
                            if (i && i(s, e.value)) return !0
                        })) && this.trigger(e.name) : 0 === s.length && e.subConditions.length && this.trigger(e.name)
                    }))
                }
                customEvent(t) {
                    const e = this.conditions.filter((t => "custom_event" === t.type));
                    e.length && e.forEach((e => {
                        const s = a[e.operator];
                        s && (s(t[1], e.value) || s(t[2], e.value)) && this.trigger(e.name)
                    }))
                }
                clickEvent(t) {
                    const e = this.conditions.filter((t => "click" === t.type));
                    e.length && e.forEach((e => {
                        const s = a[e.operator];
                        s && (s(t[3], e.value) || s(t[4], e.value)) && this.trigger(e.name)
                    }))
                }
                pageLocationEvent(t) {
                    const e = this.conditions.filter((t => "visited_url" === t.type));
                    e && e.forEach((e => {
                        const s = a[e.operator];
                        s && s(t[1], e.value) && this.trigger(e.name)
                    }))
                }
                jsExceptionEvent(t) {
                    const e = [t[1], t[2], t[3]],
                        s = this.conditions.filter((t => "exception" === t.type));
                    s && s.forEach((t => {
                        const s = a[t.operator];
                        s && e.some((e => s(e, t.value))) && this.trigger(t.name)
                    }))
                }
            }
            const a = {
                    is: (t, e) => e.some((e => t.includes(e))),
                    isAny: () => !0,
                    isNot: (t, e) => !e.some((e => t.includes(e))),
                    contains: (t, e) => e.some((e => t.includes(e))),
                    notContains: (t, e) => !e.some((e => t.includes(e))),
                    startsWith: (t, e) => e.some((e => t.startsWith(e))),
                    endsWith: (t, e) => e.some((e => t.endsWith(e))),
                    greaterThan: (t, e) => t > e,
                    greaterOrEqual: (t, e) => t >= e,
                    lessOrEqual: (t, e) => t <= e,
                    lessThan: (t, e) => t < e
                },
                c = t => {
                    const e = {
                            on: "is",
                            notOn: "isNot",
                            ">": "greaterThan",
                            "<": "lessThan",
                            "=": "is",
                            "<=": "lessOrEqual",
                            ">=": "greaterOrEqual"
                        },
                        s = t => {
                            if (Object.keys(e).includes(t)) return e[t]
                        };
                    let i = {
                        type: "",
                        operator: "",
                        value: t.value,
                        key: ""
                    };
                    switch (t.type) {
                        case "click":
                            i = {
                                type: "click",
                                operator: s(t.operator),
                                value: t.value,
                                key: ""
                            };
                            break;
                        case "location":
                            i = {
                                type: "visited_url",
                                operator: t.operator,
                                value: t.value,
                                key: ""
                            };
                            break;
                        case "custom":
                            i = {
                                type: "custom_event",
                                operator: t.operator,
                                value: t.value,
                                key: ""
                            };
                            break;
                        case "metadata":
                            i = {
                                type: "featureFlag" === t.source ? "feature_flag" : t.type,
                                operator: t.operator,
                                value: t.value,
                                key: ""
                            };
                            break;
                        case "error":
                            i = {
                                type: "exception",
                                operator: t.operator,
                                value: t.value,
                                key: ""
                            };
                            break;
                        case "duration":
                            i = {
                                type: "session_duration",
                                value: t.value[0],
                                key: ""
                            };
                            break;
                        case "fetchUrl":
                            i = {
                                type: "network_request",
                                key: "url",
                                operator: t.operator,
                                value: t.value
                            };
                            break;
                        case "fetchStatusCode":
                            i = {
                                type: "network_request",
                                key: "status",
                                operator: s(t.operator),
                                value: t.value
                            };
                            break;
                        case "fetchMethod":
                            i = {
                                type: "network_request",
                                key: "method",
                                operator: s(t.operator),
                                value: t.value
                            };
                            break;
                        case "fetchDuration":
                            i = {
                                type: "network_request",
                                key: "duration",
                                operator: s(t.operator),
                                value: t.value
                            }
                    }
                    return i
                };
            class h {
                constructor(t) {
                    this.app = t, this.flags = [], this.storageKey = "__openreplay_flags";
                    const e = this.app.sessionStorage.getItem(this.storageKey);
                    if (e) {
                        const t = e.split(";").filter(Boolean);
                        this.flags = t.map((t => JSON.parse(t)))
                    }
                }
                getFeatureFlag(t) {
                    return this.flags.find((e => e.key === t))
                }
                isFlagEnabled(t) {
                    return -1 !== this.flags.findIndex((e => e.key === t))
                }
                onFlagsLoad(t) {
                    this.onFlagsCb = t
                }
                async reloadFlags(t) {
                    const e = this.app.sessionStorage.getItem(this.storageKey),
                        s = {};
                    e && e.split(";").filter(Boolean).forEach((t => {
                        const e = JSON.parse(t);
                        s[e.key] = {
                            key: e.key,
                            value: e.value
                        }
                    }));
                    const i = this.app.session.getInfo(),
                        n = this.app.session.userInfo,
                        r = {
                            projectID: i.projectID,
                            userID: i.userID,
                            metadata: i.metadata,
                            referrer: document.referrer,
                            os: n.userOS,
                            device: n.userDevice,
                            country: n.userCountry,
                            state: n.userState,
                            city: n.userCity,
                            browser: n.userBrowser,
                            persistFlags: s
                        },
                        o = t ? ? this.app.session.getSessionToken(),
                        a = await fetch(this.app.options.ingestPoint + "/v1/web/feature-flags", {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                                Authorization: `Bearer ${o}`
                            },
                            body: JSON.stringify(r)
                        });
                    if (200 === a.status) {
                        const t = await a.json();
                        return this.handleFlags(t.flags)
                    }
                }
                handleFlags(t) {
                    const e = [];
                    t.forEach((t => {
                        t.is_persist && e.push(t)
                    }));
                    let s = "";
                    return this.diffPersist(e).forEach((t => {
                        s += `${JSON.stringify(t)};`
                    })), this.app.sessionStorage.setItem(this.storageKey, s), this.flags = t, this.onFlagsCb ? .(t)
                }
                clearPersistFlags() {
                    this.app.sessionStorage.removeItem(this.storageKey)
                }
                diffPersist(t) {
                    const e = this.app.sessionStorage.getItem(this.storageKey);
                    if (!e) return t;
                    const s = e.split(";").filter(Boolean).map((t => JSON.parse(t)));
                    return t.filter((t => -1 === s.findIndex((e => e.key === t.key))))
                }
            }
            var l = s("ziTh");
            const u = {
                    htmlmasked: "hidden",
                    masked: "obscured"
                },
                d = !("undefined" == typeof window),
                p = d && navigator.userAgent.match(/firefox|fxios/i);
            let f = d ? Date.now() - performance.now() : 0;

            function g() {
                f = Date.now() - performance.now()
            }

            function m() {
                return f
            }
            const y = d && performance.now ? () => Math.round(performance.now() + f) : () => Date.now(),
                b = "repeat" in String.prototype ? t => "*".repeat(t.length) : t => t.replace(/./g, "*");

            function v(t) {
                return t.trim().replace(/\s+/g, " ")
            }

            function S(t) {
                return t.startsWith("https://") || t.startsWith("http://")
            }
            const w = "https://docs.openreplay.com",
                k = {};

            function T(t, e, s = "/") {
                k[t] || (l.warn(`OpenReplay: ${t} is deprecated. ${e?`Please, use ${e} instead.`:""} Visit ${w}${s} for more information.`), k[t] = !0)
            }

            function I(t) {
                let e = t.getAttribute("data-openreplay-label");
                return null !== e || (e = t.getAttribute("data-asayer-label"), null !== e && T('"data-asayer-label" attribute', '"data-openreplay-label" attribute', "/")), e
            }

            function x(t, e) {
                const s = `data-openreplay-${e}`;
                return !!t.hasAttribute(s) && (u[e] && T(`"${s}" attribute`, `"${u[e]}" attribute`, "/installation/sanitize-data"), !0)
            }

            function E(t) {
                return t.toString(16).padStart(2, "0")
            }

            function _(t) {
                return window.Zone && "__symbol__" in window.Zone ? window.Zone.__symbol__(t) : t
            }

            function C(t) {
                const e = _("MutationObserver");
                return new window[e](t)
            }

            function N(t, e, s, i) {
                const n = _("addEventListener");
                try {
                    t[n](e, s, i)
                } catch (t) {
                    const e = t.message;
                    l.debug(`Openreplay: ${e}; if this error is caused by an IframeObserver, ignore it`)
                }
            }

            function O(t, e, s, i) {
                const n = _("removeEventListener");
                try {
                    t[n](e, s, i)
                } catch (t) {
                    const e = t.message;
                    l.debug(`Openreplay: ${e}; if this error is caused by an IframeObserver, ignore it`)
                }
            }
            const R = new class {
                constructor() {
                    this.taskQueue = [], this.isRunning = !1
                }
                addTask(t) {
                    this.taskQueue.push(t), this.runTasks()
                }
                runTasks() {
                    if (this.isRunning || 0 === this.taskQueue.length) return;
                    this.isRunning = !0;
                    const t = () => {
                        if (0 === this.taskQueue.length) return void(this.isRunning = !1);
                        const e = this.taskQueue.shift();
                        Promise.resolve(e()).then((() => {
                            requestAnimationFrame((() => t()))
                        }))
                    };
                    t()
                }
            };

            function M(t, e) {
                const s = { ...t
                };
                for (const i in e)
                    if (e.hasOwnProperty(i)) {
                        const n = e[i],
                            r = t[i];
                        "object" != typeof n || Array.isArray(n) || null === n ? s[i] = n : s[i] = M(r || {}, n)
                    }
                return s
            }

            function D(t) {
                return [0, t]
            }

            function L(t, e) {
                return [13, t, e]
            }

            function A(t, e) {
                return [30, t, e]
            }

            function j(t, e, s, i) {
                return [57, t, e, s, i]
            }

            function F(t) {
                return [58, t]
            }

            function H(t, e, s, i) {
                return [60, t, e, s, i]
            }

            function B(t, e) {
                return [70, t, e]
            }

            function P(t, e, s) {
                return [71, t, e, s]
            }

            function z(t, e, s, i) {
                return [73, t, e, s, i]
            }

            function U(t, e) {
                return [75, t, e]
            }

            function q(t, e) {
                return [76, t, e]
            }

            function W(t, e) {
                return [77, t, e]
            }

            function $(t, e, s, i) {
                return [78, t, e, s, i]
            }

            function V(t, e, s, i, n, r, o, a, c) {
                return [83, t, e, s, i, n, r, o, a, c]
            }

            function X(t, e, s) {
                return [113, t, e, s]
            }

            function K(t, e, s, i, n, r, o, a, c, h) {
                return [116, t, e, s, i, n, r, o, a, c, h]
            }

            function J(t) {
                return [117, t]
            }

            function G(t) {
                return [118, t]
            }
            const Y = d && "performance" in window && "memory" in performance ? performance : {
                    memory: {}
                },
                Q = d ? 1024 * (navigator.deviceMemory || 0) : 0,
                Z = Y.memory.jsHeapSizeLimit || 0,
                tt = "__or__watched_tags__",
                et = {
                    position: "fixed",
                    top: 0,
                    left: 0,
                    width: "100vw",
                    height: "100vh",
                    background: "rgba(0, 0, 0, 0.40)",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    zIndex: 999999,
                    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"'
                },
                st = {
                    display: "flex",
                    flexDirection: "column",
                    gap: "2rem",
                    alignItems: "center",
                    padding: "1.5rem",
                    borderRadius: "2px",
                    border: "1px solid #D9D9D9",
                    background: "#FFF",
                    width: "22rem"
                },
                it = {
                    display: "flex",
                    "flex-direction": "column",
                    gap: "unset",
                    "align-items": "center",
                    padding: "unset",
                    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
                    "border-radius": "2px",
                    border: "1px solid #D9D9D9",
                    background: "rgba(255, 255, 255, 0.75)",
                    width: "22rem"
                },
                nt = {
                    fontFamily: "Verdana, sans-serif",
                    fontSize: "1.25rem",
                    fontStyle: "normal",
                    fontWeight: "500",
                    lineHeight: "1.75rem",
                    color: "rgba(0, 0, 0, 0.85)"
                },
                rt = {
                    borderTop: "1px solid rgba(0, 0, 0, 0.06)",
                    borderBottom: "1px solid rgba(0, 0, 0, 0.06)",
                    padding: "1.25rem 0rem",
                    color: "rgba(0, 0, 0, 0.85)",
                    fontFamily: "Verdana, sans-serif",
                    fontSize: "13px",
                    fontStyle: "normal",
                    fontWeight: "400",
                    lineHeight: "auto",
                    whiteSpace: "pre-wrap"
                },
                ot = {
                    display: "flex",
                    padding: "0.4rem 0.9375rem",
                    justifyContent: "center",
                    alignItems: "center",
                    gap: "0.625rem",
                    borderRadius: "0.25rem",
                    border: "1px solid #394EFF",
                    background: "#394EFF",
                    boxShadow: "0px 2px 0px 0px rgba(0, 0, 0, 0.04)",
                    color: "#FFF",
                    textAlign: "center",
                    fontFamily: "Verdana, sans-serif",
                    fontSize: "1rem",
                    fontStyle: "normal",
                    fontWeight: "500",
                    lineHeight: "1.5rem",
                    cursor: "pointer"
                },
                at = {
                    fontFamily: "Verdana, sans-serif",
                    fontSize: "13px",
                    fontWeight: "500",
                    lineHeight: "auto",
                    display: "flex",
                    justifyContent: "space-between",
                    width: "100%",
                    cursor: "pointer"
                },
                ct = {
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "flex-start",
                    gap: "0.625rem",
                    fontSize: "13px",
                    lineHeight: "auto"
                },
                ht = {
                    padding: "0.5rem",
                    gap: "0.5rem",
                    fontFamily: "Verdana, sans-serif",
                    fontSize: "16px",
                    fontStyle: "normal",
                    fontWeight: "500",
                    lineHeight: "auto",
                    color: "white",
                    display: "flex",
                    alignItems: "center",
                    width: "100%",
                    borderRadius: "2px",
                    background: "rgba(0, 0, 0, 0.75)",
                    boxSizing: "border-box"
                },
                lt = {
                    boxSizing: "border-box",
                    display: "block",
                    width: "100%",
                    borderBottom: "1px solid #D9D9D9",
                    background: "#FFF",
                    padding: "0.65rem",
                    alignSelf: "stretch",
                    color: "#000",
                    fontFamily: "Verdana, sans-serif",
                    fontStyle: "normal",
                    fontWeight: "400"
                },
                ut = { ...lt,
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    gap: "0.625rem"
                },
                dt = {
                    fontSize: "1.25rem",
                    fontWeight: "500",
                    cursor: "pointer",
                    color: "#394EFF"
                },
                pt = {
                    display: "flex",
                    padding: "0.4rem 0.9375rem",
                    justifyContent: "center",
                    alignItems: "center",
                    gap: "0.625rem",
                    borderRadius: "0.25rem",
                    border: "1px solid #394EFF",
                    background: "#394EFF",
                    boxShadow: "0px 2px 0px 0px rgba(0, 0, 0, 0.04)",
                    color: "#FFF",
                    textAlign: "center",
                    fontFamily: "Verdana, sans-serif",
                    fontSize: "1rem",
                    fontStyle: "normal",
                    fontWeight: "500",
                    lineHeight: "1.5rem",
                    width: "100%",
                    boxSizing: "border-box",
                    cursor: "pointer"
                },
                ft = {
                    marginTop: "1rem",
                    marginBottom: "1rem",
                    cursor: "pointer",
                    display: "block",
                    fontWeight: "500",
                    fontSize: "13px!important",
                    lineHeight: "auto"
                },
                gt = {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    gap: "1rem",
                    padding: "0.5rem",
                    width: "100%",
                    boxSizing: "border-box"
                },
                mt = {
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    justifyContent: "center",
                    borderRadius: "6.25em",
                    outline: "1px solid #394EFF",
                    fontSize: "13px",
                    height: "24px",
                    width: "24px"
                },
                yt = {
                    display: "flex",
                    flexDirection: "column",
                    alignItems: "center",
                    justifyContent: "center",
                    borderRadius: "6.25em",
                    outline: "1px solid #D2DFFF",
                    boxShadow: "0px 2px 0px 0px rgba(0, 0, 0, 0.04)",
                    background: "#D2DFFF",
                    fontSize: "13px",
                    height: "24px",
                    width: "24px"
                },
                bt = {
                    borderRadius: "0.375rem",
                    border: "1px solid rgba(0, 0, 0, 0.06)",
                    background: "#F5F7FF",
                    boxShadow: "0px 2px 0px 0px rgba(0, 0, 0, 0.04)",
                    display: "flex",
                    flexDirection: "column",
                    padding: "0.625rem 0.9375rem",
                    gap: "0.5rem",
                    alignSelf: "stretch"
                },
                vt = {
                    fontWeight: "bold"
                },
                St = {
                    fontSize: "13px",
                    lineHeight: "auto"
                },
                wt = {
                    marginRight: "0.5rem",
                    cursor: "pointer",
                    color: "#394EFF",
                    textAlign: "center",
                    fontFamily: "Verdana, sans-serif",
                    fontSize: "13px",
                    fontStyle: "normal",
                    fontWeight: "500",
                    lineHeight: "auto"
                },
                kt = { ...wt,
                    display: "flex",
                    padding: "0.25rem 0.9375rem",
                    justifyContent: "center",
                    alignItems: "center",
                    gap: "0.5rem",
                    borderRadius: "0.25rem",
                    border: "1px solid #394EFF"
                },
                Tt = {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    width: "100%",
                    boxSizing: "border-box"
                },
                It = {
                    border: "4px solid rgba(255, 255, 255, 0.4)",
                    width: "16px",
                    height: "16px",
                    borderRadius: "50%",
                    borderLeftColor: "#fff",
                    animation: "spin 0.5s linear infinite"
                };
            var xt = s("ziTh");
            const Et = {
                width: 1280,
                height: 720
            };
            class _t {
                constructor(t) {
                    this.app = t, this.mediaRecorder = null, this.recordedChunks = [], this.stream = null, this.recStartTs = null
                }
                async startRecording(t, e, s, i) {
                    this.recStartTs = this.app.timestamp();
                    const n = e;
                    try {
                        this.stream = await navigator.mediaDevices.getUserMedia({
                            video: !!i && { ...n,
                                frameRate: {
                                    ideal: t
                                }
                            },
                            audio: s
                        }), this.mediaRecorder = new MediaRecorder(this.stream, {
                            mimeType: "video/webm;codecs=vp9"
                        }), this.recordedChunks = [], this.mediaRecorder.ondataavailable = t => {
                            t.data.size > 0 && this.recordedChunks.push(t.data)
                        }, this.mediaRecorder.start()
                    } catch (t) {
                        xt.error(t)
                    }
                }
                async stopRecording() {
                    return new Promise((t => {
                        this.mediaRecorder && (this.mediaRecorder.onstop = () => {
                            const e = new Blob(this.recordedChunks, {
                                type: "video/webm"
                            });
                            t(e)
                        }, this.mediaRecorder.stop())
                    }))
                }
                async sendToAPI() {
                    const t = await this.stopRecording();
                    return fetch(`${this.app.options.ingestPoint}/v1/web/uxt/upload-url`, {
                        headers: {
                            Authorization: `Bearer ${this.app.session.getSessionToken()}`
                        }
                    }).then((t => {
                        if (t.ok) return t.json();
                        throw new Error("Failed to get upload url")
                    })).then((({
                        url: e
                    }) => fetch(e, {
                        method: "PUT",
                        headers: {
                            "Content-Type": "video/webm"
                        },
                        body: t
                    }))).catch(xt.error).finally((() => {
                        this.discard()
                    }))
                }
                async saveToFile(t = "recorded-video.webm") {
                    const e = await this.stopRecording(),
                        s = URL.createObjectURL(e),
                        i = document.createElement("a");
                    i.style.display = "none", i.href = s, i.download = t, document.body.appendChild(i), i.click(), window.URL.revokeObjectURL(s), document.body.removeChild(i)
                }
                discard() {
                    this.mediaRecorder ? .stop(), this.stream ? .getTracks().forEach((t => t.stop()))
                }
            }

            function Ct(t, e, s, i, n) {
                const r = document.createElement(t);
                return r.className = e, Object.assign(r.style, s), i && (r.textContent = i), n && (r.id = n), r
            }
            const Nt = "or_uxt_test_start",
                Ot = "or_uxt_task_index",
                Rt = "or_uxt_session_id";
            var Mt = s("ziTh");
            class Dt {
                constructor(t, e, s, i, n, r, o, a, c) {
                    this.ingestPoint = t, this.getTimestamp = e, this.token = s, this.testId = i, this.storageKey = n, this.setStorageKey = r, this.removeStorageKey = o, this.getStorageKey = a, this.getSessionId = c, this.durations = {
                        testStart: 0,
                        tasks: []
                    }, this.getDurations = () => this.durations, this.setDurations = t => {
                        this.durations.testStart = t.testStart, this.durations.tasks = t.tasks
                    }, this.signalTask = (t, e, s) => {
                        if (!t) return Mt.error("User Testing: No Task ID Given");
                        const i = this.durations.tasks.find((e => e.taskId === t)),
                            n = this.getTimestamp(),
                            r = i ? n - i.started : 0;
                        return fetch(`${this.ingestPoint}/v1/web/uxt/signals/task`, {
                            method: "POST",
                            headers: {
                                Authorization: `Bearer ${this.token}`
                            },
                            body: JSON.stringify({
                                testId: this.testId,
                                taskId: t,
                                status: e,
                                duration: r,
                                timestamp: n,
                                taskAnswer: s
                            })
                        })
                    }, this.signalTest = t => {
                        const e = this.getTimestamp();
                        if ("begin" === t && this.testId) {
                            const t = this.getSessionId();
                            this.setStorageKey(Rt, t), this.setStorageKey(this.storageKey, this.testId.toString()), this.setStorageKey(Nt, e.toString())
                        } else this.removeStorageKey(this.storageKey), this.removeStorageKey(Ot), this.removeStorageKey(Nt);
                        const s = e - (this.durations.testStart || e);
                        return fetch(`${this.ingestPoint}/v1/web/uxt/signals/test`, {
                            method: "POST",
                            headers: {
                                Authorization: `Bearer ${this.token}`
                            },
                            body: JSON.stringify({
                                testId: this.testId,
                                status: t,
                                duration: s,
                                timestamp: e
                            })
                        })
                    };
                    const h = this.getStorageKey(Nt);
                    h && (this.durations.testStart = parseInt(h, 10))
                }
            }
            var Lt = s("ziTh");
            class At {
                constructor(t, e) {
                    this.app = t, this.storageKey = e, this.bg = Ct("div", "bg", et, void 0, "__or_ut_bg"), this.container = Ct("div", "container", st, void 0, "__or_ut_ct"), this.widgetGuidelinesVisible = !0, this.widgetTasksVisible = !1, this.widgetVisible = !0, this.isActive = !1, this.descriptionSection = null, this.taskSection = null, this.endSection = null, this.stopButton = null, this.stopButtonContainer = null, this.test = null, this.testId = null, this.signalManager = null, this.getTest = (t, e, s) => {
                        this.testId = t;
                        const i = this.app.options.ingestPoint;
                        return fetch(`${i}/v1/web/uxt/test/${t}`, {
                            headers: {
                                Authorization: `Bearer ${e}`
                            }
                        }).then((t => t.json())).then((({
                            test: i
                        }) => {
                            this.isActive = !0, this.test = i, this.signalManager = new Dt(this.app.options.ingestPoint, (() => this.app.timestamp()), e, t, this.storageKey, ((t, e) => this.app.localStorage.setItem(t, e)), (t => this.app.localStorage.removeItem(t)), (t => this.app.localStorage.getItem(t)), (() => this.app.getSessionID())), this.createGreeting(i.title, i.reqMic, i.reqCamera), s && ((i.reqMic || i.reqCamera) && this.userRecorder.startRecording(30, Et, i.reqMic, i.reqCamera), this.showWidget(i.description, i.tasks, !0), this.showTaskSection())
                        })).then((() => t)).catch((t => {
                            Lt.log("OR: Error fetching test", t)
                        }))
                    }, this.hideTaskSection = () => !1, this.showTaskSection = () => !0, this.collapseWidget = () => !1, this.removeGreeting = () => !1, this.toggleDescriptionVisibility = () => {}, this.currentTaskIndex = 0, this.userRecorder = new _t(t), this.app.getSessionID() !== this.app.localStorage.getItem(Rt) && (this.app.localStorage.removeItem(this.storageKey), this.app.localStorage.removeItem(Rt), this.app.localStorage.removeItem("or_uxt_test_id"), this.app.localStorage.removeItem(Ot), this.app.localStorage.removeItem(Nt));
                    const s = this.app.localStorage.getItem(Ot);
                    s && (this.currentTaskIndex = parseInt(s, 10))
                }
                getTestId() {
                    return this.testId
                }
                createGreeting(t, e, s) {
                    const i = Ct("div", "title", nt, t),
                        n = Ct("div", "description", rt, "Welcome, you're here to help us improve, not to be judged. Your insights matter!\n\n📹 We're recording this browser tab to learn from your experience.\n🎤 Please enable mic and camera if asked, to give us a complete picture."),
                        r = Ct("div", "button", ot, "Read guidelines to begin");
                    this.removeGreeting = () => ((e || s) && this.userRecorder.startRecording(30, Et, e, s), this.container.removeChild(r), this.container.removeChild(n), this.container.removeChild(i), !1), r.onclick = () => {
                        this.removeGreeting();
                        const t = this.signalManager ? .getDurations();
                        t && this.signalManager && (t.testStart = this.app.timestamp(), this.signalManager.setDurations(t)), this.signalManager ? .signalTest("begin"), this.container.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"', Object.assign(this.container.style, it), this.showWidget(this.test ? .guidelines || "", this.test ? .tasks || [])
                    }, this.container.append(i, n, r), this.bg.appendChild(this.container), document.body.appendChild(this.bg)
                }
                showWidget(t, e, s) {
                    this.container.innerHTML = "", Object.assign(this.bg.style, {
                        position: "fixed",
                        zIndex: 99999999999999,
                        right: "8px",
                        left: "unset",
                        width: "fit-content",
                        top: "8px",
                        height: "fit-content",
                        background: "unset",
                        display: "unset",
                        alignItems: "unset",
                        justifyContent: "unset"
                    });
                    const i = this.createTitleSection();
                    this.container.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"', Object.assign(this.container.style, it);
                    const n = this.createDescriptionSection(t),
                        r = this.createTasksSection(e),
                        o = Ct("div", "stop_bn_or", ft, "Abort Session"),
                        a = Ct("div", "stop_ct_or", {
                            fontSize: "13px!important"
                        });
                    a.style.fontSize = "13px", a.append(o), this.container.append(i, n, r, a), this.taskSection = r, this.descriptionSection = n, this.stopButton = o, this.stopButtonContainer = a, o.onclick = () => {
                        this.userRecorder.discard(), this.signalManager ? .signalTest("skipped"), document.body.removeChild(this.bg), window.close()
                    }, s ? this.toggleDescriptionVisibility() : this.hideTaskSection()
                }
                createTitleSection() {
                    const t = Ct("div", "title", ht),
                        e = function() {
                            const t = document.createElement("div");
                            t.className = "grid";
                            for (let e = 0; e < 16; e++) {
                                const e = document.createElement("div");
                                Object.assign(e.style, {
                                    width: "2px",
                                    height: "2px",
                                    borderRadius: "10px",
                                    background: "white"
                                }), e.className = "cell", t.appendChild(e)
                            }
                            return Object.assign(t.style, {
                                display: "grid",
                                gridTemplateColumns: "repeat(4, 1fr)",
                                gridTemplateRows: "repeat(4, 1fr)",
                                gap: "2px",
                                cursor: "grab"
                            }), t
                        }(),
                        s = Ct("div", "title_text", {
                            maxWidth: "19rem",
                            overflow: "hidden",
                            textOverflow: "ellipsis",
                            width: "100%",
                            fontSize: 16,
                            lineHeight: "auto",
                            cursor: "pointer"
                        }, this.test ? .title),
                        i = function() {
                            const t = document.createElement("div");
                            Object.assign(t.style, {
                                width: "0",
                                height: "0",
                                borderLeft: "7px solid transparent",
                                borderRight: "7px solid transparent",
                                borderBottom: "7px solid white"
                            });
                            const e = document.createElement("div");
                            return e.appendChild(t), Object.assign(e.style, {
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                width: "16px",
                                height: "16px",
                                cursor: "pointer",
                                marginLeft: "auto",
                                transform: "rotate(180deg)"
                            }), e
                        }();
                    t.append(e, s, i);
                    const n = t => (this.widgetVisible = t, this.container.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"', Object.assign(this.container.style, this.widgetVisible ? it : {
                            border: "none",
                            background: "none",
                            padding: 0
                        }), this.taskSection && Object.assign(this.taskSection.style, this.widgetVisible ? lt : {
                            display: "none"
                        }), this.descriptionSection && Object.assign(this.descriptionSection.style, this.widgetVisible ? lt : {
                            display: "none"
                        }), this.endSection && Object.assign(this.endSection.style, this.widgetVisible ? lt : {
                            display: "none"
                        }), this.stopButton && Object.assign(this.stopButton.style, this.widgetVisible ? ft : {
                            display: "none"
                        }), t),
                        r = () => {
                            Object.assign(i.style, {
                                transform: this.widgetVisible ? "rotate(0deg)" : "rotate(180deg)"
                            }), n(!this.widgetVisible)
                        };
                    var o, a;
                    return s.onclick = r, i.onclick = r, o = this.bg, (a = e).onmousedown = function(t) {
                        const e = o.getBoundingClientRect(),
                            s = t.clientX - e.left,
                            i = t.clientY - e.top;

                        function n(t, n) {
                            let r = t - s,
                                a = n - i;
                            r <= 5 && (r = 5), a <= 5 && (a = 5), r >= window.innerWidth - e.width && (r = window.innerWidth - e.width), a >= window.innerHeight - e.height && (a = window.innerHeight - e.height), o.style.left = `${r}px`, o.style.top = `${a}px`
                        }

                        function r(t) {
                            n(t.pageX, t.pageY)
                        }
                        o.style.position = "fixed", o.style.zIndex = 99999999999999, n(t.pageX, t.pageY), document.addEventListener("mousemove", r);
                        const a = () => {
                            document.removeEventListener("mousemove", r), document.removeEventListener("mouseup", a)
                        };
                        document.addEventListener("mouseup", a)
                    }, a.ondragstart = function() {
                        return !1
                    }, this.collapseWidget = () => n(!1), t
                }
                createDescriptionSection(t) {
                    const e = Ct("div", "description_section_or", lt),
                        s = Ct("div", "description_s_title_or", at),
                        i = Ct("div", "title", {
                            fontSize: 13,
                            fontWeight: 500,
                            lineHeight: "auto"
                        }, "Introduction & Guidelines"),
                        n = Ct("div", "icon", dt, "-"),
                        r = Ct("div", "content", ct),
                        o = Ct("div", "text_description", {
                            maxHeight: "250px",
                            overflowY: "auto",
                            whiteSpace: "pre-wrap",
                            fontSize: 13,
                            color: "#454545",
                            lineHeight: "auto"
                        });
                    o.innerHTML = t;
                    const a = Ct("div", "button_begin_or", pt, "Begin Test");
                    s.append(i, n), r.append(o, a), e.append(s, r);
                    const c = () => {
                        this.widgetGuidelinesVisible = !this.widgetGuidelinesVisible, n.textContent = this.widgetGuidelinesVisible ? "-" : "+", Object.assign(r.style, this.widgetGuidelinesVisible ? ct : {
                            display: "none"
                        })
                    };
                    return s.onclick = c, this.toggleDescriptionVisibility = () => {
                        this.widgetGuidelinesVisible = !1, n.textContent = this.widgetGuidelinesVisible ? "-" : "+", Object.assign(r.style, this.widgetGuidelinesVisible ? ct : {
                            display: "none"
                        }), r.removeChild(a)
                    }, a.onclick = () => {
                        if (c(), this.test) {
                            const t = this.signalManager ? .getDurations(),
                                e = t ? t.tasks.findIndex((t => this.test && t.taskId === this.test.tasks[0].task_id)) : null;
                            t && -1 === e && (t.tasks.push({
                                taskId: this.test.tasks[0].task_id,
                                started: this.app.timestamp()
                            }), this.signalManager ? .setDurations(t)), this.signalManager ? .signalTask(this.test.tasks[0].task_id, "begin")
                        }
                        this.showTaskSection(), r.removeChild(a)
                    }, e
                }
                createTasksSection(t) {
                    this.container.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"', Object.assign(this.container.style, it);
                    const e = Ct("div", "task_section_or", lt),
                        s = Ct("div", "description_t_title_or", at),
                        i = Ct("div", "title", {
                            fontSize: "13px",
                            fontWeight: "500",
                            lineHeight: "auto"
                        }, "Tasks"),
                        n = Ct("div", "icon", dt, "-"),
                        r = Ct("div", "content", ct),
                        o = Ct("div", "pagination", gt),
                        a = Ct("div", "taskCard", bt),
                        c = Ct("div", "taskText", vt),
                        h = Ct("div", "taskDescription", St),
                        l = Ct("div", "taskButtons", Tt),
                        u = Ct("div", "taskText", vt);
                    u.textContent = "Your answer";
                    const d = Ct("textarea", "taskDescription", {
                            resize: "vertical"
                        }),
                        p = Ct("div", "inputArea", bt);
                    p.append(u, d);
                    const f = Ct("div", "closePanelButton", wt, "Collapse Panel"),
                        g = Ct("div", "nextButton", kt, "Done, Next");
                    s.append(i, n), a.append(c, h), l.append(f, g), r.append(o, a, p, l), e.append(s, r);
                    const m = () => {
                        const e = t[this.currentTaskIndex];
                        c.textContent = e.title, h.textContent = e.description, e.allow_typing ? p.style.display = "flex" : p.style.display = "none"
                    };
                    t.forEach(((t, e) => {
                        const s = Ct("span", `or_task_${e}`, {
                            outline: "1px solid #efefef",
                            fontSize: "13px",
                            height: "24px",
                            width: "24px",
                            display: "flex",
                            flexDirection: "column",
                            alignItems: "center",
                            justifyContent: "center",
                            borderRadius: "6.25em"
                        }, (e + 1).toString());
                        s.id = `or_task_${e}`, o.append(s)
                    })), this.hideTaskSection = () => (n.textContent = "+", Object.assign(r.style, {
                        display: "none"
                    }), this.widgetTasksVisible = !1, !1), this.showTaskSection = () => (n.textContent = "-", Object.assign(r.style, ct), this.widgetTasksVisible = !0, !0);
                    const y = () => {
                        const t = document.getElementById(`or_task_${this.currentTaskIndex}`);
                        t && Object.assign(t.style, mt);
                        for (let t = 0; t < this.currentTaskIndex; t++) {
                            const e = document.getElementById(`or_task_${t}`);
                            e && Object.assign(e.style, yt)
                        }
                    };
                    return s.onclick = () => {
                        this.widgetTasksVisible = !this.widgetTasksVisible, n.textContent = this.widgetTasksVisible ? "-" : "+", Object.assign(r.style, this.widgetTasksVisible ? ct : {
                            display: "none"
                        })
                    }, f.onclick = this.collapseWidget, g.onclick = () => {
                        const e = t[this.currentTaskIndex].allow_typing ? d.value : void 0;
                        if (d.value = "", this.signalManager ? .signalTask(t[this.currentTaskIndex].task_id, "done", e), this.currentTaskIndex < t.length - 1) {
                            this.currentTaskIndex++, m();
                            const e = this.signalManager ? .getDurations();
                            e && -1 === e.tasks.findIndex((e => e.taskId === t[this.currentTaskIndex].task_id)) && (e.tasks.push({
                                taskId: t[this.currentTaskIndex].task_id,
                                started: this.app.timestamp()
                            }), this.signalManager ? .setDurations(e)), this.signalManager ? .signalTask(t[this.currentTaskIndex].task_id, "begin"), y()
                        } else this.showEndSection();
                        this.app.localStorage.setItem("or_uxt_task_index", this.currentTaskIndex.toString())
                    }, setTimeout((() => {
                        const t = document.getElementById("or_task_0");
                        t && Object.assign(t.style, mt), m(), y()
                    }), 1), e
                }
                showEndSection() {
                    let t = !0;
                    this.signalManager ? .signalTest("done");
                    const e = Ct("div", "end_section_or", ut),
                        s = Ct("div", "end_title_or", {
                            fontSize: "1.25rem",
                            fontWeight: "500"
                        }, "Thank you! 👍"),
                        i = Ct("div", "end_description_or", {}, this.test ? .conclusion ? ? "Thank you for participating in our usability test. Your feedback has been captured and will be used to enhance our website. \n\nWe appreciate your time and valuable input."),
                        n = Ct("div", "end_button_or", pt, "Submitting Feedback"),
                        r = function() {
                            ! function() {
                                const t = document.createElement("style");
                                t.type = "text/css", t.innerText = "@keyframes spin {\n        0% { transform: rotate(0deg); }\n        100% { transform: rotate(360deg); }\n    }", document.head.appendChild(t)
                            }();
                            const t = document.createElement("div");
                            return t.classList.add("spinner"), Object.assign(t.style, It), t
                        }();
                    n.appendChild(r), this.test ? .reqMic || this.test ? .reqCamera ? this.userRecorder.sendToAPI().then((() => {
                        n.removeChild(r), n.textContent = "End Session", t = !1
                    })).catch((e => {
                        Lt.error(e), n.removeChild(r), n.textContent = "End Session", t = !1
                    })) : (n.removeChild(r), n.textContent = "End Session", t = !1), this.taskSection && this.container.removeChild(this.taskSection), this.descriptionSection && this.container.removeChild(this.descriptionSection), this.stopButton && this.stopButtonContainer && this.container.removeChild(this.stopButtonContainer), n.onclick = () => {
                        t || (window.close(), document.body.removeChild(this.bg))
                    }, e.append(s, i, n), this.endSection = e, this.container.append(e)
                }
            }

            function jt(t) {
                return !!t && null != t.nodeType
            }

            function Ft(t) {
                return "http://www.w3.org/2000/svg" === t.namespaceURI
            }

            function Ht(t) {
                return t.nodeType === Node.ELEMENT_NODE
            }

            function Bt(t) {
                return t.nodeType === Node.TEXT_NODE
            }

            function Pt(t) {
                return t.nodeType === Node.DOCUMENT_NODE
            }

            function zt(t) {
                return t.nodeType === Node.DOCUMENT_NODE || t.nodeType === Node.DOCUMENT_FRAGMENT_NODE
            }

            function Ut(t, e) {
                return t.localName === e
            }
            const qt = {
                low: .35,
                medium: .55,
                high: .8
            };
            var Wt = s("ziTh");
            class $t {
                constructor(t = 0) {
                    this.shouldLog = t => this.level >= t, this.log = (...t) => {
                        this.shouldLog(4) && Wt.log(...t)
                    }, this.warn = (...t) => {
                        this.shouldLog(3) && Wt.warn(...t)
                    }, this.error = (...t) => {
                        this.shouldLog(2) && Wt.error(...t)
                    }, this.level = t
                }
            }
            class Vt {
                constructor(t) {
                    this.node_id = t, this.nodes = [], this.totalNodeAmount = 0, this.nodeCallbacks = [], this.elementListeners = new Map, this.nextNodeId = 0, this.scanTree = t => {
                        this.nodes.forEach((e => t(e)))
                    }
                }
                syntheticMode(t) {
                    const e = 99999999 * t;
                    if (e > 9007199254740900) throw new Error("Placeholder id overflow");
                    this.nextNodeId = e
                }
                attachNodeCallback(t) {
                    this.nodeCallbacks.push(t)
                }
                attachNodeListener(t, e, s, i = !0) {
                    const n = this.getID(t);
                    if (void 0 === n) return;
                    N(t, e, s, i);
                    let r = this.elementListeners.get(n);
                    void 0 === r && (r = [], this.elementListeners.set(n, r)), r.push([e, s, i])
                }
                registerNode(t) {
                    let e = t[this.node_id];
                    const s = void 0 === e;
                    return s && (e = this.nextNodeId, this.totalNodeAmount++, this.nextNodeId++, this.nodes[e] = t, t[this.node_id] = e), [e, s]
                }
                unregisterNode(t) {
                    const e = t[this.node_id];
                    if (void 0 !== e) {
                        t[this.node_id] = void 0, delete t[this.node_id], delete this.nodes[e];
                        const s = this.elementListeners.get(e);
                        void 0 !== s && (this.elementListeners.delete(e), s.forEach((e => O(t, e[0], e[1], e[2])))), this.totalNodeAmount--
                    }
                    return e
                }
                cleanTree() {
                    for (let t = 0; t < this.nodes.length; t++) {
                        const e = this.nodes[t];
                        e && !document.contains(e) && this.unregisterNode(e)
                    }
                }
                callNodeCallbacks(t, e) {
                    this.nodeCallbacks.forEach((s => s(t, e)))
                }
                getID(t) {
                    if (t) return t[this.node_id]
                }
                getNode(t) {
                    return this.nodes[t]
                }
                getNodeCount() {
                    return this.totalNodeAmount
                }
                clear() {
                    for (let t = 0; t < this.nodes.length; t++) {
                        const e = this.nodes[t];
                        e && this.unregisterNode(e)
                    }
                    this.nextNodeId = 0, this.nodes.length = 0
                }
            }

            function Xt(t) {
                if (function(t) {
                        return t.nodeType === Node.COMMENT_NODE
                    }(t)) return !0;
                if (Bt(t)) return !1;
                if (!Ht(t)) return !0;
                const e = t.tagName.toUpperCase();
                if ("LINK" === e) {
                    const e = t.getAttribute("rel"),
                        s = t.getAttribute("as");
                    return !(e ? .includes("stylesheet") || "style" === s || "font" === s)
                }
                return "SCRIPT" === e || "NOSCRIPT" === e || "META" === e || "TITLE" === e || "BASE" === e
            }

            function Kt(t) {
                return !!zt(t) || !Xt(t)
            }
            var Jt;
            ! function(t) {
                t[t.New = 0] = "New", t[t.Removed = 1] = "Removed", t[t.Changed = 2] = "Changed"
            }(Jt || (Jt = {}));
            class Gt {
                constructor(t, e = !1) {
                    this.app = t, this.isTopContext = e, this.commited = [], this.recents = new Map, this.indexes = [], this.attributesMap = new Map, this.textSet = new Set, this.observer = C(this.app.safe((t => {
                        for (const e of t) {
                            const t = e.target,
                                s = e.type;
                            if (!Kt(t)) continue;
                            if ("childList" === s) {
                                for (let t = 0; t < e.removedNodes.length; t++) Kt(e.removedNodes[t]) && this.bindNode(e.removedNodes[t]);
                                for (let t = 0; t < e.addedNodes.length; t++) this.bindTree(e.addedNodes[t]);
                                continue
                            }
                            const i = this.app.nodes.getID(t);
                            if (void 0 !== i)
                                if (this.recents.has(i) || this.recents.set(i, Jt.Changed), "attributes" !== s) "characterData" !== s || this.textSet.add(i);
                                else {
                                    const t = e.attributeName;
                                    if (null === t) continue;
                                    let s = this.attributesMap.get(i);
                                    void 0 === s && this.attributesMap.set(i, s = new Set), s.add(t)
                                }
                        }
                        this.commitNodes()
                    })))
                }
                clear() {
                    this.commited.length = 0, this.recents.clear(), this.indexes.length = 1, this.attributesMap.clear(), this.textSet.clear()
                }
                sendNodeAttribute(t, e, s, i) {
                    if (Ft(e)) return "xlink:" === s.substr(0, 6) && (s = s.substr(6)), void(null === i ? this.app.send(L(t, s)) : "href" === s ? (i.length > 1e5 && (i = ""), this.app.send(H(t, s, i, this.app.getBaseHref()))) : this.app.attributeSender.sendSetAttribute(t, s, i));
                    "src" !== s && "srcset" !== s && "integrity" !== s && "crossorigin" !== s && "autocomplete" !== s && "on" !== s.substr(0, 2) && ("value" === s && Ut(e, "input") && "button" !== e.type && "reset" !== e.type && "submit" !== e.type || (null !== i ? "style" === s || "href" === s && Ut(e, "link") ? this.app.send(H(t, s, i, this.app.getBaseHref())) : (("href" === s || i.length > 1e5) && (i = ""), this.app.attributeSender.sendSetAttribute(t, s, i)) : this.app.send(L(t, s))))
                }
                sendNodeData(t, e, s) {
                    Ut(e, "style") ? this.app.send(function(t, e, s) {
                        return [61, t, e, s]
                    }(t, s, this.app.getBaseHref())) : (s = this.app.sanitizer.sanitize(t, s), this.app.send(function(t, e) {
                        return [14, t, e]
                    }(t, s)))
                }
                bindNode(t) {
                    const [e, s] = this.app.nodes.registerNode(t);
                    s ? this.recents.set(e, Jt.New) : this.recents.get(e) !== Jt.New && this.recents.set(e, Jt.Removed)
                }
                bindTree(t) {
                    if (!Kt(t)) return;
                    this.bindNode(t);
                    const e = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT, {
                        acceptNode: t => (void 0 !== this.app.nodes.getID(t) && this.app.debug.error("! Node is already bound", t), Xt(t) || void 0 !== this.app.nodes.getID(t) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT)
                    }, !1);
                    for (; e.nextNode();) this.bindNode(e.currentNode)
                }
                unbindTree(t) {
                    const e = this.app.nodes.unregisterNode(t);
                    if (void 0 !== e && this.recents.get(e) === Jt.Removed) {
                        this.app.send(function(t) {
                            return [11, t]
                        }(e));
                        const s = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT, {
                            acceptNode: t => Xt(t) || void 0 === this.app.nodes.getID(t) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT
                        }, !1);
                        let i = 0;
                        const n = this.app.nodes.getNodeCount();
                        for (; s.nextNode();) i += 1, this.app.nodes.unregisterNode(s.currentNode);
                        const r = Math.floor(i / n * 100);
                        r > 30 && this.app.send([115, r])
                    }
                }
                _commitNode(t, e) {
                    if (zt(e)) return !0;
                    const s = e.parentNode;
                    let i;
                    if (!Ut(e, "html") || !this.isTopContext) {
                        if (null === s) return this.unbindTree(e), !1;
                        if (i = this.app.nodes.getID(s), void 0 === i) return this.unbindTree(e), !1;
                        if (!this.commitNode(i)) return this.unbindTree(e), !1;
                        if (this.app.sanitizer.handleNode(t, i, e), this.app.sanitizer.isHidden(i)) return !1
                    }
                    let n = e.previousSibling;
                    for (; null !== n;) {
                        const e = this.app.nodes.getID(n);
                        if (void 0 !== e) {
                            this.commitNode(e), this.indexes[t] = this.indexes[e] + 1;
                            break
                        }
                        n = n.previousSibling
                    }
                    null === n && (this.indexes[t] = 0);
                    const r = this.recents.get(t),
                        o = r === Jt.New,
                        a = this.indexes[t];
                    if (void 0 === a) throw "commitNode: missing node index";
                    if (o) {
                        if (Ht(e)) {
                            let s = e;
                            if (void 0 !== i) {
                                if (this.app.sanitizer.isHidden(t)) {
                                    const t = s.clientWidth,
                                        i = s.clientHeight;
                                    s = e.cloneNode(), s.style.width = `${t}px`, s.style.height = `${i}px`
                                }
                                this.app.send(function(t, e, s, i, n) {
                                    return [8, t, e, s, i, n]
                                }(t, i, a, s.tagName, Ft(e)))
                            }
                            for (let e = 0; e < s.attributes.length; e++) {
                                const i = s.attributes[e];
                                this.sendNodeAttribute(t, s, i.nodeName, i.value)
                            }
                        } else Bt(e) && (this.app.send(function(t, e, s) {
                            return [9, t, e, s]
                        }(t, i, a)), this.sendNodeData(t, s, e.data));
                        return !0
                    }
                    r === Jt.Removed && void 0 !== i && this.app.send(function(t, e, s) {
                        return [10, t, e, s]
                    }(t, i, a));
                    const c = this.attributesMap.get(t);
                    if (void 0 !== c) {
                        if (!Ht(e)) throw "commitNode: node is not an element";
                        for (const s of c) this.sendNodeAttribute(t, e, s, e.getAttribute(s))
                    }
                    if (this.textSet.has(t)) {
                        if (!Bt(e)) throw "commitNode: node is not a text";
                        this.sendNodeData(t, s, e.data)
                    }
                    return !0
                }
                commitNode(t) {
                    const e = this.app.nodes.getNode(t);
                    if (void 0 === e) return !1;
                    const s = this.commited[t];
                    return void 0 !== s ? s : this.commited[t] = this._commitNode(t, e)
                }
                commitNodes(t = !1) {
                    let e;
                    this.recents.forEach(((s, i) => {
                        this.commitNode(i), s === Jt.New && (e = this.app.nodes.getNode(i)) && this.app.nodes.callNodeCallbacks(e, t)
                    })), this.clear()
                }
                observeRoot(t, e, s = t) {
                    this.observer.observe(t, {
                        childList: !0,
                        attributes: !0,
                        characterData: !0,
                        subtree: !0,
                        attributeOldValue: !1,
                        characterDataOldValue: !1
                    }), this.bindTree(s), e(this.app.nodes.getID(t)), this.commitNodes(!0)
                }
                disconnect() {
                    this.observer.disconnect(), this.clear()
                }
            }
            class Yt extends Gt {
                observe(t) {
                    const e = t.contentDocument,
                        s = this.app.nodes.getID(t);
                    e && void 0 !== s && this.observeRoot(e, (t => {
                        void 0 !== t ? this.app.send(B(s, t)) : this.app.debug.log("OpenReplay: Iframe document not bound")
                    }))
                }
                syntheticObserve(t, e) {
                    this.observeRoot(e, (e => {
                        void 0 !== e ? this.app.send(B(t, e)) : this.app.debug.log("OpenReplay: Iframe document not bound")
                    }))
                }
            }
            class Qt extends Gt {
                observe(t) {
                    const e = t.shadowRoot,
                        s = this.app.nodes.getID(t);
                    e && void 0 !== s && this.observeRoot(e, (t => {
                        void 0 !== t ? this.app.send(B(s, t)) : this.app.debug.error("OpenReplay: Shadow Root was not bound")
                    }))
                }
            }
            class Zt {
                constructor() {
                    this.states = new Map
                }
                calcOffset(t) {
                    let e = 0,
                        s = 0;
                    if (t.parent && ([e, s] = this.calcOffset(t.parent)), !t.offset) {
                        const {
                            left: e,
                            top: s
                        } = t.iFrame.getBoundingClientRect();
                        t.offset = [e, s]
                    }
                    const [i, n] = t.offset;
                    return [e + i, s + n]
                }
                getDocumentOffset(t) {
                    const e = this.states.get(t);
                    return e ? this.calcOffset(e) : [0, 0]
                }
                observe(t) {
                    const e = t.contentDocument;
                    if (!e) return;
                    const s = t.ownerDocument,
                        i = {
                            offset: null,
                            iFrame: t,
                            parent: this.states.get(s) || null,
                            clear: () => {
                                s.removeEventListener("scroll", n), s.defaultView ? .removeEventListener("resize", n)
                            }
                        },
                        n = () => {
                            i.offset = null
                        };
                    s.addEventListener("scroll", n), s.defaultView ? .addEventListener("resize", n), this.states.set(e, i)
                }
                clear() {
                    this.states.forEach((t => t.clear())), this.states.clear()
                }
            }
            const te = d ? Element.prototype.attachShadow : () => new ShadowRoot;
            class ee extends Gt {
                constructor(t, e) {
                    super(t, !0), this.iframeOffsets = new Zt, this.contextCallbacks = [], this.contextsSet = new Set, this.iframeObservers = [], this.shadowRootObservers = [], this.options = Object.assign({
                        captureIFrames: !0
                    }, e), this.app.nodes.attachNodeCallback((t => {
                        Ut(t, "iframe") && (this.options.captureIFrames && !x(t, "obscured") || x(t, "capture")) && this.handleIframe(t)
                    })), this.app.nodes.attachNodeCallback((t => {
                        Ht(t) && null !== t.shadowRoot && this.handleShadowRoot(t.shadowRoot)
                    }))
                }
                attachContextCallback(t) {
                    this.contextCallbacks.push(t)
                }
                getDocumentOffset(t) {
                    return this.iframeOffsets.getDocumentOffset(t)
                }
                handleIframe(t) {
                    let e = null;
                    const s = this.app.safe((() => setTimeout((() => {
                        if (void 0 === this.app.nodes.getID(t)) return;
                        if (! function(t) {
                                try {
                                    return Boolean(t.contentDocument)
                                } catch (t) {
                                    return !1
                                }
                            }(t)) return;
                        const s = t.contentWindow,
                            i = t.contentDocument;
                        if (i && i !== e) {
                            const s = new Yt(this.app);
                            this.iframeObservers.push(s), s.observe(t), e = i, this.iframeOffsets.observe(t)
                        }
                        s && s === s.window && !this.contextsSet.has(s) && (this.contextsSet.add(s), this.contextCallbacks.forEach((t => t(s))))
                    }), 100)));
                    t.addEventListener("load", s), s()
                }
                handleShadowRoot(t) {
                    const e = new Qt(this.app);
                    this.shadowRootObservers.push(e), e.observe(t.host)
                }
                observe() {
                    const t = this;
                    Element.prototype.attachShadow = function() {
                        const e = te.apply(this, arguments);
                        return t.handleShadowRoot(e), e
                    }, this.app.nodes.clear(), this.observeRoot(window.document, (() => {
                        this.app.send([7]), this.app.nodes.callNodeCallbacks(document, !0)
                    }), window.document.documentElement)
                }
                crossdomainObserve(t, e) {
                    const s = this;
                    Element.prototype.attachShadow = function() {
                        const t = te.apply(this, arguments);
                        return s.handleShadowRoot(t), t
                    }, this.app.nodes.clear(), this.app.nodes.syntheticMode(e);
                    const i = new Yt(this.app);
                    this.iframeObservers.push(i), i.syntheticObserve(t, window.document)
                }
                disconnect() {
                    this.iframeOffsets.clear(), Element.prototype.attachShadow = te, this.iframeObservers.forEach((t => t.disconnect())), this.iframeObservers = [], this.shadowRootObservers.forEach((t => t.disconnect())), this.shadowRootObservers = [], super.disconnect()
                }
            }
            var se;
            ! function(t) {
                t[t.Plain = 0] = "Plain", t[t.Obscured = 1] = "Obscured", t[t.Hidden = 2] = "Hidden"
            }(se || (se = {}));
            class ie {
                constructor(t, e) {
                    this.app = t, this.obscured = new Set, this.hidden = new Set, this.options = Object.assign({
                        obscureTextEmails: !0,
                        obscureTextNumbers: !1
                    }, e)
                }
                handleNode(t, e, s) {
                    if ((this.obscured.has(e) || Ht(s) && (x(s, "masked") || x(s, "obscured"))) && this.obscured.add(t), (this.hidden.has(e) || Ht(s) && (x(s, "htmlmasked") || x(s, "hidden"))) && this.hidden.add(t), void 0 !== this.options.domSanitizer && Ht(s)) {
                        const e = this.options.domSanitizer(s);
                        e === se.Obscured && this.obscured.add(t), e === se.Hidden && this.hidden.add(t)
                    }
                }
                sanitize(t, e) {
                    return this.obscured.has(t) ? (t => t.trim().replace(/[^\f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]/g, "█"))(e) : (this.options.obscureTextNumbers && (e = e.replace(/\d/g, "0")), this.options.obscureTextEmails && (e = e.replace(/^\w+([+.-]\w+)*@\w+([.-]\w+)*\.\w{2,3}$/g, (t => {
                        const [e, s] = t.split("@"), [i, n] = s.split(".");
                        return `${b(e)}@${b(i)}.${b(n)}`
                    }))), e)
                }
                isObscured(t) {
                    return this.obscured.has(t)
                }
                isHidden(t) {
                    return this.hidden.has(t)
                }
                getInnerTextSecure(t) {
                    const e = this.app.nodes.getID(t);
                    return e ? this.sanitize(e, t.innerText) : ""
                }
                clear() {
                    this.obscured.clear(), this.hidden.clear()
                }
            }
            class ne {
                constructor(t, e) {
                    this.app = t, this.options = e, this.metadata = {}, this.userID = null, this.callbacks = [], this.timestamp = 0, this.createTabId()
                }
                attachUpdateCallback(t) {
                    this.callbacks.push(t)
                }
                handleUpdate(t) {
                    null == t.userID && delete t.userID, null == t.sessionID && delete t.sessionID, this.callbacks.forEach((e => e(t)))
                }
                assign(t) {
                    void 0 !== t.userID && (this.userID = t.userID), void 0 !== t.metadata && Object.entries(t.metadata).forEach((([t, e]) => this.metadata[t] = e)), void 0 !== t.sessionID && (this.sessionID = t.sessionID), void 0 !== t.timestamp && (this.timestamp = t.timestamp), void 0 !== t.projectID && (this.projectID = t.projectID), this.handleUpdate(t)
                }
                setMetadata(t, e) {
                    this.metadata[t] = e, this.handleUpdate({
                        metadata: {
                            [t]: e
                        }
                    })
                }
                setUserID(t) {
                    this.userID = t, this.handleUpdate({
                        userID: t
                    })
                }
                setUserInfo(t) {
                    this.userInfo = t
                }
                getPageNumber() {
                    const t = this.app.sessionStorage.getItem(this.options.session_pageno_key);
                    if (null != t) return parseInt(t)
                }
                incPageNo() {
                    let t = this.getPageNumber();
                    return void 0 === t ? t = 0 : t++, this.app.sessionStorage.setItem(this.options.session_pageno_key, t.toString()), t
                }
                getSessionToken() {
                    return this.app.sessionStorage.getItem(this.options.session_token_key) || void 0
                }
                setSessionToken(t) {
                    this.app.sessionStorage.setItem(this.options.session_token_key, t)
                }
                applySessionHash(t) {
                    const e = decodeURI(t).split("&");
                    let s = t,
                        i = "100500";
                    2 == e.length && ([i, s] = e), i && s && (this.app.sessionStorage.setItem(this.options.session_token_key, s), this.app.sessionStorage.setItem(this.options.session_pageno_key, i))
                }
                getSessionHash() {
                    const t = this.getPageNumber(),
                        e = this.getSessionToken();
                    if (void 0 !== t && void 0 !== e) return encodeURI(String(t) + "&" + e)
                }
                getTabId() {
                    return this.tabId || this.createTabId(), this.tabId
                }
                regenerateTabId() {
                    const t = function(t) {
                        const e = new Uint8Array(6),
                            s = window.crypto || window.msCrypto;
                        return s ? (s.getRandomValues(e), Array.from(e, E).join("")) : Array.from({
                            length: 12
                        }, (() => E(Math.floor(16 * Math.random())))).join("")
                    }();
                    this.app.sessionStorage.setItem(this.options.session_tabid_key, t), this.tabId = t
                }
                createTabId() {
                    const t = this.app.sessionStorage.getItem(this.options.session_tabid_key);
                    t ? this.tabId = t : this.regenerateTabId()
                }
                getInfo() {
                    return {
                        sessionID: this.sessionID,
                        metadata: this.metadata,
                        userID: this.userID,
                        timestamp: this.timestamp,
                        projectID: this.projectID
                    }
                }
                reset() {
                    this.app.sessionStorage.removeItem(this.options.session_token_key), this.metadata = {}, this.userID = null, this.sessionID = void 0, this.timestamp = 0
                }
            }
            class re {
                constructor(t) {
                    this.app = t, this.timer = null, this.callbacks = []
                }
                attach(t, e = 0, s = !0, i) {
                    i && (t = t.bind(i)), s && (t = this.app.safe(t)), this.callbacks.unshift(e ? function(t, e) {
                        let s = 0;
                        return () => {
                            s++ >= e && (s = 0, t())
                        }
                    }(t, e) : t)
                }
                start() {
                    null === this.timer && (this.timer = setInterval((() => this.callbacks.forEach((t => {
                        t && t()
                    }))), 30))
                }
                stop() {
                    null !== this.timer && (clearInterval(this.timer), this.timer = null)
                }
            }
            var oe = s("ziTh");
            const ae = "canceled",
                ce = "or_uxt_active",
                he = "or_buffer_1",
                le = t => ({
                    reason: t,
                    success: !1
                });
            var ue;
            ! function(t) {
                t[t.NotActive = 0] = "NotActive", t[t.Starting = 1] = "Starting", t[t.Active = 2] = "Active", t[t.ColdStart = 3] = "ColdStart"
            }(ue || (ue = {}));
            const de = "https://api.openreplay.com/ingest";

            function pe() {
                const t = -1 * (new Date).getTimezoneOffset(),
                    e = t >= 0 ? "+" : "-",
                    s = Math.floor(Math.abs(t) / 60),
                    i = Math.abs(t) % 60;
                return `UTC${e}${String(s).padStart(2,"0")}:${String(i).padStart(2,"0")}`
            }
            const fe = t => new Promise((e => setTimeout(e, t))),
                ge = "never-gonna-give-you-up",
                me = "never-gonna-let-you-down",
                ye = "never-gonna-run-around-and-desert-you",
                be = "never-gonna-make-you-cry",
                ve = "never-gonna-say-goodbye",
                Se = "never-gonna-tell-a-lie-and-hurt-you";
            class we {
                constructor(t, e, s, i, n) {
                    this.signalError = i, this.insideIframe = n, this.messages = [], this.bufferedMessages1 = [], this.bufferedMessages2 = [], this.startCallbacks = [], this.stopCallbacks = [], this.commitCallbacks = [], this.activityState = ue.NotActive, this.version = "14.0.6", this.socketMode = !1, this.compressionThreshold = 24e3, this.bc = null, this.canvasRecorder = null, this.conditionsManager = null, this.canStart = !1, this.rootId = null, this.pageFrames = [], this.frameOderNumber = 0, this.initialHostName = location.hostname, this.features = {
                        "feature-flags": !0,
                        "usability-test": !0
                    }, this.startTimeout = null, this.coldStartCommitN = 0, this.delay = 0, this.coldInterval = null, this.orderNumber = 0, this.coldStartTs = 0, this.singleBuffer = !1, this.onSessionSent = () => {}, this.restartCanvasTracking = () => {
                        this.canvasRecorder ? .restartTracking()
                    }, this.flushBuffer = async t => new Promise((e => {
                        let s = !1;
                        const i = [t.shift()];
                        for (; !s;) {
                            const e = t[0];
                            e && 0 !== e[0] ? i.push(t.shift()) : s = !0
                        }
                        this.postToWorker(i), e(null)
                    })), this.onUxtCb = [], this.contextId = Math.random().toString(36).slice(2), this.projectKey = t, -1 !== Object.keys(s).findIndex((t => ["fixedCanvasScaling", "disableCanvas"].includes(t))) && (oe.warn('Openreplay: canvas options are moving to separate key "canvas" in next update. Please update your configuration.'), s = { ...s,
                        canvas: {
                            __save_canvas_locally: s.__save_canvas_locally,
                            fixedCanvasScaling: s.fixedCanvasScaling,
                            disableCanvas: s.disableCanvas
                        }
                    }), this.networkOptions = s.network;
                    const o = {
                        revID: "",
                        node_id: "__openreplay_id",
                        session_token_key: "__openreplay_token",
                        session_pageno_key: "__openreplay_pageno",
                        session_reset_key: "__openreplay_reset",
                        session_tabid_key: "__openreplay_tabid",
                        local_uuid_key: "__openreplay_uuid",
                        ingestPoint: de,
                        resourceBaseHref: null,
                        __is_snippet: !1,
                        __debug_report_edp: null,
                        __debug__: 0,
                        __save_canvas_locally: !1,
                        localStorage: null,
                        sessionStorage: null,
                        disableStringDict: !1,
                        forceSingleTab: !1,
                        assistSocketHost: "",
                        fixedCanvasScaling: !1,
                        disableCanvas: !1,
                        captureIFrames: !0,
                        obscureTextEmails: !0,
                        obscureTextNumbers: !1,
                        crossdomain: {
                            parentDomain: "*"
                        },
                        canvas: {
                            disableCanvas: !1,
                            fixedCanvasScaling: !1,
                            __save_canvas_locally: !1,
                            useAnimationFrame: !1
                        }
                    };
                    if (this.options = M(o, s), !this.insideIframe && !this.options.forceSingleTab && globalThis && "BroadcastChannel" in globalThis) {
                        const t = location.hostname.split(".").slice(-2).join("_");
                        this.bc = new BroadcastChannel(`rick_${t}`)
                    }
                    this.revID = this.options.revID, this.localStorage = this.options.localStorage ? ? window.localStorage, this.sessionStorage = this.options.sessionStorage ? ? window.sessionStorage, this.sanitizer = new ie(this, s), this.nodes = new Vt(this.options.node_id), this.observer = new ee(this, s), this.ticker = new re(this), this.ticker.attach((() => this.commit())), this.debug = new $t(this.options.__debug__), this.session = new ne(this, this.options), this.attributeSender = new r(this, Boolean(this.options.disableStringDict)), this.featureFlags = new h(this), this.tagWatcher = new class {
                        constructor(t, e, s) {
                            this.sessionStorage = t, this.errLog = e, this.onTag = s, this.intervals = {}, this.tags = [];
                            const i = JSON.parse(t.getItem(tt) ? ? "[]");
                            this.setTags(i), this.observer = new IntersectionObserver((t => {
                                t.forEach((t => {
                                    if (t.isIntersecting && t.target) {
                                        const e = t.target.__or_watcher_tagname;
                                        e && this.onTagRendered(e), this.observer.unobserve(t.target)
                                    }
                                }))
                            }))
                        }
                        async fetchTags(t, e) {
                            return fetch(`${t}/v1/web/tags`, {
                                method: "GET",
                                headers: {
                                    Authorization: `Bearer ${e}`
                                }
                            }).then((t => t.json())).then((({
                                tags: t
                            }) => {
                                if (t && t.length) {
                                    this.setTags(t);
                                    const e = JSON.stringify(t);
                                    this.sessionStorage.setItem(tt, e || "")
                                }
                            })).catch((t => this.errLog(t)))
                        }
                        setTags(t) {
                            this.tags = t, this.intervals = {}, t.forEach((t => {
                                this.intervals[t.id] = setInterval((() => {
                                    const e = document.querySelectorAll(t.selector);
                                    if (e.length > 0) {
                                        const s = e[0];
                                        s.__or_watcher_tagname = t.id, this.observer.observe(s)
                                    }
                                }), 500)
                            }))
                        }
                        onTagRendered(t) {
                            this.intervals[t] && clearInterval(this.intervals[t]), this.onTag(t)
                        }
                        clear() {
                            this.tags.forEach((t => {
                                clearInterval(this.intervals[t.id])
                            })), this.tags = [], this.intervals = {}, this.observer.disconnect()
                        }
                    }(this.sessionStorage, this.debug.error, (t => {
                        this.send([120, t])
                    })), this.session.attachUpdateCallback((({
                        userID: t,
                        metadata: e
                    }) => {
                        null != t && this.send(function(t) {
                            return [28, t]
                        }(t)), null != e && Object.entries(e).forEach((([t, e]) => this.send(A(t, e))))
                    })), null != e && this.session.applySessionHash(e), this.initWorker();
                    const a = this.session.getTabId();
                    if (this.insideIframe) {
                        const t = t => {
                            const {
                                data: e
                            } = t;
                            e.line === ve && (this.rootId = e.id, this.session.setSessionToken(e.token), this.frameOderNumber = e.frameOrderNumber, this.debug.log("starting iframe tracking", e), this.allowAppStart())
                        };
                        window.addEventListener("message", t), this.attachStopCallback((() => {
                            window.removeEventListener("message", t)
                        }));
                        const e = this.initialHostName;
                        window.parent.postMessage({
                            line: be,
                            source: a,
                            context: this.contextId,
                            domain: e
                        }, "*")
                    } else {
                        let t = 0;
                        const e = e => {
                            const {
                                data: s
                            } = e;
                            if (s.line === be) {
                                const i = s.domain,
                                    n = Array.from(document.querySelectorAll("iframe"));
                                this.pageFrames = n;
                                const r = async () => {
                                    let s = 0;
                                    for (; s < 10;) {
                                        const r = this.checkNodeId(n, i);
                                        if (r) {
                                            this.waitStarted().then((() => {
                                                t++;
                                                const s = this.session.getSessionToken(),
                                                    n = {
                                                        line: ve,
                                                        context: this.contextId,
                                                        domain: i,
                                                        id: r,
                                                        token: s,
                                                        frameOrderNumber: t
                                                    };
                                                this.debug.log("iframe_data", n), e.source ? .postMessage(n, "*")
                                            })).catch(oe.error), s = 10;
                                            break
                                        }
                                        s++, await fe(100)
                                    }
                                };
                                r()
                            }
                            if (s.line === Se) {
                                const t = s.messages.map((t => {
                                    if (20 === t[0]) {
                                        let s = t;
                                        return this.pageFrames.forEach((i => {
                                            if (i.dataset.domain === e.data.domain) {
                                                const [e, n, r] = t, {
                                                    left: o,
                                                    top: a
                                                } = i.getBoundingClientRect();
                                                s = [e, n + o, r + a]
                                            }
                                        })), s
                                    }
                                    if (68 === t[0]) {
                                        let s = t;
                                        return this.pageFrames.forEach((i => {
                                            if (i.dataset.domain === e.data.domain) {
                                                const [e, n, r, o, a, c, h] = t, {
                                                    left: l,
                                                    top: u,
                                                    width: d,
                                                    height: p
                                                } = i.getBoundingClientRect(), f = (c / 100 * d + l) / document.documentElement.scrollWidth, g = (h / 100 * p + u) / document.documentElement.scrollHeight;
                                                s = [e, n, r, o, a, Math.round(1e3 * f) / 10, Math.round(1e3 * g) / 10]
                                            }
                                        })), s
                                    }
                                    return t
                                }));
                                this.messages.push(...t)
                            }
                        };
                        window.addEventListener("message", e), this.attachStopCallback((() => {
                            window.removeEventListener("message", e)
                        }))
                    }
                    null !== this.bc && (this.bc.postMessage({
                        line: ge,
                        source: a,
                        context: this.contextId
                    }), this.startTimeout = setTimeout((() => {
                        this.allowAppStart()
                    }), 500), this.bc.onmessage = t => {
                        if (t.data.context !== this.contextId) {
                            if (t.data.line === me) {
                                const e = t.data.token;
                                this.session.setSessionToken(e), this.allowAppStart()
                            }
                            if (t.data.line === ye) {
                                const e = t.data.token;
                                this.session.regenerateTabId(), this.session.setSessionToken(e), this.allowAppStart()
                            }
                            if (t.data.line === ge) {
                                const e = this.session.getSessionToken();
                                e && this.bc && this.bc.postMessage({
                                    line: t.data.source === a ? ye : me,
                                    token: e,
                                    source: a,
                                    context: this.contextId
                                })
                            }
                        }
                    })
                }
                allowAppStart() {
                    this.canStart = !0, this.startTimeout && (clearTimeout(this.startTimeout), this.startTimeout = null)
                }
                checkNodeId(t, e) {
                    for (const s of t)
                        if (s.dataset.domain === e) return s[this.options.node_id];
                    return null
                }
                initWorker() {
                    try {
                        this.worker = new Worker(URL.createObjectURL(new Blob(['"use strict";class t{constructor(t,s,i,e=10,n=250,h,r){this.onUnauthorised=s,this.onFailure=i,this.MAX_ATTEMPTS_COUNT=e,this.ATTEMPT_TIMEOUT=n,this.onCompress=h,this.pageNo=r,this.attemptsCount=0,this.busy=!1,this.queue=[],this.token=null,this.lastBatchNum=0,this.ingestURL=t+"/v1/web/i",this.isCompressing=void 0!==h}getQueueStatus(){return 0===this.queue.length&&!this.busy}authorise(t){this.token=t,this.busy||this.sendNext()}push(t){if(this.busy||!this.token)this.queue.push(t);else if(this.busy=!0,this.isCompressing&&this.onCompress)this.onCompress(t);else{const s=++this.lastBatchNum;this.sendBatch(t,!1,s)}}sendNext(){const t=this.queue.shift();if(t)if(this.busy=!0,this.isCompressing&&this.onCompress)this.onCompress(t);else{const s=++this.lastBatchNum;this.sendBatch(t,!1,s)}else this.busy=!1}retry(t,s,i){this.attemptsCount>=this.MAX_ATTEMPTS_COUNT?this.onFailure(`Failed to send batch after ${this.attemptsCount} attempts.`):(this.attemptsCount++,setTimeout((()=>this.sendBatch(t,s,i)),this.ATTEMPT_TIMEOUT*this.attemptsCount))}sendBatch(t,s,i){const e=i?.toString().replace(/^([^_]+)_([^_]+).*/,"$1_$2_$3");this.busy=!0;const n={Authorization:`Bearer ${this.token}`};s&&(n["Content-Encoding"]="gzip"),null!==this.token?fetch(`${this.ingestURL}?batch=${this.pageNo??"noPageNum"}_${e??"noBatchNum"}`,{body:t,method:"POST",headers:n,keepalive:t.length<65536}).then((e=>{if(401===e.status)return this.busy=!1,void this.onUnauthorised();e.status>=400?this.retry(t,s,`${i??"noBatchNum"}_network:${e.status}`):(this.attemptsCount=0,this.sendNext())})).catch((e=>{console.warn("OpenReplay:",e),this.retry(t,s,`${i??"noBatchNum"}_reject:${e.message}`)})):setTimeout((()=>{this.sendBatch(t,s,`${i??"noBatchNum"}_newToken`)}),500)}sendCompressed(t){const s=++this.lastBatchNum;this.sendBatch(t,!0,s)}sendUncompressed(t){const s=++this.lastBatchNum;this.sendBatch(t,!1,s)}clean(){this.sendNext(),setTimeout((()=>{this.token=null,this.queue.length=0}),10)}}const s="function"==typeof TextEncoder?new TextEncoder:{encode(t){const s=t.length,i=new Uint8Array(3*s);let e=-1;for(let n=0,h=0,r=0;r!==s;){if(n=t.charCodeAt(r),r+=1,n>=55296&&n<=56319){if(r===s){i[e+=1]=239,i[e+=1]=191,i[e+=1]=189;break}if(h=t.charCodeAt(r),!(h>=56320&&h<=57343)){i[e+=1]=239,i[e+=1]=191,i[e+=1]=189;continue}if(n=1024*(n-55296)+h-56320+65536,r+=1,n>65535){i[e+=1]=240|n>>>18,i[e+=1]=128|n>>>12&63,i[e+=1]=128|n>>>6&63,i[e+=1]=128|63&n;continue}}n<=127?i[e+=1]=0|n:n<=2047?(i[e+=1]=192|n>>>6,i[e+=1]=128|63&n):(i[e+=1]=224|n>>>12,i[e+=1]=128|n>>>6&63,i[e+=1]=128|63&n)}return i.subarray(0,e+1)}};class i{constructor(t){this.size=t,this.offset=0,this.checkpointOffset=0,this.data=new Uint8Array(t)}getCurrentOffset(){return this.offset}checkpoint(){this.checkpointOffset=this.offset}get isEmpty(){return 0===this.offset}skip(t){return this.offset+=t,this.offset<=this.size}set(t,s){this.data.set(t,s)}boolean(t){return this.data[this.offset++]=+t,this.offset<=this.size}uint(t){for((t<0||t>Number.MAX_SAFE_INTEGER)&&(t=0);t>=128;)this.data[this.offset++]=t%256|128,t=Math.floor(t/128);return this.data[this.offset++]=t,this.offset<=this.size}int(t){return t=Math.round(t),this.uint(t>=0?2*t:-2*t-1)}string(t){const i=s.encode(t),e=i.byteLength;return!(!this.uint(e)||this.offset+e>this.size)&&(this.data.set(i,this.offset),this.offset+=e,!0)}reset(){this.offset=0,this.checkpointOffset=0}flush(){const t=this.data.slice(0,this.checkpointOffset);return this.reset(),t}}class e extends i{encode(t){switch(t[0]){case 0:case 11:case 114:case 115:return this.uint(t[1]);case 4:case 44:case 47:return this.string(t[1])&&this.string(t[2])&&this.uint(t[3]);case 5:case 20:case 38:case 70:case 75:case 76:case 77:case 82:return this.uint(t[1])&&this.uint(t[2]);case 6:return this.int(t[1])&&this.int(t[2]);case 7:return!0;case 8:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.string(t[4])&&this.boolean(t[5]);case 9:case 10:case 24:case 51:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3]);case 12:case 61:case 71:return this.uint(t[1])&&this.string(t[2])&&this.string(t[3]);case 13:case 14:case 17:case 50:case 54:return this.uint(t[1])&&this.string(t[2]);case 16:return this.uint(t[1])&&this.int(t[2])&&this.int(t[3]);case 18:return this.uint(t[1])&&this.string(t[2])&&this.int(t[3]);case 19:return this.uint(t[1])&&this.boolean(t[2]);case 21:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.string(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8]);case 22:case 27:case 30:case 41:case 45:case 46:case 63:case 64:case 79:return this.string(t[1])&&this.string(t[2]);case 23:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8])&&this.uint(t[9]);case 28:case 29:case 42:case 117:case 118:return this.string(t[1]);case 37:return this.uint(t[1])&&this.string(t[2])&&this.uint(t[3]);case 39:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.uint(t[7]);case 40:return this.string(t[1])&&this.uint(t[2])&&this.string(t[3])&&this.string(t[4]);case 48:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.int(t[5]);case 49:return this.int(t[1])&&this.int(t[2])&&this.uint(t[3])&&this.uint(t[4]);case 53:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.string(t[7])&&this.string(t[8]);case 55:return this.boolean(t[1]);case 57:case 60:return this.uint(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4]);case 58:case 120:return this.int(t[1]);case 59:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.string(t[5])&&this.string(t[6])&&this.string(t[7]);case 67:case 73:return this.uint(t[1])&&this.string(t[2])&&this.uint(t[3])&&this.string(t[4]);case 68:return this.uint(t[1])&&this.uint(t[2])&&this.string(t[3])&&this.string(t[4])&&this.uint(t[5])&&this.uint(t[6]);case 69:return this.uint(t[1])&&this.uint(t[2])&&this.string(t[3])&&this.string(t[4]);case 78:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4]);case 81:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.int(t[4])&&this.string(t[5]);case 83:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.string(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8])&&this.uint(t[9]);case 84:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.uint(t[4])&&this.string(t[5])&&this.string(t[6]);case 112:return this.uint(t[1])&&this.string(t[2])&&this.boolean(t[3])&&this.string(t[4])&&this.int(t[5])&&this.int(t[6]);case 113:return this.uint(t[1])&&this.uint(t[2])&&this.string(t[3]);case 116:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.string(t[7])&&this.string(t[8])&&this.uint(t[9])&&this.boolean(t[10]);case 119:return this.string(t[1])&&this.uint(t[2]);case 121:return this.string(t[1])&&this.string(t[2])&&this.uint(t[3])&&this.uint(t[4]);case 122:return this.string(t[1])&&this.string(t[2])&&this.uint(t[3])&&this.string(t[4]);case 123:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.uint(t[5])}}}class n{constructor(t,s,i,n,h,r){this.pageNo=t,this.timestamp=s,this.url=i,this.onBatch=n,this.tabId=h,this.onOfflineEnd=r,this.nextIndex=0,this.beaconSize=2e5,this.encoder=new e(this.beaconSize),this.sizeBuffer=new Uint8Array(3),this.isEmpty=!0,this.beaconSizeLimit=1e6,this.prepare()}writeType(t){return this.encoder.uint(t[0])}writeFields(t){return this.encoder.encode(t)}writeSizeAt(t,s){for(let s=0;s<3;s++)this.sizeBuffer[s]=t>>8*s;this.encoder.set(this.sizeBuffer,s)}prepare(){if(!this.encoder.isEmpty)return;const t=[81,1,this.pageNo,this.nextIndex,this.timestamp,this.url],s=[118,this.tabId];this.writeType(t),this.writeFields(t),this.writeWithSize(s),this.isEmpty=!0}writeWithSize(t){const s=this.encoder;if(!this.writeType(t)||!s.skip(3))return!1;const i=s.getCurrentOffset(),e=this.writeFields(t);if(e){const e=s.getCurrentOffset()-i;if(e>16777215)return console.warn("OpenReplay: max message size overflow."),!1;this.writeSizeAt(e,i-3),s.checkpoint(),this.isEmpty=this.isEmpty&&0===t[0],this.nextIndex++}return e}setBeaconSizeLimit(t){this.beaconSizeLimit=t}writeMessage(t){if("q_end"===t[0])return this.finaliseBatch(),this.onOfflineEnd();0===t[0]&&(this.timestamp=t[1]),122===t[0]&&(this.url=t[1]),this.writeWithSize(t)||(this.finaliseBatch(),this.writeWithSize(t)||(this.encoder=new e(this.beaconSizeLimit),this.prepare(),this.writeWithSize(t)?this.finaliseBatch():console.warn("OpenReplay: beacon size overflow. Skipping large message.",t,this),this.encoder=new e(this.beaconSize),this.prepare()))}finaliseBatch(){if(this.isEmpty)return;const t=this.encoder.flush();this.onBatch(t),this.prepare()}clean(){this.encoder.reset()}}var h;!function(t){t[t.NotActive=0]="NotActive",t[t.Starting=1]="Starting",t[t.Stopping=2]="Stopping",t[t.Active=3]="Active",t[t.Stopped=4]="Stopped"}(h||(h={}));let r=null,a=null,u=h.NotActive;function o(){a&&a.finaliseBatch()}function c(){return new Promise((t=>{u=h.Stopping,null!==l&&(clearInterval(l),l=null),a&&(a.clean(),a=null),r&&(r.clean(),setTimeout((()=>{r=null}),20)),setTimeout((()=>{u=h.NotActive,t(null)}),100)}))}function g(){u!==h.Stopped&&(postMessage("a_stop"),c().then((()=>{postMessage("a_start")})))}let p,l=null;self.onmessage=({data:s})=>{if(null!=s){if("stop"===s)return o(),void c().then((()=>{u=h.Stopped}));if("forceFlushBatch"!==s){if(!Array.isArray(s)){if("compressed"===s.type){if(!r)return console.debug("OR WebWorker: sender not initialised. Compressed batch."),void g();s.batch&&r.sendCompressed(s.batch)}if("uncompressed"===s.type){if(!r)return console.debug("OR WebWorker: sender not initialised. Uncompressed batch."),void g();s.batch&&r.sendUncompressed(s.batch)}return"start"===s.type?(u=h.Starting,r=new t(s.ingestPoint,(()=>{g()}),(t=>{!function(t){postMessage({type:"failure",reason:t}),c()}(t)}),s.connAttemptCount,s.connAttemptGap,(t=>{postMessage({type:"compress",batch:t},[t.buffer])}),s.pageNo),a=new n(s.pageNo,s.timestamp,s.url,(t=>{r&&r.push(t)}),s.tabId,(()=>postMessage({type:"queue_empty"}))),null===l&&(l=setInterval(o,1e4)),u=h.Active):"auth"===s.type?r?a?(r.authorise(s.token),void(s.beaconSizeLimit&&a.setBeaconSizeLimit(s.beaconSizeLimit))):(console.debug("OR WebWorker: writer not initialised. Received auth."),void g()):(console.debug("OR WebWorker: sender not initialised. Received auth."),void g()):void 0}if(a){const t=a;s.forEach((s=>{55===s[0]&&(s[1]?p=setTimeout((()=>g()),18e5):clearTimeout(p)),t.writeMessage(s)}))}else postMessage("not_init"),g()}else o()}else o()};'], {
                            type: "text/javascript"
                        }))), this.worker.onerror = t => {
                            this._debug("webworker_error", t)
                        }, this.worker.onmessage = ({
                            data: t
                        }) => {
                            this.handleWorkerMsg(t)
                        };
                        const t = () => {
                            this.worker && this.worker.postMessage(null)
                        };
                        this.attachEventListener(window, "beforeunload", t, !1), this.attachEventListener(document.body, "mouseleave", t, !1, !1), this.attachEventListener(document, "visibilitychange", t, !1)
                    } catch (t) {
                        this._debug("worker_start", t)
                    }
                }
                handleWorkerMsg(t) {
                    if ("a_stop" === t) this.stop(!1);
                    else if ("a_start" === t) this.start({}, !0);
                    else if ("not_init" === t) this.debug.warn("OR WebWorker: writer not initialised. Restarting tracker");
                    else if ("failure" === t.type) this.stop(!1), this.debug.error("worker_failed", t.reason), this._debug("worker_failed", t.reason);
                    else if ("compress" === t.type) {
                        const e = t.batch;
                        e.byteLength > this.compressionThreshold ? (0, i.iv)(t.batch, {
                            mtime: 0
                        }, ((t, s) => {
                            t ? (this.debug.error("Openreplay compression error:", t), this.worker ? .postMessage({
                                type: "uncompressed",
                                batch: e
                            })) : this.worker ? .postMessage({
                                type: "compressed",
                                batch: s
                            })
                        })) : this.worker ? .postMessage({
                            type: "uncompressed",
                            batch: e
                        })
                    } else "queue_empty" === t.type && this.onSessionSent()
                }
                _debug(t, e) {
                    null !== this.options.__debug_report_edp && fetch(this.options.__debug_report_edp, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({
                            context: t,
                            error: `${e}`
                        })
                    }), this.debug.error("OpenReplay error: ", t, e)
                }
                send(t, e = !1) {
                    this.activityState !== ue.NotActive && (this.activityState === ue.ColdStart ? (this.bufferedMessages1.push(t), this.singleBuffer || this.bufferedMessages2.push(t), this.conditionsManager ? .processMessage(t)) : this.messages.push(t), this.activityState === ue.Active && e && this.commit())
                }
                _nCommit() {
                    if (this.socketMode) return this.messages.unshift(G(this.session.getTabId())), this.messages.unshift(D(this.timestamp())), this.commitCallbacks.forEach((t => t(this.messages))), void(this.messages.length = 0);
                    if (void 0 !== this.worker && this.messages.length) {
                        if (this.insideIframe) return window.parent.postMessage({
                            line: Se,
                            messages: this.messages,
                            domain: this.initialHostName
                        }, "*"), this.commitCallbacks.forEach((t => t(this.messages))), void(this.messages.length = 0);
                        try {
                            t = () => {
                                this.messages.unshift(G(this.session.getTabId())), this.messages.unshift(D(this.timestamp())), this.worker ? .postMessage(this.messages), this.commitCallbacks.forEach((t => t(this.messages))), this.messages.length = 0
                            }, R.addTask(t)
                        } catch (t) {
                            this._debug("worker_commit", t), this.stop(!0), setTimeout((() => {
                                this.start()
                            }), 500)
                        }
                        var t
                    }
                }
                _cStartCommit() {
                    this.coldStartCommitN += 1, 2 === this.coldStartCommitN && (this.bufferedMessages1.push(D(this.timestamp())), this.bufferedMessages1.push(G(this.session.getTabId())), this.bufferedMessages2.push(D(this.timestamp())), this.bufferedMessages2.push(G(this.session.getTabId())), this.coldStartCommitN = 0)
                }
                commit() {
                    this.activityState === ue.ColdStart ? this._cStartCommit() : this._nCommit()
                }
                postToWorker(t) {
                    this.worker ? .postMessage(t), this.commitCallbacks.forEach((e => e(t))), t.length = 0
                }
                timestamp() {
                    return y() + this.delay
                }
                safe(t) {
                    const e = this;
                    return function(...s) {
                        try {
                            t.apply(this, s)
                        } catch (t) {
                            e._debug("safe_fn_call", t)
                        }
                    }
                }
                attachCommitCallback(t) {
                    this.commitCallbacks.push(t)
                }
                attachStartCallback(t, e = !1) {
                    e && (t = this.safe(t)), this.startCallbacks.push(t)
                }
                attachStopCallback(t, e = !1) {
                    e && (t = this.safe(t)), this.stopCallbacks.push(t)
                }
                attachEventListener(t, e, s, i = !0, n = !0) {
                    i && (s = this.safe(s)), this.attachStartCallback((() => t ? N(t, e, s, n) : null), i), this.attachStopCallback((() => t ? O(t, e, s, n) : null), i)
                }
                checkRequiredVersion(t) {
                    const e = t.split(/[.-]/),
                        s = this.version.split(/[.-]/);
                    for (let t = 0; t < 3; t++) {
                        if (isNaN(Number(s[t])) || isNaN(Number(e[t]))) return !1;
                        if (Number(s[t]) > Number(e[t])) return !0;
                        if (Number(s[t]) < Number(e[t])) return !1
                    }
                    return !0
                }
                getTrackerInfo() {
                    return {
                        userUUID: this.localStorage.getItem(this.options.local_uuid_key),
                        projectKey: this.projectKey,
                        revID: this.revID,
                        trackerVersion: this.version,
                        isSnippet: this.options.__is_snippet
                    }
                }
                getSessionInfo() {
                    return { ...this.session.getInfo(),
                        ...this.getTrackerInfo()
                    }
                }
                getSessionToken() {
                    return this.session.getSessionToken()
                }
                getSessionID() {
                    return this.session.getInfo().sessionID || void 0
                }
                getSessionURL(t) {
                    const {
                        projectID: e,
                        sessionID: s,
                        timestamp: i
                    } = this.session.getInfo();
                    if (!e || !s) return void this.debug.error("OpenReplay error: Unable to build session URL");
                    const n = this.options.ingestPoint,
                        r = (/api\.openreplay\.com/.test(n) ? "https://app.openreplay.com/ingest" : n).replace(/ingest$/, `${e}/session/${s}`);
                    return t ? .withCurrentTime ? `${r}?jumpto=${y()-i}` : r
                }
                getHost() {
                    return new URL(this.options.ingestPoint).host
                }
                getProjectKey() {
                    return this.projectKey
                }
                getBaseHref() {
                    return "string" == typeof this.options.resourceBaseHref ? this.options.resourceBaseHref : (this.options.resourceBaseHref, document.baseURI ? document.baseURI : document.head ? .getElementsByTagName("base")[0] ? .getAttribute("href") || location.origin + location.pathname)
                }
                resolveResourceURL(t) {
                    const e = new URL(this.getBaseHref());
                    return e.pathname += "/" + new URL(t).pathname, e.pathname.replace(/\/+/g, "/"), e.toString()
                }
                isServiceURL(t) {
                    return t.startsWith(this.options.ingestPoint)
                }
                active() {
                    return this.activityState === ue.Active
                }
                resetNextPageSession(t) {
                    t ? this.sessionStorage.setItem(this.options.session_reset_key, "t") : this.sessionStorage.removeItem(this.options.session_reset_key)
                }
                checkSessionToken(t) {
                    const e = null !== this.sessionStorage.getItem(this.options.session_reset_key),
                        s = t || e,
                        i = this.session.getSessionToken();
                    return s || !i
                }
                async coldStart(t = {}, e) {
                    this.singleBuffer = !1;
                    const s = this.checkSessionToken(t.forceNew);
                    e && await this.setupConditionalStart(t);
                    const i = () => {
                        this.orderNumber += 1, g(), this.coldStartTs = y(), this.orderNumber % 2 == 0 ? (this.bufferedMessages1.length = 0, this.bufferedMessages1.push(D(this.timestamp())), this.bufferedMessages1.push(G(this.session.getTabId()))) : (this.bufferedMessages2.length = 0, this.bufferedMessages2.push(D(this.timestamp())), this.bufferedMessages2.push(G(this.session.getTabId()))), this.stop(!1), this.activityState = ue.ColdStart, t.sessionHash && this.session.applySessionHash(t.sessionHash), t.forceNew && this.session.reset(), this.session.assign({
                            userID: t.userID,
                            metadata: t.metadata
                        }), s || (this.debug.log("continuing session on new tab", this.session.getTabId()), this.send(J(this.session.getTabId()))), this.observer.observe(), this.ticker.start()
                    };
                    this.coldInterval = setInterval((() => {
                        i()
                    }), 3e4), i()
                }
                async setupConditionalStart(t) {
                    this.conditionsManager = new o(this, t);
                    const e = await fetch(this.options.ingestPoint + "/v1/web/start", {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: JSON.stringify({ ...this.getTrackerInfo(),
                                timestamp: y(),
                                doNotRecord: !0,
                                bufferDiff: 0,
                                userID: this.session.getInfo().userID,
                                token: void 0,
                                deviceMemory: Q,
                                jsHeapSizeLimit: Z,
                                timezone: pe(),
                                width: window.screen.width,
                                height: window.screen.height
                            })
                        }),
                        {
                            token: s,
                            userBrowser: i,
                            userCity: n,
                            userCountry: r,
                            userDevice: a,
                            userOS: c,
                            userState: h,
                            projectID: l,
                            features: u
                        } = await e.json();
                    this.features = u || this.features, this.session.assign({
                        projectID: l
                    }), this.session.setUserInfo({
                        userBrowser: i,
                        userCity: n,
                        userCountry: r,
                        userDevice: a,
                        userOS: c,
                        userState: h
                    });
                    const d = {
                        sessionToken: s,
                        userUUID: "",
                        sessionID: ""
                    };
                    this.startCallbacks.forEach((t => t(d))), await (this.conditionsManager ? .fetchConditions(l, s)), this.features["feature-flags"] && (await this.featureFlags.reloadFlags(s), this.conditionsManager ? .processFlags(this.featureFlags.flags)), await this.tagWatcher.fetchTags(this.options.ingestPoint, s)
                }
                offlineRecording(t = {}, e) {
                    this.onSessionSent = e, this.singleBuffer = !0;
                    const s = this.checkSessionToken(t.forceNew);
                    g(), this.coldStartTs = y();
                    const i = this.localStorage.getItem(he);
                    if (i) {
                        const t = JSON.parse(i);
                        this.bufferedMessages1 = Array.isArray(t) ? t : this.bufferedMessages1, this.localStorage.removeItem(he)
                    }
                    this.bufferedMessages1.push(D(this.timestamp())), this.bufferedMessages1.push(G(this.session.getTabId())), this.activityState = ue.ColdStart, t.sessionHash && this.session.applySessionHash(t.sessionHash), t.forceNew && this.session.reset(), this.session.assign({
                        userID: t.userID,
                        metadata: t.metadata
                    });
                    const n = {
                        sessionToken: "",
                        userUUID: "",
                        sessionID: ""
                    };
                    return this.startCallbacks.forEach((t => t(n))), s || this.send(J(this.session.getTabId())), this.observer.observe(), this.ticker.start(), {
                        saveBuffer: this.saveBuffer,
                        getBuffer: this.getBuffer,
                        setBuffer: this.setBuffer
                    }
                }
                saveBuffer() {
                    this.localStorage.setItem(he, JSON.stringify(this.bufferedMessages1))
                }
                getBuffer() {
                    return this.bufferedMessages1
                }
                setBuffer(t) {
                    this.bufferedMessages1 = t
                }
                async uploadOfflineRecording() {
                    this.stop(!1);
                    const t = y();
                    this.worker ? .postMessage({
                        type: "start",
                        pageNo: this.session.incPageNo(),
                        ingestPoint: this.options.ingestPoint,
                        timestamp: this.coldStartTs,
                        url: document.URL,
                        connAttemptCount: this.options.connAttemptCount,
                        connAttemptGap: this.options.connAttemptGap,
                        tabId: this.session.getTabId()
                    });
                    const e = await fetch(this.options.ingestPoint + "/v1/web/start", {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: JSON.stringify({ ...this.getTrackerInfo(),
                                timestamp: t,
                                doNotRecord: !1,
                                bufferDiff: t - this.coldStartTs,
                                userID: this.session.getInfo().userID,
                                token: void 0,
                                deviceMemory: Q,
                                jsHeapSizeLimit: Z,
                                timezone: pe()
                            })
                        }),
                        {
                            token: s,
                            userBrowser: i,
                            userCity: n,
                            userCountry: r,
                            userDevice: o,
                            userOS: a,
                            userState: c,
                            beaconSizeLimit: h,
                            projectID: l
                        } = await e.json();
                    for (this.worker ? .postMessage({
                            type: "auth",
                            token: s,
                            beaconSizeLimit: h
                        }), this.session.assign({
                            projectID: l
                        }), this.session.setUserInfo({
                            userBrowser: i,
                            userCity: n,
                            userCountry: r,
                            userDevice: o,
                            userOS: a,
                            userState: c
                        }); this.bufferedMessages1.length > 0;) await this.flushBuffer(this.bufferedMessages1);
                    this.postToWorker([
                        ["q_end"]
                    ]), this.clearBuffers()
                }
                async _start(t = {}, e = !1, s) {
                    const i = this.activityState === ue.ColdStart;
                    if (i && this.coldInterval && clearInterval(this.coldInterval), !this.worker) {
                        const t = "No worker found: perhaps, CSP is not set.";
                        return this.signalError(t, []), Promise.resolve(le(t))
                    }
                    if (this.activityState === ue.Active || this.activityState === ue.Starting) {
                        const t = "OpenReplay: trying to call `start()` on the instance that has been started already.";
                        return Promise.resolve(le(t))
                    }
                    this.activityState = ue.Starting, i || g(), t.sessionHash && this.session.applySessionHash(t.sessionHash), t.forceNew && this.session.reset(), this.session.assign({
                        userID: t.userID,
                        metadata: t.metadata
                    });
                    const n = y();
                    this.worker.postMessage({
                        type: "start",
                        pageNo: this.session.incPageNo(),
                        ingestPoint: this.options.ingestPoint,
                        timestamp: i ? this.coldStartTs : n,
                        url: document.URL,
                        connAttemptCount: this.options.connAttemptCount,
                        connAttemptGap: this.options.connAttemptGap,
                        tabId: this.session.getTabId()
                    });
                    const r = this.session.getSessionToken(),
                        o = this.checkSessionToken(t.forceNew);
                    this.sessionStorage.removeItem(this.options.session_reset_key), this.debug.log("OpenReplay: starting session; need new session id?", o, "session token: ", r);
                    try {
                        const e = await window.fetch(this.options.ingestPoint + "/v1/web/start", {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json"
                            },
                            body: JSON.stringify({ ...this.getTrackerInfo(),
                                timestamp: n,
                                doNotRecord: !1,
                                bufferDiff: n - this.coldStartTs,
                                userID: this.session.getInfo().userID,
                                token: o ? void 0 : r,
                                deviceMemory: Q,
                                jsHeapSizeLimit: Z,
                                timezone: pe(),
                                condition: s,
                                assistOnly: t.assistOnly ? ? this.socketMode,
                                width: window.screen.width,
                                height: window.screen.height
                            })
                        });
                        if (200 !== e.status) {
                            const t = await e.text(),
                                s = t === ae ? ae : `Server error: ${e.status}. ${t}`;
                            return le(s)
                        }
                        if (!this.worker) {
                            const t = "no worker found after start request (this should not happen in real world)";
                            return this.signalError(t, []), le(t)
                        }
                        const {
                            token: c,
                            userUUID: h,
                            projectID: l,
                            beaconSizeLimit: u,
                            compressionThreshold: d,
                            delay: p,
                            sessionID: f,
                            startTimestamp: g,
                            userBrowser: m,
                            userCity: y,
                            userCountry: b,
                            userDevice: v,
                            userOS: S,
                            userState: w,
                            canvasEnabled: k,
                            canvasQuality: T,
                            canvasFPS: I,
                            assistOnly: x,
                            features: E
                        } = await e.json();
                        if (this.features = E || this.features, "string" != typeof c || "string" != typeof h || "number" != typeof g && void 0 !== g || "string" != typeof f || "number" != typeof p || "number" != typeof u && void 0 !== u) {
                            const t = `Incorrect server response: ${JSON.stringify(e)}`;
                            return this.signalError(t, []), le(t)
                        }
                        this.delay = p, this.session.setSessionToken(c), this.session.setUserInfo({
                            userBrowser: m,
                            userCity: y,
                            userCountry: b,
                            userDevice: v,
                            userOS: S,
                            userState: w
                        }), this.session.assign({
                            sessionID: f,
                            timestamp: g || n,
                            projectID: l
                        }), x ? (this.socketMode = !0, this.worker.postMessage("stop")) : this.worker.postMessage({
                            type: "auth",
                            token: c,
                            beaconSizeLimit: u
                        }), o || c !== r || (this.debug.log("continuing session on new tab", this.session.getTabId()), this.send(J(this.session.getTabId()))), Object.entries(this.session.getInfo().metadata).forEach((([t, e]) => this.send(A(t, e)))), this.localStorage.setItem(this.options.local_uuid_key, h), this.compressionThreshold = d;
                        const _ = {
                            sessionToken: c,
                            userUUID: h,
                            sessionID: f
                        };
                        if (this.startCallbacks.forEach((t => t(_))), this.features["feature-flags"] && this.featureFlags.reloadFlags(), await this.tagWatcher.fetchTags(this.options.ingestPoint, c), this.activityState = ue.Active, k && !this.options.canvas.disableCanvas && (this.canvasRecorder = this.canvasRecorder ? ? new class {
                                constructor(t, e) {
                                    this.app = t, this.options = e, this.snapshots = {}, this.intervals = [], this.restartTracking = () => {
                                        this.clear(), this.app.nodes.scanTree(this.captureCanvas)
                                    }, this.captureCanvas = t => {
                                        const e = this.app.nodes.getID(t);
                                        e && Ut(t, "canvas") && (this.app.sanitizer.isObscured(e) || this.app.sanitizer.isHidden(e) || !Ut(t, "canvas") || this.snapshots[e] || new IntersectionObserver((t => {
                                            t.forEach((t => {
                                                t.isIntersecting && (t.target ? this.snapshots[e] && this.snapshots[e].createdAt ? this.snapshots[e].paused = !1 : this.recordCanvas(t.target, e) : this.snapshots[e] && (this.snapshots[e].paused = !0))
                                            }))
                                        })).observe(t))
                                    }, this.recordCanvas = (t, e) => {
                                        const s = this.app.timestamp();
                                        this.snapshots[e] = {
                                            images: [],
                                            createdAt: s,
                                            paused: !1,
                                            dummy: document.createElement("canvas")
                                        };
                                        const i = [119, e.toString(), s];
                                        this.app.send(i);
                                        const n = t => {
                                                ! function(t, e = "medium", s, i = !1, n, r) {
                                                    const o = `image/${n}`;
                                                    if (i) {
                                                        const i = window.devicePixelRatio || 1;
                                                        s.width = t.width / i, s.height = t.height / i;
                                                        const n = s.getContext("2d");
                                                        if (!n) return "";
                                                        n.clearRect(0, 0, s.width, s.height), n.drawImage(t, 0, 0, s.width, s.height), s.toBlob(r, o, qt[e])
                                                    } else t.toBlob(r, o, qt[e])
                                                }(t, this.options.quality, this.snapshots[e].dummy, this.options.fixedScaling, this.fileExt, (t => {
                                                    if (t) {
                                                        if (!this.snapshots[e]) return this.app.debug.warn("Canvas not present in snapshots after capture:", this.snapshots, e);
                                                        this.snapshots[e].images.push({
                                                            id: this.app.timestamp(),
                                                            data: t
                                                        }), this.snapshots[e].images.length > 9 && (this.sendSnaps(this.snapshots[e].images, e, this.snapshots[e].createdAt), this.snapshots[e].images = [])
                                                    }
                                                }))
                                            },
                                            r = setInterval((() => {
                                                const s = this.app.nodes.getID(t),
                                                    i = s ? this.app.nodes.getNode(s) : void 0;
                                                return this.snapshots[e] ? i && Ut(i, "canvas") && i === t ? void(this.snapshots[e].paused || (this.options.useAnimationFrame ? requestAnimationFrame((() => {
                                                    n(i)
                                                })) : n(i))) : (this.app.debug.log("Canvas element not in sync"), void clearInterval(r)) : (this.app.debug.log("Canvas is not present in {snapshots}"), void clearInterval(r))
                                            }), this.interval);
                                        this.intervals.push(r)
                                    }, this.fileExt = e.fileExt ? ? "webp", this.interval = 1e3 / e.fps
                                }
                                startTracking() {
                                    setTimeout((() => {
                                        this.app.nodes.scanTree(this.captureCanvas), this.app.nodes.attachNodeCallback((t => {
                                            this.captureCanvas(t)
                                        }))
                                    }), 500)
                                }
                                sendSnaps(t, e, s) {
                                    if (0 === Object.keys(this.snapshots).length) return;
                                    const i = new FormData;
                                    t.forEach((t => {
                                        const n = t.data;
                                        n && (i.append("snapshot", n, `${s}_${e}_${t.id}.${this.fileExt}`), this.options.isDebug && function(t, e) {
                                            const s = URL.createObjectURL(t),
                                                i = document.createElement("a");
                                            i.href = s, i.download = e, i.style.display = "none", document.body.appendChild(i), i.click(), document.body.removeChild(i)
                                        }(n, `${s}_${e}_${t.id}.${this.fileExt}`))
                                    })), fetch(this.app.options.ingestPoint + "/v1/web/images", {
                                        method: "POST",
                                        headers: {
                                            Authorization: `Bearer ${this.app.session.getSessionToken()??""}`
                                        },
                                        body: i
                                    }).then((() => !0)).catch((t => {
                                        this.app.debug.error("error saving canvas", t)
                                    }))
                                }
                                clear() {
                                    this.intervals.forEach((t => clearInterval(t))), this.snapshots = {}
                                }
                            }(this, {
                                fps: I,
                                quality: T,
                                isDebug: this.options.canvas.__save_canvas_locally,
                                fixedScaling: this.options.canvas.fixedCanvasScaling,
                                useAnimationFrame: this.options.canvas.useAnimationFrame
                            }), this.canvasRecorder.startTracking()), i) {
                            const t = this.bufferedMessages1.length > this.bufferedMessages2.length ? this.bufferedMessages1 : this.bufferedMessages2;
                            for (; t.length > 0;) await this.flushBuffer(t);
                            this.clearBuffers(), this.commit()
                        } else this.insideIframe && this.rootId ? this.observer.crossdomainObserve(this.rootId, this.frameOderNumber) : this.observer.observe(), this.ticker.start();
                        if (this.features["usability-test"]) {
                            let t;
                            this.uxtManager = this.uxtManager ? this.uxtManager : new At(this, ce);
                            const e = this.localStorage.getItem(ce);
                            if (e && (t = parseInt(e, 10)), location ? .search) {
                                const e = new URLSearchParams(location.search);
                                if (e.has("oruxt")) {
                                    const s = e.get("oruxt");
                                    t = s ? parseInt(s, 10) : void 0
                                }
                            }
                            t && (this.uxtManager.isActive ? this.onUxtCb.forEach((e => e(t))) : this.uxtManager.getTest(t, c, Boolean(e)).then((t => {
                                t && this.onUxtCb.forEach((e => e(t)))
                            })))
                        }
                        return a = _, { ...a,
                            success: !0
                        }
                    } catch (t) {
                        if (this.stop(), this.session.reset(), t === ae) return this.signalError(ae, []), le(ae);
                        this._debug("session_start", t);
                        const e = t instanceof Error ? t.message : t.toString();
                        return this.signalError(e, []), le(e)
                    }
                    var a
                }
                addOnUxtCb(t) {
                    this.onUxtCb.push(t)
                }
                getUxtId() {
                    return this.uxtManager ? .getTestId()
                }
                async waitStart() {
                    return new Promise((t => {
                        const e = () => {
                            this.canStart ? t(!0) : setTimeout(e, 25)
                        };
                        e()
                    }))
                }
                async waitStarted() {
                    return new Promise((t => {
                        const e = () => {
                            this.activityState === ue.Active ? t(!0) : setTimeout(e, 25)
                        };
                        e()
                    }))
                }
                async start(...t) {
                    if (this.activityState === ue.Active || this.activityState === ue.Starting) {
                        const t = "OpenReplay: trying to call `start()` on the instance that has been started already.";
                        return Promise.resolve(le(t))
                    }
                    return document.hidden ? new Promise((e => {
                        const s = async () => {
                            document.hidden || (await this.waitStart(), document.removeEventListener("visibilitychange", s), e(this._start(...t)))
                        };
                        document.addEventListener("visibilitychange", s)
                    })) : (await this.waitStart(), this._start(...t))
                }
                forceFlushBatch() {
                    this.worker ? .postMessage("forceFlushBatch")
                }
                getTabId() {
                    return this.session.getTabId()
                }
                clearBuffers() {
                    this.bufferedMessages1.length = 0, this.bufferedMessages2.length = 0
                }
                trackWs(t) {
                    const e = t;
                    return (t, s, i = "down") => {
                        "string" != typeof t || "string" != typeof s || s.length > 5242880 || t.length > 255 || this.send(function(t, e, s, i, n, r) {
                            return [84, "websocket", e, s, i, n, r]
                        }(0, e, s, this.timestamp(), i, t))
                    }
                }
                stop(t = !0) {
                    if (this.activityState !== ue.NotActive) try {
                        this.attributeSender.clear(), this.sanitizer.clear(), this.observer.disconnect(), this.nodes.clear(), this.ticker.stop(), this.stopCallbacks.forEach((t => t())), this.debug.log("OpenReplay tracking stopped."), this.tagWatcher.clear(), this.worker && t && this.worker.postMessage("stop"), this.canvasRecorder ? .clear()
                    } finally {
                        this.activityState = ue.NotActive
                    }
                }
            }
            const ke = d && "InstallTrigger" in window ? t => t.message + "\n" + t.stack : t => t.stack || t.message;

            function Te(t) {
                return void 0 === t ? "undefined" : null === t ? "null" : t instanceof Error ? ke(t) : Array.isArray(t) ? `Array(${t.length})` : String(t)
            }

            function Ie(t) {
                if (void 0 === t) return "undefined";
                if (null === t) return "null";
                if (t instanceof Error) return ke(t);
                if (Array.isArray(t)) return `Array(${t.length})[${t.slice(0,10).map(Te).join(", ")}]`;
                if ("object" == typeof t) {
                    const e = [];
                    let s = 0;
                    for (const i in t) {
                        if (10 == ++s) break;
                        const n = t[i];
                        e.push(i + ": " + Te(n))
                    }
                    return "{" + e.join(", ") + "}"
                }
                return t.toString()
            }
            const xe = ["log", "info", "warn", "error", "debug", "assert"];

            function Ee(t, e) {
                const s = Object.assign({
                    consoleMethods: xe,
                    consoleThrottling: 30
                }, e);
                if (!Array.isArray(s.consoleMethods) || 0 === s.consoleMethods.length) return;
                const i = t.safe(((e, s) => t.send(function(t, e) {
                    return [22, t, e]
                }(e, function(t) {
                    return "string" == typeof t[0] && t.unshift(t.shift().replace(/%(o|s|f|d|i)/g, ((e, s) => {
                        const i = t.shift();
                        if (void 0 === i) return e;
                        switch (s) {
                            case "o":
                                return Ie(i);
                            case "s":
                                return Te(i);
                            case "f":
                                return function(t) {
                                    return "number" != typeof t ? "NaN" : t.toString()
                                }(i);
                            case "d":
                            case "i":
                                return function(t) {
                                    return "number" != typeof t ? "NaN" : Math.floor(t).toString()
                                }(i);
                            default:
                                return e
                        }
                    }))), t.map(Ie).join(" ")
                }(s)))));
                let n = 0;
                const r = () => {
                    n = 0
                };
                t.attachStartCallback(r), t.ticker.attach(r, 33, !1);
                const o = t.safe((e => ((e, r) => {
                    const o = {
                        apply: function(t, e, o) {
                            Reflect.apply(t, r, o), n += 1, n > s.consoleThrottling || i(t.name, o)
                        }
                    };
                    s.consoleMethods.forEach((s => {
                        if (-1 === xe.indexOf(s)) return void t.debug.error(`OpenReplay: unsupported console method "${s}"`);
                        const i = r.console[s];
                        e[s] = new Proxy(i, o)
                    }))
                })(e.console, e)));
                o(window), t.observer.attachContextCallback(o)
            }
            var _e = s("MjPQ");

            function Ce(t) {
                return [{
                    columnNumber: t.colno,
                    lineNumber: t.lineno,
                    fileName: t.filename,
                    functionName: "",
                    source: ""
                }]
            }

            function Ne(t, e, s = {}) {
                let i = e;
                try {
                    i = _e.parse(t)
                } catch (t) {}
                return $(t.name, t.message, JSON.stringify(i), JSON.stringify(s))
            }

            function Oe(t, e = window, s = {}) {
                if (t instanceof ErrorEvent) {
                    if (t.error instanceof Error) return Ne(t.error, Ce(t), s); {
                        let [e, i] = t.message.split(":");
                        return i || (e = "Error", i = t.message), $(e, i, JSON.stringify(Ce(t)), JSON.stringify(s))
                    }
                }
                if ("PromiseRejectionEvent" in e && t instanceof e.PromiseRejectionEvent) {
                    if (t.reason instanceof Error) return Ne(t.reason, [], s); {
                        let e;
                        try {
                            e = JSON.stringify(t.reason)
                        } catch (s) {
                            e = String(t.reason)
                        }
                        return $("Unhandled Promise Rejection", e, "[]", JSON.stringify(s))
                    }
                }
                return null
            }

            function Re(t, e = document.location) {
                return (t = t.trim()).startsWith("//") || t.startsWith("http://") || t.startsWith("https://") || t.startsWith("data:") ? t : t.startsWith("/") ? e.origin + t : e.origin + e.pathname + t
            }
            const Me = ["text", "password", "email", "search", "number", "range", "date", "tel", "time"],
                De = d && "labels" in HTMLInputElement.prototype ? t => {
                    let e = t;
                    for (; null !== (e = e.parentNode);)
                        if (Ut(e, "label")) return e;
                    const s = t.labels;
                    if (null !== s && 1 === s.length) return s[0]
                } : t => {
                    let e = t;
                    for (; null !== (e = e.parentNode);)
                        if (Ut(e, "label")) return e;
                    const s = t.id;
                    if (s) {
                        const e = t.ownerDocument.querySelectorAll('label[for="' + s + '"]');
                        if (null !== e && 1 === e.length) return e[0]
                    }
                };

            function Le(t) {
                let e = I(t);
                if (null === e) {
                    const s = De(t);
                    e = s && s.innerText || t.placeholder || t.name || t.id || t.className || t.type
                }
                return v(e).slice(0, 100)
            }
            let Ae, je, Fe;

            function He(t, e) {
                if (Fe = new Date, t.nodeType !== Node.ELEMENT_NODE) throw new Error("Can't generate CSS selector for non-element node type.");
                if ("html" === t.tagName.toLowerCase()) return "html";
                const s = {
                    root: document.body,
                    idName: t => !0,
                    className: t => !0,
                    tagName: t => !0,
                    attr: (t, e) => !1,
                    seedMinLength: 1,
                    optimizedMinLength: 2,
                    threshold: 1e3,
                    maxNumberOfTries: 1e4,
                    timeoutMs: void 0
                };
                Ae = { ...s,
                    ...e
                }, je = function(t, e) {
                    return t.nodeType === Node.DOCUMENT_NODE ? t : t === e.root ? t.ownerDocument : t
                }(Ae.root, s);
                let i = Be(t, "all", (() => Be(t, "two", (() => Be(t, "one", (() => Be(t, "none")))))));
                if (i) {
                    const e = ts(es(i, t));
                    return e.length > 0 && (i = e[0]), ze(i)
                }
                throw new Error("Selector was not found.")
            }

            function Be(t, e, s) {
                let i = null,
                    n = [],
                    r = t,
                    o = 0;
                for (; r;) {
                    const t = (new Date).getTime() - Fe.getTime();
                    if (void 0 !== Ae.timeoutMs && t > Ae.timeoutMs) throw new Error(`Timeout: Can't find a unique selector after ${t}ms`);
                    let a = Ye(We(r)) || Ye(...$e(r)) || Ye(...Ve(r)) || Ye(Xe(r)) || [{
                        name: "*",
                        penalty: 3
                    }];
                    const c = Ke(r);
                    if ("all" == e) c && (a = a.concat(a.filter(Ge).map((t => Je(t, c)))));
                    else if ("two" == e) a = a.slice(0, 1), c && (a = a.concat(a.filter(Ge).map((t => Je(t, c)))));
                    else if ("one" == e) {
                        const [t] = a = a.slice(0, 1);
                        c && Ge(t) && (a = [Je(t, c)])
                    } else "none" == e && (a = [{
                        name: "*",
                        penalty: 3
                    }], c && (a = [Je(a[0], c)]));
                    for (let t of a) t.level = o;
                    if (n.push(a), n.length >= Ae.seedMinLength && (i = Pe(n, s), i)) break;
                    r = r.parentElement, o++
                }
                return i || (i = Pe(n, s)), !i && s ? s() : i
            }

            function Pe(t, e) {
                const s = ts(Ze(t));
                if (s.length > Ae.threshold) return e ? e() : null;
                for (let t of s)
                    if (qe(t)) return t;
                return null
            }

            function ze(t) {
                let e = t[0],
                    s = e.name;
                for (let i = 1; i < t.length; i++) {
                    const n = t[i].level || 0;
                    s = e.level === n - 1 ? `${t[i].name} > ${s}` : `${t[i].name} ${s}`, e = t[i]
                }
                return s
            }

            function Ue(t) {
                return t.map((t => t.penalty)).reduce(((t, e) => t + e), 0)
            }

            function qe(t) {
                const e = ze(t);
                switch (je.querySelectorAll(e).length) {
                    case 0:
                        throw new Error(`Can't select any node with this selector: ${e}`);
                    case 1:
                        return !0;
                    default:
                        return !1
                }
            }

            function We(t) {
                const e = t.getAttribute("id");
                return e && Ae.idName(e) ? {
                    name: "#" + CSS.escape(e),
                    penalty: 0
                } : null
            }

            function $e(t) {
                const e = Array.from(t.attributes).filter((t => Ae.attr(t.name, t.value)));
                return e.map((t => ({
                    name: `[${CSS.escape(t.name)}="${CSS.escape(t.value)}"]`,
                    penalty: .5
                })))
            }

            function Ve(t) {
                return Array.from(t.classList).filter(Ae.className).map((t => ({
                    name: "." + CSS.escape(t),
                    penalty: 1
                })))
            }

            function Xe(t) {
                const e = t.tagName.toLowerCase();
                return Ae.tagName(e) ? {
                    name: e,
                    penalty: 2
                } : null
            }

            function Ke(t) {
                const e = t.parentNode;
                if (!e) return null;
                let s = e.firstChild;
                if (!s) return null;
                let i = 0;
                for (; s && (s.nodeType === Node.ELEMENT_NODE && i++, s !== t);) s = s.nextSibling;
                return i
            }

            function Je(t, e) {
                return {
                    name: t.name + `:nth-child(${e})`,
                    penalty: t.penalty + 1
                }
            }

            function Ge(t) {
                return "html" !== t.name && !t.name.startsWith("#")
            }

            function Ye(...t) {
                const e = t.filter(Qe);
                return e.length > 0 ? e : null
            }

            function Qe(t) {
                return null != t
            }

            function* Ze(t, e = []) {
                if (t.length > 0)
                    for (let s of t[0]) yield* Ze(t.slice(1, t.length), e.concat(s));
                else yield e
            }

            function ts(t) {
                return [...t].sort(((t, e) => Ue(t) - Ue(e)))
            }

            function* es(t, e, s = {
                counter: 0,
                visited: new Map
            }) {
                if (t.length > 2 && t.length > Ae.optimizedMinLength)
                    for (let i = 1; i < t.length - 1; i++) {
                        if (s.counter > Ae.maxNumberOfTries) return;
                        s.counter += 1;
                        const n = [...t];
                        n.splice(i, 1);
                        const r = ze(n);
                        if (s.visited.has(r)) return;
                        qe(n) && ss(n, e) && (yield n, s.visited.set(r, !0), yield* es(n, e, s))
                    }
            }

            function ss(t, e) {
                return je.querySelector(ze(t)) === e
            }

            function is(t) {
                const e = t.tagName.toUpperCase();
                return "BUTTON" === e || "A" === e || "LI" === e || "SELECT" === e || "TR" === e || "TH" === e || null != t.onclick || "button" === t.getAttribute("role")
            }

            function ns(t, e) {
                return t instanceof Element ? function(t, e) {
                    let s = t;
                    for (; null !== s && s !== e.documentElement;) {
                        if (x(s, "masked")) return null;
                        s = s.parentElement
                    }
                    if (Ft(t)) {
                        let e = t.ownerSVGElement;
                        for (; null !== e;) t = e, e = e.ownerSVGElement
                    }
                    for (s = t; null !== s && s !== e.documentElement;) {
                        const t = s.tagName.toUpperCase();
                        if ("LABEL" === t) return null;
                        if ("INPUT" === t) return s;
                        if (is(s) || null !== I(s)) return s;
                        s = s.parentElement
                    }
                    return t === e.documentElement ? null : t
                }(t, e) : null
            }

            function rs(t, e) {
                const {
                    disableClickmaps: s = !1
                } = e || {};
                let i, n = -1,
                    r = -1,
                    o = !1,
                    a = null,
                    c = 0,
                    h = {},
                    l = 0,
                    u = 0,
                    d = 0,
                    p = 0;
                t.attachStartCallback((() => {
                    i = setInterval((() => function() {
                        const e = p / 225;
                        l ? (d > 4 && (e - l) / 225 > .008 && t.send([114, y()]), p = 0, d = 0, l = e) : l = e
                    }()), 225)
                })), t.attachStopCallback((() => {
                    n = -1, r = -1, o = !1, a = null, h = {}, i && clearInterval(i)
                }));
                const f = () => {
                        o && (t.send([20, n, r]), o = !1)
                    },
                    g = (i, l = !1) => {
                        const g = l ? t.attachEventListener.bind(t) : t.nodes.attachNodeListener.bind(t.nodes);
                        g(i.documentElement, "mouseover", (t => {
                            const e = ns(t.target, i);
                            e !== a && (a = e, c = performance.now())
                        })), g(i, "mousemove", (e => {
                            const [s, a] = t.observer.getDocumentOffset(i);
                            n = e.clientX + s, r = e.clientY + a, o = !0;
                            const c = Math.sign(e.movementX);
                            p += Math.abs(e.movementX) + Math.abs(e.movementY), c !== u && (u = c, d++)
                        }), !1), g(i, "click", (n => {
                            const r = ns(n.target, i);
                            if (!n.clientX && !n.clientY || null === r) return;
                            const o = t.nodes.getID(r);
                            if (void 0 !== o) {
                                const l = n.pageX,
                                    u = n.pageY,
                                    d = i.documentElement.scrollWidth,
                                    p = i.documentElement.scrollHeight,
                                    g = os(l / d),
                                    m = os(u / p);
                                f(), t.send(function(t, e, s, i, n, r) {
                                    return [68, t, e, s, i, n, r]
                                }(o, a === r ? Math.round(performance.now() - c) : 0, function(e) {
                                    const s = I(e);
                                    if (null !== s) return s;
                                    if (Ut(e, "input")) return Le(e);
                                    if (is(e)) {
                                        let s = "";
                                        return e instanceof HTMLElement && (s = t.sanitizer.getInnerTextSecure(e)), s = s || e.id || e.className, v(s).slice(0, 100)
                                    }
                                    return ""
                                }(r), is(r) && !s ? function(t, e, s) {
                                    return h[t] = h[t] || function(t, e, s) {
                                        return He(t, {
                                            root: e.body,
                                            seedMinLength: 3,
                                            optimizedMinLength: s ? .minSelectorDepth || 2,
                                            threshold: s ? .nthThreshold || 1e3,
                                            maxNumberOfTries: s ? .maxOptimiseTries || 1e4
                                        })
                                    }(e, i, s)
                                }(o, r, e) : "", g, m), !0)
                            }
                            a = null
                        }))
                    };
                t.nodes.attachNodeCallback((t => {
                    Pt(t) && g(t)
                })), g(document, !0), t.ticker.attach(f, e ? .trackingOffset || 7)
            }

            function os(t) {
                return Math.round(1e4 * t)
            }

            function as(t) {
                const e = t.defaultView;
                return [e && e.scrollX || t.documentElement && t.documentElement.scrollLeft || t.body && t.body.scrollLeft || 0, e && e.scrollY || t.documentElement && t.documentElement.scrollTop || t.body && t.body.scrollTop || 0]
            }

            function cs(t) {
                return zt(t) && !!t.adoptedStyleSheets
            }
            let hs = 15;

            function ls() {
                return hs++
            }
            const us = new Map;
            var ds;
            ! function(t) {
                t[t.UNSENT = 0] = "UNSENT", t[t.OPENED = 1] = "OPENED", t[t.HEADERS_RECEIVED = 2] = "HEADERS_RECEIVED", t[t.LOADING = 3] = "LOADING", t[t.DONE = 4] = "DONE"
            }(ds || (ds = {}));
            class ps {
                constructor(t = [], e, s) {
                    this.ignoredHeaders = t, this.setSessionTokenHeader = e, this.sanitize = s, this.id = "", this.name = "", this.method = "", this.url = "", this.status = 0, this.statusText = "", this.cancelState = 0, this.readyState = 0, this.header = {}, this.responseType = "", this.requestHeader = {}, this.responseSize = 0, this.responseSizeText = "", this.startTime = 0, this.endTime = 0, this.duration = 0, this.getData = {}, this.requestData = null
                }
                getMessage() {
                    const {
                        reqHs: t,
                        resHs: e
                    } = this.writeHeaders(), s = {
                        headers: t,
                        body: "GET" === this.method ? JSON.stringify(this.getData) : this.requestData
                    }, i = {
                        headers: e,
                        body: this.response
                    }, n = this.sanitize({
                        url: this.url,
                        method: this.method,
                        status: this.status,
                        request: s,
                        response: i
                    });
                    if (n) return V(this.requestType, n.method, n.url, JSON.stringify(n.request), JSON.stringify(n.response), n.status, this.startTime + m(), this.duration, this.responseSize)
                }
                writeHeaders() {
                    const t = {};
                    Object.entries(this.requestHeader).forEach((([e, s]) => {
                        this.isHeaderIgnored(e) || (t[e] = s)
                    })), this.setSessionTokenHeader(((e, s) => {
                        t[e] = s
                    }));
                    const e = {};
                    return Object.entries(this.header).forEach((([t, s]) => {
                        this.isHeaderIgnored(t) || (e[t] = s)
                    })), {
                        reqHs: t,
                        resHs: e
                    }
                }
                isHeaderIgnored(t) {
                    return Array.isArray(this.ignoredHeaders) ? this.ignoredHeaders.map((t => t.toLowerCase())).includes(t.toLowerCase()) : this.ignoredHeaders
                }
            }
            const fs = (t, e) => {
                    let s = "";
                    switch (t) {
                        case "":
                        case "text":
                        case "json":
                            "string" == typeof e ? s = e : ms(e) || Array.isArray(e) ? s = JSON.stringify(e) : void 0 !== e && (s = Object.prototype.toString.call(e));
                            break;
                        default:
                            void 0 !== e && (s = Object.prototype.toString.call(e))
                    }
                    return s
                },
                gs = t => {
                    if (!t) return null;
                    let e;
                    if ("string" == typeof t) {
                        "{" !== t[0] && "[" !== t[0] || (e = t);
                        const s = t.split("&");
                        e = 1 === s.length ? t : s.join(",")
                    } else if (null == (s = t) || ArrayBuffer.isView(s) || "undefined" == typeof Symbol || "function" != typeof s[Symbol.iterator]) e = t instanceof Blob || t instanceof ReadableStream || t instanceof ArrayBuffer ? "byte data" : ms(t) ? t : "can't parse body " + typeof t;
                    else {
                        const s = [];
                        for (const [e, i] of t) s.push(`${e}=${"string"==typeof i?i:"[object Object]"}`);
                        e = s.join(",")
                    }
                    var s;
                    return e
                };

            function ms(t) {
                return null !== t && "object" == typeof t
            }

            function ys(t) {
                return t <= 0 ? "" : t >= 1e6 ? (t / 1e3 / 1e3).toFixed(1) + " MB" : t >= 1e3 ? (t / 1e3).toFixed(1) + " KB" : `${t}B`
            }
            const bs = t => (t.startsWith("//") && (t = `${new URL(window.location.href).protocol}${t}`), t.startsWith("http") ? new URL(t) : new URL(t, window.location.href));
            class vs {
                constructor(t, e) {
                    this.resp = t, this.item = e, this.mockReader()
                }
                set(t, e, s) {
                    return Reflect.set(t, e, s)
                }
                get(t, e) {
                    const s = Reflect.get(t, e);
                    switch (e) {
                        case "arrayBuffer":
                        case "blob":
                        case "formData":
                        case "json":
                        case "text":
                            return () => (this.item.responseType = e.toLowerCase(), s.apply(t).then((t => (this.item.response = fs(this.item.responseType, t), t))))
                    }
                    return "function" == typeof s ? s.bind(t) : s
                }
                mockReader() {
                    let t;
                    if (!this.resp.body) return;
                    if ("function" != typeof this.resp.body.getReader) return;
                    const e = this.resp.body.getReader;
                    this.resp.body.getReader = () => {
                        const s = e.apply(this.resp.body);
                        if (this.item.readyState === ds.DONE) return s;
                        const i = s.read,
                            n = s.cancel;
                        return this.item.responseType = "arraybuffer", s.read = () => i.apply(s).then((e => {
                            if (t) {
                                const s = new Uint8Array(t.length + e.value.length);
                                s.set(t), s.set(e.value, t.length), t = s
                            } else t = new Uint8Array(e.value);
                            return this.item.endTime = performance.now(), this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime), this.item.readyState = e.done ? 4 : 3, this.item.statusText = e.done ? String(this.item.status) : "Loading", this.item.responseSize = t.length, this.item.responseSizeText = ys(this.item.responseSize), e.done && (this.item.response = fs(this.item.responseType, t)), e
                        })), s.cancel = (...e) => (this.item.cancelState = 2, this.item.statusText = "Cancel", this.item.endTime = performance.now(), this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime), this.item.response = fs(this.item.responseType, t), n.apply(s, e)), s
                    }
                }
            }
            class Ss {
                constructor(t, e, s, i, n, r) {
                    this.ignoredHeaders = t, this.setSessionTokenHeader = e, this.sanitize = s, this.sendMessage = i, this.isServiceUrl = n, this.tokenUrlMatcher = r
                }
                apply(t, e, s) {
                    const i = s[0],
                        n = s[1];
                    if (!i || "string" != typeof i && !i ? .url) return t.apply(window, s);
                    if (i instanceof URL || "string" == typeof i ? this.isServiceUrl(String(i)) : this.isServiceUrl(String(i.url))) return t.apply(window, s);
                    const r = new ps(this.ignoredHeaders, this.setSessionTokenHeader, this.sanitize);
                    return this.beforeFetch(r, i, n), this.setSessionTokenHeader(((t, e) => {
                        if (void 0 === this.tokenUrlMatcher || this.tokenUrlMatcher(r.url)) return void 0 === s[1] && s[0] instanceof Request ? s[0].headers.append(t, e) : (s[1] || (s[1] = {}), void 0 === s[1].headers && (s[1] = { ...s[1],
                            headers: {}
                        }), void(s[1].headers instanceof Headers ? s[1].headers.append(t, e) : Array.isArray(s[1].headers) ? s[1].headers.push([t, e]) : s[1].headers[t] = e))
                    })), t.apply(window, s).then(this.afterFetch(r)).catch((t => {
                        throw r.endTime = performance.now(), r.duration = r.endTime - (r.startTime || r.endTime), t
                    }))
                }
                beforeFetch(t, e, s) {
                    let i, n = "GET",
                        r = {};
                    if ("string" == typeof e ? (n = s ? .method || "GET", i = bs(e), r = s ? .headers || {}) : (n = e.method || "GET", i = bs(e.url), r = e.headers), t.method = n, t.requestType = "fetch", t.requestHeader = r, t.url = i.toString(), t.name = (i.pathname.split("/").pop() || "") + i.search, t.status = 0, t.statusText = "Pending", t.readyState = 1, t.startTime || (t.startTime = performance.now()), "[object Headers]" === Object.prototype.toString.call(r)) {
                        t.requestHeader = {};
                        for (const [e, s] of r) t.requestHeader[e] = s
                    } else t.requestHeader = r;
                    if (i.search && i.searchParams) {
                        t.getData = {};
                        for (const [e, s] of i.searchParams) t.getData[e] = s
                    }
                    s ? .body && (t.requestData = gs(s.body))
                }
                afterFetch(t) {
                    return e => {
                        t.endTime = performance.now(), t.duration = t.endTime - (t.startTime || t.endTime), t.status = e.status, t.statusText = String(e.status);
                        let s = !1;
                        t.header = {};
                        for (const [i, n] of e.headers) t.header[i] = n, s = n.toLowerCase().indexOf("chunked") > -1 || s;
                        return s ? t.readyState = 3 : (t.readyState = 4, this.handleResponseBody(e.clone(), t).then((e => {
                            t.responseSize = "string" == typeof e ? e.length : e.byteLength, t.responseSizeText = ys(t.responseSize), t.response = fs(t.responseType, e);
                            const s = t.getMessage();
                            s && this.sendMessage(s)
                        })).catch((t => {
                            if ("AbortError" !== t.name) throw t
                        }))), new Proxy(e, new vs(e, t))
                    }
                }
                handleResponseBody(t, e) {
                    const s = t.headers.get("content-type");
                    return s && s.includes("application/json") ? (e.responseType = "json", t.text()) : s && (s.includes("text/html") || s.includes("text/plain")) ? (e.responseType = "text", t.text()) : (e.responseType = "arraybuffer", t.arrayBuffer())
                }
            }
            class ws {
                static create(t, e, s, i, n, r) {
                    return new Proxy(fetch, new Ss(t, e, s, i, n, r))
                }
            }
            class ks {
                constructor(t, e, s, i, n, r, o) {
                    this.ignoredHeaders = e, this.setSessionTokenHeader = s, this.sanitize = i, this.sendMessage = n, this.isServiceUrl = r, this.tokenUrlMatcher = o, this.XMLReq = t, this.XMLReq.onreadystatechange = () => {
                        this.onReadyStateChange()
                    }, this.XMLReq.onabort = () => {
                        this.onAbort()
                    }, this.XMLReq.ontimeout = () => {
                        this.onTimeout()
                    }, this.item = new ps(e, s, i), this.item.requestType = "xhr"
                }
                get(t, e) {
                    switch (e) {
                        case "open":
                            return this.getOpen(t);
                        case "send":
                            return this.setSessionTokenHeader(((e, s) => {
                                (void 0 === this.tokenUrlMatcher || this.tokenUrlMatcher(this.item.url)) && t.setRequestHeader(e, s)
                            })), this.getSend(t);
                        case "setRequestHeader":
                            return this.getSetRequestHeader(t);
                        default:
                            const s = Reflect.get(t, e);
                            return "function" == typeof s ? s.bind(t) : s
                    }
                }
                set(t, e, s) {
                    switch (e) {
                        case "onreadystatechange":
                            return this.setOnReadyStateChange(t, e, s);
                        case "onabort":
                            return this.setOnAbort(t, e, s);
                        case "ontimeout":
                            return this.setOnTimeout(t, e, s)
                    }
                    return Reflect.set(t, e, s)
                }
                onReadyStateChange() {
                    if (!(this.item.url && this.isServiceUrl(this.item.url) || (this.item.readyState = this.XMLReq.readyState, this.item.responseType = this.XMLReq.responseType, this.item.endTime = performance.now(), this.item.duration = this.item.endTime - this.item.startTime, this.updateItemByReadyState(), setTimeout((() => {
                            this.item.response = fs(this.item.responseType, this.item.response)
                        }), 0), this.XMLReq.readyState !== ds.DONE))) {
                        const t = this.item.getMessage();
                        t && this.sendMessage(t)
                    }
                }
                onAbort() {
                    this.item.cancelState = 1, this.item.statusText = "Abort";
                    const t = this.item.getMessage();
                    t && this.sendMessage(t)
                }
                onTimeout() {
                    this.item.cancelState = 3, this.item.statusText = "Timeout";
                    const t = this.item.getMessage();
                    t && this.sendMessage(t)
                }
                getOpen(t) {
                    const e = Reflect.get(t, "open");
                    return (...s) => {
                        const i = s[0],
                            n = s[1];
                        return this.item.method = i ? i.toUpperCase() : "GET", this.item.url = n.toString ? .() || "", this.item.name = this.item.url ? .replace(new RegExp("/*$"), "").split("/").pop() ? ? "", this.item.getData = ((t, e = {}) => {
                            ms(e) || (e = {});
                            let s = t ? t.split("?") : [];
                            if (s.shift(), s.length > 0) {
                                s = s.join("?").split("&");
                                for (const t of s) {
                                    const s = t.split("=");
                                    try {
                                        e[s[0]] = decodeURIComponent(s[1])
                                    } catch (t) {
                                        e[s[0]] = s[1]
                                    }
                                }
                            }
                            return e
                        })(this.item.url, {}), e.apply(t, s)
                    }
                }
                getSend(t) {
                    const e = Reflect.get(t, "send");
                    return (...s) => {
                        const i = s[0];
                        return this.item.requestData = gs(i), e.apply(t, s)
                    }
                }
                getSetRequestHeader(t) {
                    const e = Reflect.get(t, "setRequestHeader");
                    return (...s) => (this.item.requestHeader || (this.item.requestHeader = {}), this.item.requestHeader[s[0]] = s[1], e.apply(t, s))
                }
                setOnReadyStateChange(t, e, s) {
                    return Reflect.set(t, e, ((...e) => {
                        this.onReadyStateChange(), s ? .apply(t, e)
                    }))
                }
                setOnAbort(t, e, s) {
                    return Reflect.set(t, e, ((...e) => {
                        this.onAbort(), s.apply(t, e)
                    }))
                }
                setOnTimeout(t, e, s) {
                    return Reflect.set(t, e, ((...e) => {
                        this.onTimeout(), s.apply(t, e)
                    }))
                }
                updateItemByReadyState() {
                    switch (this.XMLReq.readyState) {
                        case ds.UNSENT:
                        case ds.OPENED:
                            this.item.status = ds.UNSENT, this.item.statusText = "Pending", this.item.startTime || (this.item.startTime = performance.now());
                            break;
                        case ds.HEADERS_RECEIVED:
                            this.item.status = this.XMLReq.status, this.item.statusText = "Loading", this.item.header = {};
                            const t = (this.XMLReq.getAllResponseHeaders() || "").split("\n");
                            for (let e = 0; e < t.length; e++) {
                                const s = t[e];
                                if (!s) continue;
                                const i = s.split(": "),
                                    n = i[0];
                                this.item.header[n] = i.slice(1).join(": ")
                            }
                            break;
                        case ds.LOADING:
                            this.item.status = this.XMLReq.status, this.item.statusText = "Loading", this.XMLReq.response && this.XMLReq.response.length && (this.item.responseSize = this.XMLReq.response.length, this.item.responseSizeText = ys(this.item.responseSize));
                            break;
                        case ds.DONE:
                            this.item.status = this.XMLReq.status || this.item.status || 0, this.item.statusText = String(this.item.status), this.item.endTime = performance.now(), this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime), this.item.response = this.XMLReq.response, this.XMLReq.response && this.XMLReq.response.length && (this.item.responseSize = this.XMLReq.response.length, this.item.responseSizeText = ys(this.item.responseSize));
                            break;
                        default:
                            this.item.status = this.XMLReq.status, this.item.statusText = "Unknown"
                    }
                }
            }
            class Ts {
                static create(t, e, s, i, n, r) {
                    return new Proxy(XMLHttpRequest, {
                        construct(o) {
                            const a = new o;
                            return new Proxy(a, new ks(a, t, e, s, i, n, r))
                        }
                    })
                }
            }
            const Is = t => t instanceof Blob ? t.type : t instanceof FormData ? "multipart/form-data" : t instanceof URLSearchParams ? "application/x-www-form-urlencoded;charset=UTF-8" : "text/plain;charset=UTF-8";
            class xs {
                constructor(t, e, s, i, n) {
                    this.ignoredHeaders = t, this.setSessionTokenHeader = e, this.sanitize = s, this.sendMessage = i, this.isServiceUrl = n
                }
                apply(t, e, s) {
                    const i = s[0],
                        n = s[1],
                        r = new ps(this.ignoredHeaders, this.setSessionTokenHeader, this.sanitize);
                    if (this.isServiceUrl(i)) return t.apply(e, s);
                    const o = bs(i);
                    if (r.method = "POST", r.url = i, r.name = (o.pathname.split("/").pop() || "") + o.search, r.requestType = "beacon", r.requestHeader = {
                            "Content-Type": Is(n)
                        }, r.status = 0, r.statusText = "Pending", o.search && o.searchParams) {
                        r.getData = {};
                        for (const [t, e] of o.searchParams) r.getData[t] = e
                    }
                    r.requestData = gs(n), r.startTime || (r.startTime = performance.now());
                    const a = t.apply(e, s);
                    a ? (r.endTime = performance.now(), r.duration = r.endTime - (r.startTime || r.endTime), r.status = 0, r.statusText = "Sent", r.readyState = 4) : (r.status = 500, r.statusText = "Unknown");
                    const c = r.getMessage();
                    return c && this.sendMessage(c), a
                }
            }
            class Es {
                static hasSendBeacon() {
                    return !!Es.origSendBeacon
                }
                static create(t, e, s, i, n) {
                    if (Es.hasSendBeacon()) return new Proxy(Es.origSendBeacon, new xs(t, e, s, i, n))
                }
            }
            Es.origSendBeacon = window ? .navigator ? .sendBeacon;
            var _s = s("ziTh");
            const Cs = t => _s.warn(`Openreplay: Can't find ${t} in global context. \nIf you're using serverside rendering in your app, make sure that tracker is loaded dynamically, otherwise ${t} won't be tracked.`);

            function Ns(t) {
                return t.__or_req_data__ || (t.__or_req_data__ = {
                    body: void 0,
                    headers: {}
                }), t.__or_req_data__
            }

            function Os(t) {
                return "string" == typeof t ? t.toUpperCase() : "GET"
            }

            function Rs(t, e = {}) {
                const s = Object.assign({
                    failuresOnly: !1,
                    ignoreHeaders: ["cookie", "set-cookie", "authorization"],
                    capturePayload: !1,
                    sessionTokenHeader: !1,
                    captureInIframes: !0,
                    axiosInstances: void 0,
                    useProxy: !0
                }, e);
                !1 === s.useProxy && t.debug.warn("Network module is migrating to proxy api, to gradually migrate and test it set useProxy to true");
                const i = s.ignoreHeaders,
                    n = Array.isArray(i) ? t => i.includes(t) : () => i,
                    r = !0 === s.sessionTokenHeader ? "X-OpenReplay-SessionToken" : s.sessionTokenHeader;

                function o(e) {
                    if (r) {
                        const s = t.getSessionToken();
                        s && t.safe(e)(r, s)
                    }
                }

                function a(t) {
                    if (s.capturePayload || (delete t.request.body, delete t.response.body), s.sanitizer) {
                        const e = t.response.body;
                        if ("string" == typeof e) try {
                            t.response.body = JSON.parse(e)
                        } catch {}
                        return s.sanitizer(t)
                    }
                    return t
                }

                function c(e) {
                    if (e && "string" != typeof e.body) try {
                        e.body = JSON.stringify(e.body)
                    } catch {
                        e.body = "<unable to stringify>", t.notify.warn("Openreplay fetch couldn't stringify body:", e.body)
                    }
                    return JSON.stringify(e)
                }
                const h = e => {
                    if (s.useProxy) return function(t, e, s, i, n, r, o) {
                        t.XMLHttpRequest ? t.XMLHttpRequest = Ts.create(e, s, i, n, r, o) : Cs("XMLHttpRequest"), t.fetch ? t.fetch = ws.create(e, s, i, n, r, o) : Cs("fetch"), t ? .navigator ? .sendBeacon && (t.navigator.sendBeacon = Es.create(e, s, i, n, r))
                    }(e, s.ignoreHeaders, o, a, (e => t.send(e)), (e => t.isServiceURL(e)), s.tokenUrlMatcher);
                    const r = e.fetch.bind(e);
                    e.fetch = (e, h = {}) => {
                        if (!("string" == typeof e || e instanceof URL) || t.isServiceURL(String(e))) return r(e, h);
                        o((function(t, e) {
                            void 0 === h.headers && (h.headers = {}), h.headers instanceof Headers ? h.headers.append(t, e) : Array.isArray(h.headers) ? h.headers.push([t, e]) : h.headers[t] = e
                        }));
                        const l = performance.now();
                        return r(e, h).then((r => {
                            const o = performance.now() - l;
                            if (s.failuresOnly && r.status < 400) return r;
                            const u = r.clone();
                            return u.text().then((s => {
                                const r = {},
                                    d = {};
                                if (!0 !== i) {
                                    const t = ([t, e]) => {
                                        n(t) || (r[t] = e)
                                    };
                                    h.headers instanceof Headers ? h.headers.forEach(((e, s) => t([s, e]))) : Array.isArray(h.headers) ? h.headers.forEach(t) : "object" == typeof h.headers && Object.entries(h.headers).forEach(t), u.headers.forEach(((t, e) => {
                                        n(e) || (d[e] = t)
                                    }))
                                }
                                const p = Os(h.method),
                                    f = a({
                                        url: String(e),
                                        method: p,
                                        status: u.status,
                                        request: {
                                            headers: r,
                                            body: h.body || null
                                        },
                                        response: {
                                            headers: d,
                                            body: s
                                        }
                                    });
                                f && t.send(V("fetch", p, String(f.url), c(f.request), c(f.response), u.status, l + m(), o, 0))
                            })).catch((e => t.debug.error("Could not process Fetch response:", e))), r
                        }))
                    };
                    const h = e.XMLHttpRequest.prototype.open,
                        l = e.XMLHttpRequest.prototype.setRequestHeader,
                        u = e.XMLHttpRequest.prototype.send;
                    s.axiosInstances || (e.XMLHttpRequest.prototype.open = function(e, s) {
                        const i = this;
                        o(((t, e) => i.setRequestHeader(t, e)));
                        let r = 0;
                        return i.addEventListener("loadstart", (t => {
                            r = t.timeStamp
                        })), i.addEventListener("load", t.safe((o => {
                            const {
                                headers: h,
                                body: l
                            } = Ns(i), u = r > 0 ? o.timeStamp - r : 0, d = (i.getAllResponseHeaders() || "").trim().split(/[\r\n]+/), p = {};
                            d.forEach((function(t) {
                                const e = t.split(": "),
                                    s = e.shift();
                                n(s) || (p[s] = e.join(": "))
                            }));
                            const f = Os(e),
                                g = a({
                                    url: String(s),
                                    method: f,
                                    status: i.status,
                                    request: {
                                        headers: h,
                                        body: l || null
                                    },
                                    response: {
                                        headers: p,
                                        body: i.response
                                    }
                                });
                            g && t.send(V("xhr", f, String(g.url), c(g.request), c(g.response), i.status, r + m(), u, 0))
                        }))), h.apply(this, arguments)
                    }, e.XMLHttpRequest.prototype.send = function(t) {
                        return Ns(this).body = t, u.apply(this, arguments)
                    }, e.XMLHttpRequest.prototype.setRequestHeader = function(t, e) {
                        return n(t) || (Ns(this).headers[t] = e), l.apply(this, arguments)
                    })
                };
                h(window), s.axiosInstances && s.axiosInstances.forEach((e => {
                    ! function(t, e, s, i, n) {
                        function r(e) {
                            t.debug.log("Openreplay: capturing axios response data", e);
                            const {
                                headers: r,
                                data: o,
                                method: a,
                                url: c,
                                baseURL: h
                            } = e.config, {
                                data: l,
                                headers: u,
                                status: d,
                                response: p
                            } = e, {
                                data: f,
                                headers: g,
                                status: y
                            } = p || {}, b = s.ignoreHeaders, v = Array.isArray(b) ? t => b.includes(t) : () => b;

                            function S(t, e) {
                                v(e[0]) || (t[e[0]] = e[1])
                            }
                            let w = {},
                                k = {};
                            r.toJSON ? w = r.toJSON() : r instanceof Headers ? r.forEach(((t, e) => S(w, [e, t]))) : Array.isArray(r) ? r.forEach((t => S(w, t))) : "object" == typeof r && Object.entries(r).forEach((t => S(w, t)));
                            const T = g || u;
                            T.toJSON ? k = T.toJSON() : T instanceof Headers ? T.forEach(((t, e) => S(k, [e, t]))) : Array.isArray(T) ? T.forEach((t => S(k, t))) : "object" == typeof T && Object.entries(T).forEach((([t, e]) => {
                                v(t) || (k[t] = e)
                            }));
                            const I = i({
                                url: c,
                                method: a || "",
                                status: d || y || 0,
                                request: {
                                    headers: w,
                                    body: o
                                },
                                response: {
                                    headers: k,
                                    body: f || l
                                }
                            });
                            if (!I) return void t.debug.log("Openreplay: empty request/response info, skipping");
                            const x = e.config.__openreplay_timing,
                                E = performance.now() - x;
                            t.debug.log("Openreplay: final req object", I), t.send(V("xhr", String(a), String(I.url), n(I.request), n(I.response), I.status, x + m(), E, 0))
                        }
                        t.debug.log("Openreplay: attaching axios spy to instance", e);
                        const o = e.interceptors.request.use((function(e) {
                                if (t.debug.log("Openreplay: capturing API request", e), e.__openreplay_timing = performance.now(), s.sessionTokenHeader) {
                                    const i = "string" == typeof s.sessionTokenHeader ? s.sessionTokenHeader : "X-OpenReplay-Session-Token",
                                        n = t.getSessionToken();
                                    n && e.headers.set(i, n)
                                }
                                return e
                            }), (function(e) {
                                t.debug.log("Openreplay: failed API request, skipping", e)
                            }), {
                                synchronous: !0
                            }),
                            a = e.interceptors.response.use((function(t) {
                                return s.failuresOnly || r(t), t
                            }), (function(e) {
                                var s, i;
                                return t.debug.log("Openreplay: capturing API request error", e), null !== (i = s = e) && "object" == typeof i && !0 === s.isAxiosError && Boolean(e.response) ? r(e.response) : e instanceof Error && t.send(Ne(e, [])), Promise.reject(e)
                            }), {
                                synchronous: !0
                            });
                        t.attachStopCallback((() => {
                            e.interceptors.request.eject ? .(o), e.interceptors.response.eject ? .(a)
                        }))
                    }(t, e, s, a, c)
                })), s.captureInIframes && t.observer.attachContextCallback(t.safe(h))
            }
            var Ms = s("ziTh");
            const Ds = "/installation/javascript-sdk";
            class Ls {
                constructor(t) {
                    if (this.options = t, this.app = null, this.crossdomainMode = !1, this.checkDoNotTrack = () => this.options.respectDoNotTrack && ("1" == navigator.doNotTrack || "1" == window.doNotTrack), this.signalStartIssue = (t, e) => {
                            const s = this.checkDoNotTrack(),
                                i = new XMLHttpRequest,
                                n = this.options.ingestPoint || de;
                            i.open("POST", n + "/v1/web/not-started"), i.send(JSON.stringify({
                                trackerVersion: "14.0.6",
                                projectKey: this.options.projectKey,
                                doNotTrack: s,
                                reason: e.length ? `missing api: ${e.join(",")}` : t
                            }))
                        }, this.restartCanvasTracking = () => {
                            null !== this.app && this.app.restartCanvasTracking()
                        }, this.handleError = (t, e = {}) => {
                            if (null !== this.app)
                                if (t instanceof Error) {
                                    const s = Ne(t, [], e);
                                    this.app.send(s)
                                } else if (t instanceof ErrorEvent || "PromiseRejectionEvent" in window && t instanceof PromiseRejectionEvent) {
                                const s = Oe(t, void 0, e);
                                null != s && this.app.send(s)
                            }
                        }, this.crossdomainMode = Boolean(function() {
                            try {
                                return window.self && window.top && window.self !== window.top
                            } catch (t) {
                                return !0
                            }
                        }() && t.crossdomain ? .enabled), !d || ! function(t) {
                            if (null == t) return Ms.error(`OpenReplay: invalid options argument type. Please, check documentation on ${w}${Ds}`), !1;
                            if ("string" != typeof t.projectKey)
                                if ("number" != typeof t.projectKey) {
                                    if ("number" != typeof t.projectID) return Ms.error(`OpenReplay: projectKey is missing or wrong type (string is expected). Please, check ${w}${Ds} for more information.`), !1;
                                    t.projectKey = t.projectID.toString(), T("`projectID` option", "`projectKey` option", Ds)
                                } else Ms.warn("OpenReplay: projectKey is expected to have a string type."), t.projectKey = t.projectKey.toString();
                            return null != t.sessionToken && T("`sessionToken` option", "`sessionHash` start() option", "/"), !0
                        }(t)) return;
                    if (window.__OPENREPLAY__) return void Ms.error("OpenReplay: one tracker instance has been initialised already");
                    if (!t.__DISABLE_SECURE_MODE && "https:" !== location.protocol) return void Ms.error("OpenReplay: Your website must be publicly accessible and running on SSL in order for OpenReplay to properly capture and replay the user session. You can disable this check by setting `__DISABLE_SECURE_MODE` option to `true` if you are testing in localhost. Keep in mind, that asset files on a local machine are not available to the outside world. This might affect tracking if you use css files.");
                    const e = [],
                        s = ["Map", "Set", "MutationObserver", "performance", "timing", "startsWith", "Blob", "Worker"];
                    if (this.checkDoNotTrack()) e.push("doNotTrack");
                    else
                        for (const t of s)
                            if ("timing" === t) {
                                if ("performance" in window && !(t in performance)) {
                                    e.push(t);
                                    break
                                }
                            } else if ("startsWith" === t) {
                        if (!(t in String.prototype)) {
                            e.push(t);
                            break
                        }
                    } else if (!(t in window)) {
                        e.push(t);
                        break
                    }
                    if (e.length > 0) {
                        const t = e.join(",");
                        return Ms.error(`OpenReplay: browser doesn't support API required for tracking or doNotTrack is set to 1. Reason: ${t}`), void this.signalStartIssue("missing_api", e)
                    }
                    const i = new we(t.projectKey, t.sessionToken, t, this.signalStartIssue, this.crossdomainMode);
                    this.app = i, this.crossdomainMode || (function(t) {
                            let e, s, i, n, r = document.referrer;
                            const o = t.safe((() => {
                                    const {
                                        URL: s
                                    } = document;
                                    s !== e && (e = s, t.send(function(t, e, s, i) {
                                        return [122, t, e, s, document.title]
                                    }(e, r, n)), n = 0, r = e)
                                })),
                                a = t.safe((() => {
                                    const {
                                        innerWidth: e,
                                        innerHeight: n
                                    } = window;
                                    e === s && n === i || (s = e, i = n, t.send(function(t, e) {
                                        return [5, t, e]
                                    }(s, i)))
                                })),
                                c = void 0 === document.hidden ? Function.prototype : t.safe((() => t.send([55, document.hidden])));
                            t.attachStartCallback((() => {
                                e = null, n = m(), s = i = -1, o(), a(), c()
                            })), void 0 !== document.hidden && t.attachEventListener(document, "visibilitychange", c, !1, !1), t.ticker.attach(o, 1, !1), t.ticker.attach(a, 5, !1)
                        }(i), function(t) {
                            const e = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                            if (void 0 === e) return;
                            const s = () => t.send([54, Math.round(1e3 * e.downlink), e.type || "unknown"]);
                            s(), e.addEventListener("change", s)
                        }(i), function(t, e) {
                            if (!Object.assign({
                                    capturePerformance: !0
                                }, e).capturePerformance) return;
                            let s, i;
                            const n = () => {
                                void 0 !== s && -1 !== s && (s++, requestAnimationFrame(n))
                            };
                            t.ticker.attach((() => {
                                void 0 !== i && -1 !== i && i++
                            }), 0, !1);
                            const r = () => {
                                void 0 !== s && void 0 !== i && (t.send(function(t, e, s, i) {
                                    return [49, t, e, s, i]
                                }(s, i, Y.memory.totalJSHeapSize || 0, Y.memory.usedJSHeapSize || 0)), i = s = document.hidden ? -1 : 0)
                            };
                            t.attachStartCallback((() => {
                                i = s = -1, r(), n()
                            })), t.attachStopCallback((() => {
                                i = s = void 0
                            })), t.ticker.attach(r, 40, !1), void 0 !== document.hidden && t.attachEventListener(document, "visibilitychange", r, !1, !1)
                        }(i, t), function(t) {
                            t.attachEventListener(window, "focus", (function() {
                                document.hidden || (t.debug.log("Openreplay: tab change to" + t.session.getTabId()), t.send(J(t.session.getTabId())))
                            }), !1, !1)
                        }(i)), rs(i, t.mouse),
                        function(t, e) {
                            let s = !1;
                            const i = new Map;

                            function n(t) {
                                jt(t) && (Ht(t) && i.set(t, [t.scrollLeft, t.scrollTop]), Pt(t) && i.set(t, as(t)))
                            }
                            const r = t.safe((() => {
                                    e || t.send(function(t, e) {
                                        return [6, t, e]
                                    }(...as(document)))
                                })),
                                o = t.safe(((e, s) => {
                                    const i = t.nodes.getID(s);
                                    void 0 !== i && t.send(function(t, e, s) {
                                        return [16, t, e, s]
                                    }(i, e[0], e[1]))
                                }));
                            t.attachStartCallback(r), t.attachStopCallback((() => {
                                s = !1, i.clear()
                            })), t.nodes.attachNodeCallback(((e, s) => {
                                s && (Ht(e) && e.scrollLeft + e.scrollTop > 0 ? i.set(e, [e.scrollLeft, e.scrollTop]) : Pt(e) && i.set(e, as(e))), zt(e) && t.nodes.attachNodeListener(e, "scroll", (t => {
                                    n(t.target)
                                }))
                            })), t.attachEventListener(document, "scroll", (t => {
                                const e = t.target;
                                e !== document ? n(e) : s = !0
                            })), t.ticker.attach((() => {
                                s && (r(), s = !1), i.forEach(o), i.clear()
                            }), 5, !1)
                        }(i, this.crossdomainMode),
                        function(t) {
                            if (null === t) return;
                            if (!window.CSSStyleSheet) return void t.send(("no_stylesheet_prototype_in_window", "", [63, "no_stylesheet_prototype_in_window", ""]));
                            const e = t.safe(((e, s, i) => {
                                    const n = us.get(e);
                                    n && ("string" == typeof i ? t.send(z(n, i, s, t.getBaseHref())) : t.send(U(n, s)))
                                })),
                                s = t.safe((e => {
                                    let s = e;
                                    for (; s.parentRule;) s = s.parentRule;
                                    const i = s.parentStyleSheet;
                                    if (!i) return void t.debug.warn("No parent StyleSheet found for", s, e);
                                    const n = us.get(i);
                                    if (!n) return void t.debug.warn("No sheedID found for", i, us);
                                    const r = s.cssText,
                                        o = i.cssRules,
                                        a = Array.from(o).indexOf(s);
                                    a >= 0 ? (t.send(z(n, r, a, t.getBaseHref())), t.send(U(n, a + 1))) : t.debug.warn("Rule index not found in", i, s)
                                })),
                                i = t.safe((t => {
                                    const {
                                        insertRule: i,
                                        deleteRule: n
                                    } = t.CSSStyleSheet.prototype, {
                                        insertRule: r,
                                        deleteRule: o
                                    } = t.CSSGroupingRule.prototype;
                                    t.CSSStyleSheet.prototype.insertRule = function(t, s = 0) {
                                        return e(this, s, t), i.call(this, t, s)
                                    }, t.CSSStyleSheet.prototype.deleteRule = function(t) {
                                        return e(this, t), n.call(this, t)
                                    }, t.CSSGroupingRule.prototype.insertRule = function(t, e = 0) {
                                        const i = r.call(this, t, e);
                                        return s(this), i
                                    }, t.CSSGroupingRule.prototype.deleteRule = function(t = 0) {
                                        const e = o.call(this, t);
                                        return s(this), e
                                    }
                                }));
                            i(window), t.observer.attachContextCallback(i), t.nodes.attachNodeCallback((s => {
                                if (!Ut(s, "style") || !s.sheet) return;
                                if (null !== s.textContent && s.textContent.trim().length > 0) return;
                                const i = t.nodes.getID(s);
                                if (!i) return;
                                const n = s.sheet,
                                    r = ls();
                                us.set(n, r), t.send(q(r, i));
                                const o = n.cssRules;
                                for (let t = 0; t < o.length; t++) e(n, t, o[t].cssText)
                            }))
                        }(i),
                        function(t) {
                            if (null === t) return;
                            if (!cs(document)) return;
                            const e = new Map,
                                s = new Map,
                                i = i => setTimeout((() => {
                                    let n = t.nodes.getID(i);
                                    if (i === document && (n = 0), void 0 === n) return;
                                    let r = s.get(n);
                                    r || (r = []);
                                    const o = [],
                                        a = i.adoptedStyleSheets;
                                    if (a && Symbol.iterator in a)
                                        for (const s of a) {
                                            let i = e.get(s);
                                            const a = !i;
                                            if (i || (i = ls(), e.set(s, i)), r.includes(i) || t.send(q(i, n)), a) {
                                                const e = s.cssRules;
                                                for (let s = 0; s < e.length; s++) t.send(z(i, e[s].cssText, s, t.getBaseHref()))
                                            }
                                            o.push(i)
                                        }
                                    if (Symbol.iterator in r)
                                        for (const e of r) o.includes(e) || t.send(W(e, n));
                                    s.set(n, o)
                                }), 20);

                            function n(t) {
                                const e = Object.getOwnPropertyDescriptor(t, "adoptedStyleSheets");
                                e && Object.defineProperty(t, "adoptedStyleSheets", { ...e,
                                    set: function(t) {
                                        const s = e.set.call(this, t);
                                        return i(this), s
                                    }
                                })
                            }
                            const r = s => {
                                if (s.__openreplay_adpss_patched__) return;
                                s.__openreplay_adpss_patched__ = !0, n(s.Document.prototype), n(s.ShadowRoot.prototype);
                                const {
                                    replace: i,
                                    replaceSync: r
                                } = s.CSSStyleSheet.prototype;
                                s.CSSStyleSheet.prototype.replace = function(s) {
                                    return i.call(this, s).then((i => {
                                        const n = e.get(this);
                                        return n && t.send(P(n, s, t.getBaseHref())), i
                                    }))
                                }, s.CSSStyleSheet.prototype.replaceSync = function(s) {
                                    const i = e.get(this);
                                    return i && t.send(P(i, s, t.getBaseHref())), r.call(this, s)
                                }
                            };
                            r(window), t.observer.attachContextCallback(t.safe(r)), t.attachStopCallback((() => {
                                e.clear(), s.clear()
                            })), t.attachStartCallback((() => {
                                i(document)
                            })), t.nodes.attachNodeCallback((t => {
                                cs(t) && i(t)
                            }))
                        }(i), Ee(i, t),
                        function(t, e) {
                            function s(e) {
                                function s(s) {
                                    const i = Oe(s, e);
                                    null != i && t.send(i)
                                }
                                t.attachEventListener(e, "unhandledrejection", s), t.attachEventListener(e, "error", s)
                            }
                            Object.assign({
                                captureExceptions: !0
                            }, e).captureExceptions && (t.observer.attachContextCallback(s), s(window))
                        }(i, t),
                        function(t) {
                            function e(e, s) {
                                t.attributeSender.sendSetAttribute(e, "src", "https://static.openreplay.com/tracker/placeholder.jpeg");
                                const {
                                    width: i,
                                    height: n
                                } = s.getBoundingClientRect();
                                s.hasAttribute("width") || t.attributeSender.sendSetAttribute(e, "width", String(i)), s.hasAttribute("height") || t.attributeSender.sendSetAttribute(e, "height", String(n))
                            }
                            const s = function(e, s) {
                                    const {
                                        srcset: i
                                    } = s;
                                    if (!i) return;
                                    const n = i.split(i.match(/,\s+/) ? /,\s+/ : ",").map((t => Re(t))).join(", ");
                                    t.attributeSender.sendSetAttribute(e, "srcset", n)
                                },
                                i = function(s, i) {
                                    i.src.length > 1e5 && e(s, i), t.send(H(s, "src", i.src, t.getBaseHref()))
                                },
                                n = t.safe((function(e) {
                                    const s = Re(e.src || "");
                                    S(s) && t.send(K(t.timestamp(), 0, 0, 0, 0, 0, s, "img", 0, !1))
                                })),
                                r = t.safe((function(r) {
                                    const o = t.nodes.getID(r);
                                    var a;
                                    void 0 !== o && r.complete && (0 !== r.naturalHeight || 0 !== r.naturalWidth || (a = r.src, p && (a.startsWith("data:image/svg+xml") || a.match(/.svg$|/i))) ? t.sanitizer.isHidden(o) || t.sanitizer.isObscured(o) ? e(o, r) : (i(o, r), s(o, r)) : n(r))
                                })),
                                o = C(t.safe((e => {
                                    for (const n of e)
                                        if ("attributes" === n.type) {
                                            const e = n.target,
                                                r = t.nodes.getID(e);
                                            if (void 0 === r) return;
                                            "src" === n.attributeName && i(r, e), "srcset" === n.attributeName && s(r, e)
                                        }
                                })));
                            t.attachStopCallback((() => {
                                o.disconnect()
                            })), t.nodes.attachNodeCallback((e => {
                                Ut(e, "img") && (t.nodes.attachNodeListener(e, "error", (() => n(e))), t.nodes.attachNodeListener(e, "load", (() => r(e))), r(e), o.observe(e, {
                                    attributes: !0,
                                    attributeFilter: ["src", "srcset"]
                                }))
                            }))
                        }(i),
                        function(t, e) {
                            const s = Object.assign({
                                obscureInputNumbers: !0,
                                obscureInputEmails: !0,
                                defaultInputMode: 1,
                                obscureInputDates: !1
                            }, e);

                            function i(e, i) {
                                let n = i.value,
                                    r = s.defaultInputMode;
                                "password" === i.type || t.sanitizer.isHidden(e) ? r = 2 : (t.sanitizer.isObscured(e) || 0 === r && (s.obscureInputNumbers && "date" !== i.type && /\d\d\d\d/.test(n) || s.obscureInputDates && "date" === i.type || s.obscureInputEmails && ("email" === i.type || ~n.indexOf("@")))) && (r = 1);
                                let o = 0;
                                switch (r) {
                                    case 2:
                                        o = -1, n = "";
                                        break;
                                    case 1:
                                        o = n.length, n = ""
                                }
                                return {
                                    value: n,
                                    mask: o
                                }
                            }

                            function n(e, s) {
                                const {
                                    value: n,
                                    mask: r
                                } = i(e, s);
                                t.send(function(t, e, s) {
                                    return [18, t, e, s]
                                }(e, n, r))
                            }
                            const r = new Map,
                                o = new Map;

                            function a(t, e) {
                                r.get(t) !== e.value && (r.set(t, e.value), n(t, e))
                            }

                            function c(e, s) {
                                o.get(e) !== s && (o.set(e, s), t.send(function(t, e) {
                                    return [19, t, e]
                                }(e, s)))
                            }
                            t.attachStopCallback((() => {
                                r.clear(), o.clear()
                            })), t.ticker.attach((() => {
                                r.forEach(((e, s) => {
                                    const i = t.nodes.getNode(s);
                                    if (!i) return r.delete(s);
                                    a(s, i)
                                })), o.forEach(((e, s) => {
                                    const i = t.nodes.getNode(s);
                                    if (!i) return o.delete(s);
                                    c(s, i.checked)
                                }))
                            }), 3), t.nodes.attachNodeCallback(t.safe((e => {
                                const s = t.nodes.getID(e);
                                if (void 0 !== s) {
                                    if (Ut(e, "select") && (n(s, e), t.nodes.attachNodeListener(e, "change", (() => n(s, e)))), function(t) {
                                            return !!Ut(t, "textarea") || !!Ut(t, "input") && Me.includes(t.type)
                                        }(e)) {
                                        a(s, e);
                                        let n = 0,
                                            r = 0,
                                            o = 0;
                                        const c = () => {
                                                n = y()
                                            },
                                            h = () => {
                                                0 === r && 0 !== n && (r = y() - n)
                                            },
                                            l = () => {
                                                0 !== n && (o = y() - n),
                                                    function(e, s, n, r) {
                                                        const {
                                                            value: o,
                                                            mask: a
                                                        } = i(e, s), c = Le(s);
                                                        t.send(function(t, e, s, i, n, r) {
                                                            return [112, t, e, s, i, n, r]
                                                        }(e, o, 0 !== a, c, n, r))
                                                    }(s, e, r, o), r = 0, o = 0, n = 0
                                            };
                                        return t.nodes.attachNodeListener(e, "focus", c), t.nodes.attachNodeListener(e, "input", h), void t.nodes.attachNodeListener(e, "change", l)
                                    }
                                    return function(t) {
                                        if (!Ut(t, "input")) return !1;
                                        const e = t.type;
                                        return "checkbox" === e || "radio" === e
                                    }(e) ? (c(s, e.checked), void t.nodes.attachNodeListener(e, "change", (() => c(s, e.checked)))) : void 0
                                }
                            })))
                        }(i, t),
                        function(t, e) {
                            const s = Object.assign({
                                captureResourceTimings: !0,
                                capturePageLoadTimings: !0,
                                capturePageRenderTimings: !0,
                                excludedResourceUrls: []
                            }, e);
                            if ("PerformanceObserver" in window || (s.captureResourceTimings = !1), !s.captureResourceTimings) return;
                            let i = {};

                            function n(e) {
                                if (e.duration < 0 || !S(e.name) || t.isServiceURL(e.name)) return;
                                null !== i && (i[e.name] = e.startTime + e.duration);
                                let n = !1;
                                s.excludedResourceUrls ? .forEach((t => {
                                    e.name.startsWith(t) && (n = !0)
                                })), n || t.send(K(e.startTime + m(), e.duration, e.responseStart && e.startTime ? e.responseStart - e.startTime : 0, e.transferSize > e.encodedBodySize ? e.transferSize - e.encodedBodySize : 0, e.encodedBodySize || 0, e.decodedBodySize || 0, e.name, e.initiatorType, e.transferSize, e.responseStatus && 304 === e.responseStatus || 0 === e.transferSize))
                            }
                            const r = new PerformanceObserver((t => t.getEntries().forEach(n)));
                            let o;
                            t.attachStartCallback((function({
                                sessionID: t
                            }) {
                                t !== o && (performance.getEntriesByType("resource").forEach(n), o = t), r.observe({
                                    entryTypes: ["resource"]
                                })
                            })), t.attachStopCallback((function() {
                                r.disconnect()
                            }));
                            let a = 0,
                                c = 0;
                            if (s.capturePageLoadTimings) {
                                let e = !1;
                                t.ticker.attach((() => {
                                    if (!e && (0 !== a && 0 !== c || performance.getEntriesByType("paint").forEach((t => {
                                            const {
                                                name: e,
                                                startTime: s
                                            } = t;
                                            switch (e) {
                                                case "first-paint":
                                                    a = s;
                                                    break;
                                                case "first-contentful-paint":
                                                    c = s
                                            }
                                        })), performance.timing.loadEventEnd || performance.now() > 3e4)) {
                                        e = !0;
                                        const {
                                            navigationStart: s,
                                            requestStart: i,
                                            responseStart: n,
                                            responseEnd: r,
                                            domContentLoadedEventStart: o,
                                            domContentLoadedEventEnd: h,
                                            loadEventStart: l,
                                            loadEventEnd: u
                                        } = performance.timing;
                                        t.send(function(t, e, s, i, n, r, o, a, c) {
                                            return [23, t, e, s, i, n, r, o, a, c]
                                        }(i - s || 0, n - s || 0, r - s || 0, o - s || 0, h - s || 0, l - s || 0, u - s || 0, a, c))
                                    }
                                }), 30)
                            }
                            if (s.capturePageRenderTimings) {
                                let e = 0,
                                    s = 0,
                                    n = 0,
                                    r = null,
                                    o = !1;
                                t.ticker.attach((() => {
                                    if (o) return;
                                    const h = performance.now();
                                    if (null !== i && (e = Math.max.apply(null, Object.keys(i).map((t => i[t]))), h - e > 1e3 && (r = function(t) {
                                            const e = [],
                                                s = document.getElementsByTagName("*"),
                                                i = /url\(("[^"]*"|'[^']*'|[^)]*)\)/i;
                                            for (let n = 0; n < s.length; n++) {
                                                const r = s[n];
                                                let o = "";
                                                if (Ut(r, "img") && (o = r.currentSrc || r.src), !o) {
                                                    const t = getComputedStyle(r).getPropertyValue("background-image");
                                                    if (t) {
                                                        const e = i.exec(t);
                                                        null !== e && (o = e[1], (o.startsWith('"') || o.startsWith("'")) && (o = o.substr(1, o.length - 2)))
                                                    }
                                                }
                                                if (!o) continue;
                                                const a = "data:image" === o.substr(0, 10) ? 0 : t[o];
                                                if (void 0 === a) continue;
                                                const c = r.getBoundingClientRect(),
                                                    h = Math.max(c.top, 0),
                                                    l = Math.max(c.left, 0),
                                                    u = Math.min(c.bottom, window.innerHeight || document.documentElement && document.documentElement.clientHeight || 0),
                                                    d = Math.min(c.right, window.innerWidth || document.documentElement && document.documentElement.clientWidth || 0);
                                                if (u <= h || d <= l) continue;
                                                const p = (u - h) * (d - l);
                                                e.push({
                                                    time: a,
                                                    area: p
                                                })
                                            }
                                            return e
                                        }(i), i = null)), null !== n && (h - n > 50 && (s = h), n = h - s > 5e3 ? null : h), null !== r && null === n || h > 3e4) {
                                        o = !0, i = null;
                                        const h = null === r ? 0 : function(t, e) {
                                                let s = Math.max(document.documentElement && document.documentElement.clientWidth || 0, window.innerWidth || 0) * Math.max(document.documentElement && document.documentElement.clientHeight || 0, window.innerHeight || 0) / 10,
                                                    i = s * t;
                                                for (let n = 0; n < e.length; n++) {
                                                    const {
                                                        time: r,
                                                        area: o
                                                    } = e[n];
                                                    s += o, i += o * (r > t ? r : t)
                                                }
                                                return 0 === s ? 0 : i / s
                                            }(c || a, r),
                                            {
                                                domContentLoadedEventEnd: l,
                                                navigationStart: u
                                            } = performance.timing,
                                            d = null === n ? Math.max(s, c, l - u || 0) : 0;
                                        t.send(function(t, e, s) {
                                            return [24, t, e, s]
                                        }(h, c > e ? c : e, d))
                                    }
                                }))
                            }
                        }(i, t),
                        function(t) {
                            function e(e) {
                                const s = t.nodes.getID(e);
                                void 0 !== s && t.send(F(s))
                            }
                            let s = !1;
                            t.nodes.attachNodeCallback((i => {
                                Ut(i, "body") && (t.nodes.attachNodeListener(i, "focus", (t => {
                                    jt(t.target) && (e(t.target), s = !1)
                                })), t.nodes.attachNodeListener(i, "blur", (e => {
                                    null === e.relatedTarget && (s = !0, setTimeout((() => {
                                        s && t.send(F(-1))
                                    }), 0))
                                })))
                            })), t.attachStartCallback((() => {
                                let t = document.activeElement;
                                for (; t && Ut(t, "iframe") && t.contentDocument;) t = t.contentDocument.activeElement;
                                t && t !== t.ownerDocument.body && e(t)
                            }), !0)
                        }(i),
                        function(t) {
                            if (!window.FontFace) return;
                            const e = new Map,
                                s = s => {
                                    class i extends s.FontFace {
                                        constructor(...i) {
                                            if ("string" == typeof i[1]) {
                                                let n = "";
                                                i[2] && t.safe((() => {
                                                    n = JSON.stringify(i[2])
                                                }));
                                                const r = [i[0], i[1], n],
                                                    o = e.get(s.document) || [];
                                                o.push(r), e.set(s.document, o);
                                                const a = s === window ? 0 : t.nodes.getID(s.document);
                                                if (void 0 === a) return;
                                                t.active() && t.send(j(a, ...r))
                                            }
                                            super(...i)
                                        }
                                    }
                                    s.FontFace = i
                                };
                            t.observer.attachContextCallback(s), s(window), t.nodes.attachNodeCallback(t.safe((s => {
                                if (!Pt(s)) return;
                                const i = e.get(s);
                                if (!i) return;
                                const n = s.defaultView === window ? 0 : t.nodes.getID(s);
                                void 0 !== n && i.forEach((e => {
                                    t.send(j(n, ...e))
                                }))
                            })))
                        }(i), Rs(i, t.network),
                        function(t) {
                            t.attachEventListener(document, "selectionchange", (() => {
                                const e = document.getSelection();
                                if (null === e || e.isCollapsed) t.send(X(-1, -1, ""));
                                else {
                                    const s = t.nodes.getID(e.anchorNode),
                                        i = t.nodes.getID(e.focusNode),
                                        n = e.toString().replace(/\s+/g, " ");
                                    s && i && t.send(X(s, i, n))
                                }
                            }))
                        }(i), window.__OPENREPLAY__ = this, t.flags && t.flags.onFlagsLoad && this.onFlagsLoad(t.flags.onFlagsLoad);
                    const n = window.open;
                    (t.autoResetOnWindowOpen || t.resetTabOnWindowOpen) && (i.attachStartCallback((() => {
                        const e = i.getTabId(),
                            s = i.sessionStorage ? ? window.sessionStorage;
                        window.open = function(...r) {
                            return t.autoResetOnWindowOpen && i.resetNextPageSession(!0), t.resetTabOnWindowOpen && s.removeItem(t.session_tabid_key || "__openreplay_tabid"), i.resetNextPageSession(!1), s.setItem(t.session_tabid_key || "__openreplay_tabid", e), n.call(window, ...r)
                        }
                    })), i.attachStopCallback((() => {
                        window.open = n
                    })))
                }
                isFlagEnabled(t) {
                    return this.featureFlags.isFlagEnabled(t)
                }
                onFlagsLoad(t) {
                    this.app ? .featureFlags.onFlagsLoad(t)
                }
                clearPersistFlags() {
                    this.app ? .featureFlags.clearPersistFlags()
                }
                reloadFlags() {
                    return this.app ? .featureFlags.reloadFlags()
                }
                getFeatureFlag(t) {
                    return this.app ? .featureFlags.getFeatureFlag(t)
                }
                getAllFeatureFlags() {
                    return this.app ? .featureFlags.flags
                }
                use(t) {
                    return t(this.app, this.options)
                }
                isActive() {
                    return null !== this.app && this.app.active()
                }
                trackWs(t) {
                    if (null !== this.app) return this.app.trackWs(t)
                }
                start(t) {
                    return this.browserEnvCheck() ? null === this.app ? Promise.reject("Browser doesn't support required api, or doNotTrack is active.") : this.app.start(t) : Promise.reject("Trying to start not in browser.")
                }
                browserEnvCheck() {
                    return !!d || (Ms.error(`OpenReplay: you are trying to start Tracker on a node.js environment. If you want to use OpenReplay with SSR, please, use componentDidMount or useEffect API for placing the \`tracker.start()\` line. Check documentation on ${w}${Ds}`), !1)
                }
                coldStart(t, e) {
                    return this.browserEnvCheck() ? null === this.app ? Promise.reject("Tracker not initialized") : void this.app.coldStart(t, e) : Promise.reject("Trying to start not in browser.")
                }
                startOfflineRecording(t, e) {
                    return this.browserEnvCheck() ? null === this.app ? Promise.reject("Tracker not initialized") : this.app.offlineRecording(t, e) : Promise.reject("Trying to start not in browser.")
                }
                uploadOfflineRecording() {
                    if (null !== this.app) return this.app.uploadOfflineRecording()
                }
                stop() {
                    if (null !== this.app) return this.app.stop(), this.app.session.getSessionHash()
                }
                forceFlushBatch() {
                    null !== this.app && this.app.forceFlushBatch()
                }
                getSessionToken() {
                    return null === this.app ? null : this.app.getSessionToken()
                }
                getSessionInfo() {
                    return null === this.app ? null : this.app.session.getInfo()
                }
                getSessionID() {
                    return null === this.app ? null : this.app.getSessionID()
                }
                getTabId() {
                    return null === this.app ? null : this.app.getTabId()
                }
                getUxId() {
                    return null === this.app ? null : this.app.getUxtId()
                }
                sessionID() {
                    return T("'sessionID' method", "'getSessionID' method", "/"), this.getSessionID()
                }
                getSessionURL(t) {
                    if (null !== this.app) return this.app.getSessionURL(t)
                }
                setUserID(t) {
                    "string" == typeof t && null !== this.app && this.app.session.setUserID(t)
                }
                userID(t) {
                    T("'userID' method", "'setUserID' method", "/"), this.setUserID(t)
                }
                setUserAnonymousID(t) {
                    "string" == typeof t && null !== this.app && this.app.send(function(t) {
                        return [29, t]
                    }(t))
                }
                userAnonymousID(t) {
                    T("'userAnonymousID' method", "'setUserAnonymousID' method", "/"), this.setUserAnonymousID(t)
                }
                setMetadata(t, e) {
                    "string" == typeof t && "string" == typeof e && null !== this.app && this.app.session.setMetadata(t, e)
                }
                metadata(t, e) {
                    T("'metadata' method", "'setMetadata' method", "/"), this.setMetadata(t, e)
                }
                event(t, e = null, s = !1) {
                    if ("string" == typeof t && null !== this.app) {
                        if (s) return this.issue(t, e);
                        try {
                            e = JSON.stringify(e)
                        } catch (t) {
                            return
                        }
                        this.app.send(function(t, e) {
                            return [27, t, e]
                        }(t, e))
                    }
                }
                issue(t, e = null) {
                    if ("string" == typeof t && null !== this.app) {
                        try {
                            e = JSON.stringify(e)
                        } catch (t) {
                            return
                        }
                        this.app.send(function(t, e) {
                            return [64, t, e]
                        }(t, e))
                    }
                }
            }
        }
    }
]);
//# sourceMappingURL=https://hrcdn.net/fcore/assets/sourcemaps/defaultVendors-node_modules_react-oauth_google_dist_index_esm_js-node_modules_dom-scroll-into-8d4ea9-4fedd912.js.map