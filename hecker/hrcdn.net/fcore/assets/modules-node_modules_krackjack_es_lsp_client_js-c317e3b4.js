"use strict";
(self.webpackChunkhackerrank_lib = self.webpackChunkhackerrank_lib || []).push([
    ["modules-node_modules_krackjack_es_lsp_client_js"], {
        kgwS: (e, o, t) => {
            t.r(o), t.d(o, {
                default: () => L
            }), t("Z2Ku"), t("KKXr");
            var i = t("/0+J"),
                n = t("L5+t"),
                s = t("0JYD"),
                a = t("IBju"),
                r = t("wOjf"),
                l = t("MJZJ"),
                d = t("4Jew"),
                c = t("5F93"),
                h = t("OIP+"),
                u = t("Jckq"),
                p = t("nsCh"),
                g = t("ziTh"),
                v = a.u.prototype.registerFeature,
                C = ["java", "java8", "java17", "java15", "cpp"];
            a.u.prototype.registerFeature = function(e) {
                var o, t, i, n, s = null !== (o = null == e || null === (t = e._client) || void 0 === t || null === (i = t._clientOptions) || void 0 === i || null === (n = i.initializationOptions) || void 0 === n ? void 0 : n.isCodeActionEnabled) && void 0 !== o && o;
                if (!e._registrationType || ("textDocument/codeAction" !== e._registrationType.method || s) && !p.ok.includes(e._registrationType.method)) {
                    for (var a = arguments.length, r = new Array(a > 1 ? a - 1 : 0), l = 1; l < a; l++) r[l - 1] = arguments[l];
                    return v.call(this, e, ...r)
                }
            };
            class L {
                constructor(e, o) {
                    var {
                        userId: t,
                        language: i,
                        selectedLanguage: s,
                        isReadonlyEditable: a,
                        lspEndpoint: r,
                        lspBaseUrl: l,
                        modelUri: d = "",
                        fileName: h,
                        dbSchema: p,
                        proxyInitialize: v,
                        proxySendRequest: L,
                        onConnect: b,
                        onError: y,
                        onClose: m,
                        onMessage: S,
                        onLspLog: w,
                        onLspError: k,
                        onLspClose: E,
                        onLspConnect: Z,
                        onLspDisconnect: f
                    } = o;
                    (0, n.Z)(this, "url", void 0), (0, n.Z)(this, "disposable", void 0), (0, n.Z)(this, "rootPath", void 0), (0, n.Z)(this, "language", void 0), (0, n.Z)(this, "selectedLanguage", void 0), (0, n.Z)(this, "isReadonlyEditable", void 0), (0, n.Z)(this, "editor", void 0), (0, n.Z)(this, "isCodeActionEnabled", void 0), (0, n.Z)(this, "proxyInitialize", void 0), (0, n.Z)(this, "proxySendRequest", void 0), (0, n.Z)(this, "webSocket", void 0), (0, n.Z)(this, "languageClient", void 0), (0, n.Z)(this, "languageClientPromise", void 0), (0, n.Z)(this, "onConnect", void 0), (0, n.Z)(this, "onError", void 0), (0, n.Z)(this, "onClose", void 0), (0, n.Z)(this, "onMessage", void 0), (0, n.Z)(this, "onLspError", void 0), (0, n.Z)(this, "onLspLog", void 0), (0, n.Z)(this, "onLspClose", void 0), (0, n.Z)(this, "onLspConnect", void 0), (0, n.Z)(this, "onLspDisconnect", void 0), this.url = function(e, o, t, i, n, s) {
                        var a = "https:" === window.location.protocol ? "wss" : "ws",
                            r = {
                                user_id: t,
                                userId: t,
                                selectedLang: n,
                                fileName: (0, u.UO)(s, n)
                            };
                        return null != i && (r.modelUri = i), (0, c.mc)("".concat(a, "://").concat(e, "/").concat(o), r)
                    }(l, r, t, d, s, h), this.rootPath = d, this.language = i, this.editor = e, this.dbSchema = p, this.proxyInitialize = v, this.proxySendRequest = L, this.isCodeActionEnabled = C.includes(s) && a, this.onError = () => {
                        y(this.language)
                    }, this.onConnect = e => {
                        b(e, this.language)
                    }, this.onClose = () => {
                        m(this.language)
                    }, this.onMessage = e => {
                        if (S) {
                            var {
                                data: o
                            } = e;
                            try {
                                var t = JSON.parse(o);
                                S(t)
                            } catch (e) {
                                g.error("Error in lsp_client onMessage", e)
                            }
                        }
                    }, this.onLspError = k, this.onLspLog = w, this.onLspClose = E, this.onLspConnect = Z, this.onLspDisconnect = f, this.start()
                }
                start() {
                    var e, o, t, n, c, u, p = this;
                    this.webSocket = (e = this.url, o = this.onConnect, t = this.onMessage, n = this.onClose, c = this.onError, (u = new s.Z(e, [], {
                        maxReconnectionDelay: 5e4,
                        minReconnectionDelay: 1e3,
                        reconnectionDelayGrowFactor: 1.5,
                        connectionTimeout: 1e4,
                        maxRetries: 15,
                        maxEnqueuedMessages: 0,
                        debug: !1
                    })).addEventListener("open", (() => {
                        o(u.retryCount)
                    })), u.addEventListener("message", t), u.addEventListener("close", n), u.addEventListener("error", c), u), this.webSocket.onopen = (0, i.Z)((function*() {
                        var e = (0, l.Z3)(p.webSocket),
                            o = new l.Mf(e),
                            t = new l.IP(e);
                        p.languageClient = function(e) {
                            var {
                                transports: o,
                                fsPath: t,
                                language: i,
                                editorValue: n,
                                isCodeActionEnabled: s,
                                onLspLog: l,
                                proxyInitialize: c,
                                proxySendRequest: u,
                                dbSchema: p
                            } = e, g = t.split("file://")[1], v = {
                                workspaceFolder: {
                                    name: "hackerrank",
                                    uri: d.Uri.parse(g),
                                    index: 0
                                },
                                documentSelector: [i],
                                errorHandler: {
                                    error: () => ({
                                        action: r.ErrorAction.Continue
                                    }),
                                    closed: () => ({
                                        action: r.CloseAction.DoNotRestart
                                    })
                                }
                            };
                            if ("csharp" === i) {
                                var C = {
                                    editorText: n
                                };
                                v.initializationOptions = C
                            }
                            "mysql" === i && p && (v.initializationOptions = {
                                dbSchema: p
                            }), s && (v.initializationOptions = {
                                isCodeActionEnabled: s
                            });
                            var L = new a.u({
                                name: "EditorLspClient",
                                clientOptions: v,
                                connectionProvider: {
                                    get: () => Promise.resolve(o)
                                }
                            });
                            return (0, h.yq)(L, l), c && (0, h.VV)({
                                client: L,
                                method: "initialize",
                                handler: c
                            }), u && (0, h.VV)({
                                client: L,
                                method: "sendRequest",
                                handler: u
                            }), L
                        }({
                            transports: {
                                reader: o,
                                writer: t
                            },
                            fsPath: p.rootPath,
                            language: p.language,
                            editorValue: p.editor.getValue(),
                            onLspLog: p.onLspLog,
                            proxyInitialize: p.proxyInitialize,
                            proxySendRequest: p.proxySendRequest,
                            isCodeActionEnabled: p.isCodeActionEnabled,
                            dbSchema: p.dbSchema
                        }), p.languageClientPromise = p.languageClient.start(), yield p.languageClientPromise, o.onClose((0, i.Z)((function*() {
                            try {
                                var e;
                                yield null === (e = p.languageClient) || void 0 === e ? void 0 : e.stop()
                            } catch (e) {
                                p.onLspError("onClose: Failed to stop LSP Client", p.language)
                            }
                        })))
                    }))
                }
                dispose() {
                    var e = this;
                    return (0, i.Z)((function*() {
                        try {
                            e.disposable && e.disposable.dispose()
                        } catch (e) {
                            g.error("Error: Unable to dispose connection")
                        }
                        if (e.languageClient) try {
                            e.webSocket._shouldReconnect = !1, yield e.languageClientPromise, yield e.languageClient.dispose(), e.languageClientPromise = null, e.languageClient = null, e.onLspDisconnect(e.language)
                        } catch (o) {
                            e.onLspError("Failed to stop LSP Client", e.language)
                        } finally {
                            e.close()
                        } else e.close()
                    }))()
                }
                close() {
                    this.webSocket && (this.webSocket.readyState !== window.WebSocket.CLOSED ? (this.webSocket._shouldReconnect = !1, this.webSocket.close(), this.webSocket = null) : this.webSocket = null)
                }
            }
        }
    }
]);
//# sourceMappingURL=https://hrcdn.net/fcore/assets/sourcemaps/modules-node_modules_krackjack_es_lsp_client_js-c317e3b4.js.map