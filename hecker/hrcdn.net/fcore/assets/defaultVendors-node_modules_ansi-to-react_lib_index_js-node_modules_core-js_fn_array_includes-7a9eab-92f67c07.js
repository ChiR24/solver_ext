(self.webpackChunkhackerrank_lib = self.webpackChunkhackerrank_lib || []).push([
    ["defaultVendors-node_modules_ansi-to-react_lib_index_js-node_modules_core-js_fn_array_includes-7a9eab"], {
        "/C7L": t => {
            "use strict";
            var e = function() {
                    function t(t, e) {
                        for (var s = 0; s < e.length; s++) {
                            var n = e[s];
                            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
                        }
                    }
                    return function(e, s, n) {
                        return s && t(e.prototype, s), n && t(e, n), e
                    }
                }(),
                s = [
                    [{
                        color: "0, 0, 0",
                        class: "ansi-black"
                    }, {
                        color: "187, 0, 0",
                        class: "ansi-red"
                    }, {
                        color: "0, 187, 0",
                        class: "ansi-green"
                    }, {
                        color: "187, 187, 0",
                        class: "ansi-yellow"
                    }, {
                        color: "0, 0, 187",
                        class: "ansi-blue"
                    }, {
                        color: "187, 0, 187",
                        class: "ansi-magenta"
                    }, {
                        color: "0, 187, 187",
                        class: "ansi-cyan"
                    }, {
                        color: "255,255,255",
                        class: "ansi-white"
                    }],
                    [{
                        color: "85, 85, 85",
                        class: "ansi-bright-black"
                    }, {
                        color: "255, 85, 85",
                        class: "ansi-bright-red"
                    }, {
                        color: "0, 255, 0",
                        class: "ansi-bright-green"
                    }, {
                        color: "255, 255, 85",
                        class: "ansi-bright-yellow"
                    }, {
                        color: "85, 85, 255",
                        class: "ansi-bright-blue"
                    }, {
                        color: "255, 85, 255",
                        class: "ansi-bright-magenta"
                    }, {
                        color: "85, 255, 255",
                        class: "ansi-bright-cyan"
                    }, {
                        color: "255, 255, 255",
                        class: "ansi-bright-white"
                    }]
                ],
                n = function() {
                    function t() {
                        ! function(t, e) {
                            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                        }(this, t), this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null, this.bright = 0
                    }
                    return e(t, null, [{
                        key: "escapeForHtml",
                        value: function(e) {
                            return (new t).escapeForHtml(e)
                        }
                    }, {
                        key: "linkify",
                        value: function(e) {
                            return (new t).linkify(e)
                        }
                    }, {
                        key: "ansiToHtml",
                        value: function(e, s) {
                            return (new t).ansiToHtml(e, s)
                        }
                    }, {
                        key: "ansiToJson",
                        value: function(e, s) {
                            return (new t).ansiToJson(e, s)
                        }
                    }, {
                        key: "ansiToText",
                        value: function(e) {
                            return (new t).ansiToText(e)
                        }
                    }]), e(t, [{
                        key: "setupPalette",
                        value: function() {
                            this.PALETTE_COLORS = [];
                            for (var t = 0; t < 2; ++t)
                                for (var e = 0; e < 8; ++e) this.PALETTE_COLORS.push(s[t][e].color);
                            for (var n = [0, 95, 135, 175, 215, 255], r = function(t, e, s) {
                                    return n[t] + ", " + n[e] + ", " + n[s]
                                }, i = 0; i < 6; ++i)
                                for (var o = 0; o < 6; ++o)
                                    for (var a = 0; a < 6; ++a) this.PALETTE_COLORS.push(r(i, o, a));
                            for (var c = 8, h = 0; h < 24; ++h, c += 10) this.PALETTE_COLORS.push(r(c, c, c))
                        }
                    }, {
                        key: "escapeForHtml",
                        value: function(t) {
                            return t.replace(/[&<>]/gm, (function(t) {
                                return "&" == t ? "&amp;" : "<" == t ? "&lt;" : ">" == t ? "&gt;" : ""
                            }))
                        }
                    }, {
                        key: "linkify",
                        value: function(t) {
                            return t.replace(/(https?:\/\/[^\s]+)/gm, (function(t) {
                                return '<a href="' + t + '">' + t + "</a>"
                            }))
                        }
                    }, {
                        key: "ansiToHtml",
                        value: function(t, e) {
                            return this.process(t, e, !0)
                        }
                    }, {
                        key: "ansiToJson",
                        value: function(t, e) {
                            return (e = e || {}).json = !0, e.clearLine = !1, this.process(t, e, !0)
                        }
                    }, {
                        key: "ansiToText",
                        value: function(t) {
                            return this.process(t, {}, !1)
                        }
                    }, {
                        key: "process",
                        value: function(t, e, s) {
                            var n = this,
                                r = t.split(/\033\[/),
                                i = r.shift();
                            null == e && (e = {}), e.clearLine = /\r/.test(t);
                            var o = r.map((function(t) {
                                return n.processChunk(t, e, s)
                            }));
                            if (e && e.json) {
                                var a = this.processChunkJson("");
                                return a.content = i, a.clearLine = e.clearLine, o.unshift(a), e.remove_empty && (o = o.filter((function(t) {
                                    return !t.isEmpty()
                                }))), o
                            }
                            return o.unshift(i), o.join("")
                        }
                    }, {
                        key: "processChunkJson",
                        value: function(t, e, n) {
                            var r = (e = void 0 === e ? {} : e).use_classes = void 0 !== e.use_classes && e.use_classes,
                                i = e.key = r ? "class" : "color",
                                o = {
                                    content: t,
                                    fg: null,
                                    bg: null,
                                    fg_truecolor: null,
                                    bg_truecolor: null,
                                    clearLine: e.clearLine,
                                    decoration: null,
                                    was_processed: !1,
                                    isEmpty: function() {
                                        return !o.content
                                    }
                                },
                                a = t.match(/^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m);
                            if (!a) return o;
                            o.content = a[4];
                            var c = a[2].split(";");
                            if ("" !== a[1] || "m" !== a[3]) return o;
                            if (!n) return o;
                            var h = this;
                            for (h.decoration = null; c.length > 0;) {
                                var u = c.shift(),
                                    l = parseInt(u);
                                if (isNaN(l) || 0 === l) h.fg = h.bg = h.decoration = null;
                                else if (1 === l) h.decoration = "bold";
                                else if (2 === l) h.decoration = "dim";
                                else if (3 == l) h.decoration = "italic";
                                else if (4 == l) h.decoration = "underline";
                                else if (5 == l) h.decoration = "blink";
                                else if (7 === l) h.decoration = "reverse";
                                else if (8 === l) h.decoration = "hidden";
                                else if (9 === l) h.decoration = "strikethrough";
                                else if (39 == l) h.fg = null;
                                else if (49 == l) h.bg = null;
                                else if (l >= 30 && l < 38) h.fg = s[0][l % 10][i];
                                else if (l >= 90 && l < 98) h.fg = s[1][l % 10][i];
                                else if (l >= 40 && l < 48) h.bg = s[0][l % 10][i];
                                else if (l >= 100 && l < 108) h.bg = s[1][l % 10][i];
                                else if (38 === l || 48 === l) {
                                    var p = 38 === l;
                                    if (c.length >= 1) {
                                        var f = c.shift();
                                        if ("5" === f && c.length >= 1) {
                                            var d = parseInt(c.shift());
                                            if (d >= 0 && d <= 255)
                                                if (r) {
                                                    var g = d >= 16 ? "ansi-palette-" + d : s[d > 7 ? 1 : 0][d % 8].class;
                                                    p ? h.fg = g : h.bg = g
                                                } else this.PALETTE_COLORS || h.setupPalette(), p ? h.fg = this.PALETTE_COLORS[d] : h.bg = this.PALETTE_COLORS[d]
                                        } else if ("2" === f && c.length >= 3) {
                                            var y = parseInt(c.shift()),
                                                m = parseInt(c.shift()),
                                                v = parseInt(c.shift());
                                            if (y >= 0 && y <= 255 && m >= 0 && m <= 255 && v >= 0 && v <= 255) {
                                                var b = y + ", " + m + ", " + v;
                                                r ? p ? (h.fg = "ansi-truecolor", h.fg_truecolor = b) : (h.bg = "ansi-truecolor", h.bg_truecolor = b) : p ? h.fg = b : h.bg = b
                                            }
                                        }
                                    }
                                }
                            }
                            return null === h.fg && null === h.bg && null === h.decoration || (o.fg = h.fg, o.bg = h.bg, o.fg_truecolor = h.fg_truecolor, o.bg_truecolor = h.bg_truecolor, o.decoration = h.decoration, o.was_processed = !0), o
                        }
                    }, {
                        key: "processChunk",
                        value: function(t, e, s) {
                            var n = this;
                            e = e || {};
                            var r = this.processChunkJson(t, e, s);
                            if (e.json) return r;
                            if (r.isEmpty()) return "";
                            if (!r.was_processed) return r.content;
                            var i = e.use_classes,
                                o = [],
                                a = [],
                                c = {},
                                h = function(t) {
                                    var e = [],
                                        s = void 0;
                                    for (s in t) t.hasOwnProperty(s) && e.push("data-" + s + '="' + n.escapeForHtml(t[s]) + '"');
                                    return e.length > 0 ? " " + e.join(" ") : ""
                                };
                            return r.fg && (i ? (a.push(r.fg + "-fg"), null !== r.fg_truecolor && (c["ansi-truecolor-fg"] = r.fg_truecolor, r.fg_truecolor = null)) : o.push("color:rgb(" + r.fg + ")")), r.bg && (i ? (a.push(r.bg + "-bg"), null !== r.bg_truecolor && (c["ansi-truecolor-bg"] = r.bg_truecolor, r.bg_truecolor = null)) : o.push("background-color:rgb(" + r.bg + ")")), r.decoration && (i ? a.push("ansi-" + r.decoration) : "bold" === r.decoration ? o.push("font-weight:bold") : "dim" === r.decoration ? o.push("opacity:0.5") : "italic" === r.decoration ? o.push("font-style:italic") : "reverse" === r.decoration ? o.push("filter:invert(100%)") : "hidden" === r.decoration ? o.push("visibility:hidden") : "strikethrough" === r.decoration ? o.push("text-decoration:line-through") : o.push("text-decoration:" + r.decoration)), i ? '<span class="' + a.join(" ") + '"' + h(c) + ">" + r.content + "</span>" : '<span style="' + o.join(";") + '"' + h(c) + ">" + r.content + "</span>"
                        }
                    }]), t
                }();
            t.exports = n
        },
        "7gKi": function(t, e, s) {
            "use strict";
            var n = this && this.__importDefault || function(t) {
                    return t && t.__esModule ? t : {
                        default: t
                    }
                },
                r = this && this.__importStar || function(t) {
                    if (t && t.__esModule) return t;
                    var e = {};
                    if (null != t)
                        for (var s in t) Object.hasOwnProperty.call(t, s) && (e[s] = t[s]);
                    return e.default = t, e
                };
            Object.defineProperty(e, "__esModule", {
                value: !0
            });
            const i = n(s("/C7L")),
                o = s("jsXJ"),
                a = r(s("DTvD")),
                c = /^(https?:\/\/(?:www\.|(?!www))[^\s.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})$/;

            function h(t, e, s, n) {
                const r = e ? null : function(t) {
                        const e = {};
                        return t.bg && (e.backgroundColor = `rgb(${t.bg})`), t.fg && (e.color = `rgb(${t.fg})`), e
                    }(s),
                    i = e ? function(t) {
                        let e = "";
                        return t.bg && (e += `${t.bg}-bg `), t.fg && (e += `${t.fg}-fg `), t.decoration && (e += `ansi-${t.decoration} `), "" === e ? null : (e = e.substring(0, e.length - 1), e)
                    }(s) : null;
                if (!t) return a.createElement("span", {
                    style: r,
                    key: n,
                    className: i
                }, s.content);
                const o = s.content.split(/(\s+)/).reduce(((t, e, s) => {
                    if (s % 2 == 1) return t.push(e), t;
                    if (!c.test(e)) return t.push(e), t;
                    const n = e.startsWith("www.") ? `http://${e}` : e;
                    return t.push(a.createElement("a", {
                        key: s,
                        href: n,
                        target: "_blank"
                    }, `${e}`)), t
                }), []);
                return a.createElement("span", {
                    style: r,
                    key: n,
                    className: i
                }, o)
            }
            e.default = function(t) {
                const {
                    className: e,
                    useClasses: s,
                    children: n,
                    linkify: r
                } = t;
                return a.createElement("code", {
                    className: e
                }, function(t, e = !1) {
                    return t = o.escapeCarriageReturn(t), i.default.ansiToJson(t, {
                        json: !0,
                        remove_empty: !0,
                        use_classes: e
                    })
                }(null != n ? n : "", null != s && s).map(h.bind(null, null != r && r, null != s && s)))
            }
        },
        FDph: (t, e, s) => {
            s("Z2Ku"), s("g3g5").Array.includes
        },
        sUjY: (t, e, s) => {
            s("L9s1"), s("g3g5").String.includes
        },
        UUeW: (t, e, s) => {
            var n = s("K0xU")("match");
            t.exports = function(t) {
                var e = /./;
                try {
                    "/./" [t](e)
                } catch (s) {
                    try {
                        return e[n] = !1, !"/./" [t](e)
                    } catch (t) {}
                }
                return !0
            }
        },
        "0sh+": (t, e, s) => {
            var n = s("quPj"),
                r = s("vhPU");
            t.exports = function(t, e, s) {
                if (n(e)) throw TypeError("String#" + s + " doesn't accept regex!");
                return String(r(t))
            }
        },
        qncB: (t, e, s) => {
            var n = s("XKFU"),
                r = s("vhPU"),
                i = s("eeVq"),
                o = s("/e88"),
                a = "[" + o + "]",
                c = RegExp("^" + a + a + "*"),
                h = RegExp(a + a + "*$"),
                u = function(t, e, s) {
                    var r = {},
                        a = i((function() {
                            return !!o[t]() || "​" != "​" [t]()
                        })),
                        c = r[t] = a ? e(l) : o[t];
                    s && (r[s] = c), n(n.P + n.F * a, "String", r)
                },
                l = u.trim = function(t, e) {
                    return t = String(r(t)), 1 & e && (t = t.replace(c, "")), 2 & e && (t = t.replace(h, "")), t
                };
            t.exports = u
        },
        "/e88": t => {
            t.exports = "\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"
        },
        L9s1: (t, e, s) => {
            "use strict";
            var n = s("XKFU"),
                r = s("0sh+"),
                i = "includes";
            n(n.P + n.F * s("UUeW")(i), "String", {
                includes: function(t) {
                    return !!~r(this, t, i).indexOf(t, arguments.length > 1 ? arguments[1] : void 0)
                }
            })
        },
        jsXJ: t => {
            function e(t) {
                if (!t) return "";
                if (!/\r/.test(t)) return t;
                for (t = t.replace(/\r+\n/gm, "\n");
                    /\r[^$]/.test(t);) {
                    var e = /^(.*)\r+/m.exec(t)[1],
                        s = /\r+(.*)$/m.exec(t)[1];
                    s += e.slice(s.length, e.length), t = t.replace(/\r+.*$/m, "\r").replace(/^.*\r/m, s)
                }
                return t
            }

            function s(t) {
                for (var e = 0, s = 0; s < t.length; s++) t[e].length <= t[s].length && (e = s);
                return e
            }

            function n(t) {
                if (!/\r/.test(t)) return t;
                for (var e = t.split("\r"), n = []; e.length > 0;) {
                    var r = s(e);
                    n.push(e[r]), e = e.slice(r + 1)
                }
                return n.join("\r")
            }
            t.exports = e, t.exports.escapeCarriageReturn = e, t.exports.escapeCarriageReturnSafe = function(t) {
                if (!t) return "";
                if (!/\r/.test(t)) return t;
                if (!/\n/.test(t)) return n(t);
                var s = (t = t.replace(/\r+\n/gm, "\n")).lastIndexOf("\n");
                return e(t.slice(0, s)) + "\n" + n(t.slice(s + 1))
            }
        },
        "4O/9": (t, e, s) => {
            var n = s("Sxd8");
            t.exports = function(t, e) {
                var s;
                if ("function" != typeof e) throw new TypeError("Expected a function");
                return t = n(t),
                    function() {
                        return --t > 0 && (s = e.apply(this, arguments)), t <= 1 && (e = void 0), s
                    }
            }
        },
        u6S6: (t, e, s) => {
            var n = s("6acW"),
                r = s("sgoq")((function(t, e, s) {
                    return e = e.toLowerCase(), t + (s ? n(e) : e)
                }));
            t.exports = r
        },
        "6acW": (t, e, s) => {
            var n = s("dt0z"),
                r = s("gQMU");
            t.exports = function(t) {
                return r(n(t).toLowerCase())
            }
        },
        BkRI: (t, e, s) => {
            var n = s("OBhP");
            t.exports = function(t) {
                return n(t, 5)
            }
        },
        sEfC: (t, e, s) => {
            var n = s("GoyQ"),
                r = s("QIyF"),
                i = s("tLB3"),
                o = Math.max,
                a = Math.min;
            t.exports = function(t, e, s) {
                var c, h, u, l, p, f, d = 0,
                    g = !1,
                    y = !1,
                    m = !0;
                if ("function" != typeof t) throw new TypeError("Expected a function");

                function v(e) {
                    var s = c,
                        n = h;
                    return c = h = void 0, d = e, l = t.apply(n, s)
                }

                function b(t) {
                    var s = t - f;
                    return void 0 === f || s >= e || s < 0 || y && t - d >= u
                }

                function w() {
                    var t = r();
                    if (b(t)) return k(t);
                    p = setTimeout(w, function(t) {
                        var s = e - (t - f);
                        return y ? a(s, u - (t - d)) : s
                    }(t))
                }

                function k(t) {
                    return p = void 0, m && c ? v(t) : (c = h = void 0, l)
                }

                function _() {
                    var t = r(),
                        s = b(t);
                    if (c = arguments, h = this, f = t, s) {
                        if (void 0 === p) return function(t) {
                            return d = t, p = setTimeout(w, e), g ? v(t) : l
                        }(f);
                        if (y) return clearTimeout(p), p = setTimeout(w, e), v(f)
                    }
                    return void 0 === p && (p = setTimeout(w, e)), l
                }
                return e = i(e) || 0, n(s) && (g = !!s.leading, u = (y = "maxWait" in s) ? o(i(s.maxWait) || 0, e) : u, m = "trailing" in s ? !!s.trailing : m), _.cancel = function() {
                    void 0 !== p && clearTimeout(p), d = 0, c = f = h = p = void 0
                }, _.flush = function() {
                    return void 0 === p ? l : k(r())
                }, _
            }
        },
        "6qam": t => {
            t.exports = function(t) {
                return null === t
            }
        },
        TP7S: t => {
            t.exports = function(t) {
                return void 0 === t
            }
        },
        QIyF: (t, e, s) => {
            var n = s("Kz5y");
            t.exports = function() {
                return n.Date.now()
            }
        },
        HZII: (t, e, s) => {
            var n = s("4O/9");
            t.exports = function(t) {
                return n(2, t)
            }
        },
        "2Pgj": (t, e, s) => {
            "use strict";
            var n;
            s.d(e, {
                Z: () => i
            });
            var r = new Uint8Array(16);

            function i() {
                if (!n && !(n = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
                return n(r)
            }
        },
        F4Yv: (t, e, s) => {
            "use strict";
            s.d(e, {
                Z: () => o
            });
            const n = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
            for (var r = [], i = 0; i < 256; ++i) r.push((i + 256).toString(16).substr(1));
            const o = function(t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    s = (r[t[e + 0]] + r[t[e + 1]] + r[t[e + 2]] + r[t[e + 3]] + "-" + r[t[e + 4]] + r[t[e + 5]] + "-" + r[t[e + 6]] + r[t[e + 7]] + "-" + r[t[e + 8]] + r[t[e + 9]] + "-" + r[t[e + 10]] + r[t[e + 11]] + r[t[e + 12]] + r[t[e + 13]] + r[t[e + 14]] + r[t[e + 15]]).toLowerCase();
                if (! function(t) {
                        return "string" == typeof t && n.test(t)
                    }(s)) throw TypeError("Stringified UUID is invalid");
                return s
            }
        },
        xQqG: (t, e, s) => {
            "use strict";
            s.d(e, {
                Z: () => h
            });
            var n, r, i = s("2Pgj"),
                o = s("F4Yv"),
                a = 0,
                c = 0;
            const h = function(t, e, s) {
                var h = e && s || 0,
                    u = e || new Array(16),
                    l = (t = t || {}).node || n,
                    p = void 0 !== t.clockseq ? t.clockseq : r;
                if (null == l || null == p) {
                    var f = t.random || (t.rng || i.Z)();
                    null == l && (l = n = [1 | f[0], f[1], f[2], f[3], f[4], f[5]]), null == p && (p = r = 16383 & (f[6] << 8 | f[7]))
                }
                var d = void 0 !== t.msecs ? t.msecs : Date.now(),
                    g = void 0 !== t.nsecs ? t.nsecs : c + 1,
                    y = d - a + (g - c) / 1e4;
                if (y < 0 && void 0 === t.clockseq && (p = p + 1 & 16383), (y < 0 || d > a) && void 0 === t.nsecs && (g = 0), g >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
                a = d, c = g, r = p;
                var m = (1e4 * (268435455 & (d += 122192928e5)) + g) % 4294967296;
                u[h++] = m >>> 24 & 255, u[h++] = m >>> 16 & 255, u[h++] = m >>> 8 & 255, u[h++] = 255 & m;
                var v = d / 4294967296 * 1e4 & 268435455;
                u[h++] = v >>> 8 & 255, u[h++] = 255 & v, u[h++] = v >>> 24 & 15 | 16, u[h++] = v >>> 16 & 255, u[h++] = p >>> 8 | 128, u[h++] = 255 & p;
                for (var b = 0; b < 6; ++b) u[h + b] = l[b];
                return e || (0, o.Z)(u)
            }
        },
        "C7/A": (t, e, s) => {
            "use strict";
            s.d(e, {
                io: () => bt
            });
            var n = {};
            s.r(n), s.d(n, {
                Decoder: () => lt,
                Encoder: () => ut,
                PacketType: () => ht,
                protocol: () => ct
            });
            const r = Object.create(null);
            r.open = "0", r.close = "1", r.ping = "2", r.pong = "3", r.message = "4", r.upgrade = "5", r.noop = "6";
            const i = Object.create(null);
            Object.keys(r).forEach((t => {
                i[r[t]] = t
            }));
            const o = {
                    type: "error",
                    data: "parser error"
                },
                a = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === Object.prototype.toString.call(Blob),
                c = "function" == typeof ArrayBuffer,
                h = (t, e) => {
                    const s = new FileReader;
                    return s.onload = function() {
                        const t = s.result.split(",")[1];
                        e("b" + t)
                    }, s.readAsDataURL(t)
                },
                u = ({
                    type: t,
                    data: e
                }, s, n) => {
                    return a && e instanceof Blob ? s ? n(e) : h(e, n) : c && (e instanceof ArrayBuffer || (i = e, "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(i) : i && i.buffer instanceof ArrayBuffer)) ? s ? n(e) : h(new Blob([e]), n) : n(r[t] + (e || ""));
                    var i
                };
            for (var l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", p = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256), f = 0; f < l.length; f++) p[l.charCodeAt(f)] = f;
            const d = "function" == typeof ArrayBuffer,
                g = (t, e) => {
                    if (d) {
                        const s = function(t) {
                            var e, s, n, r, i, o = .75 * t.length,
                                a = t.length,
                                c = 0;
                            "=" === t[t.length - 1] && (o--, "=" === t[t.length - 2] && o--);
                            var h = new ArrayBuffer(o),
                                u = new Uint8Array(h);
                            for (e = 0; e < a; e += 4) s = p[t.charCodeAt(e)], n = p[t.charCodeAt(e + 1)], r = p[t.charCodeAt(e + 2)], i = p[t.charCodeAt(e + 3)], u[c++] = s << 2 | n >> 4, u[c++] = (15 & n) << 4 | r >> 2, u[c++] = (3 & r) << 6 | 63 & i;
                            return h
                        }(t);
                        return y(s, e)
                    }
                    return {
                        base64: !0,
                        data: t
                    }
                },
                y = (t, e) => "blob" === e && t instanceof ArrayBuffer ? new Blob([t]) : t,
                m = (t, e) => {
                    if ("string" != typeof t) return {
                        type: "message",
                        data: y(t, e)
                    };
                    const s = t.charAt(0);
                    return "b" === s ? {
                        type: "message",
                        data: g(t.substring(1), e)
                    } : i[s] ? t.length > 1 ? {
                        type: i[s],
                        data: t.substring(1)
                    } : {
                        type: i[s]
                    } : o
                },
                v = String.fromCharCode(30);

            function b(t) {
                if (t) return function(t) {
                    for (var e in b.prototype) t[e] = b.prototype[e];
                    return t
                }(t)
            }
            b.prototype.on = b.prototype.addEventListener = function(t, e) {
                return this._callbacks = this._callbacks || {}, (this._callbacks["$" + t] = this._callbacks["$" + t] || []).push(e), this
            }, b.prototype.once = function(t, e) {
                function s() {
                    this.off(t, s), e.apply(this, arguments)
                }
                return s.fn = e, this.on(t, s), this
            }, b.prototype.off = b.prototype.removeListener = b.prototype.removeAllListeners = b.prototype.removeEventListener = function(t, e) {
                if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
                var s, n = this._callbacks["$" + t];
                if (!n) return this;
                if (1 == arguments.length) return delete this._callbacks["$" + t], this;
                for (var r = 0; r < n.length; r++)
                    if ((s = n[r]) === e || s.fn === e) {
                        n.splice(r, 1);
                        break
                    }
                return 0 === n.length && delete this._callbacks["$" + t], this
            }, b.prototype.emit = function(t) {
                this._callbacks = this._callbacks || {};
                for (var e = new Array(arguments.length - 1), s = this._callbacks["$" + t], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
                if (s) {
                    n = 0;
                    for (var r = (s = s.slice(0)).length; n < r; ++n) s[n].apply(this, e)
                }
                return this
            }, b.prototype.emitReserved = b.prototype.emit, b.prototype.listeners = function(t) {
                return this._callbacks = this._callbacks || {}, this._callbacks["$" + t] || []
            }, b.prototype.hasListeners = function(t) {
                return !!this.listeners(t).length
            };
            const w = "undefined" != typeof self ? self : "undefined" != typeof window ? window : Function("return this")();

            function k(t, ...e) {
                return e.reduce(((e, s) => (t.hasOwnProperty(s) && (e[s] = t[s]), e)), {})
            }
            const _ = setTimeout,
                E = clearTimeout;

            function T(t, e) {
                e.useNativeTimers ? (t.setTimeoutFn = _.bind(w), t.clearTimeoutFn = E.bind(w)) : (t.setTimeoutFn = setTimeout.bind(w), t.clearTimeoutFn = clearTimeout.bind(w))
            }
            class C extends Error {
                constructor(t, e, s) {
                    super(t), this.description = e, this.context = s, this.type = "TransportError"
                }
            }
            class x extends b {
                constructor(t) {
                    super(), this.writable = !1, T(this, t), this.opts = t, this.query = t.query, this.readyState = "", this.socket = t.socket
                }
                onError(t, e, s) {
                    return super.emitReserved("error", new C(t, e, s)), this
                }
                open() {
                    return "closed" !== this.readyState && "" !== this.readyState || (this.readyState = "opening", this.doOpen()), this
                }
                close() {
                    return "opening" !== this.readyState && "open" !== this.readyState || (this.doClose(), this.onClose()), this
                }
                send(t) {
                    "open" === this.readyState && this.write(t)
                }
                onOpen() {
                    this.readyState = "open", this.writable = !0, super.emitReserved("open")
                }
                onData(t) {
                    const e = m(t, this.socket.binaryType);
                    this.onPacket(e)
                }
                onPacket(t) {
                    super.emitReserved("packet", t)
                }
                onClose(t) {
                    this.readyState = "closed", super.emitReserved("close", t)
                }
            }
            const O = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""),
                R = 64,
                A = {};
            let L, S = 0,
                B = 0;

            function N(t) {
                let e = "";
                do {
                    e = O[t % R] + e, t = Math.floor(t / R)
                } while (t > 0);
                return e
            }

            function P() {
                const t = N(+new Date);
                return t !== L ? (S = 0, L = t) : t + "." + N(S++)
            }
            for (; B < R; B++) A[O[B]] = B;

            function j(t) {
                let e = "";
                for (let s in t) t.hasOwnProperty(s) && (e.length && (e += "&"), e += encodeURIComponent(s) + "=" + encodeURIComponent(t[s]));
                return e
            }
            let q = !1;
            try {
                q = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest
            } catch (t) {}
            const I = q;

            function F(t) {
                const e = t.xdomain;
                try {
                    if ("undefined" != typeof XMLHttpRequest && (!e || I)) return new XMLHttpRequest
                } catch (t) {}
                if (!e) try {
                    return new(w[["Active"].concat("Object").join("X")])("Microsoft.XMLHTTP")
                } catch (t) {}
            }

            function D() {}
            const U = null != new F({
                xdomain: !1
            }).responseType;
            class M extends b {
                constructor(t, e) {
                    super(), T(this, e), this.opts = e, this.method = e.method || "GET", this.uri = t, this.async = !1 !== e.async, this.data = void 0 !== e.data ? e.data : null, this.create()
                }
                create() {
                    const t = k(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
                    t.xdomain = !!this.opts.xd, t.xscheme = !!this.opts.xs;
                    const e = this.xhr = new F(t);
                    try {
                        e.open(this.method, this.uri, this.async);
                        try {
                            if (this.opts.extraHeaders) {
                                e.setDisableHeaderCheck && e.setDisableHeaderCheck(!0);
                                for (let t in this.opts.extraHeaders) this.opts.extraHeaders.hasOwnProperty(t) && e.setRequestHeader(t, this.opts.extraHeaders[t])
                            }
                        } catch (t) {}
                        if ("POST" === this.method) try {
                            e.setRequestHeader("Content-type", "text/plain;charset=UTF-8")
                        } catch (t) {}
                        try {
                            e.setRequestHeader("Accept", "*/*")
                        } catch (t) {}
                        "withCredentials" in e && (e.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (e.timeout = this.opts.requestTimeout), e.onreadystatechange = () => {
                            4 === e.readyState && (200 === e.status || 1223 === e.status ? this.onLoad() : this.setTimeoutFn((() => {
                                this.onError("number" == typeof e.status ? e.status : 0)
                            }), 0))
                        }, e.send(this.data)
                    } catch (t) {
                        return void this.setTimeoutFn((() => {
                            this.onError(t)
                        }), 0)
                    }
                    "undefined" != typeof document && (this.index = M.requestsCount++, M.requests[this.index] = this)
                }
                onError(t) {
                    this.emitReserved("error", t, this.xhr), this.cleanup(!0)
                }
                cleanup(t) {
                    if (void 0 !== this.xhr && null !== this.xhr) {
                        if (this.xhr.onreadystatechange = D, t) try {
                            this.xhr.abort()
                        } catch (t) {}
                        "undefined" != typeof document && delete M.requests[this.index], this.xhr = null
                    }
                }
                onLoad() {
                    const t = this.xhr.responseText;
                    null !== t && (this.emitReserved("data", t), this.emitReserved("success"), this.cleanup())
                }
                abort() {
                    this.cleanup()
                }
            }

            function V() {
                for (let t in M.requests) M.requests.hasOwnProperty(t) && M.requests[t].abort()
            }
            M.requestsCount = 0, M.requests = {}, "undefined" != typeof document && ("function" == typeof attachEvent ? attachEvent("onunload", V) : "function" == typeof addEventListener && addEventListener("onpagehide" in w ? "pagehide" : "unload", V, !1));
            const H = "function" == typeof Promise && "function" == typeof Promise.resolve ? t => Promise.resolve().then(t) : (t, e) => e(t, 0),
                K = w.WebSocket || w.MozWebSocket;
            s("r6pt").lW;
            const $ = "undefined" != typeof navigator && "string" == typeof navigator.product && "reactnative" === navigator.product.toLowerCase(),
                W = {
                    websocket: class extends x {
                        constructor(t) {
                            super(t), this.supportsBinary = !t.forceBase64
                        }
                        get name() {
                            return "websocket"
                        }
                        doOpen() {
                            if (!this.check()) return;
                            const t = this.uri(),
                                e = this.opts.protocols,
                                s = $ ? {} : k(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
                            this.opts.extraHeaders && (s.headers = this.opts.extraHeaders);
                            try {
                                this.ws = $ ? new K(t, e, s) : e ? new K(t, e) : new K(t)
                            } catch (t) {
                                return this.emitReserved("error", t)
                            }
                            this.ws.binaryType = this.socket.binaryType || "arraybuffer", this.addEventListeners()
                        }
                        addEventListeners() {
                            this.ws.onopen = () => {
                                this.opts.autoUnref && this.ws._socket.unref(), this.onOpen()
                            }, this.ws.onclose = t => this.onClose({
                                description: "websocket connection closed",
                                context: t
                            }), this.ws.onmessage = t => this.onData(t.data), this.ws.onerror = t => this.onError("websocket error", t)
                        }
                        write(t) {
                            this.writable = !1;
                            for (let e = 0; e < t.length; e++) {
                                const s = t[e],
                                    n = e === t.length - 1;
                                u(s, this.supportsBinary, (t => {
                                    try {
                                        this.ws.send(t)
                                    } catch (t) {}
                                    n && H((() => {
                                        this.writable = !0, this.emitReserved("drain")
                                    }), this.setTimeoutFn)
                                }))
                            }
                        }
                        doClose() {
                            void 0 !== this.ws && (this.ws.close(), this.ws = null)
                        }
                        uri() {
                            let t = this.query || {};
                            const e = this.opts.secure ? "wss" : "ws";
                            let s = "";
                            this.opts.port && ("wss" === e && 443 !== Number(this.opts.port) || "ws" === e && 80 !== Number(this.opts.port)) && (s = ":" + this.opts.port), this.opts.timestampRequests && (t[this.opts.timestampParam] = P()), this.supportsBinary || (t.b64 = 1);
                            const n = j(t);
                            return e + "://" + (-1 !== this.opts.hostname.indexOf(":") ? "[" + this.opts.hostname + "]" : this.opts.hostname) + s + this.opts.path + (n.length ? "?" + n : "")
                        }
                        check() {
                            return !!K
                        }
                    },
                    polling: class extends x {
                        constructor(t) {
                            if (super(t), this.polling = !1, "undefined" != typeof location) {
                                const e = "https:" === location.protocol;
                                let s = location.port;
                                s || (s = e ? "443" : "80"), this.xd = "undefined" != typeof location && t.hostname !== location.hostname || s !== t.port, this.xs = t.secure !== e
                            }
                            const e = t && t.forceBase64;
                            this.supportsBinary = U && !e
                        }
                        get name() {
                            return "polling"
                        }
                        doOpen() {
                            this.poll()
                        }
                        pause(t) {
                            this.readyState = "pausing";
                            const e = () => {
                                this.readyState = "paused", t()
                            };
                            if (this.polling || !this.writable) {
                                let t = 0;
                                this.polling && (t++, this.once("pollComplete", (function() {
                                    --t || e()
                                }))), this.writable || (t++, this.once("drain", (function() {
                                    --t || e()
                                })))
                            } else e()
                        }
                        poll() {
                            this.polling = !0, this.doPoll(), this.emitReserved("poll")
                        }
                        onData(t) {
                            ((t, e) => {
                                const s = t.split(v),
                                    n = [];
                                for (let t = 0; t < s.length; t++) {
                                    const r = m(s[t], e);
                                    if (n.push(r), "error" === r.type) break
                                }
                                return n
                            })(t, this.socket.binaryType).forEach((t => {
                                if ("opening" === this.readyState && "open" === t.type && this.onOpen(), "close" === t.type) return this.onClose({
                                    description: "transport closed by the server"
                                }), !1;
                                this.onPacket(t)
                            })), "closed" !== this.readyState && (this.polling = !1, this.emitReserved("pollComplete"), "open" === this.readyState && this.poll())
                        }
                        doClose() {
                            const t = () => {
                                this.write([{
                                    type: "close"
                                }])
                            };
                            "open" === this.readyState ? t() : this.once("open", t)
                        }
                        write(t) {
                            this.writable = !1, ((t, e) => {
                                const s = t.length,
                                    n = new Array(s);
                                let r = 0;
                                t.forEach(((t, i) => {
                                    u(t, !1, (t => {
                                        n[i] = t, ++r === s && e(n.join(v))
                                    }))
                                }))
                            })(t, (t => {
                                this.doWrite(t, (() => {
                                    this.writable = !0, this.emitReserved("drain")
                                }))
                            }))
                        }
                        uri() {
                            let t = this.query || {};
                            const e = this.opts.secure ? "https" : "http";
                            let s = "";
                            !1 !== this.opts.timestampRequests && (t[this.opts.timestampParam] = P()), this.supportsBinary || t.sid || (t.b64 = 1), this.opts.port && ("https" === e && 443 !== Number(this.opts.port) || "http" === e && 80 !== Number(this.opts.port)) && (s = ":" + this.opts.port);
                            const n = j(t);
                            return e + "://" + (-1 !== this.opts.hostname.indexOf(":") ? "[" + this.opts.hostname + "]" : this.opts.hostname) + s + this.opts.path + (n.length ? "?" + n : "")
                        }
                        request(t = {}) {
                            return Object.assign(t, {
                                xd: this.xd,
                                xs: this.xs
                            }, this.opts), new M(this.uri(), t)
                        }
                        doWrite(t, e) {
                            const s = this.request({
                                method: "POST",
                                data: t
                            });
                            s.on("success", e), s.on("error", ((t, e) => {
                                this.onError("xhr post error", t, e)
                            }))
                        }
                        doPoll() {
                            const t = this.request();
                            t.on("data", this.onData.bind(this)), t.on("error", ((t, e) => {
                                this.onError("xhr poll error", t, e)
                            })), this.pollXhr = t
                        }
                    }
                },
                Y = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
                J = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];

            function z(t) {
                const e = t,
                    s = t.indexOf("["),
                    n = t.indexOf("]"); - 1 != s && -1 != n && (t = t.substring(0, s) + t.substring(s, n).replace(/:/g, ";") + t.substring(n, t.length));
                let r = Y.exec(t || ""),
                    i = {},
                    o = 14;
                for (; o--;) i[J[o]] = r[o] || "";
                return -1 != s && -1 != n && (i.source = e, i.host = i.host.substring(1, i.host.length - 1).replace(/;/g, ":"), i.authority = i.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), i.ipv6uri = !0), i.pathNames = function(t, e) {
                    const s = e.replace(/\/{2,9}/g, "/").split("/");
                    return "/" != e.slice(0, 1) && 0 !== e.length || s.splice(0, 1), "/" == e.slice(-1) && s.splice(s.length - 1, 1), s
                }(0, i.path), i.queryKey = function(t, e) {
                    const s = {};
                    return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, (function(t, e, n) {
                        e && (s[e] = n)
                    })), s
                }(0, i.query), i
            }
            class X extends b {
                constructor(t, e = {}) {
                    super(), t && "object" == typeof t && (e = t, t = null), t ? (t = z(t), e.hostname = t.host, e.secure = "https" === t.protocol || "wss" === t.protocol, e.port = t.port, t.query && (e.query = t.query)) : e.host && (e.hostname = z(e.host).host), T(this, e), this.secure = null != e.secure ? e.secure : "undefined" != typeof location && "https:" === location.protocol, e.hostname && !e.port && (e.port = this.secure ? "443" : "80"), this.hostname = e.hostname || ("undefined" != typeof location ? location.hostname : "localhost"), this.port = e.port || ("undefined" != typeof location && location.port ? location.port : this.secure ? "443" : "80"), this.transports = e.transports || ["polling", "websocket"], this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({
                        path: "/engine.io",
                        agent: !1,
                        withCredentials: !1,
                        upgrade: !0,
                        timestampParam: "t",
                        rememberUpgrade: !1,
                        rejectUnauthorized: !0,
                        perMessageDeflate: {
                            threshold: 1024
                        },
                        transportOptions: {},
                        closeOnBeforeunload: !0
                    }, e), this.opts.path = this.opts.path.replace(/\/$/, "") + "/", "string" == typeof this.opts.query && (this.opts.query = function(t) {
                        let e = {},
                            s = t.split("&");
                        for (let t = 0, n = s.length; t < n; t++) {
                            let n = s[t].split("=");
                            e[decodeURIComponent(n[0])] = decodeURIComponent(n[1])
                        }
                        return e
                    }(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, "function" == typeof addEventListener && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {
                        this.transport && (this.transport.removeAllListeners(), this.transport.close())
                    }, addEventListener("beforeunload", this.beforeunloadEventListener, !1)), "localhost" !== this.hostname && (this.offlineEventListener = () => {
                        this.onClose("transport close", {
                            description: "network connection lost"
                        })
                    }, addEventListener("offline", this.offlineEventListener, !1))), this.open()
                }
                createTransport(t) {
                    const e = Object.assign({}, this.opts.query);
                    e.EIO = 4, e.transport = t, this.id && (e.sid = this.id);
                    const s = Object.assign({}, this.opts.transportOptions[t], this.opts, {
                        query: e,
                        socket: this,
                        hostname: this.hostname,
                        secure: this.secure,
                        port: this.port
                    });
                    return new W[t](s)
                }
                open() {
                    let t;
                    if (this.opts.rememberUpgrade && X.priorWebsocketSuccess && -1 !== this.transports.indexOf("websocket")) t = "websocket";
                    else {
                        if (0 === this.transports.length) return void this.setTimeoutFn((() => {
                            this.emitReserved("error", "No transports available")
                        }), 0);
                        t = this.transports[0]
                    }
                    this.readyState = "opening";
                    try {
                        t = this.createTransport(t)
                    } catch (t) {
                        return this.transports.shift(), void this.open()
                    }
                    t.open(), this.setTransport(t)
                }
                setTransport(t) {
                    this.transport && this.transport.removeAllListeners(), this.transport = t, t.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (t => this.onClose("transport close", t)))
                }
                probe(t) {
                    let e = this.createTransport(t),
                        s = !1;
                    X.priorWebsocketSuccess = !1;
                    const n = () => {
                        s || (e.send([{
                            type: "ping",
                            data: "probe"
                        }]), e.once("packet", (t => {
                            if (!s)
                                if ("pong" === t.type && "probe" === t.data) {
                                    if (this.upgrading = !0, this.emitReserved("upgrading", e), !e) return;
                                    X.priorWebsocketSuccess = "websocket" === e.name, this.transport.pause((() => {
                                        s || "closed" !== this.readyState && (h(), this.setTransport(e), e.send([{
                                            type: "upgrade"
                                        }]), this.emitReserved("upgrade", e), e = null, this.upgrading = !1, this.flush())
                                    }))
                                } else {
                                    const t = new Error("probe error");
                                    t.transport = e.name, this.emitReserved("upgradeError", t)
                                }
                        })))
                    };

                    function r() {
                        s || (s = !0, h(), e.close(), e = null)
                    }
                    const i = t => {
                        const s = new Error("probe error: " + t);
                        s.transport = e.name, r(), this.emitReserved("upgradeError", s)
                    };

                    function o() {
                        i("transport closed")
                    }

                    function a() {
                        i("socket closed")
                    }

                    function c(t) {
                        e && t.name !== e.name && r()
                    }
                    const h = () => {
                        e.removeListener("open", n), e.removeListener("error", i), e.removeListener("close", o), this.off("close", a), this.off("upgrading", c)
                    };
                    e.once("open", n), e.once("error", i), e.once("close", o), this.once("close", a), this.once("upgrading", c), e.open()
                }
                onOpen() {
                    if (this.readyState = "open", X.priorWebsocketSuccess = "websocket" === this.transport.name, this.emitReserved("open"), this.flush(), "open" === this.readyState && this.opts.upgrade && this.transport.pause) {
                        let t = 0;
                        const e = this.upgrades.length;
                        for (; t < e; t++) this.probe(this.upgrades[t])
                    }
                }
                onPacket(t) {
                    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) switch (this.emitReserved("packet", t), this.emitReserved("heartbeat"), t.type) {
                        case "open":
                            this.onHandshake(JSON.parse(t.data));
                            break;
                        case "ping":
                            this.resetPingTimeout(), this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong");
                            break;
                        case "error":
                            const e = new Error("server error");
                            e.code = t.data, this.onError(e);
                            break;
                        case "message":
                            this.emitReserved("data", t.data), this.emitReserved("message", t.data)
                    }
                }
                onHandshake(t) {
                    this.emitReserved("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.maxPayload = t.maxPayload, this.onOpen(), "closed" !== this.readyState && this.resetPingTimeout()
                }
                resetPingTimeout() {
                    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn((() => {
                        this.onClose("ping timeout")
                    }), this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref()
                }
                onDrain() {
                    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, 0 === this.writeBuffer.length ? this.emitReserved("drain") : this.flush()
                }
                flush() {
                    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
                        const t = this.getWritablePackets();
                        this.transport.send(t), this.prevBufferLen = t.length, this.emitReserved("flush")
                    }
                }
                getWritablePackets() {
                    if (!(this.maxPayload && "polling" === this.transport.name && this.writeBuffer.length > 1)) return this.writeBuffer;
                    let t = 1;
                    for (let s = 0; s < this.writeBuffer.length; s++) {
                        const n = this.writeBuffer[s].data;
                        if (n && (t += "string" == typeof(e = n) ? function(t) {
                                let e = 0,
                                    s = 0;
                                for (let n = 0, r = t.length; n < r; n++) e = t.charCodeAt(n), e < 128 ? s += 1 : e < 2048 ? s += 2 : e < 55296 || e >= 57344 ? s += 3 : (n++, s += 4);
                                return s
                            }(e) : Math.ceil(1.33 * (e.byteLength || e.size))), s > 0 && t > this.maxPayload) return this.writeBuffer.slice(0, s);
                        t += 2
                    }
                    var e;
                    return this.writeBuffer
                }
                write(t, e, s) {
                    return this.sendPacket("message", t, e, s), this
                }
                send(t, e, s) {
                    return this.sendPacket("message", t, e, s), this
                }
                sendPacket(t, e, s, n) {
                    if ("function" == typeof e && (n = e, e = void 0), "function" == typeof s && (n = s, s = null), "closing" === this.readyState || "closed" === this.readyState) return;
                    (s = s || {}).compress = !1 !== s.compress;
                    const r = {
                        type: t,
                        data: e,
                        options: s
                    };
                    this.emitReserved("packetCreate", r), this.writeBuffer.push(r), n && this.once("flush", n), this.flush()
                }
                close() {
                    const t = () => {
                            this.onClose("forced close"), this.transport.close()
                        },
                        e = () => {
                            this.off("upgrade", e), this.off("upgradeError", e), t()
                        },
                        s = () => {
                            this.once("upgrade", e), this.once("upgradeError", e)
                        };
                    return "opening" !== this.readyState && "open" !== this.readyState || (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", (() => {
                        this.upgrading ? s() : t()
                    })) : this.upgrading ? s() : t()), this
                }
                onError(t) {
                    X.priorWebsocketSuccess = !1, this.emitReserved("error", t), this.onClose("transport error", t)
                }
                onClose(t, e) {
                    "opening" !== this.readyState && "open" !== this.readyState && "closing" !== this.readyState || (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), "function" == typeof removeEventListener && (removeEventListener("beforeunload", this.beforeunloadEventListener, !1), removeEventListener("offline", this.offlineEventListener, !1)), this.readyState = "closed", this.id = null, this.emitReserved("close", t, e), this.writeBuffer = [], this.prevBufferLen = 0)
                }
                filterUpgrades(t) {
                    const e = [];
                    let s = 0;
                    const n = t.length;
                    for (; s < n; s++) ~this.transports.indexOf(t[s]) && e.push(t[s]);
                    return e
                }
            }
            X.protocol = 4, X.protocol;
            const Z = "function" == typeof ArrayBuffer,
                Q = t => "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(t) : t.buffer instanceof ArrayBuffer,
                G = Object.prototype.toString,
                tt = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === G.call(Blob),
                et = "function" == typeof File || "undefined" != typeof File && "[object FileConstructor]" === G.call(File);

            function st(t) {
                return Z && (t instanceof ArrayBuffer || Q(t)) || tt && t instanceof Blob || et && t instanceof File
            }

            function nt(t, e) {
                if (!t || "object" != typeof t) return !1;
                if (Array.isArray(t)) {
                    for (let e = 0, s = t.length; e < s; e++)
                        if (nt(t[e])) return !0;
                    return !1
                }
                if (st(t)) return !0;
                if (t.toJSON && "function" == typeof t.toJSON && 1 === arguments.length) return nt(t.toJSON(), !0);
                for (const e in t)
                    if (Object.prototype.hasOwnProperty.call(t, e) && nt(t[e])) return !0;
                return !1
            }

            function rt(t) {
                const e = [],
                    s = t.data,
                    n = t;
                return n.data = it(s, e), n.attachments = e.length, {
                    packet: n,
                    buffers: e
                }
            }

            function it(t, e) {
                if (!t) return t;
                if (st(t)) {
                    const s = {
                        _placeholder: !0,
                        num: e.length
                    };
                    return e.push(t), s
                }
                if (Array.isArray(t)) {
                    const s = new Array(t.length);
                    for (let n = 0; n < t.length; n++) s[n] = it(t[n], e);
                    return s
                }
                if ("object" == typeof t && !(t instanceof Date)) {
                    const s = {};
                    for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && (s[n] = it(t[n], e));
                    return s
                }
                return t
            }

            function ot(t, e) {
                return t.data = at(t.data, e), t.attachments = void 0, t
            }

            function at(t, e) {
                if (!t) return t;
                if (t && !0 === t._placeholder) {
                    if ("number" == typeof t.num && t.num >= 0 && t.num < e.length) return e[t.num];
                    throw new Error("illegal attachments")
                }
                if (Array.isArray(t))
                    for (let s = 0; s < t.length; s++) t[s] = at(t[s], e);
                else if ("object" == typeof t)
                    for (const s in t) Object.prototype.hasOwnProperty.call(t, s) && (t[s] = at(t[s], e));
                return t
            }
            const ct = 5;
            var ht;
            ! function(t) {
                t[t.CONNECT = 0] = "CONNECT", t[t.DISCONNECT = 1] = "DISCONNECT", t[t.EVENT = 2] = "EVENT", t[t.ACK = 3] = "ACK", t[t.CONNECT_ERROR = 4] = "CONNECT_ERROR", t[t.BINARY_EVENT = 5] = "BINARY_EVENT", t[t.BINARY_ACK = 6] = "BINARY_ACK"
            }(ht || (ht = {}));
            class ut {
                constructor(t) {
                    this.replacer = t
                }
                encode(t) {
                    return t.type !== ht.EVENT && t.type !== ht.ACK || !nt(t) ? [this.encodeAsString(t)] : (t.type = t.type === ht.EVENT ? ht.BINARY_EVENT : ht.BINARY_ACK, this.encodeAsBinary(t))
                }
                encodeAsString(t) {
                    let e = "" + t.type;
                    return t.type !== ht.BINARY_EVENT && t.type !== ht.BINARY_ACK || (e += t.attachments + "-"), t.nsp && "/" !== t.nsp && (e += t.nsp + ","), null != t.id && (e += t.id), null != t.data && (e += JSON.stringify(t.data, this.replacer)), e
                }
                encodeAsBinary(t) {
                    const e = rt(t),
                        s = this.encodeAsString(e.packet),
                        n = e.buffers;
                    return n.unshift(s), n
                }
            }
            class lt extends b {
                constructor(t) {
                    super(), this.reviver = t
                }
                add(t) {
                    let e;
                    if ("string" == typeof t) {
                        if (this.reconstructor) throw new Error("got plaintext data when reconstructing a packet");
                        e = this.decodeString(t), e.type === ht.BINARY_EVENT || e.type === ht.BINARY_ACK ? (this.reconstructor = new pt(e), 0 === e.attachments && super.emitReserved("decoded", e)) : super.emitReserved("decoded", e)
                    } else {
                        if (!st(t) && !t.base64) throw new Error("Unknown type: " + t);
                        if (!this.reconstructor) throw new Error("got binary data when not reconstructing a packet");
                        e = this.reconstructor.takeBinaryData(t), e && (this.reconstructor = null, super.emitReserved("decoded", e))
                    }
                }
                decodeString(t) {
                    let e = 0;
                    const s = {
                        type: Number(t.charAt(0))
                    };
                    if (void 0 === ht[s.type]) throw new Error("unknown packet type " + s.type);
                    if (s.type === ht.BINARY_EVENT || s.type === ht.BINARY_ACK) {
                        const n = e + 1;
                        for (;
                            "-" !== t.charAt(++e) && e != t.length;);
                        const r = t.substring(n, e);
                        if (r != Number(r) || "-" !== t.charAt(e)) throw new Error("Illegal attachments");
                        s.attachments = Number(r)
                    }
                    if ("/" === t.charAt(e + 1)) {
                        const n = e + 1;
                        for (; ++e && "," !== t.charAt(e) && e !== t.length;);
                        s.nsp = t.substring(n, e)
                    } else s.nsp = "/";
                    const n = t.charAt(e + 1);
                    if ("" !== n && Number(n) == n) {
                        const n = e + 1;
                        for (; ++e;) {
                            const s = t.charAt(e);
                            if (null == s || Number(s) != s) {
                                --e;
                                break
                            }
                            if (e === t.length) break
                        }
                        s.id = Number(t.substring(n, e + 1))
                    }
                    if (t.charAt(++e)) {
                        const n = this.tryParse(t.substr(e));
                        if (!lt.isPayloadValid(s.type, n)) throw new Error("invalid payload");
                        s.data = n
                    }
                    return s
                }
                tryParse(t) {
                    try {
                        return JSON.parse(t, this.reviver)
                    } catch (t) {
                        return !1
                    }
                }
                static isPayloadValid(t, e) {
                    switch (t) {
                        case ht.CONNECT:
                            return "object" == typeof e;
                        case ht.DISCONNECT:
                            return void 0 === e;
                        case ht.CONNECT_ERROR:
                            return "string" == typeof e || "object" == typeof e;
                        case ht.EVENT:
                        case ht.BINARY_EVENT:
                            return Array.isArray(e) && e.length > 0;
                        case ht.ACK:
                        case ht.BINARY_ACK:
                            return Array.isArray(e)
                    }
                }
                destroy() {
                    this.reconstructor && this.reconstructor.finishedReconstruction()
                }
            }
            class pt {
                constructor(t) {
                    this.packet = t, this.buffers = [], this.reconPack = t
                }
                takeBinaryData(t) {
                    if (this.buffers.push(t), this.buffers.length === this.reconPack.attachments) {
                        const t = ot(this.reconPack, this.buffers);
                        return this.finishedReconstruction(), t
                    }
                    return null
                }
                finishedReconstruction() {
                    this.reconPack = null, this.buffers = []
                }
            }

            function ft(t, e, s) {
                return t.on(e, s),
                    function() {
                        t.off(e, s)
                    }
            }
            const dt = Object.freeze({
                connect: 1,
                connect_error: 1,
                disconnect: 1,
                disconnecting: 1,
                newListener: 1,
                removeListener: 1
            });
            class gt extends b {
                constructor(t, e, s) {
                    super(), this.connected = !1, this.receiveBuffer = [], this.sendBuffer = [], this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = e, s && s.auth && (this.auth = s.auth), this.io._autoConnect && this.open()
                }
                get disconnected() {
                    return !this.connected
                }
                subEvents() {
                    if (this.subs) return;
                    const t = this.io;
                    this.subs = [ft(t, "open", this.onopen.bind(this)), ft(t, "packet", this.onpacket.bind(this)), ft(t, "error", this.onerror.bind(this)), ft(t, "close", this.onclose.bind(this))]
                }
                get active() {
                    return !!this.subs
                }
                connect() {
                    return this.connected || (this.subEvents(), this.io._reconnecting || this.io.open(), "open" === this.io._readyState && this.onopen()), this
                }
                open() {
                    return this.connect()
                }
                send(...t) {
                    return t.unshift("message"), this.emit.apply(this, t), this
                }
                emit(t, ...e) {
                    if (dt.hasOwnProperty(t)) throw new Error('"' + t.toString() + '" is a reserved event name');
                    e.unshift(t);
                    const s = {
                        type: ht.EVENT,
                        data: e,
                        options: {}
                    };
                    if (s.options.compress = !1 !== this.flags.compress, "function" == typeof e[e.length - 1]) {
                        const t = this.ids++,
                            n = e.pop();
                        this._registerAckCallback(t, n), s.id = t
                    }
                    const n = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
                    return this.flags.volatile && (!n || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(s), this.packet(s)) : this.sendBuffer.push(s)), this.flags = {}, this
                }
                _registerAckCallback(t, e) {
                    const s = this.flags.timeout;
                    if (void 0 === s) return void(this.acks[t] = e);
                    const n = this.io.setTimeoutFn((() => {
                        delete this.acks[t];
                        for (let e = 0; e < this.sendBuffer.length; e++) this.sendBuffer[e].id === t && this.sendBuffer.splice(e, 1);
                        e.call(this, new Error("operation has timed out"))
                    }), s);
                    this.acks[t] = (...t) => {
                        this.io.clearTimeoutFn(n), e.apply(this, [null, ...t])
                    }
                }
                packet(t) {
                    t.nsp = this.nsp, this.io._packet(t)
                }
                onopen() {
                    "function" == typeof this.auth ? this.auth((t => {
                        this.packet({
                            type: ht.CONNECT,
                            data: t
                        })
                    })) : this.packet({
                        type: ht.CONNECT,
                        data: this.auth
                    })
                }
                onerror(t) {
                    this.connected || this.emitReserved("connect_error", t)
                }
                onclose(t, e) {
                    this.connected = !1, delete this.id, this.emitReserved("disconnect", t, e)
                }
                onpacket(t) {
                    if (t.nsp === this.nsp) switch (t.type) {
                        case ht.CONNECT:
                            if (t.data && t.data.sid) {
                                const e = t.data.sid;
                                this.onconnect(e)
                            } else this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                            break;
                        case ht.EVENT:
                        case ht.BINARY_EVENT:
                            this.onevent(t);
                            break;
                        case ht.ACK:
                        case ht.BINARY_ACK:
                            this.onack(t);
                            break;
                        case ht.DISCONNECT:
                            this.ondisconnect();
                            break;
                        case ht.CONNECT_ERROR:
                            this.destroy();
                            const e = new Error(t.data.message);
                            e.data = t.data.data, this.emitReserved("connect_error", e)
                    }
                }
                onevent(t) {
                    const e = t.data || [];
                    null != t.id && e.push(this.ack(t.id)), this.connected ? this.emitEvent(e) : this.receiveBuffer.push(Object.freeze(e))
                }
                emitEvent(t) {
                    if (this._anyListeners && this._anyListeners.length) {
                        const e = this._anyListeners.slice();
                        for (const s of e) s.apply(this, t)
                    }
                    super.emit.apply(this, t)
                }
                ack(t) {
                    const e = this;
                    let s = !1;
                    return function(...n) {
                        s || (s = !0, e.packet({
                            type: ht.ACK,
                            id: t,
                            data: n
                        }))
                    }
                }
                onack(t) {
                    const e = this.acks[t.id];
                    "function" == typeof e && (e.apply(this, t.data), delete this.acks[t.id])
                }
                onconnect(t) {
                    this.id = t, this.connected = !0, this.emitBuffered(), this.emitReserved("connect")
                }
                emitBuffered() {
                    this.receiveBuffer.forEach((t => this.emitEvent(t))), this.receiveBuffer = [], this.sendBuffer.forEach((t => {
                        this.notifyOutgoingListeners(t), this.packet(t)
                    })), this.sendBuffer = []
                }
                ondisconnect() {
                    this.destroy(), this.onclose("io server disconnect")
                }
                destroy() {
                    this.subs && (this.subs.forEach((t => t())), this.subs = void 0), this.io._destroy(this)
                }
                disconnect() {
                    return this.connected && this.packet({
                        type: ht.DISCONNECT
                    }), this.destroy(), this.connected && this.onclose("io client disconnect"), this
                }
                close() {
                    return this.disconnect()
                }
                compress(t) {
                    return this.flags.compress = t, this
                }
                get volatile() {
                    return this.flags.volatile = !0, this
                }
                timeout(t) {
                    return this.flags.timeout = t, this
                }
                onAny(t) {
                    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this
                }
                prependAny(t) {
                    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this
                }
                offAny(t) {
                    if (!this._anyListeners) return this;
                    if (t) {
                        const e = this._anyListeners;
                        for (let s = 0; s < e.length; s++)
                            if (t === e[s]) return e.splice(s, 1), this
                    } else this._anyListeners = [];
                    return this
                }
                listenersAny() {
                    return this._anyListeners || []
                }
                onAnyOutgoing(t) {
                    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this
                }
                prependAnyOutgoing(t) {
                    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this
                }
                offAnyOutgoing(t) {
                    if (!this._anyOutgoingListeners) return this;
                    if (t) {
                        const e = this._anyOutgoingListeners;
                        for (let s = 0; s < e.length; s++)
                            if (t === e[s]) return e.splice(s, 1), this
                    } else this._anyOutgoingListeners = [];
                    return this
                }
                listenersAnyOutgoing() {
                    return this._anyOutgoingListeners || []
                }
                notifyOutgoingListeners(t) {
                    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
                        const e = this._anyOutgoingListeners.slice();
                        for (const s of e) s.apply(this, t.data)
                    }
                }
            }

            function yt(t) {
                t = t || {}, this.ms = t.min || 100, this.max = t.max || 1e4, this.factor = t.factor || 2, this.jitter = t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0, this.attempts = 0
            }
            yt.prototype.duration = function() {
                var t = this.ms * Math.pow(this.factor, this.attempts++);
                if (this.jitter) {
                    var e = Math.random(),
                        s = Math.floor(e * this.jitter * t);
                    t = 0 == (1 & Math.floor(10 * e)) ? t - s : t + s
                }
                return 0 | Math.min(t, this.max)
            }, yt.prototype.reset = function() {
                this.attempts = 0
            }, yt.prototype.setMin = function(t) {
                this.ms = t
            }, yt.prototype.setMax = function(t) {
                this.max = t
            }, yt.prototype.setJitter = function(t) {
                this.jitter = t
            };
            class mt extends b {
                constructor(t, e) {
                    var s;
                    super(), this.nsps = {}, this.subs = [], t && "object" == typeof t && (e = t, t = void 0), (e = e || {}).path = e.path || "/socket.io", this.opts = e, T(this, e), this.reconnection(!1 !== e.reconnection), this.reconnectionAttempts(e.reconnectionAttempts || 1 / 0), this.reconnectionDelay(e.reconnectionDelay || 1e3), this.reconnectionDelayMax(e.reconnectionDelayMax || 5e3), this.randomizationFactor(null !== (s = e.randomizationFactor) && void 0 !== s ? s : .5), this.backoff = new yt({
                        min: this.reconnectionDelay(),
                        max: this.reconnectionDelayMax(),
                        jitter: this.randomizationFactor()
                    }), this.timeout(null == e.timeout ? 2e4 : e.timeout), this._readyState = "closed", this.uri = t;
                    const r = e.parser || n;
                    this.encoder = new r.Encoder, this.decoder = new r.Decoder, this._autoConnect = !1 !== e.autoConnect, this._autoConnect && this.open()
                }
                reconnection(t) {
                    return arguments.length ? (this._reconnection = !!t, this) : this._reconnection
                }
                reconnectionAttempts(t) {
                    return void 0 === t ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this)
                }
                reconnectionDelay(t) {
                    var e;
                    return void 0 === t ? this._reconnectionDelay : (this._reconnectionDelay = t, null === (e = this.backoff) || void 0 === e || e.setMin(t), this)
                }
                randomizationFactor(t) {
                    var e;
                    return void 0 === t ? this._randomizationFactor : (this._randomizationFactor = t, null === (e = this.backoff) || void 0 === e || e.setJitter(t), this)
                }
                reconnectionDelayMax(t) {
                    var e;
                    return void 0 === t ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, null === (e = this.backoff) || void 0 === e || e.setMax(t), this)
                }
                timeout(t) {
                    return arguments.length ? (this._timeout = t, this) : this._timeout
                }
                maybeReconnectOnOpen() {
                    !this._reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect()
                }
                open(t) {
                    if (~this._readyState.indexOf("open")) return this;
                    this.engine = new X(this.uri, this.opts);
                    const e = this.engine,
                        s = this;
                    this._readyState = "opening", this.skipReconnect = !1;
                    const n = ft(e, "open", (function() {
                            s.onopen(), t && t()
                        })),
                        r = ft(e, "error", (e => {
                            s.cleanup(), s._readyState = "closed", this.emitReserved("error", e), t ? t(e) : s.maybeReconnectOnOpen()
                        }));
                    if (!1 !== this._timeout) {
                        const t = this._timeout;
                        0 === t && n();
                        const s = this.setTimeoutFn((() => {
                            n(), e.close(), e.emit("error", new Error("timeout"))
                        }), t);
                        this.opts.autoUnref && s.unref(), this.subs.push((function() {
                            clearTimeout(s)
                        }))
                    }
                    return this.subs.push(n), this.subs.push(r), this
                }
                connect(t) {
                    return this.open(t)
                }
                onopen() {
                    this.cleanup(), this._readyState = "open", this.emitReserved("open");
                    const t = this.engine;
                    this.subs.push(ft(t, "ping", this.onping.bind(this)), ft(t, "data", this.ondata.bind(this)), ft(t, "error", this.onerror.bind(this)), ft(t, "close", this.onclose.bind(this)), ft(this.decoder, "decoded", this.ondecoded.bind(this)))
                }
                onping() {
                    this.emitReserved("ping")
                }
                ondata(t) {
                    try {
                        this.decoder.add(t)
                    } catch (t) {
                        this.onclose("parse error", t)
                    }
                }
                ondecoded(t) {
                    H((() => {
                        this.emitReserved("packet", t)
                    }), this.setTimeoutFn)
                }
                onerror(t) {
                    this.emitReserved("error", t)
                }
                socket(t, e) {
                    let s = this.nsps[t];
                    return s || (s = new gt(this, t, e), this.nsps[t] = s), s
                }
                _destroy(t) {
                    const e = Object.keys(this.nsps);
                    for (const t of e)
                        if (this.nsps[t].active) return;
                    this._close()
                }
                _packet(t) {
                    const e = this.encoder.encode(t);
                    for (let s = 0; s < e.length; s++) this.engine.write(e[s], t.options)
                }
                cleanup() {
                    this.subs.forEach((t => t())), this.subs.length = 0, this.decoder.destroy()
                }
                _close() {
                    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close()
                }
                disconnect() {
                    return this._close()
                }
                onclose(t, e) {
                    this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", t, e), this._reconnection && !this.skipReconnect && this.reconnect()
                }
                reconnect() {
                    if (this._reconnecting || this.skipReconnect) return this;
                    const t = this;
                    if (this.backoff.attempts >= this._reconnectionAttempts) this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
                    else {
                        const e = this.backoff.duration();
                        this._reconnecting = !0;
                        const s = this.setTimeoutFn((() => {
                            t.skipReconnect || (this.emitReserved("reconnect_attempt", t.backoff.attempts), t.skipReconnect || t.open((e => {
                                e ? (t._reconnecting = !1, t.reconnect(), this.emitReserved("reconnect_error", e)) : t.onreconnect()
                            })))
                        }), e);
                        this.opts.autoUnref && s.unref(), this.subs.push((function() {
                            clearTimeout(s)
                        }))
                    }
                }
                onreconnect() {
                    const t = this.backoff.attempts;
                    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", t)
                }
            }
            const vt = {};

            function bt(t, e) {
                "object" == typeof t && (e = t, t = void 0);
                const s = function(t, e = "", s) {
                        let n = t;
                        s = s || "undefined" != typeof location && location, null == t && (t = s.protocol + "//" + s.host), "string" == typeof t && ("/" === t.charAt(0) && (t = "/" === t.charAt(1) ? s.protocol + t : s.host + t), /^(https?|wss?):\/\//.test(t) || (t = void 0 !== s ? s.protocol + "//" + t : "https://" + t), n = z(t)), n.port || (/^(http|ws)$/.test(n.protocol) ? n.port = "80" : /^(http|ws)s$/.test(n.protocol) && (n.port = "443")), n.path = n.path || "/";
                        const r = -1 !== n.host.indexOf(":") ? "[" + n.host + "]" : n.host;
                        return n.id = n.protocol + "://" + r + ":" + n.port + e, n.href = n.protocol + "://" + r + (s && s.port === n.port ? "" : ":" + n.port), n
                    }(t, (e = e || {}).path || "/socket.io"),
                    n = s.source,
                    r = s.id,
                    i = s.path,
                    o = vt[r] && i in vt[r].nsps;
                let a;
                return e.forceNew || e["force new connection"] || !1 === e.multiplex || o ? a = new mt(n, e) : (vt[r] || (vt[r] = new mt(n, e)), a = vt[r]), s.query && !e.query && (e.query = s.queryKey), a.socket(s.path, e)
            }
            Object.assign(bt, {
                Manager: mt,
                Socket: gt,
                io: bt,
                connect: bt
            })
        }
    }
]);
//# sourceMappingURL=https://hrcdn.net/fcore/assets/sourcemaps/defaultVendors-node_modules_ansi-to-react_lib_index_js-node_modules_core-js_fn_array_includes-7a9eab-92f67c07.js.map