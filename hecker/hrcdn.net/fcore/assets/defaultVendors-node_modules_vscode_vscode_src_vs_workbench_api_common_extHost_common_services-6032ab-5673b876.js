"use strict";
(self.webpackChunkhackerrank_lib = self.webpackChunkhackerrank_lib || []).push([
    ["defaultVendors-node_modules_vscode_vscode_src_vs_workbench_api_common_extHost_common_services-6032ab"], {
        D7Te: (e, t, i) => {
            var s = i("yJ/l"),
                o = i("rqgR"),
                r = i("n9io"),
                n = i("rx29"),
                a = i("45t+"),
                c = i("0f12"),
                d = i("l6bu"),
                l = i("DvZ5"),
                h = i("JbH+"),
                u = i("ri7g"),
                p = i("w14f"),
                m = i("GZWR"),
                g = i("bQf8"),
                v = i("jTbC"),
                _ = i("GWyr"),
                f = i("nG0x"),
                y = i("CRYY"),
                w = i("ZuU9"),
                x = i("ofuf"),
                b = i("PmF0"),
                D = i("P+6B"),
                C = i("Vvlp"),
                S = i("L03f"),
                E = i("0eYU"),
                P = i("CbIF"),
                T = i("ZXjZ"),
                k = i("9STo"),
                I = i("ocTE"),
                A = i("3BDB");
            (0, s.zr)(E.O, E.I, s._Z.Delayed), (0, s.zr)(C.y, D.m, s._Z.Delayed), (0, s.zr)(v.J, v.H, s._Z.Delayed), (0, s.zr)(c.f7, c.jK, s._Z.Eager), (0, s.zr)(T.E, T.j, s._Z.Eager), (0, s.zr)(k.X, k.Q, s._Z.Eager), (0, s.zr)(a.E1, a.T_, s._Z.Eager), (0, s.zr)(f.a, f.L, s._Z.Eager), (0, s.zr)(A.s7, A.Qp, s._Z.Eager), (0, s.zr)(u.gM, u.uU, s._Z.Eager), (0, s.zr)(n.W, n.w, s._Z.Eager), (0, s.zr)(d.T, d.W, s._Z.Eager), (0, s.zr)(P.W, P.b, s._Z.Eager), (0, s.zr)(y.G, y.J, s._Z.Eager), (0, s.zr)(o.U, o.X, s._Z.Delayed), (0, s.zr)(p.FR, p.dX, s._Z.Eager), (0, s.zr)(m.W, m.Y, s._Z.Eager), (0, s.zr)(h.h2, h.TE, s._Z.Eager), (0, s.zr)(l.$3, l.Ry, s._Z.Eager), (0, s.zr)(I.P, I.C, s._Z.Eager), (0, s.zr)(g.rd, g.Ce, s._Z.Eager), (0, s.zr)(_.V, _.x, s._Z.Eager), (0, s.zr)(r.w, r.M, s._Z.Eager), (0, s.zr)(w.Z, w.p, s._Z.Eager), (0, s.zr)(x.fv, x.wM, s._Z.Eager), (0, s.zr)(b.v, b.y, s._Z.Eager), (0, s.zr)(S.w, S.Y, s._Z.Eager)
        },
        jTbC: (e, t, i) => {
            i.d(t, {
                H: () => d,
                J: () => c
            });
            var s = i("t5wJ"),
                o = i("OYZR"),
                r = i("Vvlp"),
                n = i("YrcG"),
                a = i("Ayc8");
            const c = (0, o.yh)("IExtHostApiDeprecationService");
            let d = class {
                constructor(e, t) {
                    this._extHostLogService = t, this._reportedUsages = new Set, this._telemetryShape = e.getProxy(n.Tr.MainThreadTelemetry)
                }
                report(e, t, i) {
                    const s = this.getUsageKey(e, t);
                    this._reportedUsages.has(s) || (this._reportedUsages.add(s), t.isUnderDevelopment && this._extHostLogService.warn(`[Deprecation Warning] '${e}' is deprecated. ${i}`), this._telemetryShape.$publicLog2("extHostDeprecatedApiUsage", {
                        extensionId: t.identifier.value,
                        apiId: e
                    }))
                }
                getUsageKey(e, t) {
                    return `${e}-${t.identifier.value}`
                }
            };
            d = (0, s.g)([(0, s.f)(0, a.O), (0, s.f)(1, r.V)], d)
        },
        ZXjZ: (e, t, i) => {
            i.d(t, {
                E: () => h,
                j: () => u
            });
            var s = i("t5wJ"),
                o = i("7icl"),
                r = i("YrcG"),
                n = i("7NN/"),
                a = i("6zxw"),
                c = i("S4z/"),
                d = i("OYZR"),
                l = i("Ayc8");
            const h = (0, d.yh)("IExtHostAuthentication");
            let u = class {
                constructor(e) {
                    this._authenticationProviders = new Map, this._onDidChangeSessions = new o.Q5, this.onDidChangeSessions = this._onDidChangeSessions.event, this._getSessionTaskSingler = new p, this._proxy = e.getProxy(r.Tr.MainThreadAuthentication)
                }
                async getSession(e, t, i, s = {}) {
                    const o = a.kP.toKey(e.identifier),
                        r = [...i].sort().join(" ");
                    return await this._getSessionTaskSingler.getOrCreate(`${o} ${t} ${r}`, (async () => {
                        await this._proxy.$ensureProvider(t);
                        const r = e.displayName || e.name;
                        return this._proxy.$getSession(t, i, o, r, s)
                    }))
                }
                async getAccounts(e) {
                    return await this._proxy.$ensureProvider(e), await this._proxy.$getAccounts(e)
                }
                async removeSession(e, t) {
                    const i = this._authenticationProviders.get(e);
                    return i ? i.provider.removeSession(t) : this._proxy.$removeSession(e, t)
                }
                registerAuthenticationProvider(e, t, i, s) {
                    if (this._authenticationProviders.get(e)) throw new Error(`An authentication provider with id '${e}' is already registered.`);
                    this._authenticationProviders.set(e, {
                        label: t,
                        provider: i,
                        options: s ? ? {
                            supportsMultipleAccounts: !1
                        }
                    });
                    const o = i.onDidChangeSessions((t => this._proxy.$sendDidChangeSessions(e, t)));
                    return this._proxy.$registerAuthenticationProvider(e, t, s ? .supportsMultipleAccounts ? ? !1), new n.JTr((() => {
                        o.dispose(), this._authenticationProviders.delete(e), this._proxy.$unregisterAuthenticationProvider(e)
                    }))
                }
                async $createSession(e, t, i) {
                    const s = this._authenticationProviders.get(e);
                    if (s) return await s.provider.createSession(t, i);
                    throw new Error(`Unable to find authentication provider with handle: ${e}`)
                }
                async $removeSession(e, t) {
                    const i = this._authenticationProviders.get(e);
                    if (i) return await i.provider.removeSession(t);
                    throw new Error(`Unable to find authentication provider with handle: ${e}`)
                }
                async $getSessions(e, t, i) {
                    const s = this._authenticationProviders.get(e);
                    if (s) return await s.provider.getSessions(t, i);
                    throw new Error(`Unable to find authentication provider with handle: ${e}`)
                }
                $onDidChangeAuthenticationSessions(e, t) {
                    return e.startsWith(c.b) || this._onDidChangeSessions.fire({
                        provider: {
                            id: e,
                            label: t
                        }
                    }), Promise.resolve()
                }
            };
            u = (0, s.g)([(0, s.f)(0, l.O)], u);
            class p {
                constructor() {
                    this._inFlightPromises = new Map
                }
                getOrCreate(e, t) {
                    const i = this._inFlightPromises.get(e);
                    if (i) return i;
                    const s = t().finally((() => this._inFlightPromises.delete(e)));
                    return this._inFlightPromises.set(e, s), s
                }
            }
        },
        "0f12": (e, t, i) => {
            i.d(t, {
                SF: () => k,
                _m: () => I,
                b9: () => A,
                f7: () => P,
                jK: () => E
            });
            var s = i("t5wJ"),
                o = i("K30K"),
                r = i("7NN/"),
                n = i("IqsH"),
                a = i("7eUP"),
                c = i("YrcG"),
                d = i("iDmX"),
                l = i("Vvlp"),
                h = i("GHax"),
                u = i("Aw1u"),
                p = i("6PFX"),
                m = i("naIR"),
                g = i("RVdl"),
                v = i("OYZR"),
                _ = i("Ayc8"),
                f = i("qLp4"),
                y = i("jxI3"),
                w = i("43lI"),
                x = i("R1fN"),
                b = i("V2Gl"),
                D = i("hL8p"),
                C = i("ofuf"),
                S = i("R7Dl");
            let E = class {#
                e;#
                t;#
                i;
                constructor(e, t, i) {
                    this._commands = new Map, this._apiCommands = new Map, this.#e = e.getProxy(c.Tr.MainThreadCommands), this._logService = t, this.#i = i, this.#t = e.getProxy(c.Tr.MainThreadTelemetry), this.converter = new T(this, (e => {
                        const t = this._apiCommands.get(e);
                        return t ? .result === I.Void ? t : void 0
                    }), t), this._argumentProcessors = [{
                        processArgument: e => (0, h.wL)(e)
                    }, {
                        processArgument: e => (0, a.rs)(e, (function(e) {
                            return u.e.isIRange(e) ? n.e6.to(e) : p.L.isIPosition(e) ? n.Ly.to(e) : u.e.isIRange(e.range) && m.ov.isUri(e.uri) ? n.xh.to(e) : e instanceof y.KN ? e.buffer.buffer : Array.isArray(e) ? void 0 : e
                        }))
                    }]
                }
                registerArgumentProcessor(e) {
                    this._argumentProcessors.push(e)
                }
                registerApiCommand(e) {
                    const t = this.registerCommand(!1, e.id, (async (...t) => {
                        const i = e.args.map(((i, s) => {
                                if (!i.validate(t[s])) throw new Error(`Invalid argument '${i.name}' when running '${e.id}', received: ${"object"==typeof t[s]?JSON.stringify(t[s],null,"\t"):t[s]} `);
                                return i.convert(t[s])
                            })),
                            s = await this.executeCommand(e.internalId, ...i);
                        return e.result.convert(s, t, this.converter)
                    }), void 0, {
                        description: e.description,
                        args: e.args,
                        returns: e.result.description
                    });
                    return this._apiCommands.set(e.id, e), new r.JTr((() => {
                        t.dispose(), this._apiCommands.delete(e.id)
                    }))
                }
                registerCommand(e, t, i, s, o, n) {
                    if (this._logService.trace("ExtHostCommands#registerCommand", t), !t.trim().length) throw new Error("invalid id");
                    if (this._commands.has(t)) throw new Error(`command '${t}' already exists`);
                    return this._commands.set(t, {
                        callback: i,
                        thisArg: s,
                        metadata: o,
                        extension: n
                    }), e && this.#e.$registerCommand(t), new r.JTr((() => {
                        this._commands.delete(t) && e && this.#e.$unregisterCommand(t)
                    }))
                }
                executeCommand(e, ...t) {
                    return this._logService.trace("ExtHostCommands#executeCommand", e), this._doExecuteCommand(e, t, !0)
                }
                async _doExecuteCommand(e, t, i) {
                    if (this._commands.has(e)) return this.#e.$fireCommandActivationEvent(e), this._executeContributedCommand(e, t, !1); {
                        let s = !1;
                        const o = (0, a.rs)(t, (function(e) {
                            return e instanceof r.Lyo ? n.Ly.from(e) : e instanceof r.e6w ? n.e6.from(e) : e instanceof r.YeX ? n.xh.from(e) : r.XsU.isNotebookRange(e) ? n.Xs.from(e) : e instanceof ArrayBuffer ? (s = !0, y.KN.wrap(new Uint8Array(e))) : e instanceof Uint8Array ? (s = !0, y.KN.wrap(e)) : e instanceof y.KN ? (s = !0, e) : Array.isArray(e) ? void 0 : e
                        }));
                        try {
                            const t = await this.#e.$executeCommand(e, s ? new w.ky(o) : o, i);
                            return (0, h.wL)(t)
                        } catch (i) {
                            if (i instanceof Error && "$executeCommand:retry" === i.message) return this._doExecuteCommand(e, t, !1);
                            throw i
                        }
                    }
                }
                async _executeContributedCommand(e, t, i) {
                    const s = this._commands.get(e);
                    if (!s) throw new Error("Unknown command");
                    const {
                        callback: r,
                        thisArg: n,
                        metadata: a
                    } = s;
                    if (a ? .args)
                        for (let i = 0; i < a.args.length; i++) try {
                            (0, o.Nf)(t[i], a.args[i].constraint)
                        } catch (t) {
                            throw new Error(`Running the contributed command: '${e}' failed. Illegal argument '${a.args[i].name}' - ${a.args[i].description}`)
                        }
                    const c = b.G.create();
                    try {
                        return await r.apply(n, t)
                    } catch (o) {
                        if (e === this.converter.delegatingCommandId) {
                            const i = this.converter.getActualCommand(...t);
                            i && (e = i.command)
                        }
                        if (this._logService.error(o, e, s.extension ? .identifier), !i) throw o;
                        if (s.extension ? .identifier) {
                            const e = this.#i.onExtensionError(s.extension.identifier, o);
                            this._logService.trace("forwarded error to extension?", e, s.extension ? .identifier)
                        }
                        throw new class extends Error {
                            constructor() {
                                super((0, x.yJ)(o)), this.id = e, this.source = s.extension ? .displayName ? ? s.extension ? .name
                            }
                        }
                    } finally {
                        this._reportTelemetry(s, e, c.elapsed())
                    }
                }
                _reportTelemetry(e, t, i) {
                    e.extension && this.#t.$publicLog2("Extension:ActionExecuted", {
                        extensionId: e.extension.identifier.value,
                        id: new D.NE(t),
                        duration: i
                    })
                }
                $executeContributedCommand(e, ...t) {
                    this._logService.trace("ExtHostCommands#$executeContributedCommand", e);
                    const i = this._commands.get(e);
                    return i ? (t = t.map((e => this._argumentProcessors.reduce(((e, t) => t.processArgument(e, i.extension ? .identifier)), e))), this._executeContributedCommand(e, t, !0)) : Promise.reject(new Error(`Contributed command '${e}' does not exist.`))
                }
                getCommands(e = !1) {
                    return this._logService.trace("ExtHostCommands#getCommands", e), this.#e.$getCommands().then((t => (e && (t = t.filter((e => "_" !== e[0]))), t)))
                }
                $getContributedCommandMetadata() {
                    const e = Object.create(null);
                    for (const [t, i] of this._commands) {
                        const {
                            metadata: s
                        } = i;
                        s && (e[t] = s)
                    }
                    return Promise.resolve(e)
                }
            };
            E = (0, s.g)([(0, s.f)(0, _.O), (0, s.f)(1, l.V), (0, s.f)(2, C.fv)], E);
            const P = (0, v.yh)("IExtHostCommands");
            class T {
                constructor(e, t, i) {
                    this._commands = e, this._lookupApiCommand = t, this._logService = i, this.delegatingCommandId = `__vsc${(0,S.R)()}`, this._cache = new Map, this._cachIdPool = 0, this._commands.registerCommand(!0, this.delegatingCommandId, this._executeConvertedCommand, this)
                }
                toInternal(e, t) {
                    if (!e) return;
                    const i = {
                        $ident: void 0,
                        id: e.command,
                        title: e.title,
                        tooltip: e.tooltip
                    };
                    if (!e.command) return i;
                    const s = this._lookupApiCommand(e.command);
                    if (s) i.id = s.internalId, i.arguments = s.args.map(((t, i) => t.convert(e.arguments && e.arguments[i])));
                    else if ((0, d.Of)(e.arguments)) {
                        const s = `${e.command} /${++this._cachIdPool}`;
                        this._cache.set(s, e), t.add((0, g.OF)((() => {
                            this._cache.delete(s), this._logService.trace("CommandsConverter#DISPOSE", s)
                        }))), i.$ident = s, i.id = this.delegatingCommandId, i.arguments = [s], this._logService.trace("CommandsConverter#CREATE", e.command, s)
                    }
                    return i
                }
                fromInternal(e) {
                    return "string" == typeof e.$ident ? this._cache.get(e.$ident) : {
                        command: e.id,
                        title: e.title,
                        arguments: e.arguments
                    }
                }
                getActualCommand(...e) {
                    return this._cache.get(e[0])
                }
                _executeConvertedCommand(...e) {
                    const t = this.getActualCommand(...e);
                    return this._logService.trace("CommandsConverter#EXECUTE", e[0], t ? t.command : "MISSING"), t ? this._commands.executeCommand(t.command, ...t.arguments || []) : Promise.reject(`Actual command not found, wanted to execute ${e[0]}`)
                }
            }
            class k {
                static {
                    this.Uri = new k("uri", "Uri of a text document", (e => m.ov.isUri(e)), (e => e))
                }
                static {
                    this.Position = new k("position", "A position in a text document", (e => r.Lyo.isPosition(e)), n.Ly.from)
                }
                static {
                    this.Range = new k("range", "A range in a text document", (e => r.e6w.isRange(e)), n.e6.from)
                }
                static {
                    this.Selection = new k("selection", "A selection in a text document", (e => r.Y19.isSelection(e)), n.Y1.from)
                }
                static {
                    this.Number = new k("number", "", (e => "number" == typeof e), (e => e))
                }
                static {
                    this.String = new k("string", "", (e => "string" == typeof e), (e => e))
                }
                static {
                    this.StringArray = k.Arr(k.String)
                }
                static Arr(e) {
                    return new k(`${e.name}_array`, `Array of ${e.name}, ${e.description}`, (t => Array.isArray(t) && t.every((t => e.validate(t)))), (t => t.map((t => e.convert(t)))))
                }
                static {
                    this.CallHierarchyItem = new k("item", "A call hierarchy item", (e => e instanceof r.llk), n.ll.from)
                }
                static {
                    this.TypeHierarchyItem = new k("item", "A type hierarchy item", (e => e instanceof r.fQK), n.fQ.from)
                }
                static {
                    this.TestItem = new k("testItem", "A VS Code TestItem", (e => e instanceof f.SJ), n.UK.from)
                }
                constructor(e, t, i, s) {
                    this.name = e, this.description = t, this.validate = i, this.convert = s
                }
                optional() {
                    return new k(this.name, `(optional) ${this.description}`, (e => null == e || this.validate(e)), (e => void 0 === e ? void 0 : null === e ? null : this.convert(e)))
                }
                with(e, t) {
                    return new k(e ? ? this.name, t ? ? this.description, this.validate, this.convert)
                }
            }
            class I {
                static {
                    this.Void = new I("no result", (e => e))
                }
                constructor(e, t) {
                    this.description = e, this.convert = t
                }
            }
            class A {
                constructor(e, t, i, s, o) {
                    this.id = e, this.internalId = t, this.description = i, this.args = s, this.result = o
                }
            }
        },
        "45t+": (e, t, i) => {
            i.d(t, {
                E1: () => b,
                T_: () => w
            });
            var s = i("t5wJ"),
                o = i("7eUP"),
                r = i("7icl"),
                n = i("n9io"),
                a = i("YrcG"),
                c = i("7NN/"),
                d = i("cSed"),
                l = i("UGb/"),
                h = i("LWIF"),
                u = i("K30K"),
                p = i("opu4"),
                m = i("OYZR"),
                g = i("Ayc8"),
                v = i("Vvlp"),
                _ = i("naIR");

            function f(e, t) {
                if (t) {
                    const i = t.split(".");
                    let s = e;
                    for (let e = 0; s && e < i.length; e++) s = s[i[e]];
                    return s
                }
            }

            function y(e) {
                return e instanceof _.ov ? {
                    resource: e
                } : (t = e) && t.uri instanceof _.ov && t.languageId && "string" == typeof t.languageId ? {
                    resource: e.uri,
                    overrideIdentifier: e.languageId
                } : function(e) {
                    return e && !e.uri && e.languageId && "string" == typeof e.languageId
                }(e) ? {
                    overrideIdentifier: e.languageId
                } : function(e) {
                    return e && e.uri instanceof _.ov && (!e.name || "string" == typeof e.name) && (!e.index || "number" == typeof e.index)
                }(e) ? {
                    resource: e.uri
                } : null === e ? {
                    resource: null
                } : void 0;
                var t
            }
            let w = class {
                constructor(e, t, i) {
                    this._proxy = e.getProxy(a.Tr.MainThreadConfiguration), this._extHostWorkspace = t, this._logService = i, this._barrier = new p.U8, this._actual = null
                }
                getConfigProvider() {
                    return this._barrier.wait().then((e => this._actual))
                }
                $initializeConfiguration(e) {
                    this._actual = new x(this._proxy, this._extHostWorkspace, e, this._logService), this._barrier.open()
                }
                $acceptConfigurationChanged(e, t) {
                    this.getConfigProvider().then((i => i.$acceptConfigurationChanged(e, t)))
                }
            };
            w = (0, s.g)([(0, s.f)(0, g.O), (0, s.f)(1, n.w), (0, s.f)(2, v.V)], w);
            class x {
                constructor(e, t, i, s) {
                    this._onDidChangeConfiguration = new r.Q5, this._proxy = e, this._logService = s, this._extHostWorkspace = t, this._configuration = l.VK.parse(i, s), this._configurationScopes = this._toMap(i.configurationScopes)
                }
                get onDidChangeConfiguration() {
                    return this._onDidChangeConfiguration && this._onDidChangeConfiguration.event
                }
                $acceptConfigurationChanged(e, t) {
                    const i = {
                        data: this._configuration.toData(),
                        workspace: this._extHostWorkspace.workspace
                    };
                    this._configuration = l.VK.parse(e, this._logService), this._configurationScopes = this._toMap(e.configurationScopes), this._onDidChangeConfiguration.fire(this._toConfigurationChangeEvent(t, i))
                }
                getConfiguration(e, t, i) {
                    const s = y(t) || {},
                        r = this._toReadonlyValue(e ? f(this._configuration.getValue(void 0, s, this._extHostWorkspace.workspace), e) : this._configuration.getValue(void 0, s, this._extHostWorkspace.workspace));
                    e && this._validateConfigurationAccess(e, s, i ? .identifier);
                    const n = {
                        has: e => void 0 !== f(r, e),
                        get: (t, n) => {
                            this._validateConfigurationAccess(e ? `${e}.${t}` : t, s, i ? .identifier);
                            let a = f(r, t);
                            if (void 0 === a) a = n;
                            else {
                                let e;
                                const i = (t, s) => {
                                    if ((0, u.Kn)(t)) {
                                        let n;
                                        const a = () => {
                                            e = e || (0, o.I8)(r), n = n || f(e, s)
                                        };
                                        return new Proxy(t, {
                                            get: (t, o) => {
                                                if ("string" == typeof o && "tojson" === o.toLowerCase()) return a(), () => n;
                                                if (e) return n = n || f(e, s), n[o];
                                                const r = t[o];
                                                return "string" == typeof o ? i(r, `${s}.${o}`) : r
                                            },
                                            set: (e, t, i) => (a(), n && (n[t] = i), !0),
                                            deleteProperty: (e, t) => (a(), n && delete n[t], !0),
                                            defineProperty: (e, t, i) => (a(), n && Object.defineProperty(n, t, i), !0)
                                        })
                                    }
                                    return Array.isArray(t) ? (0, o.I8)(t) : t
                                };
                                a = i(a, t)
                            }
                            return a
                        },
                        update: (t, i, o, r) => {
                            t = e ? `${e}.${t}` : t;
                            const n = function(e) {
                                if (null == e) return null;
                                if ("boolean" == typeof e) return e ? d.JD.USER : d.JD.WORKSPACE;
                                switch (e) {
                                    case c.JDx.Global:
                                        return d.JD.USER;
                                    case c.JDx.Workspace:
                                        return d.JD.WORKSPACE;
                                    case c.JDx.WorkspaceFolder:
                                        return d.JD.WORKSPACE_FOLDER
                                }
                            }(o);
                            return void 0 !== i ? this._proxy.$updateConfigurationOption(n, t, i, s, r) : this._proxy.$removeConfigurationOption(n, t, s, r)
                        },
                        inspect: t => {
                            t = e ? `${e}.${t}` : t;
                            const i = this._configuration.inspect(t, s, this._extHostWorkspace.workspace);
                            if (i) return {
                                key: t,
                                defaultValue: (0, o.I8)(i.policy ? .value ? ? i.default ? .value),
                                globalValue: (0, o.I8)(i.user ? .value ? ? i.application ? .value),
                                workspaceValue: (0, o.I8)(i.workspace ? .value),
                                workspaceFolderValue: (0, o.I8)(i.workspaceFolder ? .value),
                                defaultLanguageValue: (0, o.I8)(i.default ? .override),
                                globalLanguageValue: (0, o.I8)(i.user ? .override ? ? i.application ? .override),
                                workspaceLanguageValue: (0, o.I8)(i.workspace ? .override),
                                workspaceFolderLanguageValue: (0, o.I8)(i.workspaceFolder ? .override),
                                languageIds: (0, o.I8)(i.overrideIdentifiers)
                            }
                        }
                    };
                    return "object" == typeof r && (0, o.jB)(n, r, !1), Object.freeze(n)
                }
                _toReadonlyValue(e) {
                    const t = e => (0, u.Kn)(e) ? new Proxy(e, {
                        get: (e, i) => t(e[i]),
                        set: (e, t, i) => {
                            throw new Error(`TypeError: Cannot assign to read only property '${String(t)}' of object`)
                        },
                        deleteProperty: (e, t) => {
                            throw new Error(`TypeError: Cannot delete read only property '${String(t)}' of object`)
                        },
                        defineProperty: (e, t) => {
                            throw new Error(`TypeError: Cannot define property '${String(t)}' for a readonly object`)
                        },
                        setPrototypeOf: e => {
                            throw new Error("TypeError: Cannot set prototype for a readonly object")
                        },
                        isExtensible: () => !1,
                        preventExtensions: () => !0
                    }) : e;
                    return t(e)
                }
                _validateConfigurationAccess(e, t, i) {
                    const s = h.eU.test(e) ? h.ue.RESOURCE : this._configurationScopes.get(e),
                        o = i ? `[${i.value}] ` : "";
                    h.ue.RESOURCE !== s ? h.ue.WINDOW !== s || t ? .resource && this._logService.warn(`${o}Accessing a window scoped configuration for a resource is not expected. To associate '${e}' to a resource, define its scope to 'resource' in configuration contributions in 'package.json'.`) : void 0 === t ? .resource && this._logService.warn(`${o}Accessing a resource scoped configuration without providing a resource is not expected. To get the effective value for '${e}', provide the URI of a resource or 'null' for any resource.`)
                }
                _toConfigurationChangeEvent(e, t) {
                    const i = new l.YX(e, t, this._configuration, this._extHostWorkspace.workspace, this._logService);
                    return Object.freeze({
                        affectsConfiguration: (e, t) => i.affectsConfiguration(e, y(t))
                    })
                }
                _toMap(e) {
                    return e.reduce(((e, t) => (e.set(t[0], t[1]), e)), new Map)
                }
            }
            const b = (0, m.yh)("IExtHostConfiguration")
        },
        ri7g: (e, t, i) => {
            i.d(t, {
                gM: () => E,
                uU: () => $
            });
            var s = i("t5wJ"),
                o = i("opu4"),
                r = i("7icl"),
                n = i("naIR"),
                a = i("RVdl"),
                c = i("6zxw"),
                d = i("OYZR"),
                l = i("YrcG"),
                h = i("PmF0"),
                u = i("spPY"),
                p = i("Ayc8"),
                m = i("7NN/"),
                g = i("n9io"),
                v = i("Cv2i"),
                _ = i("xHkz"),
                f = i("yylF"),
                y = i("45t+"),
                w = i("L03f"),
                x = i("6JmM"),
                b = i("0f12"),
                D = i("IqsH"),
                C = i("iDmX"),
                S = i("3BDB");
            const E = (0, d.yh)("IExtHostDebugService");
            let P = class extends a.JT {
                get onDidStartDebugSession() {
                    return this._onDidStartDebugSession.event
                }
                get onDidTerminateDebugSession() {
                    return this._onDidTerminateDebugSession.event
                }
                get onDidChangeActiveDebugSession() {
                    return this._onDidChangeActiveDebugSession.event
                }
                get activeDebugSession() {
                    return this._activeDebugSession ? .api
                }
                get onDidReceiveDebugSessionCustomEvent() {
                    return this._onDidReceiveDebugSessionCustomEvent.event
                }
                get activeDebugConsole() {
                    return this._activeDebugConsole.value
                }
                constructor(e, t, i, s, o, n, a, c) {
                    super(), this._workspaceService = t, this._extensionService = i, this._configurationService = s, this._editorTabs = o, this._variableResolver = n, this._commands = a, this._testing = c, this._debugSessions = new Map, this._debugVisualizationTreeItemIdsCounter = 0, this._debugVisualizationProviders = new Map, this._debugVisualizationTrees = new Map, this._debugVisualizationTreeItemIds = new WeakMap, this._debugVisualizationElements = new Map, this._visualizers = new Map, this._visualizerIdCounter = 0, this._configProviderHandleCounter = 0, this._configProviders = [], this._adapterFactoryHandleCounter = 0, this._adapterFactories = [], this._trackerFactoryHandleCounter = 0, this._trackerFactories = [], this._debugAdapters = new Map, this._debugAdaptersTrackers = new Map, this._onDidStartDebugSession = this._register(new r.Q5), this._onDidTerminateDebugSession = this._register(new r.Q5), this._onDidChangeActiveDebugSession = this._register(new r.Q5), this._onDidReceiveDebugSessionCustomEvent = this._register(new r.Q5), this._debugServiceProxy = e.getProxy(l.Tr.MainThreadDebugService), this._onDidChangeBreakpoints = this._register(new r.Q5), this._onDidChangeActiveStackItem = this._register(new r.Q5), this._activeDebugConsole = new k(this._debugServiceProxy), this._breakpoints = new Map, this._extensionService.getExtensionRegistry().then((e => {
                        this._register(e.onDidChange((t => {
                            this.registerAllDebugTypes(e)
                        }))), this.registerAllDebugTypes(e)
                    }))
                }
                async $getVisualizerTreeItem(e, t) {
                    const i = this.hydrateVisualizationContext(t);
                    if (!i) return;
                    const s = await (this._debugVisualizationTrees.get(e) ? .getTreeItem ? .(i));
                    return s ? this.convertVisualizerTreeItem(e, s) : void 0
                }
                registerDebugVisualizationTree(e, t, i) {
                    const s = c.kP.toKey(e.identifier),
                        o = this.extensionVisKey(s, t);
                    if (this._debugVisualizationProviders.has(o)) throw new Error(`A debug visualization provider with id '${t}' is already registered`);
                    return this._debugVisualizationTrees.set(o, i), this._debugServiceProxy.$registerDebugVisualizerTree(o, !!i.editItem), (0, a.OF)((() => {
                        this._debugServiceProxy.$unregisterDebugVisualizerTree(o), this._debugVisualizationTrees.delete(t)
                    }))
                }
                async $getVisualizerTreeItemChildren(e, t) {
                    const i = this._debugVisualizationElements.get(t) ? .item;
                    if (!i) return [];
                    const s = await (this._debugVisualizationTrees.get(e) ? .getChildren ? .(i));
                    return s ? .map((t => this.convertVisualizerTreeItem(e, t))) || []
                }
                async $editVisualizerTreeItem(e, t) {
                    const i = this._debugVisualizationElements.get(e);
                    if (!i) return;
                    const s = await (this._debugVisualizationTrees.get(i.provider) ? .editItem ? .(i.item, t));
                    return this.convertVisualizerTreeItem(i.provider, s || i.item)
                }
                $disposeVisualizedTree(e) {
                    const t = this._debugVisualizationElements.get(e);
                    if (!t) return;
                    const i = [t.children];
                    for (const e of i)
                        if (e)
                            for (const t of e) i.push(this._debugVisualizationElements.get(t) ? .children), this._debugVisualizationElements.delete(t)
                }
                convertVisualizerTreeItem(e, t) {
                    let i = this._debugVisualizationTreeItemIds.get(t);
                    return i || (i = this._debugVisualizationTreeItemIdsCounter++, this._debugVisualizationTreeItemIds.set(t, i), this._debugVisualizationElements.set(i, {
                        provider: e,
                        item: t
                    })), D.rT.from(t, i)
                }
                asDebugSourceUri(e, t) {
                    const i = e;
                    if ("number" == typeof i.sourceReference && i.sourceReference > 0) {
                        let e = `debug:${encodeURIComponent(i.path||"")}`,
                            s = "?";
                        return t && (e += `${s}session=${encodeURIComponent(t.id)}`, s = "&"), e += `${s}ref=${i.sourceReference}`, n.ov.parse(e)
                    }
                    if (i.path) return n.ov.file(i.path);
                    throw new Error("cannot create uri from DAP 'source' object; properties 'path' and 'sourceReference' are both missing.")
                }
                registerAllDebugTypes(e) {
                    const t = [];
                    for (const i of e.getAllExtensionDescriptions())
                        if (i.contributes) {
                            const e = i.contributes.debuggers;
                            if (e && e.length > 0)
                                for (const i of e)(0, f.b3)(i) && t.push(i.type)
                        }
                    this._debugServiceProxy.$registerDebugTypes(t)
                }
                get activeStackItem() {
                    return this._activeStackItem
                }
                get onDidChangeActiveStackItem() {
                    return this._onDidChangeActiveStackItem.event
                }
                get onDidChangeBreakpoints() {
                    return this._onDidChangeBreakpoints.event
                }
                get breakpoints() {
                    const e = [];
                    return this._breakpoints.forEach((t => e.push(t))), e
                }
                async $resolveDebugVisualizer(e, t) {
                    const i = this._visualizers.get(e);
                    if (!i) throw new Error(`No debug visualizer found with id '${e}'`);
                    let {
                        v: s,
                        provider: o,
                        extensionId: r
                    } = i;
                    if (s.visualization || (s = await (o.resolveDebugVisualization ? .(s, t)) || s, i.v = s), !s.visualization) throw new Error(`No visualization returned from resolveDebugVisualization in '${o}'`);
                    return this.serializeVisualization(r, s.visualization)
                }
                async $executeDebugVisualizerCommand(e) {
                    const t = this._visualizers.get(e);
                    if (!t) throw new Error(`No debug visualizer found with id '${e}'`);
                    const i = t.v.visualization;
                    i && "command" in i && this._commands.executeCommand(i.command, ...i.arguments || [])
                }
                hydrateVisualizationContext(e) {
                    const t = this._debugSessions.get(e.sessionId);
                    return t && {
                        session: t.api,
                        variable: e.variable,
                        containerId: e.containerId,
                        frameId: e.frameId,
                        threadId: e.threadId
                    }
                }
                async $provideDebugVisualizers(e, t, i, s) {
                    const o = this.hydrateVisualizationContext(i),
                        r = this.extensionVisKey(e, t),
                        n = this._debugVisualizationProviders.get(r);
                    if (!o || !n) return [];
                    const a = await n.provideDebugVisualization(o, s);
                    return a ? a.map((t => {
                        const i = ++this._visualizerIdCounter;
                        this._visualizers.set(i, {
                            v: t,
                            provider: n,
                            extensionId: e
                        });
                        const s = t.iconPath ? this.getIconPathOrClass(t.iconPath) : void 0;
                        return {
                            id: i,
                            name: t.name,
                            iconClass: s ? .iconClass,
                            iconPath: s ? .iconPath,
                            visualization: this.serializeVisualization(e, t.visualization)
                        }
                    })) : []
                }
                $disposeDebugVisualizers(e) {
                    for (const t of e) this._visualizers.delete(t)
                }
                registerDebugVisualizationProvider(e, t, i) {
                    if (!e.contributes ? .debugVisualizers ? .some((e => e.id === t))) throw new Error(`Extensions may only call registerDebugVisualizationProvider() for renderers they contribute (got ${t})`);
                    const s = c.kP.toKey(e.identifier),
                        o = this.extensionVisKey(s, t);
                    if (this._debugVisualizationProviders.has(o)) throw new Error(`A debug visualization provider with id '${t}' is already registered`);
                    return this._debugVisualizationProviders.set(o, i), this._debugServiceProxy.$registerDebugVisualizer(s, t), (0, a.OF)((() => {
                        this._debugServiceProxy.$unregisterDebugVisualizer(s, t), this._debugVisualizationProviders.delete(t)
                    }))
                }
                addBreakpoints(e) {
                    const t = e.filter((e => {
                        const t = e.id;
                        return !this._breakpoints.has(t) && (this._breakpoints.set(t, e), !0)
                    }));
                    this.fireBreakpointChanges(t, [], []);
                    const i = [],
                        s = new Map;
                    for (const e of t)
                        if (e instanceof m.TGJ) {
                            let t = s.get(e.location.uri.toString());
                            t || (t = {
                                type: "sourceMulti",
                                uri: e.location.uri,
                                lines: []
                            }, s.set(e.location.uri.toString(), t), i.push(t)), t.lines.push({
                                id: e.id,
                                enabled: e.enabled,
                                condition: e.condition,
                                hitCondition: e.hitCondition,
                                logMessage: e.logMessage,
                                line: e.location.range.start.line,
                                character: e.location.range.start.character,
                                mode: e.mode
                            })
                        } else e instanceof m.TpX && i.push({
                            type: "function",
                            id: e.id,
                            enabled: e.enabled,
                            hitCondition: e.hitCondition,
                            logMessage: e.logMessage,
                            condition: e.condition,
                            functionName: e.functionName,
                            mode: e.mode
                        });
                    return this._debugServiceProxy.$registerBreakpoints(i)
                }
                removeBreakpoints(e) {
                    const t = e.filter((e => this._breakpoints.delete(e.id)));
                    this.fireBreakpointChanges([], t, []);
                    const i = t.filter((e => e instanceof m.TGJ)).map((e => e.id)),
                        s = t.filter((e => e instanceof m.TpX)).map((e => e.id)),
                        o = t.filter((e => e instanceof m.K1l)).map((e => e.id));
                    return this._debugServiceProxy.$unregisterBreakpoints(i, s, o)
                }
                startDebugging(e, t, i) {
                    const s = i.testRun && this._testing.getMetadataForRun(i.testRun);
                    return this._debugServiceProxy.$startDebugging(e ? e.uri : void 0, t, {
                        parentSessionID: i.parentSession ? i.parentSession.id : void 0,
                        lifecycleManagedByParent: i.lifecycleManagedByParent,
                        repl: i.consoleMode === m.lZM.MergeWithParent ? "mergeWithParent" : "separate",
                        noDebug: i.noDebug,
                        compact: i.compact,
                        suppressSaveBeforeStart: i.suppressSaveBeforeStart,
                        testRun: s && {
                            runId: s.runId,
                            taskId: s.taskId
                        },
                        suppressDebugStatusbar: i.suppressDebugStatusbar ? ? i.debugUI ? .simple,
                        suppressDebugToolbar: i.suppressDebugToolbar ? ? i.debugUI ? .simple,
                        suppressDebugView: i.suppressDebugView ? ? i.debugUI ? .simple
                    })
                }
                stopDebugging(e) {
                    return this._debugServiceProxy.$stopDebugging(e ? e.id : void 0)
                }
                registerDebugConfigurationProvider(e, t, i) {
                    if (!t) return new m.JTr((() => {}));
                    const s = this._configProviderHandleCounter++;
                    return this._configProviders.push({
                        type: e,
                        handle: s,
                        provider: t
                    }), this._debugServiceProxy.$registerDebugConfigurationProvider(e, i, !!t.provideDebugConfigurations, !!t.resolveDebugConfiguration, !!t.resolveDebugConfigurationWithSubstitutedVariables, s), new m.JTr((() => {
                        this._configProviders = this._configProviders.filter((e => e.provider !== t)), this._debugServiceProxy.$unregisterDebugConfigurationProvider(s)
                    }))
                }
                registerDebugAdapterDescriptorFactory(e, t, i) {
                    if (!i) return new m.JTr((() => {}));
                    if (!this.definesDebugType(e, t)) throw new Error(`a DebugAdapterDescriptorFactory can only be registered from the extension that defines the '${t}' debugger.`);
                    if (this.getAdapterDescriptorFactoryByType(t)) throw new Error("a DebugAdapterDescriptorFactory can only be registered once per a type.");
                    const s = this._adapterFactoryHandleCounter++;
                    return this._adapterFactories.push({
                        type: t,
                        handle: s,
                        factory: i
                    }), this._debugServiceProxy.$registerDebugAdapterDescriptorFactory(t, s), new m.JTr((() => {
                        this._adapterFactories = this._adapterFactories.filter((e => e.factory !== i)), this._debugServiceProxy.$unregisterDebugAdapterDescriptorFactory(s)
                    }))
                }
                registerDebugAdapterTrackerFactory(e, t) {
                    if (!t) return new m.JTr((() => {}));
                    const i = this._trackerFactoryHandleCounter++;
                    return this._trackerFactories.push({
                        type: e,
                        handle: i,
                        factory: t
                    }), new m.JTr((() => {
                        this._trackerFactories = this._trackerFactories.filter((e => e.factory !== t))
                    }))
                }
                async $runInTerminal(e, t) {
                    return Promise.resolve(void 0)
                }
                async $substituteVariables(e, t) {
                    let i;
                    const s = await this.getFolder(e);
                    return s && (i = {
                        uri: s.uri,
                        name: s.name,
                        index: s.index,
                        toResource: () => {
                            throw new Error("Not implemented")
                        }
                    }), (await this._variableResolver.getResolver()).resolveAnyAsync(i, t)
                }
                createDebugAdapter(e, t) {
                    if ("implementation" === e.type) return new A(e.implementation)
                }
                createSignService() {}
                async $startDASession(e, t) {
                    const i = this,
                        s = await this.getSession(t);
                    return this.getAdapterDescriptor(this.getAdapterDescriptorFactoryByType(s.type), s).then((t => {
                        if (!t) throw new Error(`Couldn't find a debug adapter descriptor for debug type '${s.type}' (extension might have failed to activate)`);
                        const o = this.convertToDto(t),
                            r = this.createDebugAdapter(o, s);
                        if (!r) throw new Error(`Couldn't create a debug adapter for type '${s.type}'.`);
                        const n = r;
                        return this._debugAdapters.set(e, n), this.getDebugAdapterTrackers(s).then((t => (t && this._debugAdaptersTrackers.set(e, t), n.onMessage((async s => {
                            if ("request" === s.type && "handshake" === s.command) {
                                const e = s,
                                    t = {
                                        type: "response",
                                        seq: 0,
                                        command: e.command,
                                        request_seq: e.seq,
                                        success: !0
                                    };
                                this._signService || (this._signService = this.createSignService());
                                try {
                                    if (!this._signService) throw new Error("no signer"); {
                                        const i = await this._signService.sign(e.arguments.value);
                                        t.body = {
                                            signature: i
                                        }, n.sendResponse(t)
                                    }
                                } catch (e) {
                                    t.success = !1, t.message = e.message, n.sendResponse(t)
                                }
                            } else t && t.onDidSendMessage && t.onDidSendMessage(s), s = (0, f.p0)(s, !0), i._debugServiceProxy.$acceptDAMessage(e, s)
                        })), n.onError((i => {
                            t && t.onError && t.onError(i), this._debugServiceProxy.$acceptDAError(e, i.name, i.message, i.stack)
                        })), n.onExit((i => {
                            t && t.onExit && t.onExit(i ? ? void 0, void 0), this._debugServiceProxy.$acceptDAExit(e, i ? ? void 0, void 0)
                        })), t && t.onWillStartSession && t.onWillStartSession(), n.startSession())))
                    }))
                }
                $sendDAMessage(e, t) {
                    t = (0, f.lv)(t, !1);
                    const i = this._debugAdaptersTrackers.get(e);
                    i && i.onWillReceiveMessage && i.onWillReceiveMessage(t);
                    const s = this._debugAdapters.get(e);
                    s ? .sendMessage(t)
                }
                $stopDASession(e) {
                    const t = this._debugAdaptersTrackers.get(e);
                    this._debugAdaptersTrackers.delete(e), t && t.onWillStopSession && t.onWillStopSession();
                    const i = this._debugAdapters.get(e);
                    return this._debugAdapters.delete(e), i ? i.stopSession() : Promise.resolve(void 0)
                }
                $acceptBreakpointsDelta(e) {
                    const t = [],
                        i = [],
                        s = [];
                    if (e.added)
                        for (const i of e.added) {
                            const e = i.id;
                            if (e && !this._breakpoints.has(e)) {
                                let s;
                                if ("function" === i.type) s = new m.TpX(i.functionName, i.enabled, i.condition, i.hitCondition, i.logMessage, i.mode);
                                else if ("data" === i.type) s = new m.K1l(i.label, i.dataId, i.canPersist, i.enabled, i.hitCondition, i.condition, i.logMessage, i.mode);
                                else {
                                    const e = n.ov.revive(i.uri);
                                    s = new m.TGJ(new m.YeX(e, new m.Lyo(i.line, i.character)), i.enabled, i.condition, i.hitCondition, i.logMessage, i.mode)
                                }(0, m.YL6)(s, e), this._breakpoints.set(e, s), t.push(s)
                            }
                        }
                    if (e.removed)
                        for (const t of e.removed) {
                            const e = this._breakpoints.get(t);
                            e && (this._breakpoints.delete(t), i.push(e))
                        }
                    if (e.changed)
                        for (const t of e.changed)
                            if (t.id) {
                                const e = this._breakpoints.get(t.id);
                                if (e) {
                                    if (e instanceof m.TpX && "function" === t.type) {
                                        const i = e;
                                        i.enabled = t.enabled, i.condition = t.condition, i.hitCondition = t.hitCondition, i.logMessage = t.logMessage, i.functionName = t.functionName
                                    } else if (e instanceof m.TGJ && "source" === t.type) {
                                        const i = e;
                                        i.enabled = t.enabled, i.condition = t.condition, i.hitCondition = t.hitCondition, i.logMessage = t.logMessage, i.location = new m.YeX(n.ov.revive(t.uri), new m.Lyo(t.line, t.character))
                                    }
                                    s.push(e)
                                }
                            }
                    this.fireBreakpointChanges(t, i, s)
                }
                async $acceptStackFrameFocus(e) {
                    let t;
                    if (e) {
                        const i = await this.getSession(e.sessionId);
                        t = "thread" === e.kind ? new m.hNq(i.api, e.threadId) : new m.U07(i.api, e.threadId, e.frameId)
                    }
                    this._activeStackItem = t, this._onDidChangeActiveStackItem.fire(this._activeStackItem)
                }
                $provideDebugConfigurations(e, t, i) {
                    return (0, o.OH)((async () => {
                        const s = this.getConfigProviderByHandle(e);
                        if (!s) throw new Error("no DebugConfigurationProvider found");
                        if (!s.provideDebugConfigurations) throw new Error("DebugConfigurationProvider has no method provideDebugConfigurations");
                        const o = await this.getFolder(t);
                        return s.provideDebugConfigurations(o, i)
                    })).then((e => {
                        if (!e) throw new Error("nothing returned from DebugConfigurationProvider.provideDebugConfigurations");
                        return e
                    }))
                }
                $resolveDebugConfiguration(e, t, i, s) {
                    return (0, o.OH)((async () => {
                        const o = this.getConfigProviderByHandle(e);
                        if (!o) throw new Error("no DebugConfigurationProvider found");
                        if (!o.resolveDebugConfiguration) throw new Error("DebugConfigurationProvider has no method resolveDebugConfiguration");
                        const r = await this.getFolder(t);
                        return o.resolveDebugConfiguration(r, i, s)
                    }))
                }
                $resolveDebugConfigurationWithSubstitutedVariables(e, t, i, s) {
                    return (0, o.OH)((async () => {
                        const o = this.getConfigProviderByHandle(e);
                        if (!o) throw new Error("no DebugConfigurationProvider found");
                        if (!o.resolveDebugConfigurationWithSubstitutedVariables) throw new Error("DebugConfigurationProvider has no method resolveDebugConfigurationWithSubstitutedVariables");
                        const r = await this.getFolder(t);
                        return o.resolveDebugConfigurationWithSubstitutedVariables(r, i, s)
                    }))
                }
                async $provideDebugAdapter(e, t) {
                    const i = this.getAdapterDescriptorFactoryByHandle(e);
                    if (!i) return Promise.reject(new Error("no adapter descriptor factory found for handle"));
                    const s = await this.getSession(t);
                    return this.getAdapterDescriptor(i, s).then((e => {
                        if (!e) throw new Error(`Couldn't find a debug adapter descriptor for debug type '${s.type}'`);
                        return this.convertToDto(e)
                    }))
                }
                async $acceptDebugSessionStarted(e) {
                    const t = await this.getSession(e);
                    this._onDidStartDebugSession.fire(t.api)
                }
                async $acceptDebugSessionTerminated(e) {
                    const t = await this.getSession(e);
                    t && (this._onDidTerminateDebugSession.fire(t.api), this._debugSessions.delete(t.id))
                }
                async $acceptDebugSessionActiveChanged(e) {
                    this._activeDebugSession = e ? await this.getSession(e) : void 0, this._onDidChangeActiveDebugSession.fire(this._activeDebugSession ? .api)
                }
                async $acceptDebugSessionNameChanged(e, t) {
                    const i = await this.getSession(e);
                    i ? ._acceptNameChanged(t)
                }
                async $acceptDebugSessionCustomEvent(e, t) {
                    const i = {
                        session: (await this.getSession(e)).api,
                        event: t.event,
                        body: t.body
                    };
                    this._onDidReceiveDebugSessionCustomEvent.fire(i)
                }
                convertToDto(e) {
                    if (e instanceof m.FLm) return {
                        type: "executable",
                        command: e.command,
                        args: e.args,
                        options: e.options
                    };
                    if (e instanceof m.cZI) return {
                        type: "server",
                        port: e.port,
                        host: e.host
                    };
                    if (e instanceof m.HGt) return {
                        type: "pipeServer",
                        path: e.path
                    };
                    if (e instanceof m.yr7) return {
                        type: "implementation",
                        implementation: e.implementation
                    };
                    throw new Error("convertToDto unexpected type")
                }
                getAdapterDescriptorFactoryByType(e) {
                    const t = this._adapterFactories.filter((t => t.type === e));
                    if (t.length > 0) return t[0].factory
                }
                getAdapterDescriptorFactoryByHandle(e) {
                    const t = this._adapterFactories.filter((t => t.handle === e));
                    if (t.length > 0) return t[0].factory
                }
                getConfigProviderByHandle(e) {
                    const t = this._configProviders.filter((t => t.handle === e));
                    if (t.length > 0) return t[0].provider
                }
                definesDebugType(e, t) {
                    if (e.contributes) {
                        const i = e.contributes.debuggers;
                        if (i && i.length > 0)
                            for (const e of i)
                                if (e.label && e.type && e.type === t) return !0
                    }
                    return !1
                }
                getDebugAdapterTrackers(e) {
                    const t = e.configuration.type,
                        i = this._trackerFactories.filter((e => e.type === t || "*" === e.type)).map((t => (0, o.OH)((() => t.factory.createDebugAdapterTracker(e.api))).then((e => e), (e => null))));
                    return Promise.race([Promise.all(i).then((e => {
                        const t = (0, C.kX)(e);
                        if (t.length > 0) return new I(t)
                    })), new Promise((e => setTimeout((() => e(void 0)), 1e3)))]).catch((e => {}))
                }
                async getAdapterDescriptor(e, t) {
                    const i = t.configuration.debugServer;
                    if ("number" == typeof i) return Promise.resolve(new m.cZI(i));
                    if (e) {
                        const i = await this._extensionService.getExtensionRegistry();
                        return (0, o.OH)((() => e.createDebugAdapterDescriptor(t.api, this.daExecutableFromPackage(t, i)))).then((e => {
                            if (e) return e
                        }))
                    }
                    const s = await this._extensionService.getExtensionRegistry();
                    return Promise.resolve(this.daExecutableFromPackage(t, s))
                }
                daExecutableFromPackage(e, t) {}
                fireBreakpointChanges(e, t, i) {
                    (e.length > 0 || t.length > 0 || i.length > 0) && this._onDidChangeBreakpoints.fire(Object.freeze({
                        added: e,
                        removed: t,
                        changed: i
                    }))
                }
                async getSession(e) {
                    if (e) {
                        if ("string" != typeof e) {
                            let t = this._debugSessions.get(e.id);
                            if (!t) {
                                const i = await this.getFolder(e.folderUri),
                                    s = e.parent ? this._debugSessions.get(e.parent) : void 0;
                                t = new T(this._debugServiceProxy, e.id, e.type, e.name, i, e.configuration, s ? .api), this._debugSessions.set(t.id, t), this._debugServiceProxy.$sessionCached(t.id)
                            }
                            return t
                        } {
                            const t = this._debugSessions.get(e);
                            if (t) return t
                        }
                    }
                    throw new Error("cannot find session")
                }
                getFolder(e) {
                    if (e) {
                        const t = n.ov.revive(e);
                        return this._workspaceService.resolveWorkspaceFolder(t)
                    }
                    return Promise.resolve(void 0)
                }
                extensionVisKey(e, t) {
                    return `${e}\0${t}`
                }
                serializeVisualization(e, t) {
                    if (t) {
                        if ("title" in t && "command" in t) return {
                            type: _.dJ.Command
                        };
                        if ("treeId" in t) return {
                            type: _.dJ.Tree,
                            id: `${e}\0${t.treeId}`
                        };
                        throw new Error("Unsupported debug visualization type")
                    }
                }
                getIconPathOrClass(e) {
                    const t = this.getIconUris(e);
                    let i, s;
                    return "id" in t ? s = x.kS.asClassName(t) : i = t, {
                        iconPath: i,
                        iconClass: s
                    }
                }
                getIconUris(e) {
                    if (e instanceof m.kS8) return {
                        id: e.id
                    };
                    const t = "object" == typeof e && "dark" in e ? e.dark : e,
                        i = "object" == typeof e && "light" in e ? e.light : e;
                    return {
                        dark: "string" == typeof t ? n.ov.file(t) : t,
                        light: "string" == typeof i ? n.ov.file(i) : i
                    }
                }
            };
            P = (0, s.g)([(0, s.f)(0, p.O), (0, s.f)(1, g.w), (0, s.f)(2, u.k2), (0, s.f)(3, y.E1), (0, s.f)(4, h.v), (0, s.f)(5, w.w), (0, s.f)(6, b.f7), (0, s.f)(7, S.s7)], P);
            class T {
                constructor(e, t, i, s, o, r, n) {
                    this._debugServiceProxy = e, this._id = t, this._type = i, this._name = s, this._workspaceFolder = o, this._configuration = r, this._parentSession = n
                }
                get api() {
                    const e = this;
                    return this.apiSession ? ? = Object.freeze({
                        id: e._id,
                        type: e._type,
                        get name() {
                            return e._name
                        },
                        set name(t) {
                            e._name = t, e._debugServiceProxy.$setDebugSessionName(e._id, t)
                        },
                        parentSession: e._parentSession,
                        workspaceFolder: e._workspaceFolder,
                        configuration: e._configuration,
                        customRequest: (t, i) => e._debugServiceProxy.$customDebugAdapterRequest(e._id, t, i),
                        getDebugProtocolBreakpoint: t => e._debugServiceProxy.$getDebugProtocolBreakpoint(e._id, t.id)
                    })
                }
                get id() {
                    return this._id
                }
                get type() {
                    return this._type
                }
                _acceptNameChanged(e) {
                    this._name = e
                }
                get configuration() {
                    return this._configuration
                }
            }
            class k {
                constructor(e) {
                    this.value = Object.freeze({
                        append(t) {
                            e.$appendDebugConsole(t)
                        },
                        appendLine(e) {
                            this.append(e + "\n")
                        }
                    })
                }
            }
            class I {
                constructor(e) {
                    this.trackers = e
                }
                onWillStartSession() {
                    this.trackers.forEach((e => e.onWillStartSession ? e.onWillStartSession() : void 0))
                }
                onWillReceiveMessage(e) {
                    this.trackers.forEach((t => t.onWillReceiveMessage ? t.onWillReceiveMessage(e) : void 0))
                }
                onDidSendMessage(e) {
                    this.trackers.forEach((t => t.onDidSendMessage ? t.onDidSendMessage(e) : void 0))
                }
                onWillStopSession() {
                    this.trackers.forEach((e => e.onWillStopSession ? e.onWillStopSession() : void 0))
                }
                onError(e) {
                    this.trackers.forEach((t => t.onError ? t.onError(e) : void 0))
                }
                onExit(e, t) {
                    this.trackers.forEach((i => i.onExit ? i.onExit(e, t) : void 0))
                }
            }
            class A extends v.o {
                constructor(e) {
                    super(), this.implementation = e, e.onDidSendMessage((e => {
                        this.acceptMessage(e)
                    }))
                }
                startSession() {
                    return Promise.resolve(void 0)
                }
                sendMessage(e) {
                    this.implementation.handleMessage(e)
                }
                stopSession() {
                    return this.implementation.dispose(), Promise.resolve(void 0)
                }
            }
            let $ = class extends P {
                constructor(e, t, i, s, o, r, n, a) {
                    super(e, t, i, s, o, r, n, a)
                }
            };
            $ = (0, s.g)([(0, s.f)(0, p.O), (0, s.f)(1, g.w), (0, s.f)(2, u.k2), (0, s.f)(3, y.E1), (0, s.f)(4, h.v), (0, s.f)(5, w.w), (0, s.f)(6, b.f7), (0, s.f)(7, S.s7)], $)
        },
        rx29: (e, t, i) => {
            i.d(t, {
                W: () => v,
                w: () => g
            });
            var s, o = i("t5wJ"),
                r = i("naIR"),
                n = i("YrcG"),
                a = i("7NN/"),
                c = i("OYZR"),
                d = i("Ayc8"),
                l = i("Vvlp"),
                h = i("iDmX"),
                u = i("p044"),
                p = i("RRaN"),
                m = i("LE1I");
            let g = class {
                static {
                    s = this
                }
                static {
                    this._handlePool = 0
                }
                static {
                    this._maxEventSize = 250
                }
                constructor(e, t) {
                    this._logService = t, this._provider = new Map, this._proxy = e.getProxy(n.Tr.MainThreadDecorations)
                }
                registerFileDecorationProvider(e, t) {
                    const i = s._handlePool++;
                    this._provider.set(i, {
                        provider: e,
                        extensionDescription: t
                    }), this._proxy.$registerDecorationProvider(i, t.identifier.value);
                    const o = e.onDidChangeFileDecorations && e.onDidChangeFileDecorations((e => {
                        if (!e) return void this._proxy.$onDidChange(i, null);
                        const o = (0, h._2)(e);
                        if (o.length <= s._maxEventSize) return void this._proxy.$onDidChange(i, o);
                        this._logService.warn("[Decorations] CAPPING events from decorations provider", t.identifier.value, o.length);
                        const r = o.map((e => ({
                                uri: e,
                                rank: (0, u.QX)(e.path, "/")
                            }))),
                            n = (0, h.vM)(r, ((e, t) => e.rank - t.rank || (0, u.qu)(e.uri.path, t.uri.path))),
                            a = [];
                        e: for (const e of n) {
                            let t;
                            for (const i of e) {
                                const e = (0, p.XX)(i.uri.path);
                                if (t !== e && (t = e, a.push(i.uri) >= s._maxEventSize)) break e
                            }
                        }
                        this._proxy.$onDidChange(i, a)
                    }));
                    return new a.JTr((() => {
                        o ? .dispose(), this._proxy.$unregisterDecorationProvider(i), this._provider.delete(i)
                    }))
                }
                async $provideDecorations(e, t, i) {
                    if (!this._provider.has(e)) return Object.create(null);
                    const s = Object.create(null),
                        {
                            provider: o,
                            extensionDescription: n
                        } = this._provider.get(e);
                    return await Promise.all(t.map((async e => {
                        try {
                            const {
                                uri: t,
                                id: c
                            } = e, d = await Promise.resolve(o.provideFileDecoration(r.ov.revive(t), i));
                            if (!d) return;
                            try {
                                a.unW.validate(d), d.badge && "string" != typeof d.badge && (0, m.H5)(n, "codiconDecoration"), s[c] = [d.propagate, d.tooltip, d.badge, d.color]
                            } catch (e) {
                                this._logService.warn(`INVALID decoration from extension '${n.identifier.value}': ${e}`)
                            }
                        } catch (e) {
                            this._logService.error(e)
                        }
                    }))), s
                }
            };
            g = s = (0, o.g)([(0, o.f)(0, d.O), (0, o.f)(1, l.V)], g);
            const v = (0, c.yh)("IExtHostDecorations")
        },
        "7rMg": (e, t, i) => {
            i.d(t, {
                T7: () => h,
                gR: () => u
            });
            var s = i("/hu5"),
                o = i("PTqS"),
                r = i("p044"),
                n = i("zr1e"),
                a = i("5G63"),
                c = i("7NN/"),
                d = i("iDmX");
            const l = new Map;

            function h(e, t) {
                t ? l.set(e, t) : l.delete(e)
            }
            class u extends n.v {
                constructor(e, t, i, s, o, r, n) {
                    super(t, i, s, o), this._proxy = e, this._languageId = r, this._isDirty = n, this._isDisposed = !1
                }
                dispose() {
                    (0, s.ok)(!this._isDisposed), this._isDisposed = !0, this._isDirty = !1
                }
                equalLines(e) {
                    return (0, d.fS)(this._lines, e)
                }
                get document() {
                    if (!this._document) {
                        const e = this;
                        this._document = {
                            get uri() {
                                return e._uri
                            },
                            get fileName() {
                                return e._uri.fsPath
                            },
                            get isUntitled() {
                                return e._uri.scheme === o.lg.untitled
                            },
                            get languageId() {
                                return e._languageId
                            },
                            get version() {
                                return e._versionId
                            },
                            get isClosed() {
                                return e._isDisposed
                            },
                            get isDirty() {
                                return e._isDirty
                            },
                            save: () => e._save(),
                            getText: t => t ? e._getTextInRange(t) : e.getText(),
                            get eol() {
                                return "\n" === e._eol ? c.b6q.LF : c.b6q.CRLF
                            },
                            get lineCount() {
                                return e._lines.length
                            },
                            lineAt: t => e._lineAt(t),
                            offsetAt: t => e._offsetAt(t),
                            positionAt: t => e._positionAt(t),
                            validateRange: t => e._validateRange(t),
                            validatePosition: t => e._validatePosition(t),
                            getWordRangeAtPosition: (t, i) => e._getWordRangeAtPosition(t, i)
                        }
                    }
                    return Object.freeze(this._document)
                }
                _acceptLanguageId(e) {
                    (0, s.ok)(!this._isDisposed), this._languageId = e
                }
                _acceptIsDirty(e) {
                    (0, s.ok)(!this._isDisposed), this._isDirty = e
                }
                _save() {
                    return this._isDisposed ? Promise.reject(new Error("Document has been closed")) : this._proxy.$trySaveDocument(this._uri)
                }
                _getTextInRange(e) {
                    const t = this._validateRange(e);
                    if (t.isEmpty) return "";
                    if (t.isSingleLine) return this._lines[t.start.line].substring(t.start.character, t.end.character);
                    const i = this._eol,
                        s = t.start.line,
                        o = t.end.line,
                        r = [];
                    r.push(this._lines[s].substring(t.start.character));
                    for (let e = s + 1; e < o; e++) r.push(this._lines[e]);
                    return r.push(this._lines[o].substring(0, t.end.character)), r.join(i)
                }
                _lineAt(e) {
                    let t;
                    if (e instanceof c.Lyo ? t = e.line : "number" == typeof e && (t = e), "number" != typeof t || t < 0 || t >= this._lines.length || Math.floor(t) !== t) throw new Error("Illegal value for `line`");
                    return new p(t, this._lines[t], t === this._lines.length - 1)
                }
                _offsetAt(e) {
                    return e = this._validatePosition(e), this._ensureLineStarts(), this._lineStarts.getPrefixSum(e.line - 1) + e.character
                }
                _positionAt(e) {
                    e = Math.floor(e), e = Math.max(0, e), this._ensureLineStarts();
                    const t = this._lineStarts.getIndexOf(e),
                        i = this._lines[t.index].length;
                    return new c.Lyo(t.index, Math.min(t.remainder, i))
                }
                _validateRange(e) {
                    if (!(e instanceof c.e6w)) throw new Error("Invalid argument");
                    const t = this._validatePosition(e.start),
                        i = this._validatePosition(e.end);
                    return t === e.start && i === e.end ? e : new c.e6w(t.line, t.character, i.line, i.character)
                }
                _validatePosition(e) {
                    if (!(e instanceof c.Lyo)) throw new Error("Invalid argument");
                    if (0 === this._lines.length) return e.with(0, 0);
                    let {
                        line: t,
                        character: i
                    } = e, s = !1;
                    if (t < 0) t = 0, i = 0, s = !0;
                    else if (t >= this._lines.length) t = this._lines.length - 1, i = this._lines[t].length, s = !0;
                    else {
                        const e = this._lines[t].length;
                        i < 0 ? (i = 0, s = !0) : i > e && (i = e, s = !0)
                    }
                    return s ? new c.Lyo(t, i) : e
                }
                _getWordRangeAtPosition(e, t) {
                    const i = this._validatePosition(e);
                    if (t) {
                        if ((0, r.IO)(t)) throw new Error(`[getWordRangeAtPosition]: ignoring custom regexp '${t.source}' because it matches the empty string.`)
                    } else s = this._languageId, t = l.get(s);
                    var s;
                    const o = (0, a.t2)(i.character + 1, (0, a.eq)(t), this._lines[i.line], 0);
                    if (o) return new c.e6w(i.line, o.startColumn - 1, i.line, o.endColumn - 1)
                }
            }
            class p {
                constructor(e, t, i) {
                    this._line = e, this._text = t, this._isLastLine = i
                }
                get lineNumber() {
                    return this._line
                }
                get text() {
                    return this._text
                }
                get range() {
                    return new c.e6w(this._line, 0, this._line, this._text.length)
                }
                get rangeIncludingLineBreak() {
                    return this._isLastLine ? this.range : new c.e6w(this._line, 0, this._line + 1, 0)
                }
                get firstNonWhitespaceCharacterIndex() {
                    return /^(\s*)/.exec(this._text)[1].length
                }
                get isEmptyOrWhitespace() {
                    return this.firstNonWhitespaceCharacterIndex === this._text.length
                }
            }
        },
        l6bu: (e, t, i) => {
            i.d(t, {
                T: () => x,
                W: () => w
            });
            var s = i("t5wJ"),
                o = i("/hu5"),
                r = i("7icl"),
                n = i("RVdl"),
                a = i("naIR"),
                c = i("OYZR"),
                d = i("YrcG"),
                l = i("7rMg"),
                h = i("Ayc8"),
                u = i("4FWJ"),
                p = i("IqsH"),
                m = i("Vvlp"),
                g = i("Ef4y"),
                v = i("PTqS"),
                _ = i("wBFb"),
                f = i("8HR7");
            class y {
                constructor(e) {
                    this.value = e, this._count = 0
                }
                ref() {
                    this._count++
                }
                unref() {
                    return 0 == --this._count
                }
            }
            let w = class {
                constructor(e, t) {
                    this._extHostRpc = e, this._logService = t, this._activeEditorId = null, this._editors = new Map, this._documents = new g.Y9, this._onDidAddDocuments = new r.Q5, this._onDidRemoveDocuments = new r.Q5, this._onDidChangeVisibleTextEditors = new r.Q5, this._onDidChangeActiveTextEditor = new r.Q5, this.onDidAddDocuments = this._onDidAddDocuments.event, this.onDidRemoveDocuments = this._onDidRemoveDocuments.event, this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event, this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event
                }
                $acceptDocumentsAndEditorsDelta(e) {
                    this.acceptDocumentsAndEditorsDelta(e)
                }
                acceptDocumentsAndEditorsDelta(e) {
                    const t = [],
                        i = [],
                        s = [];
                    if (e.removedDocuments)
                        for (const i of e.removedDocuments) {
                            const e = a.ov.revive(i),
                                s = this._documents.get(e);
                            s ? .unref() && (this._documents.delete(e), t.push(s.value))
                        }
                    if (e.addedDocuments)
                        for (const t of e.addedDocuments) {
                            const e = a.ov.revive(t.uri);
                            let s = this._documents.get(e);
                            if (s && e.scheme !== v.lg.vscodeNotebookCell && e.scheme !== v.lg.vscodeInteractiveInput) throw new Error(`document '${e} already exists!'`);
                            s || (s = new y(new l.gR(this._extHostRpc.getProxy(d.Tr.MainThreadDocuments), e, t.lines, t.EOL, t.versionId, t.languageId, t.isDirty)), this._documents.set(e, s), i.push(s.value)), s.ref()
                        }
                    if (e.removedEditors)
                        for (const t of e.removedEditors) {
                            const e = this._editors.get(t);
                            this._editors.delete(t), e && s.push(e)
                        }
                    if (e.addedEditors)
                        for (const t of e.addedEditors) {
                            const e = a.ov.revive(t.documentUri);
                            (0, o.ok)(this._documents.has(e), `document '${e}' does not exist`), (0, o.ok)(!this._editors.has(t.id), `editor '${t.id}' already exists!`);
                            const i = this._documents.get(e).value,
                                s = new u.aQ(t.id, this._extHostRpc.getProxy(d.Tr.MainThreadTextEditors), this._logService, new f.o((() => i.document)), t.selections.map(p.Y1.to), t.options, t.visibleRanges.map((e => p.e6.to(e))), "number" == typeof t.editorPosition ? p.eI.to(t.editorPosition) : void 0);
                            this._editors.set(t.id, s)
                        }
                    void 0 !== e.newActiveEditor && ((0, o.ok)(null === e.newActiveEditor || this._editors.has(e.newActiveEditor), `active editor '${e.newActiveEditor}' does not exist`), this._activeEditorId = e.newActiveEditor), (0, n.B9)(t), (0, n.B9)(s), e.removedDocuments && this._onDidRemoveDocuments.fire(t), e.addedDocuments && this._onDidAddDocuments.fire(i), (e.removedEditors || e.addedEditors) && this._onDidChangeVisibleTextEditors.fire(this.allEditors().map((e => e.value))), void 0 !== e.newActiveEditor && this._onDidChangeActiveTextEditor.fire(this.activeEditor())
                }
                getDocument(e) {
                    return this._documents.get(e) ? .value
                }
                allDocuments() {
                    return _.$.map(this._documents.values(), (e => e.value))
                }
                getEditor(e) {
                    return this._editors.get(e)
                }
                activeEditor(e) {
                    if (!this._activeEditorId) return;
                    const t = this._editors.get(this._activeEditorId);
                    return e ? t : t ? .value
                }
                allEditors() {
                    return [...this._editors.values()]
                }
            };
            w = (0, s.g)([(0, s.f)(0, h.O), (0, s.f)(1, m.V)], w);
            const x = (0, c.yh)("IExtHostDocumentsAndEditors")
        },
        PmF0: (e, t, i) => {
            i.d(t, {
                v: () => p,
                y: () => v
            });
            var s = i("t5wJ"),
                o = i("t1yw"),
                r = i("7icl"),
                n = i("K30K"),
                a = i("naIR"),
                c = i("OYZR"),
                d = i("YrcG"),
                l = i("Ayc8"),
                h = i("IqsH"),
                u = i("7NN/");
            const p = (0, c.yh)("IExtHostEditorTabs");
            class m {
                constructor(e, t, i) {
                    this._activeTabIdGetter = i, this._parentGroup = t, this.acceptDtoUpdate(e)
                }
                get apiObject() {
                    if (!this._apiObject) {
                        const e = this,
                            t = {
                                get isActive() {
                                    return e._dto.id === e._activeTabIdGetter()
                                },
                                get label() {
                                    return e._dto.label
                                },
                                get input() {
                                    return e._input
                                },
                                get isDirty() {
                                    return e._dto.isDirty
                                },
                                get isPinned() {
                                    return e._dto.isPinned
                                },
                                get isPreview() {
                                    return e._dto.isPreview
                                },
                                get group() {
                                    return e._parentGroup.apiObject
                                }
                            };
                        this._apiObject = Object.freeze(t)
                    }
                    return this._apiObject
                }
                get tabId() {
                    return this._dto.id
                }
                acceptDtoUpdate(e) {
                    this._dto = e, this._input = this._initInput()
                }
                _initInput() {
                    switch (this._dto.input.kind) {
                        case d.LJ.TextInput:
                            return new u.Y_o(a.ov.revive(this._dto.input.uri));
                        case d.LJ.TextDiffInput:
                            return new u.lF4(a.ov.revive(this._dto.input.original), a.ov.revive(this._dto.input.modified));
                        case d.LJ.TextMergeInput:
                            return new u.kiP(a.ov.revive(this._dto.input.base), a.ov.revive(this._dto.input.input1), a.ov.revive(this._dto.input.input2), a.ov.revive(this._dto.input.result));
                        case d.LJ.CustomEditorInput:
                            return new u.zwE(a.ov.revive(this._dto.input.uri), this._dto.input.viewType);
                        case d.LJ.WebviewEditorInput:
                            return new u.kU2(this._dto.input.viewType);
                        case d.LJ.NotebookInput:
                            return new u.IAb(a.ov.revive(this._dto.input.uri), this._dto.input.notebookType);
                        case d.LJ.NotebookDiffInput:
                            return new u.ogl(a.ov.revive(this._dto.input.original), a.ov.revive(this._dto.input.modified), this._dto.input.notebookType);
                        case d.LJ.TerminalEditorInput:
                            return new u.UyC;
                        case d.LJ.InteractiveEditorInput:
                            return new u.Ngc(a.ov.revive(this._dto.input.uri), a.ov.revive(this._dto.input.inputBoxUri));
                        case d.LJ.ChatEditorInput:
                            return new u.XgO;
                        case d.LJ.MultiDiffEditorInput:
                            return new u.UwW(this._dto.input.diffEditors.map((e => new u.lF4(a.ov.revive(e.original), a.ov.revive(e.modified)))));
                        default:
                            return
                    }
                }
            }
            class g {
                constructor(e, t) {
                    this._tabs = [], this._activeTabId = "", this._dto = e, this._activeGroupIdGetter = t;
                    for (const t of e.tabs) t.isActive && (this._activeTabId = t.id), this._tabs.push(new m(t, this, (() => this.activeTabId())))
                }
                get apiObject() {
                    if (!this._apiObject) {
                        const e = this,
                            t = {
                                get isActive() {
                                    return e._dto.groupId === e._activeGroupIdGetter()
                                },
                                get viewColumn() {
                                    return h.eI.to(e._dto.viewColumn)
                                },
                                get activeTab() {
                                    return e._tabs.find((t => t.tabId === e._activeTabId)) ? .apiObject
                                },
                                get tabs() {
                                    return Object.freeze(e._tabs.map((e => e.apiObject)))
                                }
                            };
                        this._apiObject = Object.freeze(t)
                    }
                    return this._apiObject
                }
                get groupId() {
                    return this._dto.groupId
                }
                get tabs() {
                    return this._tabs
                }
                acceptGroupDtoUpdate(e) {
                    this._dto = e
                }
                acceptTabOperation(e) {
                    if (e.kind === d._o.TAB_OPEN) {
                        const t = new m(e.tabDto, this, (() => this.activeTabId()));
                        return this._tabs.splice(e.index, 0, t), e.tabDto.isActive && (this._activeTabId = t.tabId), t
                    }
                    if (e.kind === d._o.TAB_CLOSE) {
                        const t = this._tabs.splice(e.index, 1)[0];
                        if (!t) throw new Error(`Tab close updated received for index ${e.index} which does not exist`);
                        return t.tabId === this._activeTabId && (this._activeTabId = ""), t
                    }
                    if (e.kind === d._o.TAB_MOVE) {
                        if (void 0 === e.oldIndex) throw new Error("Invalid old index on move IPC");
                        const t = this._tabs.splice(e.oldIndex, 1)[0];
                        if (!t) throw new Error(`Tab move updated received for index ${e.oldIndex} which does not exist`);
                        return this._tabs.splice(e.index, 0, t), t
                    }
                    const t = this._tabs.find((t => t.tabId === e.tabDto.id));
                    if (!t) throw new Error("INVALID tab");
                    return e.tabDto.isActive ? this._activeTabId = e.tabDto.id : this._activeTabId !== e.tabDto.id || e.tabDto.isActive || (this._activeTabId = ""), t.acceptDtoUpdate(e.tabDto), t
                }
                activeTabId() {
                    return this._activeTabId
                }
            }
            let v = class {
                constructor(e) {
                    this._onDidChangeTabs = new r.Q5, this._onDidChangeTabGroups = new r.Q5, this._extHostTabGroups = [], this._proxy = e.getProxy(d.Tr.MainThreadEditorTabs)
                }
                get tabGroups() {
                    if (!this._apiObject) {
                        const e = this,
                            t = {
                                onDidChangeTabGroups: e._onDidChangeTabGroups.event,
                                onDidChangeTabs: e._onDidChangeTabs.event,
                                get all() {
                                    return Object.freeze(e._extHostTabGroups.map((e => e.apiObject)))
                                },
                                get activeTabGroup() {
                                    const t = e._activeGroupId;
                                    return (0, n.cW)(e._extHostTabGroups.find((e => e.groupId === t)) ? .apiObject)
                                },
                                close: async (e, t) => {
                                    const i = Array.isArray(e) ? e : [e];
                                    return !i.length || (function(e) {
                                        return void 0 !== e.tabs
                                    }(i[0]) ? this._closeGroups(i, t) : this._closeTabs(i, t))
                                }
                            };
                        this._apiObject = Object.freeze(t)
                    }
                    return this._apiObject
                }
                $acceptEditorTabModel(e) {
                    const t = new Set(this._extHostTabGroups.map((e => e.groupId))),
                        i = new Set(e.map((e => e.groupId))),
                        s = (0, o.qP)(t, i),
                        r = this._extHostTabGroups.filter((e => s.removed.includes(e.groupId))).map((e => e.apiObject)),
                        a = [],
                        c = [];
                    this._extHostTabGroups = e.map((e => {
                        const t = new g(e, (() => this._activeGroupId));
                        return s.added.includes(t.groupId) ? a.push(t.apiObject) : c.push(t.apiObject), t
                    }));
                    const d = (0, n.cW)(e.find((e => !0 === e.isActive)) ? .groupId);
                    void 0 !== d && this._activeGroupId !== d && (this._activeGroupId = d), this._onDidChangeTabGroups.fire(Object.freeze({
                        opened: a,
                        closed: r,
                        changed: c
                    }))
                }
                $acceptTabGroupUpdate(e) {
                    const t = this._extHostTabGroups.find((t => t.groupId === e.groupId));
                    if (!t) throw new Error("Update Group IPC call received before group creation.");
                    t.acceptGroupDtoUpdate(e), e.isActive && (this._activeGroupId = e.groupId), this._onDidChangeTabGroups.fire(Object.freeze({
                        changed: [t.apiObject],
                        opened: [],
                        closed: []
                    }))
                }
                $acceptTabOperation(e) {
                    const t = this._extHostTabGroups.find((t => t.groupId === e.groupId));
                    if (!t) throw new Error("Update Tabs IPC call received before group creation.");
                    const i = t.acceptTabOperation(e);
                    switch (e.kind) {
                        case d._o.TAB_OPEN:
                            return void this._onDidChangeTabs.fire(Object.freeze({
                                opened: [i.apiObject],
                                closed: [],
                                changed: []
                            }));
                        case d._o.TAB_CLOSE:
                            return void this._onDidChangeTabs.fire(Object.freeze({
                                opened: [],
                                closed: [i.apiObject],
                                changed: []
                            }));
                        case d._o.TAB_MOVE:
                        case d._o.TAB_UPDATE:
                            return void this._onDidChangeTabs.fire(Object.freeze({
                                opened: [],
                                closed: [],
                                changed: [i.apiObject]
                            }))
                    }
                }
                _findExtHostTabFromApi(e) {
                    for (const t of this._extHostTabGroups)
                        for (const i of t.tabs)
                            if (i.apiObject === e) return i
                }
                _findExtHostTabGroupFromApi(e) {
                    return this._extHostTabGroups.find((t => t.apiObject === e))
                }
                async _closeTabs(e, t) {
                    const i = [];
                    for (const t of e) {
                        const e = this._findExtHostTabFromApi(t);
                        if (!e) throw new Error("Tab close: Invalid tab not found!");
                        i.push(e.tabId)
                    }
                    return this._proxy.$closeTab(i, t)
                }
                async _closeGroups(e, t) {
                    const i = [];
                    for (const t of e) {
                        const e = this._findExtHostTabGroupFromApi(t);
                        if (!e) throw new Error("Group close: Invalid group not found!");
                        i.push(e.groupId)
                    }
                    return this._proxy.$closeGroup(i, t)
                }
            };
            v = (0, s.g)([(0, s.f)(0, l.O)], v)
        },
        spPY: (e, t, i) => {
            i.d(t, {
                Qx: () => te,
                hj: () => ne,
                k2: () => re,
                vM: () => ee
            });
            var s = i("t5wJ"),
                o = i("yFKF"),
                r = i("RRaN"),
                n = i("JKRA"),
                a = i("oVnE"),
                c = i("opu4"),
                d = i("RVdl"),
                l = i("cd+3"),
                h = i("naIR"),
                u = i("Vvlp"),
                p = i("YrcG"),
                m = i("45t+"),
                g = i("PUdK"),
                v = i("NTAU"),
                _ = i("6zxw"),
                f = i("LE1I");
            class y {
                static {
                    this.NONE = new y(!1, -1, -1, -1)
                }
                constructor(e, t, i, s) {
                    this.startup = e, this.codeLoadingTime = t, this.activateCallTime = i, this.activateResolvedTime = s
                }
            }
            class w {
                constructor(e) {
                    this._startup = e, this._codeLoadingStart = -1, this._codeLoadingStop = -1, this._activateCallStart = -1, this._activateCallStop = -1, this._activateResolveStart = -1, this._activateResolveStop = -1
                }
                _delta(e, t) {
                    return -1 === e || -1 === t ? -1 : t - e
                }
                build() {
                    return new y(this._startup, this._delta(this._codeLoadingStart, this._codeLoadingStop), this._delta(this._activateCallStart, this._activateCallStop), this._delta(this._activateResolveStart, this._activateResolveStop))
                }
                codeLoadingStart() {
                    this._codeLoadingStart = Date.now()
                }
                codeLoadingStop() {
                    this._codeLoadingStop = Date.now()
                }
                activateCallStart() {
                    this._activateCallStart = Date.now()
                }
                activateCallStop() {
                    this._activateCallStop = Date.now()
                }
                activateResolveStart() {
                    this._activateResolveStart = Date.now()
                }
                activateResolveStop() {
                    this._activateResolveStop = Date.now()
                }
            }
            class x {
                constructor(e, t, i, s, o, r) {
                    this.activationFailed = e, this.activationFailedError = t, this.activationTimes = i, this.module = s, this.exports = o, this.subscriptions = r
                }
            }
            class b extends x {
                constructor(e) {
                    super(!1, null, e, {
                        activate: void 0,
                        deactivate: void 0
                    }, void 0, [])
                }
            }
            class D extends x {
                constructor() {
                    super(!1, null, y.NONE, {
                        activate: void 0,
                        deactivate: void 0
                    }, void 0, [])
                }
            }
            class C extends x {
                constructor(e) {
                    super(!0, e, y.NONE, {
                        activate: void 0,
                        deactivate: void 0
                    }, void 0, [])
                }
            }
            let S = class {
                constructor(e, t, i, s) {
                    this._logService = s, this._registry = e, this._globalRegistry = t, this._host = i, this._operations = new _.C1, this._alreadyActivatedEvents = Object.create(null)
                }
                dispose() {
                    for (const [e, t] of this._operations) t.dispose()
                }
                async waitForActivatingExtensions() {
                    const e = [];
                    for (const [t, i] of this._operations) e.push(i.wait());
                    await Promise.all(e)
                }
                isActivated(e) {
                    const t = this._operations.get(e);
                    return Boolean(t && t.value)
                }
                getActivatedExtension(e) {
                    const t = this._operations.get(e);
                    if (!t || !t.value) throw new Error(`Extension '${e.value}' is not known or not activated`);
                    return t.value
                }
                async activateByEvent(e, t) {
                    if (this._alreadyActivatedEvents[e]) return;
                    const i = this._registry.getExtensionDescriptionsForActivationEvent(e);
                    await this._activateExtensions(i.map((i => ({
                        id: i.identifier,
                        reason: {
                            startup: t,
                            extensionId: i.identifier,
                            activationEvent: e
                        }
                    })))), this._alreadyActivatedEvents[e] = !0
                }
                activateById(e, t) {
                    const i = this._registry.getExtensionDescription(e);
                    if (!i) throw new Error(`Extension '${e.value}' is not known`);
                    return this._activateExtensions([{
                        id: i.identifier,
                        reason: t
                    }])
                }
                async _activateExtensions(e) {
                    const t = e.filter((e => !this.isActivated(e.id))).map((e => this._handleActivationRequest(e)));
                    await Promise.all(t.map((e => e.wait())))
                }
                _handleActivationRequest(e) {
                    if (this._operations.has(e.id)) return this._operations.get(e.id);
                    if (this._isHostExtension(e.id)) return this._createAndSaveOperation(e, null, [], null);
                    const t = this._registry.getExtensionDescription(e.id);
                    if (!t) {
                        const t = new Error(`Cannot activate unknown extension '${e.id.value}'`),
                            i = this._createAndSaveOperation(e, null, [], new C(t));
                        return this._host.onExtensionActivationError(e.id, t, new f.$V(e.id.value)), i
                    }
                    const i = [],
                        s = void 0 === t.extensionDependencies ? [] : t.extensionDependencies;
                    for (const o of s) {
                        if (this._isResolvedExtension(o)) continue;
                        const s = this._operations.get(o);
                        if (s) {
                            i.push(s);
                            continue
                        }
                        if (this._isHostExtension(o)) {
                            i.push(this._handleActivationRequest({
                                id: this._globalRegistry.getExtensionDescription(o).identifier,
                                reason: e.reason
                            }));
                            continue
                        }
                        const r = this._registry.getExtensionDescription(o);
                        if (r) {
                            if (!r.main && !r.browser) continue;
                            i.push(this._handleActivationRequest({
                                id: r.identifier,
                                reason: e.reason
                            }));
                            continue
                        }
                        const n = t.displayName || t.identifier.value,
                            a = new Error(`Cannot activate the '${n}' extension because it depends on unknown extension '${o}'`),
                            c = this._createAndSaveOperation(e, t.displayName, [], new C(a));
                        return this._host.onExtensionActivationError(t.identifier, a, new f.$V(o)), c
                    }
                    return this._createAndSaveOperation(e, t.displayName, i, null)
                }
                _createAndSaveOperation(e, t, i, s) {
                    const o = new E(e.id, t, e.reason, i, s, this._host, this._logService);
                    return this._operations.set(e.id, o), o
                }
                _isHostExtension(e) {
                    return v.ci.isHostExtension(e, this._registry, this._globalRegistry)
                }
                _isResolvedExtension(e) {
                    const t = this._globalRegistry.getExtensionDescription(e);
                    return !!t && !t.main && !t.browser
                }
            };
            S = (0, s.g)([(0, s.f)(3, u.V)], S);
            let E = class {
                get value() {
                    return this._value
                }
                get friendlyName() {
                    return this._displayName || this._id.value
                }
                constructor(e, t, i, s, o, r, n) {
                    this._id = e, this._displayName = t, this._reason = i, this._deps = s, this._value = o, this._host = r, this._logService = n, this._barrier = new c.U8, this._isDisposed = !1, this._initialize()
                }
                dispose() {
                    this._isDisposed = !0
                }
                wait() {
                    return this._barrier.wait()
                }
                async _initialize() {
                    await this._waitForDepsThenActivate(), this._barrier.open()
                }
                async _waitForDepsThenActivate() {
                    if (!this._value) {
                        for (; this._deps.length > 0;) {
                            for (let e = 0; e < this._deps.length; e++) {
                                const t = this._deps[e];
                                if (!t.value || t.value.activationFailed) {
                                    if (t.value && t.value.activationFailed) {
                                        const e = new Error(`Cannot activate the '${this.friendlyName}' extension because its dependency '${t.friendlyName}' failed to activate`);
                                        return e.detail = t.value.activationFailedError, this._value = new C(e), void this._host.onExtensionActivationError(this._id, e, null)
                                    }
                                } else this._deps.splice(e, 1), e--
                            }
                            this._deps.length > 0 && await Promise.race(this._deps.map((e => e.wait())))
                        }
                        await this._activate()
                    }
                }
                async _activate() {
                    try {
                        this._value = await this._host.actualActivateExtension(this._id, this._reason)
                    } catch (e) {
                        const t = new Error;
                        if (e && e.name && (t.name = e.name), e && e.message ? t.message = `Activating extension '${this._id.value}' failed: ${e.message}.` : t.message = `Activating extension '${this._id.value}' failed: ${e}.`, e && e.stack && (t.stack = e.stack), this._value = new C(t), this._isDisposed && (0, g.n2)(e)) return;
                        this._host.onExtensionActivationError(this._id, t, null), this._logService.error(`Activating extension ${this._id.value} failed due to an error:`), this._logService.error(e)
                    }
                }
            };
            E = (0, s.g)([(0, s.f)(6, u.V)], E);
            var P = i("GZWR"),
                T = i("n9io"),
                k = i("jxI3");
            class I {
                constructor(e, t, i) {
                    this._deferredPromises = new Map, this._id = e, this._shared = t, this._storage = i, this._init = this._storage.initializeExtensionStorage(this._shared, this._id, Object.create(null)).then((e => (this._value = e, this))), this._storageListener = this._storage.onDidChangeStorage((e => {
                        e.shared === this._shared && e.key === this._id && (this._value = e.value)
                    })), this._scheduler = new c.pY((() => {
                        const e = this._deferredPromises;
                        this._deferredPromises = new Map, (async () => {
                            try {
                                await this._storage.setValue(this._shared, this._id, this._value);
                                for (const t of e.values()) t.complete()
                            } catch (t) {
                                for (const i of e.values()) i.error(t)
                            }
                        })()
                    }), 0)
                }
                keys() {
                    return Object.entries(this._value ? ? {}).filter((([, e]) => void 0 !== e)).map((([e]) => e))
                }
                get whenReady() {
                    return this._init
                }
                get(e, t) {
                    let i = this._value[e];
                    return void 0 === i && (i = t), i
                }
                update(e, t) {
                    this._value[e] = t;
                    const i = this._deferredPromises.get(e);
                    if (void 0 !== i) return i.p;
                    const s = new c.CR;
                    return this._deferredPromises.set(e, s), this._scheduler.isScheduled() || this._scheduler.schedule(), s.p
                }
                dispose() {
                    this._storageListener.dispose()
                }
            }
            class A extends I {
                setKeysForSync(e) {
                    this._storage.registerExtensionStorageKeysToSync({
                        id: this._id,
                        version: this._extension.version
                    }, e)
                }
                constructor(e, t) {
                    super(e.identifier.value, !0, t), this._extension = e
                }
            }
            var $ = i("7NN/"),
                R = i("83Eb"),
                H = i("OYZR"),
                F = i("5h1i"),
                N = i("PZtK"),
                M = i("Ayc8"),
                L = i("5g4k"),
                O = i("bQf8"),
                U = i("DvZ5"),
                V = i("9STo"),
                W = i("7icl"),
                B = i("EpfU"),
                z = i("ZuU9");
            class j {#
                s;
                constructor(e, t) {
                    this.disposables = new d.SL, this._id = _.kP.toKey(e.identifier), this.#s = t, this.onDidChange = W.ju.map(W.ju.filter(this.#s.onDidChangePassword, (e => e.extensionId === this._id)), (e => ({
                        key: e.key
                    })), this.disposables)
                }
                dispose() {
                    this.disposables.dispose()
                }
                get(e) {
                    return this.#s.get(this._id, e)
                }
                store(e, t) {
                    return this.#s.store(this._id, e, t)
                }
                delete(e) {
                    return this.#s.delete(this._id, e)
                }
            }
            var q, K = i("PTqS"),
                J = i("0eYU"),
                G = i("V2Gl"),
                Q = i("pLPy"),
                Z = i("CbIF"),
                Y = i("ziTh");
            const X = "vs/workbench/api/common/extHostExtensionService",
                ee = (0, H.yh)("IHostUtils");
            let te = q = class extends d.JT {
                constructor(e, t, i, s, o, r, n, a, d, l, h, u, m) {
                    super(), this._extHostManagedSockets = u, this._extHostLanguageModels = m, this._onDidChangeRemoteConnectionData = this._register(new W.Q5), this.onDidChangeRemoteConnectionData = this._onDidChangeRemoteConnectionData.event, this._realPathCache = new Map, this._isTerminating = !1, this._hostUtils = t, this._extHostContext = i, this._initData = n, this._extHostWorkspace = s, this._extHostConfiguration = o, this._logService = r, this._extHostTunnelService = d, this._extHostTerminalService = l, this._extHostLocalizationService = h, this._mainThreadWorkspaceProxy = this._extHostContext.getProxy(p.Tr.MainThreadWorkspace), this._mainThreadTelemetryProxy = this._extHostContext.getProxy(p.Tr.MainThreadTelemetry), this._mainThreadExtensionsProxy = this._extHostContext.getProxy(p.Tr.MainThreadExtensionService), this._almostReadyToRunExtensions = new c.U8, this._readyToStartExtensionHost = new c.U8, this._readyToRunExtensions = new c.U8, this._eagerExtensionsActivated = new c.U8, this._activationEventsReader = new de(this._initData.extensions.activationEvents), this._globalRegistry = new v.ci(this._activationEventsReader, this._initData.extensions.allExtensions);
                    const f = new _.o$(this._initData.extensions.myExtensions);
                    this._myRegistry = new v.ci(this._activationEventsReader, ae(this._globalRegistry, f)), Q.yg && (this._logService.info(`Creating extension host with the following global extensions: ${oe(this._globalRegistry)}`), this._logService.info(`Creating extension host with the following local extensions: ${oe(this._myRegistry)}`)), this._storage = new P.Y(this._extHostContext, this._logService), this._secretState = new z.p(this._extHostContext), this._storagePath = a, this._instaService = e.createChild(new L.y([P.W, this._storage], [z.Z, this._secretState])), this._activator = this._register(new S(this._myRegistry, this._globalRegistry, {
                        onExtensionActivationError: (e, t, i) => {
                            this._mainThreadExtensionsProxy.$onExtensionActivationError(e, (0, g.ri)(t), i)
                        },
                        actualActivateExtension: async (e, t) => {
                            if (v.ci.isHostExtension(e, this._myRegistry, this._globalRegistry)) return await this._mainThreadExtensionsProxy.$activateExtension(e, t), new D;
                            const i = this._myRegistry.getExtensionDescription(e);
                            return this._activateExtension(i, t)
                        }
                    }, this._logService)), this._extensionPathIndex = null, this._resolvers = Object.create(null), this._started = !1, this._remoteConnectionData = this._initData.remote.connectionData
                }
                getRemoteConnectionData() {
                    return this._remoteConnectionData
                }
                async initialize() {
                    try {
                        await this._beforeAlmostReadyToRunExtensions(), this._almostReadyToRunExtensions.open(), await this._extHostWorkspace.waitForInitializeCall(), (0, n.B)("code/extHost/ready"), this._readyToStartExtensionHost.open(), this._initData.autoStart && this._startExtensionHost()
                    } catch (e) {
                        (0, g.dL)(e)
                    }
                }
                async _deactivateAll() {
                    this._storagePath.onWillDeactivateAll();
                    let e = [];
                    try {
                        e = this._myRegistry.getAllExtensionDescriptions().map((e => e.identifier)).filter((e => this.isActivated(e))).map((e => this._deactivate(e)))
                    } catch (e) {}
                    await Promise.all(e)
                }
                terminate(e, t = 0) {
                    if (this._isTerminating) return;
                    this._isTerminating = !0, this._logService.info(`Extension host terminating: ${e}`), this._logService.flush(), this._extHostTerminalService.dispose(), this._activator.dispose(), Q.n2 && (0, g.sH)((e => {
                        this._logService.error(e)
                    })), this._extHostContext.dispose();
                    const i = this._deactivateAll();
                    Promise.race([(0, c.Vs)(5e3), i]).finally((() => {
                        this._hostUtils.pid ? this._logService.info(`Extension host with pid ${this._hostUtils.pid} exiting with code ${t}`) : this._logService.info(`Extension host exiting with code ${t}`), this._logService.flush(), this._logService.dispose(), this._hostUtils.exit(t)
                    }))
                }
                isActivated(e) {
                    return !!this._readyToRunExtensions.isOpen() && this._activator.isActivated(e)
                }
                async getExtension(e) {
                    const t = await this._mainThreadExtensionsProxy.$getExtension(e);
                    return t && { ...t,
                        identifier: new _.kP(t.identifier.value),
                        extensionLocation: h.ov.revive(t.extensionLocation)
                    }
                }
                _activateByEvent(e, t) {
                    return this._activator.activateByEvent(e, t)
                }
                _activateById(e, t) {
                    return this._activator.activateById(e, t)
                }
                activateByIdWithErrors(e, t) {
                    return this._activateById(e, t).then((() => {
                        const t = this._activator.getActivatedExtension(e);
                        if (t.activationFailed) return Promise.reject(t.activationFailedError)
                    }))
                }
                getExtensionRegistry() {
                    return this._readyToRunExtensions.wait().then((e => this._myRegistry))
                }
                getExtensionExports(e) {
                    if (this._readyToRunExtensions.isOpen()) return this._activator.getActivatedExtension(e).exports;
                    try {
                        return this._activator.getActivatedExtension(e).exports
                    } catch (e) {
                        return null
                    }
                }
                async _realPathExtensionUri(e) {
                    if (e.scheme === K.lg.file && this._hostUtils.fsRealpath) {
                        const t = e.fsPath;
                        this._realPathCache.has(t) || this._realPathCache.set(t, this._hostUtils.fsRealpath(t));
                        const i = await this._realPathCache.get(t);
                        return h.ov.file(i)
                    }
                    return e
                }
                async getExtensionPathIndex() {
                    return this._extensionPathIndex || (this._extensionPathIndex = this._createExtensionPathIndex(this._myRegistry.getAllExtensionDescriptions()).then((e => new ce(e)))), this._extensionPathIndex
                }
                async _createExtensionPathIndex(e) {
                    const t = l.Id.forUris((e => a.wi.ignorePathCasing(e)));
                    return await Promise.all(e.map((async e => {
                        if (this._getEntryPoint(e)) {
                            const i = await this._realPathExtensionUri(e.extensionLocation);
                            t.set(i, e)
                        }
                    }))), t
                }
                _deactivate(e) {
                    let t = Promise.resolve(void 0);
                    if (!this._readyToRunExtensions.isOpen()) return t;
                    if (!this._activator.isActivated(e)) return t;
                    const i = this._activator.getActivatedExtension(e);
                    if (!i) return t;
                    try {
                        "function" == typeof i.module.deactivate && (t = Promise.resolve(i.module.deactivate()).then(void 0, (e => (this._logService.error(e), Promise.resolve(void 0)))))
                    } catch (t) {
                        this._logService.error(`An error occurred when deactivating the extension '${e.value}':`), this._logService.error(t)
                    }
                    try {
                        (0, d.B9)(i.subscriptions)
                    } catch (t) {
                        this._logService.error(`An error occurred when deactivating the subscriptions for extension '${e.value}':`), this._logService.error(t)
                    }
                    return t
                }
                async _activateExtension(e, t) {
                    return this._initData.remote.isRemote ? this._mainThreadExtensionsProxy.$onWillActivateExtension(e.identifier) : await this._mainThreadExtensionsProxy.$onWillActivateExtension(e.identifier), this._doActivateExtension(e, t).then((i => {
                        const s = i.activationTimes;
                        return this._mainThreadExtensionsProxy.$onDidActivateExtension(e.identifier, s.codeLoadingTime, s.activateCallTime, s.activateResolvedTime, t), this._logExtensionActivationTimes(e, t, "success", s), i
                    }), (i => {
                        throw this._logExtensionActivationTimes(e, t, "failure"), i
                    }))
                }
                _logExtensionActivationTimes(e, t, i, s) {
                    const o = se(e, t);
                    this._mainThreadTelemetryProxy.$publicLog2("extensionActivationTimes", { ...o,
                        ...s || {},
                        outcome: i
                    })
                }
                _doActivateExtension(e, t) {
                    const i = se(e, t);
                    this._mainThreadTelemetryProxy.$publicLog2("activatePlugin", i);
                    const s = this._getEntryPoint(e);
                    if (!s) return Promise.resolve(new b(y.NONE));
                    this._logService.info(`ExtensionService#_doActivateExtension ${e.identifier.value}, startup: ${t.startup}, activationEvent: '${t.activationEvent}'${e.identifier.value!==t.extensionId.value?`, root cause: ${t.extensionId.value}`:""}`), this._logService.flush();
                    const o = new w(t.startup);
                    return Promise.all([this._loadCommonJSModule(e, (0, a.Vo)(e.extensionLocation, s), o), this._loadExtensionContext(e)]).then((t => ((0, n.B)(`code/extHost/willActivateExtension/${e.identifier.value}`), q._callActivate(this._logService, e.identifier, t[0], t[1], o)))).then((t => ((0, n.B)(`code/extHost/didActivateExtension/${e.identifier.value}`), t)))
                }
                _loadExtensionContext(e) {
                    const t = this._extHostLanguageModels.createLanguageModelAccessInformation(e),
                        i = this._register(new A(e, this._storage)),
                        s = this._register(new I(e.identifier.value, !1, this._storage)),
                        o = this._register(new j(e, this._secretState)),
                        n = e.isUnderDevelopment ? this._initData.environment.extensionTestsLocationURI ? $.UCC.Test : $.UCC.Development : $.UCC.Production,
                        a = this._initData.remote.isRemote ? $.TPH.Workspace : $.TPH.UI;
                    return this._logService.trace(`ExtensionService#loadExtensionContext ${e.identifier.value}`), Promise.all([i.whenReady, s.whenReady, this._storagePath.whenReady]).then((() => {
                        const c = this;
                        let d, l;
                        const u = (0, f.$x)(e, "ipc") ? this._initData.messagePorts ? .get(_.kP.toKey(e.identifier)) : void 0;
                        return Object.freeze({
                            globalState: i,
                            workspaceState: s,
                            secrets: o,
                            subscriptions: [],
                            get languageModelAccessInformation() {
                                return t
                            },
                            get extensionUri() {
                                return e.extensionLocation
                            },
                            get extensionPath() {
                                return e.extensionLocation.fsPath
                            },
                            asAbsolutePath: t => (0, r.v_)(e.extensionLocation.fsPath, t),
                            get storagePath() {
                                return c._storagePath.workspaceValue(e) ? .fsPath
                            },
                            get globalStoragePath() {
                                return c._storagePath.globalValue(e).fsPath
                            },
                            get logPath() {
                                return (0, r.v_)(c._initData.logsLocation.fsPath, e.identifier.value)
                            },
                            get logUri() {
                                return h.ov.joinPath(c._initData.logsLocation, e.identifier.value)
                            },
                            get storageUri() {
                                return c._storagePath.workspaceValue(e)
                            },
                            get globalStorageUri() {
                                return c._storagePath.globalValue(e)
                            },
                            get extensionMode() {
                                return n
                            },
                            get extension() {
                                return void 0 === d && (d = new ne(c, e.identifier, e, a, !1)), d
                            },
                            get extensionRuntime() {
                                return (0, f.H5)(e, "extensionRuntime"), c.extensionRuntime
                            },
                            get environmentVariableCollection() {
                                return c._extHostTerminalService.getEnvironmentVariableCollection(e)
                            },
                            get messagePassingProtocol() {
                                if (!l) {
                                    if (!u) return;
                                    const e = W.ju.buffer(W.ju.fromDOMEventEmitter(u, "message", (e => e.data)));
                                    u.start(), l = {
                                        onDidReceiveMessage: e,
                                        postMessage: u.postMessage.bind(u)
                                    }
                                }
                                return l
                            }
                        })
                    }))
                }
                static _callActivate(e, t, i, s, o) {
                    return i = i || {
                        activate: void 0,
                        deactivate: void 0
                    }, this._callActivateOptional(e, t, i, s, o).then((e => new x(!1, null, o.build(), i, e, s.subscriptions)))
                }
                static _callActivateOptional(e, t, i, s, o) {
                    if ("function" != typeof i.activate) return Promise.resolve(i);
                    try {
                        o.activateCallStart(), e.trace(`ExtensionService#_callActivateOptional ${t.value}`);
                        const r = "object" == typeof global ? global : self,
                            n = i.activate.apply(r, [s]);
                        return o.activateCallStop(), o.activateResolveStart(), Promise.resolve(n).then((e => (o.activateResolveStop(), e)))
                    } catch (e) {
                        return Promise.reject(e)
                    }
                }
                _activateOneStartupFinished(e, t) {
                    this._activateById(e.identifier, {
                        startup: !1,
                        extensionId: e.identifier,
                        activationEvent: t
                    }).then(void 0, (e => {
                        this._logService.error(e)
                    }))
                }
                _activateAllStartupFinishedDeferred(e, t = 0) {
                    const i = Date.now();
                    (0, Q.fn)((() => {
                        for (let s = t; s < e.length; s += 1) {
                            const t = e[s];
                            for (const o of t.activationEvents ? ? [])
                                if ("onStartupFinished" === o) {
                                    if (Date.now() - i > 50) {
                                        this._activateAllStartupFinishedDeferred(e, s);
                                        break
                                    }
                                    this._activateOneStartupFinished(t, o)
                                }
                        }
                    }))
                }
                _activateAllStartupFinished() {
                    this._mainThreadExtensionsProxy.$setPerformanceMarks((0, n._)()), this._extHostConfiguration.getConfigProvider().then((e => {
                        const t = e.getConfiguration("extensions.experimental").get("deferredStartupFinishedActivation"),
                            i = this._myRegistry.getAllExtensionDescriptions();
                        if (t) this._activateAllStartupFinishedDeferred(i);
                        else
                            for (const e of i)
                                if (e.activationEvents)
                                    for (const t of e.activationEvents) "onStartupFinished" === t && this._activateOneStartupFinished(e, t)
                    }))
                }
                _handleEagerExtensions() {
                    const e = this._activateByEvent("*", !0).then(void 0, (e => {
                        this._logService.error(e)
                    }));
                    this._register(this._extHostWorkspace.onDidChangeWorkspace((e => this._handleWorkspaceContainsEagerExtensions(e.added))));
                    const t = this._extHostWorkspace.workspace ? this._extHostWorkspace.workspace.folders : [],
                        i = this._handleWorkspaceContainsEagerExtensions(t),
                        s = this._handleRemoteResolverEagerExtensions(),
                        o = Promise.all([s, e, i]).then((() => {}));
                    return Promise.race([o, (0, c.Vs)(1e4)]).then((() => {
                        this._activateAllStartupFinished()
                    })), o
                }
                _handleWorkspaceContainsEagerExtensions(e) {
                    return 0 === e.length ? Promise.resolve(void 0) : Promise.all(this._myRegistry.getAllExtensionDescriptions().map((t => this._handleWorkspaceContainsEagerExtension(e, t)))).then((() => {}))
                }
                async _handleWorkspaceContainsEagerExtension(e, t) {
                    if (this.isActivated(t.identifier)) return;
                    const i = !this._initData.remote.isRemote && !!this._initData.remote.authority,
                        s = {
                            logService: this._logService,
                            folders: e.map((e => e.uri)),
                            forceUsingSearch: i || !this._hostUtils.fsExists,
                            exists: e => this._hostUtils.fsExists(e.fsPath),
                            checkExists: (e, t, i) => this._mainThreadWorkspaceProxy.$checkExists(e, t, i)
                        },
                        o = await (0, B.U)(s, t);
                    return o ? this._activateById(t.identifier, {
                        startup: !0,
                        extensionId: t.identifier,
                        activationEvent: o.activationEvent
                    }).then(void 0, (e => this._logService.error(e))) : void 0
                }
                async _handleRemoteResolverEagerExtensions() {
                    if (this._initData.remote.authority) return this._activateByEvent(`onResolveRemoteAuthority:${this._initData.remote.authority}`, !1)
                }
                async $extensionTestsExecute() {
                    await this._eagerExtensionsActivated.wait();
                    try {
                        return await this._doHandleExtensionTests()
                    } catch (e) {
                        throw Y.error(e), e
                    }
                }
                async _doHandleExtensionTests() {
                    const {
                        extensionDevelopmentLocationURI: e,
                        extensionTestsLocationURI: t
                    } = this._initData.environment;
                    if (!e || !t) throw new Error((0, o.C$)(X, 0, "Cannot load test runner."));
                    const i = await this._loadCommonJSModule(null, t, new w(!1));
                    if (!i || "function" != typeof i.run) throw new Error((0, o.C$)(X, 1, "Path {0} does not point to a valid extension test runner.", t.toString()));
                    return new Promise(((e, s) => {
                        const o = (0, a.z_)(t),
                            r = i.run(o, ((t, i) => {
                                t ? (Q.yg && this._logService.error("Test runner called back with error", t), s(t)) : (Q.yg && (i ? this._logService.info(`Test runner called back with ${i} failures.`) : this._logService.info("Test runner called back with successful outcome.")), e("number" == typeof i && i > 0 ? 1 : 0))
                            }));
                        r && r.then && r.then((() => {
                            Q.yg && this._logService.info("Test runner finished successfully."), e(0)
                        })).catch((e => {
                            Q.yg && this._logService.error("Test runner finished with error", e), s(e instanceof Error && e.stack ? e.stack : String(e))
                        }))
                    }))
                }
                _startExtensionHost() {
                    if (this._started) throw new Error("Extension host is already started!");
                    return this._started = !0, this._readyToStartExtensionHost.wait().then((() => this._readyToRunExtensions.open())).then((() => Promise.race([this._activator.waitForActivatingExtensions(), (0, c.Vs)(1e3)]))).then((() => this._handleEagerExtensions())).then((() => {
                        this._eagerExtensionsActivated.open(), this._logService.info("Eager extensions activated")
                    }))
                }
                registerRemoteAuthorityResolver(e, t) {
                    return this._resolvers[e] = t, (0, d.OF)((() => {
                        delete this._resolvers[e]
                    }))
                }
                async getRemoteExecServer(e) {
                    const {
                        resolver: t
                    } = await this._activateAndGetResolver(e);
                    return t ? .resolveExecServer ? .(e, {
                        resolveAttempt: 0
                    })
                }
                async _activateAndGetResolver(e) {
                    const t = e.indexOf("+");
                    if (-1 === t) throw new $.qaI("Not an authority that can be resolved!", R.XP.InvalidAuthority);
                    const i = e.substr(0, t);
                    return await this._almostReadyToRunExtensions.wait(), await this._activateByEvent(`onResolveRemoteAuthority:${i}`, !1), {
                        authorityPrefix: i,
                        resolver: this._resolvers[i]
                    }
                }
                async $resolveAuthority(e, t) {
                    const i = G.G.create(!1),
                        s = () => `[resolveAuthority(${(0,R.lt)(e)},${t})][${i.elapsed()}ms] `,
                        o = e => this._logService.info(`${s()}${e}`),
                        r = e => this._logService.warn(`${s()}${e}`),
                        a = (e, t = undefined) => this._logService.error(`${s()}${e}`, t),
                        d = e => {
                            if (e instanceof $.qaI) return {
                                type: "error",
                                error: {
                                    code: e._code,
                                    message: e._message,
                                    detail: e._detail
                                }
                            };
                            throw e
                        },
                        l = async e => {
                            o(`activating resolver for ${e}...`);
                            const {
                                resolver: t,
                                authorityPrefix: i
                            } = await this._activateAndGetResolver(e);
                            if (!t) throw a(`no resolver for ${i}`), new $.qaI(`No remote extension installed to resolve ${i}.`, R.XP.NoResolverFound);
                            return {
                                resolver: t,
                                authorityPrefix: i,
                                remoteAuthority: e
                            }
                        },
                        h = e.split(/@|%40/g).reverse();
                    let u;
                    o(`activating remote resolvers ${h.join(" -> ")}`);
                    try {
                        u = await Promise.all(h.map(l)).catch((async t => {
                            if (!(t instanceof $.qaI) || t._code !== R.XP.InvalidAuthority) throw t;
                            return r(`resolving nested authorities failed: ${t.message}`), [await l(e)]
                        }))
                    } catch (e) {
                        return d(e)
                    }
                    const p = new c.zh;
                    let m, g;
                    p.cancelAndSet((() => o("waiting...")), 1e3);
                    for (const [e, {
                            authorityPrefix: i,
                            resolver: s,
                            remoteAuthority: r
                        }] of u.entries()) try {
                        if (e === u.length - 1) o("invoking final resolve()..."), (0, n.B)(`code/extHost/willResolveAuthority/${i}`), m = await s.resolve(r, {
                            resolveAttempt: t,
                            execServer: g
                        }), (0, n.B)(`code/extHost/didResolveAuthorityOK/${i}`), o("setting tunnel factory..."), this._register(await this._extHostTunnelService.setTunnelFactory(s, $.ryi.isManagedResolvedAuthority(m) ? m : void 0));
                        else {
                            if (o(`invoking resolveExecServer() for ${r}`), (0, n.B)(`code/extHost/willResolveExecServer/${i}`), g = await (s.resolveExecServer ? .(r, {
                                    resolveAttempt: t,
                                    execServer: g
                                })), !g) throw new $.qaI(`Exec server was not available for ${r}`, R.XP.NoResolverFound);
                            (0, n.B)(`code/extHost/didResolveExecServerOK/${i}`)
                        }
                    } catch (e) {
                        return (0, n.B)(`code/extHost/didResolveAuthorityError/${i}`), a("returned an error", e), p.dispose(), d(e)
                    }
                    p.dispose();
                    const v = {
                            environmentTunnels: m.environmentTunnels,
                            features: m.tunnelFeatures ? {
                                elevation: m.tunnelFeatures.elevation,
                                privacyOptions: m.tunnelFeatures.privacyOptions,
                                protocol: void 0 === m.tunnelFeatures.protocol || m.tunnelFeatures.protocol
                            } : void 0
                        },
                        _ = {
                            extensionHostEnv: m.extensionHostEnv,
                            isTrusted: m.isTrusted,
                            authenticationSession: m.authenticationSessionForInitializingExtensions ? {
                                id: m.authenticationSessionForInitializingExtensions.id,
                                providerId: m.authenticationSessionForInitializingExtensions.providerId
                            } : void 0
                        };
                    let f;
                    if (o("returned " + ($.ryi.isManagedResolvedAuthority(m) ? "managed authority" : `${m.host}:${m.port}`)), $.ryi.isManagedResolvedAuthority(m)) {
                        const i = t;
                        this._extHostManagedSockets.setFactory(i, m.makeConnection), f = {
                            authority: e,
                            connectTo: new R.xf(i),
                            connectionToken: m.connectionToken
                        }
                    } else f = {
                        authority: e,
                        connectTo: new R.JE(m.host, m.port),
                        connectionToken: m.connectionToken
                    };
                    return {
                        type: "ok",
                        value: {
                            authority: f,
                            options: _,
                            tunnelInformation: v
                        }
                    }
                }
                async $getCanonicalURI(e, t) {
                    this._logService.info(`$getCanonicalURI invoked for authority (${(0,R.lt)(e)})`);
                    const {
                        resolver: i
                    } = await this._activateAndGetResolver(e);
                    if (!i) return null;
                    const s = h.ov.revive(t);
                    if (void 0 === i.getCanonicalURI) return s;
                    return await (0, c.OH)((() => i.getCanonicalURI(s))) || s
                }
                async $startExtensionHost(e) {
                    e.toAdd.forEach((e => e.extensionLocation = h.ov.revive(e.extensionLocation)));
                    const {
                        globalRegistry: t,
                        myExtensions: i
                    } = ie(this._activationEventsReader, this._globalRegistry, this._myRegistry, e), s = await this._createExtensionPathIndex(i);
                    return (await this.getExtensionPathIndex()).setSearchTree(s), this._globalRegistry.set(t.getAllExtensionDescriptions()), this._myRegistry.set(i), Q.yg && (this._logService.info(`$startExtensionHost: global extensions: ${oe(this._globalRegistry)}`), this._logService.info(`$startExtensionHost: local extensions: ${oe(this._myRegistry)}`)), this._startExtensionHost()
                }
                $activateByEvent(e, t) {
                    return t === f.mF.Immediate ? this._almostReadyToRunExtensions.wait().then((t => this._activateByEvent(e, !1))) : this._readyToRunExtensions.wait().then((t => this._activateByEvent(e, !1)))
                }
                async $activate(e, t) {
                    return await this._readyToRunExtensions.wait(), !!this._myRegistry.getExtensionDescription(e) && (await this._activateById(e, t), !0)
                }
                async $deltaExtensions(e) {
                    e.toAdd.forEach((e => e.extensionLocation = h.ov.revive(e.extensionLocation)));
                    const {
                        globalRegistry: t,
                        myExtensions: i
                    } = ie(this._activationEventsReader, this._globalRegistry, this._myRegistry, e), s = await this._createExtensionPathIndex(i);
                    return (await this.getExtensionPathIndex()).setSearchTree(s), this._globalRegistry.set(t.getAllExtensionDescriptions()), this._myRegistry.set(i), Q.yg && (this._logService.info(`$deltaExtensions: global extensions: ${oe(this._globalRegistry)}`), this._logService.info(`$deltaExtensions: local extensions: ${oe(this._myRegistry)}`)), Promise.resolve(void 0)
                }
                async $test_latency(e) {
                    return e
                }
                async $test_up(e) {
                    return e.byteLength
                }
                async $test_down(e) {
                    const t = k.KN.alloc(e),
                        i = Math.random() % 256;
                    for (let s = 0; s < e; s++) t.writeUInt8(i, s);
                    return t
                }
                async $updateRemoteConnectionData(e) {
                    this._remoteConnectionData = e, this._onDidChangeRemoteConnectionData.fire()
                }
            };

            function ie(e, t, i, s) {
                e.addActivationEvents(s.addActivationEvents);
                const o = new v.ci(e, t.getAllExtensionDescriptions());
                o.deltaExtensions(s.toAdd, s.toRemove);
                const r = new _.o$(i.getAllExtensionDescriptions().map((e => e.identifier)));
                for (const e of s.myToRemove) r.delete(e);
                for (const e of s.myToAdd) r.add(e);
                return {
                    globalRegistry: o,
                    myExtensions: ae(o, r)
                }
            }

            function se(e, t) {
                return {
                    id: e.identifier.value,
                    name: e.name,
                    extensionVersion: e.version,
                    publisherDisplayName: e.publisher,
                    activationEvents: e.activationEvents ? e.activationEvents.join(",") : null,
                    isBuiltin: e.isBuiltin,
                    reason: t.activationEvent,
                    reasonId: t.extensionId.value
                }
            }

            function oe(e) {
                return e.getAllExtensionDescriptions().map((e => e.identifier.value)).join(",")
            }
            te = q = (0, s.g)([(0, s.f)(0, H.TG), (0, s.f)(1, ee), (0, s.f)(2, M.O), (0, s.f)(3, T.w), (0, s.f)(4, m.E1), (0, s.f)(5, u.V), (0, s.f)(6, F.$), (0, s.f)(7, N.L), (0, s.f)(8, O.rd), (0, s.f)(9, U.$3), (0, s.f)(10, J.O), (0, s.f)(11, Z.W), (0, s.f)(12, V.X)], te);
            const re = (0, H.yh)("IExtHostExtensionService");
            class ne {#
                o;#
                r;#
                n;
                constructor(e, t, i, s, o) {
                    this.#o = e, this.#r = t, this.#n = i.identifier, this.id = i.identifier.value, this.extensionUri = i.extensionLocation, this.extensionPath = (0, r.Fv)((0, a.z_)(i.extensionLocation)), this.packageJSON = i, this.extensionKind = s, this.isFromDifferentExtensionHost = o
                }
                get isActive() {
                    return this.#o.isActivated(this.#n)
                }
                get exports() {
                    if ("none" !== this.packageJSON.api && !this.isFromDifferentExtensionHost) return this.#o.getExtensionExports(this.#n)
                }
                async activate() {
                    if (this.isFromDifferentExtensionHost) throw new Error("Cannot activate foreign extension");
                    return await this.#o.activateByIdWithErrors(this.#n, {
                        startup: !1,
                        extensionId: this.#r,
                        activationEvent: "api"
                    }), this.exports
                }
            }

            function ae(e, t) {
                return e.getAllExtensionDescriptions().filter((e => t.has(e.identifier)))
            }
            class ce {
                constructor(e) {
                    this._searchTree = e
                }
                setSearchTree(e) {
                    this._searchTree = e
                }
                findSubstr(e) {
                    return this._searchTree.findSubstr(e)
                }
                forEach(e) {
                    return this._searchTree.forEach(e)
                }
            }
            class de {
                constructor(e) {
                    this._map = new _.C1, this.addActivationEvents(e)
                }
                readActivationEvents(e) {
                    return this._map.get(e.identifier) ? ? []
                }
                addActivationEvents(e) {
                    for (const t of Object.keys(e)) this._map.set(t, e[t])
                }
            }
        },
        nG0x: (e, t, i) => {
            i.d(t, {
                L: () => v,
                a: () => _
            });
            var s, o = i("t5wJ"),
                r = i("YrcG"),
                n = i("ts6x"),
                a = i("7NN/"),
                c = i("jxI3"),
                d = i("OYZR"),
                l = i("Ayc8"),
                h = i("CRYY"),
                u = i("RVdl"),
                p = i("opu4"),
                m = i("oVnE"),
                g = i("PTqS");
            let v = s = class {
                constructor(e, t) {
                    this._fileSystemProvider = new Map, this._writeQueue = new p.sW, this._proxy = e.getProxy(r.Tr.MainThreadFileSystem);
                    const i = this;
                    this.value = Object.freeze({
                        async stat(e) {
                            try {
                                let t;
                                const s = i._fileSystemProvider.get(e.scheme);
                                return s ? (await i._proxy.$ensureActivation(e.scheme), t = await s.impl.stat(e)) : t = await i._proxy.$stat(e), {
                                    type: t.type,
                                    ctime: t.ctime,
                                    mtime: t.mtime,
                                    size: t.size,
                                    permissions: t.permissions === n.rM.Readonly ? 1 : void 0
                                }
                            } catch (e) {
                                s._handleError(e)
                            }
                        },
                        async readDirectory(e) {
                            try {
                                const t = i._fileSystemProvider.get(e.scheme);
                                return t ? (await i._proxy.$ensureActivation(e.scheme), (await t.impl.readDirectory(e)).slice()) : await i._proxy.$readdir(e)
                            } catch (e) {
                                return s._handleError(e)
                            }
                        },
                        async createDirectory(e) {
                            try {
                                const t = i._fileSystemProvider.get(e.scheme);
                                return t && !t.isReadonly ? (await i._proxy.$ensureActivation(e.scheme), await i.mkdirp(t.impl, t.extUri, e)) : await i._proxy.$mkdir(e)
                            } catch (e) {
                                return s._handleError(e)
                            }
                        },
                        async readFile(e) {
                            try {
                                const t = i._fileSystemProvider.get(e.scheme);
                                return t ? (await i._proxy.$ensureActivation(e.scheme), (await t.impl.readFile(e)).slice()) : (await i._proxy.$readFile(e)).buffer
                            } catch (e) {
                                return s._handleError(e)
                            }
                        },
                        async writeFile(e, t) {
                            try {
                                const s = i._fileSystemProvider.get(e.scheme);
                                return s && !s.isReadonly ? (await i._proxy.$ensureActivation(e.scheme), await i.mkdirp(s.impl, s.extUri, s.extUri.dirname(e)), await i._writeQueue.queueFor(e, (() => Promise.resolve(s.impl.writeFile(e, t, {
                                    create: !0,
                                    overwrite: !0
                                }))))) : await i._proxy.$writeFile(e, c.KN.wrap(t))
                            } catch (e) {
                                return s._handleError(e)
                            }
                        },
                        async delete(e, t) {
                            try {
                                const s = i._fileSystemProvider.get(e.scheme);
                                return !s || s.isReadonly || t ? .useTrash ? await i._proxy.$delete(e, {
                                    recursive: !1,
                                    useTrash: !1,
                                    atomic: !1,
                                    ...t
                                }) : (await i._proxy.$ensureActivation(e.scheme), await s.impl.delete(e, {
                                    recursive: !1,
                                    ...t
                                }))
                            } catch (e) {
                                return s._handleError(e)
                            }
                        },
                        async rename(e, t, o) {
                            try {
                                return await i._proxy.$rename(e, t, {
                                    overwrite: !1,
                                    ...o
                                })
                            } catch (e) {
                                return s._handleError(e)
                            }
                        },
                        async copy(e, t, o) {
                            try {
                                return await i._proxy.$copy(e, t, {
                                    overwrite: !1,
                                    ...o
                                })
                            } catch (e) {
                                return s._handleError(e)
                            }
                        },
                        isWritableFileSystem(e) {
                            const i = t.getCapabilities(e);
                            if ("number" == typeof i) return !(i & n.Bb.Readonly)
                        }
                    })
                }
                async mkdirp(e, t, i) {
                    const s = [];
                    for (; !t.isEqual(i, t.dirname(i));) try {
                        if (0 == ((await e.stat(i)).type & n.Tv.Directory)) throw a.yNx.FileExists(`Unable to create folder '${i.scheme===g.lg.file?i.fsPath:i.toString(!0)}' that already exists but is not a directory`);
                        break
                    } catch (e) {
                        if ((0, n.q9)(e) !== n.bH.FileNotFound) throw e;
                        s.push(t.basename(i)), i = t.dirname(i)
                    }
                    for (let o = s.length - 1; o >= 0; o--) {
                        i = t.joinPath(i, s[o]);
                        try {
                            await e.createDirectory(i)
                        } catch (e) {
                            if ((0, n.q9)(e) !== n.bH.FileExists) throw e
                        }
                    }
                }
                static _handleError(e) {
                    if (e instanceof a.yNx) throw e;
                    if (e instanceof n.lR) switch (e.code) {
                        case n.bH.FileExists:
                            throw a.yNx.FileExists(e.message);
                        case n.bH.FileNotFound:
                            throw a.yNx.FileNotFound(e.message);
                        case n.bH.FileNotADirectory:
                            throw a.yNx.FileNotADirectory(e.message);
                        case n.bH.FileIsADirectory:
                            throw a.yNx.FileIsADirectory(e.message);
                        case n.bH.NoPermissions:
                            throw a.yNx.NoPermissions(e.message);
                        case n.bH.Unavailable:
                            throw a.yNx.Unavailable(e.message);
                        default:
                            throw new a.yNx(e.message, e.name)
                    }
                    if (!(e instanceof Error)) throw new a.yNx(String(e));
                    if ("ENOPRO" === e.name || e.message.includes("ENOPRO")) throw a.yNx.Unavailable(e.message);
                    switch (e.name) {
                        case n.bH.FileExists:
                            throw a.yNx.FileExists(e.message);
                        case n.bH.FileNotFound:
                            throw a.yNx.FileNotFound(e.message);
                        case n.bH.FileNotADirectory:
                            throw a.yNx.FileNotADirectory(e.message);
                        case n.bH.FileIsADirectory:
                            throw a.yNx.FileIsADirectory(e.message);
                        case n.bH.NoPermissions:
                            throw a.yNx.NoPermissions(e.message);
                        case n.bH.Unavailable:
                            throw a.yNx.Unavailable(e.message);
                        default:
                            throw new a.yNx(e.message, e.name)
                    }
                }
                addFileSystemProvider(e, t, i) {
                    return this._fileSystemProvider.set(e, {
                        impl: t,
                        extUri: i ? .isCaseSensitive ? m.SF : m.F_,
                        isReadonly: !!i ? .isReadonly
                    }), (0, u.OF)((() => this._fileSystemProvider.delete(e)))
                }
                getFileSystemProviderExtUri(e) {
                    return this._fileSystemProvider.get(e) ? .extUri ? ? m.SF
                }
            };
            v = s = (0, o.g)([(0, o.f)(0, l.O), (0, o.f)(1, h.G)], v);
            const _ = (0, d.yh)("IExtHostConsumerFileSystem")
        },
        CRYY: (e, t, i) => {
            i.d(t, {
                G: () => c,
                J: () => a
            });
            var s = i("PTqS"),
                o = i("oVnE"),
                r = i("ts6x"),
                n = i("OYZR");
            class a {
                constructor() {
                    this._systemSchemes = new Set(Object.keys(s.lg)), this._providerInfo = new Map, this.extUri = new o.U9((e => {
                        const t = this._providerInfo.get(e.scheme);
                        return void 0 !== t && !(t & r.Bb.PathCaseSensitive)
                    }))
                }
                $acceptProviderInfos(e, t) {
                    null === t ? this._providerInfo.delete(e.scheme) : this._providerInfo.set(e.scheme, t)
                }
                isFreeScheme(e) {
                    return !this._providerInfo.has(e) && !this._systemSchemes.has(e)
                }
                getCapabilities(e) {
                    return this._providerInfo.get(e)
                }
            }
            const c = (0, n.yh)("IExtHostFileSystemInfo")
        },
        "9STo": (e, t, i) => {
            i.d(t, {
                Q: () => P,
                X: () => C
            });
            var s, o = i("t5wJ"),
                r = i("opu4"),
                n = i("rJtg"),
                a = i("R1fN"),
                c = i("PUdK"),
                d = i("7icl"),
                l = i("wBFb"),
                h = i("RVdl"),
                u = i("yFKF"),
                p = i("6zxw"),
                m = i("OYZR"),
                g = i("Vvlp"),
                v = i("xoT7"),
                _ = i("YrcG"),
                f = i("ZXjZ"),
                y = i("Ayc8"),
                w = i("IqsH"),
                x = i("7NN/"),
                b = i("S4z/"),
                D = i("LE1I");
            const C = (0, m.yh)("IExtHostLanguageModels");
            class S {
                constructor(e, t) {
                    this.option = e, this.stream = new r.lK, this.stream = t ? ? new r.lK
                }
            }
            class E {
                constructor() {
                    this._responseStreams = new Map, this._defaultStream = new r.lK, this._isDone = !1;
                    const e = this;
                    this.apiObject = {
                        get stream() {
                            return e._defaultStream.asyncIterable
                        },
                        get text() {
                            return r.Aq.map(e._defaultStream.asyncIterable, (e => e instanceof x.NEU ? e.value : void 0)).coalesce()
                        }
                    }
                }* _streams() {
                    if (this._responseStreams.size > 0)
                        for (const [, e] of this._responseStreams) yield e.stream;
                    else yield this._defaultStream
                }
                handleFragment(e) {
                    if (this._isDone) return;
                    let t, i = this._responseStreams.get(e.index);
                    i || (i = 0 === this._responseStreams.size ? new S(e.index, this._defaultStream) : new S(e.index), this._responseStreams.set(e.index, i)), t = "text" === e.part.type ? new x.NEU(e.part.value) : new x._n6(e.part.name, e.part.parameters), i.stream.emitOne(t)
                }
                reject(e) {
                    this._isDone = !0;
                    for (const t of this._streams()) t.reject(e)
                }
                resolve() {
                    this._isDone = !0;
                    for (const e of this._streams()) e.resolve()
                }
            }
            let P = class {
                static {
                    s = this
                }
                static {
                    this._idPool = 1
                }
                constructor(e, t, i) {
                    this._logService = t, this._extHostAuthentication = i, this._onDidChangeModelAccess = new d.Q5, this._onDidChangeProviders = new d.Q5, this.onDidChangeProviders = this._onDidChangeProviders.event, this._languageModels = new Map, this._allLanguageModelData = new Map, this._modelAccessList = new p.C1, this._pendingRequest = new Map, this._languageAccessInformationExtensions = new Set, this._proxy = e.getProxy(_.Tr.MainThreadLanguageModels)
                }
                dispose() {
                    this._onDidChangeModelAccess.dispose(), this._onDidChangeProviders.dispose()
                }
                registerLanguageModel(e, t, i, o) {
                    const r = s._idPool++;
                    let n;
                    this._languageModels.set(r, {
                        extension: e.identifier,
                        provider: i,
                        languageModelId: t
                    }), o.auth && (n = {
                        providerLabel: e.displayName || e.name,
                        accountLabel: "object" == typeof o.auth ? o.auth.label : void 0
                    }), this._proxy.$registerLanguageModelProvider(r, `${p.kP.toKey(e.identifier)}/${r}/${t}`, {
                        extension: e.identifier,
                        id: t,
                        vendor: o.vendor ? ? p.kP.toKey(e.identifier),
                        name: o.name ? ? "",
                        family: o.family ? ? "",
                        version: o.version,
                        maxInputTokens: o.maxInputTokens,
                        maxOutputTokens: o.maxOutputTokens,
                        auth: n,
                        targetExtensions: o.extensions
                    });
                    const a = i.onDidReceiveLanguageModelResponse2 ? .((({
                        extensionId: e,
                        participant: i,
                        tokenCount: s
                    }) => {
                        this._proxy.$whenLanguageModelChatRequestMade(t, new p.kP(e), i, s)
                    }));
                    return (0, h.OF)((() => {
                        this._languageModels.delete(r), this._proxy.$unregisterProvider(r), a ? .dispose()
                    }))
                }
                async $startChatRequest(e, t, i, s, o, r) {
                    const n = this._languageModels.get(e);
                    if (!n) throw new Error("Provider not found");
                    const a = new v.Ex((async e => {
                        if (r.isCancellationRequested) return void this._logService.warn(`[CHAT](${n.extension.value}) CANNOT send progress because the REQUEST IS CANCELLED`);
                        let i;
                        e.part instanceof x._n6 ? i = {
                            type: "function_use",
                            name: e.part.name,
                            parameters: e.part.parameters
                        } : e.part instanceof x.NEU && (i = {
                            type: "text",
                            value: e.part.value
                        }), i ? this._proxy.$reportResponsePart(t, {
                            index: e.index,
                            part: i
                        }) : this._logService.warn(`[CHAT](${n.extension.value}) UNKNOWN part ${JSON.stringify(e)}`)
                    }));
                    let d;
                    if (n.provider.provideLanguageModelResponse2) d = Promise.resolve(n.provider.provideLanguageModelResponse2(s.map(w.xf.to), o, p.kP.toKey(i), a, r));
                    else {
                        const e = new v.Ex((async e => {
                            a.report({
                                index: e.index,
                                part: new x.NEU(e.part)
                            })
                        }));
                        d = Promise.resolve(n.provider.provideLanguageModelResponse(s.map(w.xf.to), o ? .modelOptions ? ? {}, p.kP.toKey(i), e, r))
                    }
                    d.then((() => {
                        this._proxy.$reportResponseDone(t, void 0)
                    }), (e => {
                        this._proxy.$reportResponseDone(t, (0, c.ri)(e))
                    }))
                }
                $provideTokenLength(e, t, i) {
                    const s = this._languageModels.get(e);
                    return s ? Promise.resolve(s.provider.provideTokenCount(t, i)) : Promise.resolve(0)
                }
                $acceptChatModelMetadata(e) {
                    if (e.added)
                        for (const {
                                identifier: t,
                                metadata: i
                            } of e.added) this._allLanguageModelData.set(t, {
                            metadata: i,
                            apiObjects: new p.C1
                        });
                    if (e.removed)
                        for (const t of e.removed) {
                            this._allLanguageModelData.delete(t);
                            for (const [e, i] of this._pendingRequest) i.languageModelId === t && (i.res.reject(new c.FU), this._pendingRequest.delete(e))
                        }
                    e.added ? .forEach((e => this._fakeAuthPopulate(e.metadata))), this._onDidChangeProviders.fire(void 0)
                }
                async selectLanguageModels(e, t) {
                    const i = await this._proxy.$selectChatModels({ ...t,
                            extension: e.identifier
                        }),
                        s = [],
                        o = this;
                    for (const t of i) {
                        const i = this._allLanguageModelData.get(t);
                        if (!i) continue;
                        this._isUsingAuth(e.identifier, i.metadata) && await this._fakeAuthPopulate(i.metadata);
                        let r = i.apiObjects.get(e.identifier);
                        r || (r = {
                            id: t,
                            vendor: i.metadata.vendor,
                            family: i.metadata.family,
                            version: i.metadata.version,
                            name: i.metadata.name,
                            maxInputTokens: i.metadata.maxInputTokens,
                            countTokens(e, i) {
                                if (!o._allLanguageModelData.has(t)) throw x.tHl.NotFound(t);
                                return o._computeTokenLength(t, e, i ? ? n.Ts.None)
                            },
                            sendRequest(i, s, r) {
                                if (!o._allLanguageModelData.has(t)) throw x.tHl.NotFound(t);
                                return o._sendChatRequest(e, t, i, s ? ? {}, r ? ? n.Ts.None)
                            }
                        }, i.apiObjects.set(e.identifier, r)), s.push(r)
                    }
                    return s
                }
                async _sendChatRequest(e, t, i, s, o) {
                    const r = this._convertMessages(e, i),
                        n = e.identifier,
                        c = this._allLanguageModelData.get(t) ? .metadata;
                    if (!c || !this._allLanguageModelData.has(t)) throw x.tHl.NotFound(`Language model '${t}' is unknown.`);
                    if (this._isUsingAuth(n, c) && (!await this._getAuthAccess(e, {
                            identifier: c.extension,
                            displayName: c.auth.providerLabel
                        }, s.justification, !1) || !this._modelAccessList.get(n) ? .has(c.extension))) throw x.tHl.NoPermissions(`Language model '${t}' cannot be used by '${n.value}'.`);
                    try {
                        const e = 1e6 * Math.random() | 0,
                            i = new E;
                        this._pendingRequest.set(e, {
                            languageModelId: t,
                            res: i
                        });
                        try {
                            await this._proxy.$tryStartChatRequest(n, t, e, r, s, o)
                        } catch (t) {
                            throw this._pendingRequest.delete(e), t
                        }
                        return i.apiObject
                    } catch (e) {
                        if (e.name === x.tHl.name) throw e;
                        throw new x.tHl(`Language model '${t}' errored: ${(0,a.yJ)(e)}`, "Unknown", e)
                    }
                }
                _convertMessages(e, t) {
                    const i = [];
                    for (const s of t) s.role === x.grl.System && (0, D.H5)(e, "languageModelSystem"), s.content2 instanceof x.DHf && (0, D.H5)(e, "lmTools"), i.push(w.xf.from(s));
                    return i
                }
                async $acceptResponsePart(e, t) {
                    const i = this._pendingRequest.get(e);
                    i && i.res.handleFragment(t)
                }
                async $acceptResponseDone(e, t) {
                    const i = this._pendingRequest.get(e);
                    i && (this._pendingRequest.delete(e), t ? i.res.reject((0, c.vr)(t)) : i.res.resolve())
                }
                async _getAuthAccess(e, t, i, s) {
                    const o = b.b + t.identifier.value;
                    if (await this._extHostAuthentication.getSession(e, o, [], {
                            silent: !0
                        })) return this.$updateModelAccesslist([{
                        from: e.identifier,
                        to: t.identifier,
                        enabled: !0
                    }]), !0;
                    if (s) return !1;
                    try {
                        const s = i ? (0, u.C$)("vs/workbench/api/common/extHostLanguageModels", 0, "Justification: {1}", t.displayName, i) : void 0;
                        return await this._extHostAuthentication.getSession(e, o, [], {
                            forceNewSession: {
                                detail: s
                            }
                        }), this.$updateModelAccesslist([{
                            from: e.identifier,
                            to: t.identifier,
                            enabled: !0
                        }]), !0
                    } catch (e) {
                        return !1
                    }
                }
                _isUsingAuth(e, t) {
                    return !!t.auth && !p.kP.equals(t.extension, e)
                }
                async _fakeAuthPopulate(e) {
                    if (e.auth)
                        for (const t of this._languageAccessInformationExtensions) try {
                            await this._getAuthAccess(t, {
                                identifier: e.extension,
                                displayName: ""
                            }, void 0, !0)
                        } catch (e) {
                            this._logService.error("Fake Auth request failed"), this._logService.error(e)
                        }
                }
                async _computeTokenLength(e, t, i) {
                    if (!this._allLanguageModelData.get(e)) throw x.tHl.NotFound(`Language model '${e}' is unknown.`);
                    const s = l.$.find(this._languageModels.values(), (t => t.languageModelId === e));
                    return s ? s.provider.provideTokenCount(t, i) : this._proxy.$countTokens(e, "string" == typeof t ? t : w.xf.from(t), i)
                }
                $updateModelAccesslist(e) {
                    const t = new Array;
                    for (const {
                            from: i,
                            to: s,
                            enabled: o
                        } of e) {
                        const e = this._modelAccessList.get(i) ? ? new p.o$;
                        if (e.has(s) !== o) {
                            o ? e.add(s) : e.delete(s), this._modelAccessList.set(i, e);
                            const r = {
                                from: i,
                                to: s
                            };
                            t.push(r), this._onDidChangeModelAccess.fire(r)
                        }
                    }
                }
                createLanguageModelAccessInformation(e) {
                    this._languageAccessInformationExtensions.add(e);
                    const t = this,
                        i = d.ju.signal(d.ju.filter(this._onDidChangeModelAccess.event, (t => p.kP.equals(t.from, e.identifier)))),
                        s = d.ju.signal(this._onDidChangeProviders.event);
                    return {
                        get onDidChange() {
                            return d.ju.any(i, s)
                        },
                        canSendRequest(i) {
                            let s;
                            e: for (const [e, o] of t._allLanguageModelData)
                                for (const e of o.apiObjects.values())
                                    if (e === i) {
                                        s = o.metadata;
                                        break e
                                    }
                            if (!s) return;
                            if (!t._isUsingAuth(e.identifier, s)) return !0;
                            const o = t._modelAccessList.get(e.identifier);
                            return o ? o.has(s.extension) : void 0
                        }
                    }
                }
            };
            P = s = (0, o.g)([(0, o.f)(0, y.O), (0, o.f)(1, g.V), (0, o.f)(2, f.E)], P)
        },
        "0eYU": (e, t, i) => {
            i.d(t, {
                I: () => u,
                O: () => p
            });
            var s = i("t5wJ"),
                o = i("pLPy"),
                r = i("p044"),
                n = i("naIR"),
                a = i("OYZR"),
                c = i("Vvlp"),
                d = i("YrcG"),
                l = i("5h1i"),
                h = i("Ayc8");
            let u = class {
                constructor(e, t, i) {
                    this.logService = i, this.bundleCache = new Map, this._proxy = t.getProxy(d.Tr.MainThreadLocalization), this.currentLanguage = e.environment.appLanguage, this.isDefaultLanguage = this.currentLanguage === o.cr
                }
                getMessage(e, t) {
                    const {
                        message: i,
                        args: s,
                        comment: o
                    } = t;
                    if (this.isDefaultLanguage) return (0, r.F9)(i, s ? ? {});
                    let n = i;
                    o && o.length > 0 && (n += `/${Array.isArray(o)?o.join(""):o}`);
                    const a = this.bundleCache.get(e) ? .contents[n];
                    return a || this.logService.warn(`Using default string since no string found in i18n bundle that has the key: ${n}`), (0, r.F9)(a ? ? i, s ? ? {})
                }
                getBundle(e) {
                    return this.bundleCache.get(e) ? .contents
                }
                getBundleUri(e) {
                    return this.bundleCache.get(e) ? .uri
                }
                async initializeLocalizedMessages(e) {
                    if (this.isDefaultLanguage || !e.l10n && !e.isBuiltin) return;
                    if (this.bundleCache.has(e.identifier.value)) return;
                    let t;
                    const i = await this.getBundleLocation(e);
                    if (i) {
                        try {
                            const s = await this._proxy.$fetchBundleContents(i),
                                o = JSON.parse(s);
                            t = e.isBuiltin ? o.contents ? .bundle : o
                        } catch (t) {
                            return void this.logService.error(`Failed to load translations for ${e.identifier.value} from ${i}: ${t.message}`)
                        }
                        t && this.bundleCache.set(e.identifier.value, {
                            contents: t,
                            uri: i
                        })
                    } else this.logService.error(`No bundle location found for extension ${e.identifier.value}`)
                }
                async getBundleLocation(e) {
                    if (e.isBuiltin) {
                        const t = await this._proxy.$fetchBuiltInBundleUri(e.identifier.value, this.currentLanguage);
                        return n.ov.revive(t)
                    }
                    return e.l10n ? n.ov.joinPath(e.extensionLocation, e.l10n, `bundle.l10n.${this.currentLanguage}.json`) : void 0
                }
            };
            u = (0, s.g)([(0, s.f)(0, l.$), (0, s.f)(1, h.O), (0, s.f)(2, c.V)], u);
            const p = (0, a.yh)("IExtHostLocalizationService")
        },
        "P+6B": (e, t, i) => {
            i.d(t, {
                m: () => l
            });
            var s = i("t5wJ"),
                o = i("7EzT"),
                r = i("YrcG"),
                n = i("5h1i"),
                a = i("Ayc8"),
                c = i("naIR"),
                d = i("GHax");
            let l = class extends o.sc {
                constructor(e, t) {
                    super(t.logLevel, t.logsLocation, t.loggers.map((e => (0, d.wL)(e)))), this._proxy = e.getProxy(r.Tr.MainThreadLogger)
                }
                $setLogLevel(e, t) {
                    t ? this.setLogLevel(c.ov.revive(t), e) : this.setLogLevel(e)
                }
                setVisibility(e, t) {
                    super.setVisibility(e, t), this._proxy.$setVisibility(e, t)
                }
                doCreateLogger(e, t, i) {
                    return new h(this._proxy, e, t, i)
                }
            };
            l = (0, s.g)([(0, s.f)(0, a.O), (0, s.f)(1, n.$)], l);
            class h extends o.Li {
                constructor(e, t, i, s) {
                    super("always" === s ? .logLevel), this.proxy = e, this.file = t, this.isLoggerCreated = !1, this.buffer = [], this.setLevel(i), this.proxy.$createLogger(t, s).then((() => {
                        this.doLog(this.buffer), this.isLoggerCreated = !0
                    }))
                }
                log(e, t) {
                    const i = [
                        [e, t]
                    ];
                    this.isLoggerCreated ? this.doLog(i) : this.buffer.push(...i)
                }
                doLog(e) {
                    this.proxy.$log(this.file, e)
                }
                flush() {
                    this.proxy.$flush(this.file)
                }
            }
        },
        CbIF: (e, t, i) => {
            i.d(t, {
                W: () => d,
                b: () => l
            });
            var s = i("t5wJ"),
                o = i("YrcG"),
                r = i("OYZR"),
                n = i("RVdl"),
                a = i("Ayc8"),
                c = i("jxI3");
            const d = (0, r.yh)("IExtHostManagedSockets");
            let l = class {
                constructor(e) {
                    this._remoteSocketIdCounter = 0, this._factory = null, this._managedRemoteSockets = new Map, this._proxy = e.getProxy(o.Tr.MainThreadManagedSockets)
                }
                setFactory(e, t) {
                    for (const e of this._managedRemoteSockets.values()) e.dispose();
                    this._factory && this._proxy.$unregisterSocketFactory(this._factory.socketFactoryId), this._factory = new h(e, t), this._proxy.$registerSocketFactory(this._factory.socketFactoryId)
                }
                async $openRemoteSocket(e) {
                    if (!this._factory || this._factory.socketFactoryId !== e) throw new Error(`No socket factory with id ${e}`);
                    const t = ++this._remoteSocketIdCounter,
                        i = await this._factory.makeConnection(),
                        s = new n.SL;
                    return this._managedRemoteSockets.set(t, new u(t, i, s)), s.add((0, n.OF)((() => this._managedRemoteSockets.delete(t)))), s.add(i.onDidEnd((() => {
                        this._proxy.$onDidManagedSocketEnd(t), s.dispose()
                    }))), s.add(i.onDidClose((e => {
                        this._proxy.$onDidManagedSocketClose(t, e ? .stack ? ? e ? .message), s.dispose()
                    }))), s.add(i.onDidReceiveMessage((e => this._proxy.$onDidManagedSocketHaveData(t, c.KN.wrap(e))))), t
                }
                $remoteSocketWrite(e, t) {
                    this._managedRemoteSockets.get(e) ? .actual.send(t.buffer)
                }
                $remoteSocketEnd(e) {
                    const t = this._managedRemoteSockets.get(e);
                    t && (t.actual.end(), t.dispose())
                }
                async $remoteSocketDrain(e) {
                    await (this._managedRemoteSockets.get(e) ? .actual.drain ? .())
                }
            };
            l = (0, s.g)([(0, s.f)(0, a.O)], l);
            class h {
                constructor(e, t) {
                    this.socketFactoryId = e, this.makeConnection = t
                }
            }
            class u extends n.JT {
                constructor(e, t, i) {
                    super(), this.socketId = e, this.actual = t, this._register(i)
                }
            }
        },
        rqgR: (e, t, i) => {
            i.d(t, {
                U: () => D,
                X: () => b
            });
            var s = i("t5wJ"),
                o = i("YrcG"),
                r = i("OYZR"),
                n = i("Ayc8"),
                a = i("6zxw"),
                c = i("7EzT"),
                d = i("Vvlp"),
                l = i("1kmT"),
                h = i("nG0x"),
                u = i("5h1i"),
                p = i("CRYY"),
                m = i("0WKM"),
                g = i("jxI3"),
                v = i("K30K"),
                _ = i("ts6x"),
                f = i("7icl"),
                y = i("RVdl");
            class w extends c.Li {
                get disposed() {
                    return this._disposed
                }
                constructor(e, t, i, s, o) {
                    super(), this.id = e, this.name = t, this.logger = i, this.proxy = s, this.extension = o, this.offset = 0, this._disposed = !1, this.visible = !1, this.setLevel(i.getLevel()), this._register(i.onDidChangeLogLevel((e => this.setLevel(e))))
                }
                get logLevel() {
                    return this.getLevel()
                }
                appendLine(e) {
                    this.append(e + "\n")
                }
                append(e) {
                    this.info(e)
                }
                clear() {
                    const e = this.offset;
                    this.logger.flush(), this.proxy.$update(this.id, l.Ed.Clear, e)
                }
                replace(e) {
                    const t = this.offset;
                    this.info(e), this.proxy.$update(this.id, l.Ed.Replace, t), this.visible && this.logger.flush()
                }
                show(e, t) {
                    this.logger.flush(), this.proxy.$reveal(this.id, !!("boolean" == typeof e ? e : t))
                }
                hide() {
                    this.proxy.$close(this.id)
                }
                log(e, t) {
                    this.offset += g.KN.fromString(t).byteLength, (0, c.cM)(this.logger, e, t), this.visible && (this.logger.flush(), this.proxy.$update(this.id, l.Ed.Append))
                }
                dispose() {
                    super.dispose(), this._disposed || (this.proxy.$dispose(this.id), this._disposed = !0)
                }
            }
            class x extends w {
                appendLine(e) {
                    this.append(e)
                }
            }
            let b = class {
                constructor(e, t, i, s, r, n) {
                    this.initData = t, this.extHostFileSystem = i, this.extHostFileSystemInfo = s, this.loggerService = r, this.logService = n, this.extensionLogDirectoryPromise = new Map, this.namePool = 1, this.channels = new Map, this.visibleChannelId = null, this.proxy = e.getProxy(o.Tr.MainThreadOutputService), this.outputsLocation = this.extHostFileSystemInfo.extUri.joinPath(t.logsLocation, `output_logging_${(0,m.rL)(new Date).replace(/-|:|\.\d+Z$/g,"")}`)
                }
                $setVisibleChannel(e) {
                    this.visibleChannelId = e;
                    for (const [e, t] of this.channels) t.visible = e === this.visibleChannelId
                }
                createOutputChannel(e, t, i) {
                    if (!(e = e.trim())) throw new Error("illegal argument `name`. must not be falsy");
                    const s = "object" == typeof t && t.log,
                        o = (0, v.HD)(t) ? t : void 0;
                    if ((0, v.HD)(o) && !o.trim()) throw new Error("illegal argument `languageId`. must not be empty");
                    let r;
                    const n = this.initData.environment.extensionLogLevel ? .find((([e]) => a.kP.equals(i.identifier, e))) ? .[1];
                    n && (r = (0, c.AW)(n));
                    const d = s ? this.doCreateLogOutputChannel(e, r, i) : this.doCreateOutputChannel(e, o, i);
                    return d.then((e => {
                        this.channels.set(e.id, e), e.visible = e.id === this.visibleChannelId
                    })), s ? this.createExtHostLogOutputChannel(e, r ? ? this.logService.getLevel(), d) : this.createExtHostOutputChannel(e, d)
                }
                async doCreateOutputChannel(e, t, i) {
                    this.outputDirectoryPromise || (this.outputDirectoryPromise = this.extHostFileSystem.value.createDirectory(this.outputsLocation).then((() => this.outputsLocation)));
                    const s = await this.outputDirectoryPromise,
                        o = this.extHostFileSystemInfo.extUri.joinPath(s, `${this.namePool++}-${e.replace(/[\\/:\*\?"<>\|]/g,"")}.log`),
                        r = this.loggerService.createLogger(o, {
                            logLevel: "always",
                            donotRotate: !0,
                            donotUseFormatters: !0,
                            hidden: !0
                        }),
                        n = await this.proxy.$register(e, o, t, i.identifier.value);
                    return new w(n, e, r, this.proxy, i)
                }
                async doCreateLogOutputChannel(e, t, i) {
                    const s = await this.createExtensionLogDirectory(i),
                        o = e.replace(/[\\/:\*\?"<>\|]/g, ""),
                        r = this.extHostFileSystemInfo.extUri.joinPath(s, `${o}.log`),
                        n = `${i.identifier.value}.${o}`,
                        a = this.loggerService.createLogger(r, {
                            id: n,
                            name: e,
                            logLevel: t,
                            extensionId: i.identifier.value
                        });
                    return new x(n, e, a, this.proxy, i)
                }
                createExtensionLogDirectory(e) {
                    let t = this.extensionLogDirectoryPromise.get(e.identifier.value);
                    if (!t) {
                        const i = this.extHostFileSystemInfo.extUri.joinPath(this.initData.logsLocation, e.identifier.value);
                        this.extensionLogDirectoryPromise.set(e.identifier.value, t = (async () => {
                            try {
                                await this.extHostFileSystem.value.createDirectory(i)
                            } catch (e) {
                                if ((0, _.q9)(e) !== _.bH.FileExists) throw e
                            }
                            return i
                        })())
                    }
                    return t
                }
                createExtHostOutputChannel(e, t) {
                    let i = !1;
                    const s = () => {
                        if (i) throw new Error("Channel has been closed")
                    };
                    return {
                        get name() {
                            return e
                        },
                        append(e) {
                            s(), t.then((t => t.append(e)))
                        },
                        appendLine(e) {
                            s(), t.then((t => t.appendLine(e)))
                        },
                        clear() {
                            s(), t.then((e => e.clear()))
                        },
                        replace(e) {
                            s(), t.then((t => t.replace(e)))
                        },
                        show(e, i) {
                            s(), t.then((t => t.show(e, i)))
                        },
                        hide() {
                            s(), t.then((e => e.hide()))
                        },
                        dispose() {
                            i = !0, t.then((e => e.dispose()))
                        }
                    }
                }
                createExtHostLogOutputChannel(e, t, i) {
                    const s = new y.SL,
                        o = () => {
                            if (s.isDisposed) throw new Error("Channel has been closed")
                        },
                        r = s.add(new f.Q5);

                    function n(e) {
                        t = e, r.fire(e)
                    }
                    return i.then((e => {
                        s.add(e), e.logLevel !== t && n(e.logLevel), s.add(e.onDidChangeLogLevel((e => n(e))))
                    })), { ...this.createExtHostOutputChannel(e, i),
                        get logLevel() {
                            return t
                        },
                        onDidChangeLogLevel: r.event,
                        trace(e, ...t) {
                            o(), i.then((i => i.trace(e, ...t)))
                        },
                        debug(e, ...t) {
                            o(), i.then((i => i.debug(e, ...t)))
                        },
                        info(e, ...t) {
                            o(), i.then((i => i.info(e, ...t)))
                        },
                        warn(e, ...t) {
                            o(), i.then((i => i.warn(e, ...t)))
                        },
                        error(e, ...t) {
                            o(), i.then((i => i.error(e, ...t)))
                        },
                        dispose() {
                            s.dispose()
                        }
                    }
                }
            };
            b = (0, s.g)([(0, s.f)(0, n.O), (0, s.f)(1, u.$), (0, s.f)(2, h.a), (0, s.f)(3, p.G), (0, s.f)(4, d.y), (0, s.f)(5, d.V)], b);
            const D = (0, r.yh)("IExtHostOutputService")
        },
        w14f: (e, t, i) => {
            i.d(t, {
                dX: () => k,
                FR: () => T
            });
            var s = i("t5wJ"),
                o = i("RVdl"),
                r = i("YrcG"),
                n = i("OYZR"),
                a = i("RRaN"),
                c = i("rJtg"),
                d = i("R1fN"),
                l = i("y5Nw"),
                h = i("oVnE"),
                u = i("V2Gl"),
                p = i("GbR3");
            class m {
                constructor(e, t, i) {
                    this.config = e, this.provider = t, this.sessionToken = i, this.isLimitHit = !1, this.resultCount = 0, this.isCanceled = !1, this.filePattern = e.filePattern, this.includePattern = e.includePattern && (0, l.Qc)(e.includePattern), this.maxResults = e.maxResults || void 0, this.exists = e.exists, this.activeCancellationTokens = new Set, this.globalExcludePattern = e.excludePattern && (0, l.Qc)(e.excludePattern)
                }
                cancel() {
                    this.isCanceled = !0, this.activeCancellationTokens.forEach((e => e.cancel())), this.activeCancellationTokens = new Set
                }
                search(e) {
                    const t = this.config.folderQueries || [];
                    return new Promise(((i, s) => {
                        const o = t => {
                            this.resultCount++, e(t)
                        };
                        if (this.isCanceled) return i({
                            limitHit: this.isLimitHit
                        });
                        this.config.extraFileResources && this.config.extraFileResources.forEach((e => {
                            const t = e.toString(),
                                i = (0, a.EZ)(t);
                            this.globalExcludePattern && this.globalExcludePattern(t, i) || this.matchFile(o, {
                                base: e,
                                basename: i
                            })
                        })), Promise.all(t.map((e => this.searchInFolder(e, o)))).then((e => {
                            i({
                                limitHit: this.isLimitHit,
                                stats: e[0] || void 0
                            })
                        }), (e => {
                            s(new Error((0, d.yJ)(e)))
                        }))
                    }))
                }
                async searchInFolder(e, t) {
                    const i = new c.AU,
                        s = this.getSearchOptionsForFolder(e),
                        o = this.initDirectoryTree(),
                        r = new p.u2(this.config, e),
                        n = !r.hasSiblingExcludeClauses();
                    let d;
                    try {
                        this.activeCancellationTokens.add(i), d = u.G.create();
                        const c = await this.provider.provideFileSearchResults({
                                pattern: this.config.filePattern || ""
                            }, s, i.token),
                            l = d.elapsed(),
                            h = u.G.create();
                        return this.isCanceled && !this.isLimitHit ? null : (c && c.forEach((i => {
                            const s = a.KR.relative(e.folder.path, i.path);
                            if (n) {
                                const o = (0, a.EZ)(i.path);
                                this.matchFile(t, {
                                    base: e.folder,
                                    relativePath: s,
                                    basename: o
                                })
                            } else this.addDirectoryEntries(o, e.folder, s, t)
                        })), this.isCanceled && !this.isLimitHit ? null : (this.matchDirectoryTree(o, r, t), {
                            providerTime: l,
                            postProcessTime: h.elapsed()
                        }))
                    } finally {
                        i.dispose(), this.activeCancellationTokens.delete(i)
                    }
                }
                getSearchOptionsForFolder(e) {
                    const t = (0, p.fV)(this.config.includePattern, e.includePattern),
                        i = (0, p.fV)(this.config.excludePattern, e.excludePattern);
                    return {
                        folder: e.folder,
                        excludes: i,
                        includes: t,
                        useIgnoreFiles: !e.disregardIgnoreFiles,
                        useGlobalIgnoreFiles: !e.disregardGlobalIgnoreFiles,
                        useParentIgnoreFiles: !e.disregardParentIgnoreFiles,
                        followSymlinks: !e.ignoreSymlinks,
                        maxResults: this.config.maxResults,
                        session: this.sessionToken
                    }
                }
                initDirectoryTree() {
                    const e = {
                        rootEntries: [],
                        pathToEntries: Object.create(null)
                    };
                    return e.pathToEntries["."] = e.rootEntries, e
                }
                addDirectoryEntries({
                    pathToEntries: e
                }, t, i, s) {
                    if (i === this.filePattern) {
                        const e = (0, a.EZ)(this.filePattern);
                        this.matchFile(s, {
                            base: t,
                            relativePath: this.filePattern,
                            basename: e
                        })
                    }! function i(s) {
                        const o = (0, a.EZ)(s),
                            r = (0, a.XX)(s);
                        let n = e[r];
                        n || (n = e[r] = [], i(r)), n.push({
                            base: t,
                            relativePath: s,
                            basename: o
                        })
                    }(i)
                }
                matchDirectoryTree({
                    rootEntries: e,
                    pathToEntries: t
                }, i, s) {
                    const o = this,
                        r = this.filePattern;
                    ! function e(n) {
                        const a = (0, p.x2)((() => n.map((e => e.basename))));
                        for (let c = 0, d = n.length; c < d; c++) {
                            const d = n[c],
                                {
                                    relativePath: l,
                                    basename: h
                                } = d;
                            if (i.matchesExcludesSync(l, h, r !== h ? a : void 0)) continue;
                            const u = t[l];
                            if (u) e(u);
                            else {
                                if (l === r) continue;
                                o.matchFile(s, d)
                            }
                            if (o.isLimitHit) break
                        }
                    }(e)
                }
                matchFile(e, t) {
                    (!this.includePattern || t.relativePath && this.includePattern(t.relativePath, t.basename)) && ((this.exists || this.maxResults && this.resultCount >= this.maxResults) && (this.isLimitHit = !0, this.cancel()), this.isLimitHit || e(t))
                }
            }
            class g {
                constructor() {
                    this.sessions = new Map
                }
                static {
                    this.BATCH_SIZE = 512
                }
                fileSearch(e, t, i, s) {
                    const o = this.getSessionTokenSource(e.cacheKey),
                        r = new m(e, t, o && o.token);
                    let n = 0;
                    return this.doSearch(r, g.BATCH_SIZE, (e => {
                        n += e.length, i(e.map((e => this.rawMatchToSearchItem(e))))
                    }), s).then((e => ({
                        limitHit: e.limitHit,
                        stats: e.stats ? {
                            fromCache: !1,
                            type: "fileSearchProvider",
                            resultCount: n,
                            detailStats: e.stats
                        } : void 0,
                        messages: []
                    })))
                }
                clearCache(e) {
                    const t = this.getSessionTokenSource(e);
                    t ? .cancel()
                }
                getSessionTokenSource(e) {
                    if (e) return this.sessions.has(e) || this.sessions.set(e, new c.AU), this.sessions.get(e)
                }
                rawMatchToSearchItem(e) {
                    return e.relativePath ? {
                        resource: (0, h.Vo)(e.base, e.relativePath)
                    } : {
                        resource: e.base
                    }
                }
                doSearch(e, t, i, s) {
                    const o = s.onCancellationRequested((() => {
                        e.cancel()
                    }));
                    let r = [];
                    return e.search((e => {
                        e && (r.push(e), t > 0 && r.length >= t && (i(r), r = []))
                    })).then((e => (r.length && i(r), o.dispose(), e)), (e => (r.length && i(r), o.dispose(), Promise.reject(e))))
                }
            }
            var v = i("Ayc8"),
                _ = i("Rtpz"),
                f = i("Vvlp"),
                y = i("naIR"),
                w = i("iDmX"),
                x = i("opu4"),
                b = i("PTqS"),
                D = i("ziTh");
            class C {
                constructor(e, t, i) {
                    this.queryProviderPair = e, this.fileUtils = t, this.processType = i, this.collector = null, this.isLimitHit = !1, this.resultCount = 0
                }
                get query() {
                    return this.queryProviderPair.query
                }
                search(e, t) {
                    const i = this.query.folderQueries || [],
                        s = new c.AU(t);
                    return new Promise(((t, o) => {
                        this.collector = new S(e);
                        let r = !1;
                        const n = (e, t) => {
                            if (!r && !this.isLimitHit) {
                                const i = this.resultSize(e);
                                E(e) && "number" == typeof this.query.maxResults && this.resultCount + i > this.query.maxResults && (this.isLimitHit = !0, r = !0, s.cancel(), e = this.trimResultToSize(e, this.query.maxResults - this.resultCount));
                                const o = this.resultSize(e);
                                this.resultCount += o, (o > 0 || !E(e)) && this.collector.add(e, t)
                            }
                        };
                        Promise.all(i.map(((e, t) => this.searchInFolder(e, (e => n(e, t)), s.token)))).then((e => {
                            s.dispose(), this.collector.flush();
                            const i = e.some((e => !!e && !!e.limitHit));
                            t({
                                limitHit: this.isLimitHit || i,
                                messages: e.flatMap((e => e ? .message ? Array.isArray(e.message) ? e.message : [e.message] : [])),
                                stats: {
                                    type: this.processType
                                }
                            })
                        }), (e => {
                            s.dispose();
                            const t = (0, d.yJ)(e);
                            o(new Error(t))
                        }))
                    }))
                }
                resultSize(e) {
                    return E(e) ? Array.isArray(e.ranges) ? e.ranges.length : 1 : 0
                }
                trimResultToSize(e, t) {
                    const i = Array.isArray(e.ranges) ? e.ranges : [e.ranges],
                        s = Array.isArray(e.preview.matches) ? e.preview.matches : [e.preview.matches];
                    return {
                        ranges: i.slice(0, t),
                        preview: {
                            matches: s.slice(0, t),
                            text: e.preview.text
                        },
                        uri: e.uri
                    }
                }
                async searchInFolder(e, t, i) {
                    const s = new p.u2(this.query, e),
                        o = [],
                        r = {
                            report: i => {
                                if (!this.validateProviderResult(i)) return;
                                const r = e.folder.scheme === b.lg.file ? (0, p.tZ)((() => this.fileUtils.readdir((0, h.XX)(i.uri)))) : void 0,
                                    n = (0, h.lX)(e.folder, i.uri);
                                if (n) {
                                    const e = s.includedInQuery(n, (0, a.EZ)(n), r);
                                    (0, x.J8)(e) ? o.push(e.then((e => {
                                        e && t(i)
                                    }))): e && t(i)
                                }
                            }
                        },
                        n = this.getSearchOptionsForFolder(e);
                    let c;
                    var d;
                    return c = this.queryProviderPair.query.type === p.xL.aiText ? await this.queryProviderPair.provider.provideAITextSearchResults(this.queryProviderPair.query.contentPattern, n, r, i) : await this.queryProviderPair.provider.provideTextSearchResults((d = this.queryProviderPair.query.contentPattern, {
                        isCaseSensitive: d.isCaseSensitive || !1,
                        isRegExp: d.isRegExp || !1,
                        isWordMatch: d.isWordMatch || !1,
                        isMultiline: d.isMultiline || !1,
                        pattern: d.pattern
                    }), n, r, i), o.length && await Promise.all(o), c
                }
                validateProviderResult(e) {
                    if (E(e))
                        if (Array.isArray(e.ranges)) {
                            if (!Array.isArray(e.preview.matches)) return D.warn("INVALID - A text search provider match's`ranges` and`matches` properties must have the same type."), !1;
                            if (e.preview.matches.length !== e.ranges.length) return D.warn("INVALID - A text search provider match's`ranges` and`matches` properties must have the same length."), !1
                        } else if (Array.isArray(e.preview.matches)) return D.warn("INVALID - A text search provider match's`ranges` and`matches` properties must have the same length."), !1;
                    return !0
                }
                getSearchOptionsForFolder(e) {
                    const t = (0, p.fV)(this.query.includePattern, e.includePattern),
                        i = (0, p.fV)(this.query.excludePattern, e.excludePattern),
                        s = {
                            folder: y.ov.from(e.folder),
                            excludes: i,
                            includes: t,
                            useIgnoreFiles: !e.disregardIgnoreFiles,
                            useGlobalIgnoreFiles: !e.disregardGlobalIgnoreFiles,
                            useParentIgnoreFiles: !e.disregardParentIgnoreFiles,
                            followSymlinks: !e.ignoreSymlinks,
                            encoding: e.fileEncoding && this.fileUtils.toCanonicalName(e.fileEncoding),
                            maxFileSize: this.query.maxFileSize,
                            maxResults: this.query.maxResults ? ? p.KR,
                            previewOptions: this.query.previewOptions,
                            afterContext: this.query.afterContext,
                            beforeContext: this.query.beforeContext
                        };
                    return "usePCRE2" in this.query && (s.usePCRE2 = this.query.usePCRE2), s
                }
            }
            class S {
                constructor(e) {
                    this._onResult = e, this._currentFolderIdx = -1, this._currentFileMatch = null, this._batchedCollector = new P(512, (e => this.sendItems(e)))
                }
                add(e, t) {
                    !this._currentFileMatch || this._currentFolderIdx === t && (0, h.Xy)(this._currentUri, e.uri) || (this.pushToCollector(), this._currentFileMatch = null), this._currentFileMatch || (this._currentFolderIdx = t, this._currentFileMatch = {
                        resource: e.uri,
                        results: []
                    }), this._currentFileMatch.results.push(function(e) {
                        return E(e) ? {
                            preview: {
                                matches: (0, w.Gb)(e.preview.matches, (e => ({
                                    startLineNumber: e.start.line,
                                    startColumn: e.start.character,
                                    endLineNumber: e.end.line,
                                    endColumn: e.end.character
                                }))),
                                text: e.preview.text
                            },
                            ranges: (0, w.Gb)(e.ranges, (e => ({
                                startLineNumber: e.start.line,
                                startColumn: e.start.character,
                                endLineNumber: e.end.line,
                                endColumn: e.end.character
                            })))
                        } : {
                            text: e.text,
                            lineNumber: e.lineNumber
                        }
                    }(e))
                }
                pushToCollector() {
                    const e = this._currentFileMatch && this._currentFileMatch.results ? this._currentFileMatch.results.length : 0;
                    this._batchedCollector.addItem(this._currentFileMatch, e)
                }
                flush() {
                    this.pushToCollector(), this._batchedCollector.flush()
                }
                sendItems(e) {
                    this._onResult(e)
                }
            }

            function E(e) {
                return !!e.preview
            }
            class P {
                static {
                    this.TIMEOUT = 4e3
                }
                static {
                    this.START_BATCH_AFTER_COUNT = 50
                }
                constructor(e, t) {
                    this.maxBatchSize = e, this.cb = t, this.totalNumberCompleted = 0, this.batch = [], this.batchSize = 0
                }
                addItem(e, t) {
                    e && this.addItemToBatch(e, t)
                }
                addItems(e, t) {
                    e && this.addItemsToBatch(e, t)
                }
                addItemToBatch(e, t) {
                    this.batch.push(e), this.batchSize += t, this.onUpdate()
                }
                addItemsToBatch(e, t) {
                    this.batch = this.batch.concat(e), this.batchSize += t, this.onUpdate()
                }
                onUpdate() {
                    this.totalNumberCompleted < P.START_BATCH_AFTER_COUNT || this.batchSize >= this.maxBatchSize ? this.flush() : this.timeoutHandle || (this.timeoutHandle = setTimeout((() => {
                        this.flush()
                    }), P.TIMEOUT))
                }
                flush() {
                    this.batchSize && (this.totalNumberCompleted += this.batchSize, this.cb(this.batch), this.batch = [], this.batchSize = 0, this.timeoutHandle && (clearTimeout(this.timeoutHandle), this.timeoutHandle = 0))
                }
            }
            const T = (0, n.yh)("IExtHostSearch");
            let k = class {
                constructor(e, t, i) {
                    this.extHostRpc = e, this._uriTransformer = t, this._logService = i, this._proxy = this.extHostRpc.getProxy(r.Tr.MainThreadSearch), this._handlePool = 0, this._textSearchProvider = new Map, this._textSearchUsedSchemes = new Set, this._aiTextSearchProvider = new Map, this._aiTextSearchUsedSchemes = new Set, this._fileSearchProvider = new Map, this._fileSearchUsedSchemes = new Set, this._fileSearchManager = new g
                }
                _transformScheme(e) {
                    return this._uriTransformer.transformOutgoingScheme(e)
                }
                registerTextSearchProvider(e, t) {
                    if (this._textSearchUsedSchemes.has(e)) throw new Error(`a text search provider for the scheme '${e}' is already registered`);
                    this._textSearchUsedSchemes.add(e);
                    const i = this._handlePool++;
                    return this._textSearchProvider.set(i, t), this._proxy.$registerTextSearchProvider(i, this._transformScheme(e)), (0, o.OF)((() => {
                        this._textSearchUsedSchemes.delete(e), this._textSearchProvider.delete(i), this._proxy.$unregisterProvider(i)
                    }))
                }
                registerAITextSearchProvider(e, t) {
                    if (this._aiTextSearchUsedSchemes.has(e)) throw new Error(`an AI text search provider for the scheme '${e}'is already registered`);
                    this._aiTextSearchUsedSchemes.add(e);
                    const i = this._handlePool++;
                    return this._aiTextSearchProvider.set(i, t), this._proxy.$registerAITextSearchProvider(i, this._transformScheme(e)), (0, o.OF)((() => {
                        this._aiTextSearchUsedSchemes.delete(e), this._aiTextSearchProvider.delete(i), this._proxy.$unregisterProvider(i)
                    }))
                }
                registerFileSearchProvider(e, t) {
                    if (this._fileSearchUsedSchemes.has(e)) throw new Error(`a file search provider for the scheme '${e}' is already registered`);
                    this._fileSearchUsedSchemes.add(e);
                    const i = this._handlePool++;
                    return this._fileSearchProvider.set(i, t), this._proxy.$registerFileSearchProvider(i, this._transformScheme(e)), (0, o.OF)((() => {
                        this._fileSearchUsedSchemes.delete(e), this._fileSearchProvider.delete(i), this._proxy.$unregisterProvider(i)
                    }))
                }
                $provideFileSearchResults(e, t, i, s) {
                    const o = I(i),
                        r = this._fileSearchProvider.get(e);
                    if (r) return this._fileSearchManager.fileSearch(o, r, (i => {
                        this._proxy.$handleFileMatch(e, t, i.map((e => e.resource)))
                    }), s);
                    throw new Error("3 unknown provider: " + e)
                }
                async doInternalFileSearchWithCustomCallback(e, t, i) {
                    return {
                        messages: []
                    }
                }
                $clearCache(e) {
                    return this._fileSearchManager.clearCache(e), Promise.resolve(void 0)
                }
                $provideTextSearchResults(e, t, i, s) {
                    const o = this._textSearchProvider.get(e);
                    if (!o || !o.provideTextSearchResults) throw new Error(`Unknown Text Search Provider ${e}`);
                    const r = I(i);
                    return this.createTextSearchManager(r, o).search((i => this._proxy.$handleTextMatch(e, t, i)), s)
                }
                $provideAITextSearchResults(e, t, i, s) {
                    const o = this._aiTextSearchProvider.get(e);
                    if (!o || !o.provideAITextSearchResults) throw new Error(`Unknown AI Text Search Provider ${e}`);
                    const r = I(i);
                    return this.createAITextSearchManager(r, o).search((i => this._proxy.$handleTextMatch(e, t, i)), s)
                }
                $enableExtensionHostSearch() {}
                createTextSearchManager(e, t) {
                    return new C({
                        query: e,
                        provider: t
                    }, {
                        readdir: e => Promise.resolve([]),
                        toCanonicalName: e => e
                    }, "textSearchProvider")
                }
                createAITextSearchManager(e, t) {
                    return new C({
                        query: e,
                        provider: t
                    }, {
                        readdir: e => Promise.resolve([]),
                        toCanonicalName: e => e
                    }, "aiTextSearchProvider")
                }
            };

            function I(e) {
                return { ...e,
                    folderQueries: e.folderQueries && e.folderQueries.map(A),
                    extraFileResources: e.extraFileResources && e.extraFileResources.map((e => y.ov.revive(e)))
                }
            }

            function A(e) {
                return { ...e,
                    folder: y.ov.revive(e.folder)
                }
            }
            k = (0, s.g)([(0, s.f)(0, v.O), (0, s.f)(1, _.F), (0, s.f)(2, f.V)], k)
        },
        ZuU9: (e, t, i) => {
            i.d(t, {
                Z: () => a,
                p: () => n
            });
            var s = i("YrcG"),
                o = i("7icl"),
                r = i("OYZR");
            class n {
                constructor(e) {
                    this._onDidChangePassword = new o.Q5, this.onDidChangePassword = this._onDidChangePassword.event, this._proxy = e.getProxy(s.Tr.MainThreadSecretState)
                }
                async $onDidChangePassword(e) {
                    this._onDidChangePassword.fire(e)
                }
                get(e, t) {
                    return this._proxy.$getPassword(e, t)
                }
                store(e, t, i) {
                    return this._proxy.$setPassword(e, t, i)
                }
                delete(e, t) {
                    return this._proxy.$deletePassword(e, t)
                }
            }
            const a = (0, r.yh)("IExtHostSecretState")
        },
        GZWR: (e, t, i) => {
            i.d(t, {
                W: () => a,
                Y: () => n
            });
            var s = i("YrcG"),
                o = i("7icl"),
                r = i("OYZR");
            class n {
                constructor(e, t) {
                    this._logService = t, this._onDidChangeStorage = new o.Q5, this.onDidChangeStorage = this._onDidChangeStorage.event, this._proxy = e.getProxy(s.Tr.MainThreadStorage)
                }
                registerExtensionStorageKeysToSync(e, t) {
                    this._proxy.$registerExtensionStorageKeysToSync(e, t)
                }
                async initializeExtensionStorage(e, t, i) {
                    const s = await this._proxy.$initializeExtensionStorage(e, t);
                    let o;
                    return s && (o = this.safeParseValue(e, t, s)), o || i
                }
                setValue(e, t, i) {
                    return this._proxy.$setValue(e, t, i)
                }
                $acceptValue(e, t, i) {
                    const s = this.safeParseValue(e, t, i);
                    s && this._onDidChangeStorage.fire({
                        shared: e,
                        key: t,
                        value: s
                    })
                }
                safeParseValue(e, t, i) {
                    try {
                        return JSON.parse(i)
                    } catch (i) {
                        this._logService.error(`[extHostStorage] unexpected error parsing storage contents (extensionId: ${t}, global: ${e}): ${i}`)
                    }
                }
            }
            const a = (0, r.yh)("IExtHostStorage")
        },
        PZtK: (e, t, i) => {
            i.d(t, {
                L: () => d,
                j: () => l
            });
            var s = i("t5wJ"),
                o = i("OYZR"),
                r = i("5h1i"),
                n = i("Vvlp"),
                a = i("nG0x"),
                c = i("naIR");
            const d = (0, o.yh)("IExtensionStoragePaths");
            let l = class {
                constructor(e, t, i) {
                    this._logService = t, this._extHostFileSystem = i, this._workspace = e.workspace ? ? void 0, this._environment = e.environment, this.whenReady = this._getOrCreateWorkspaceStoragePath().then((e => this._value = e))
                }
                async _getWorkspaceStorageURI(e) {
                    return c.ov.joinPath(this._environment.workspaceStorageHome, e)
                }
                async _getOrCreateWorkspaceStoragePath() {
                    if (!this._workspace) return Promise.resolve(void 0);
                    const e = this._workspace.id,
                        t = await this._getWorkspaceStorageURI(e);
                    try {
                        return await this._extHostFileSystem.value.stat(t), this._logService.trace("[ExtHostStorage] storage dir already exists", t), t
                    } catch {}
                    try {
                        return this._logService.trace("[ExtHostStorage] creating dir and metadata-file", t), await this._extHostFileSystem.value.createDirectory(t), await this._extHostFileSystem.value.writeFile(c.ov.joinPath(t, "meta.json"), (new TextEncoder).encode(JSON.stringify({
                            id: this._workspace.id,
                            configuration: c.ov.revive(this._workspace.configuration) ? .toString(),
                            name: this._workspace.name
                        }, void 0, 2))), t
                    } catch (e) {
                        return void this._logService.error("[ExtHostStorage]", e)
                    }
                }
                workspaceValue(e) {
                    if (this._value) return c.ov.joinPath(this._value, e.identifier.value)
                }
                globalValue(e) {
                    return c.ov.joinPath(this._environment.globalStorageHome, e.identifier.value.toLowerCase())
                }
                onWillDeactivateAll() {}
            };
            l = (0, s.g)([(0, s.f)(0, r.$), (0, s.f)(1, n.V), (0, s.f)(2, a.a)], l)
        },
        "JbH+": (e, t, i) => {
            i.d(t, {
                TE: () => H,
                h2: () => F
            });
            var s, o, r, n, a, c, d, l, h, u, p = i("t5wJ"),
                m = i("naIR"),
                g = i("opu4"),
                v = i("7icl"),
                _ = i("YrcG"),
                f = i("7NN/"),
                y = i("n9io"),
                w = i("l6bu"),
                x = i("45t+"),
                b = i("rJtg"),
                D = i("DvZ5"),
                C = i("Ayc8"),
                S = i("5h1i"),
                E = i("OYZR"),
                P = i("PTqS"),
                T = i("pLPy"),
                k = i("Vvlp"),
                I = i("jTbC"),
                A = (i("2u7n"), i("PUdK"));
            ! function(e) {
                e.from = function(e) {
                    if (null != e) return e
                }, e.to = function(e) {
                    if (null != e) return e
                }
            }(s || (s = {})),
            function(e) {
                e.from = function(e) {
                    if (null != e) return e
                }, e.to = function(e) {
                    if (null != e) return e
                }
            }(o || (o = {})),
            function(e) {
                e.from = function(e) {
                    if (null != e) return e
                }, e.to = function(e) {
                    if (null != e) return e
                }
            }(r || (r = {})),
            function(e) {
                e.is = function(e) {
                    return !!e && (e && !!e.process)
                }, e.from = function(e) {
                    if (null == e) return;
                    const t = {
                        process: e.process,
                        args: e.args
                    };
                    return e.options && (t.options = r.from(e.options)), t
                }, e.to = function(e) {
                    if (null != e) return new f.OLe(e.process, e.args, e.options)
                }
            }(n || (n = {})),
            function(e) {
                e.from = function(e) {
                    if (null != e) return e
                }, e.to = function(e) {
                    if (null != e) return e
                }
            }(a || (a = {})),
            function(e) {
                e.is = function(e) {
                    if (e) {
                        const t = e;
                        return t && (!!t.commandLine || !!t.command)
                    }
                    return !1
                }, e.from = function(e) {
                    if (null == e) return;
                    const t = {};
                    return void 0 !== e.commandLine ? t.commandLine = e.commandLine : (t.command = e.command, t.args = e.args), e.options && (t.options = a.from(e.options)), t
                }, e.to = function(e) {
                    if (null != e && (void 0 !== e.command || void 0 !== e.commandLine)) return e.commandLine ? new f.yGk(e.commandLine, e.options) : new f.yGk(e.command, e.args ? e.args : [], e.options)
                }
            }(c || (c = {})),
            function(e) {
                e.is = function(e) {
                    return !!e && (e && "customExecution" === e.customExecution)
                }, e.from = function(e) {
                    return {
                        customExecution: "customExecution"
                    }
                }, e.to = function(e, t) {
                    return t.get(e)
                }
            }(d || (d = {})),
            function(e) {
                e.from = function(e) {
                    if (null != e) return {
                        _id: e.id,
                        isDefault: e.isDefault
                    }
                }
            }(l || (l = {})),
            function(e) {
                function t(e, t) {
                    if (null == e) return;
                    let i;
                    e.execution instanceof f.OLe ? i = n.from(e.execution) : e.execution instanceof f.yGk ? i = c.from(e.execution) : e.execution && e.execution instanceof f.mgN && (i = d.from(e.execution));
                    const r = s.from(e.definition);
                    let a;
                    return a = e.scope ? "number" == typeof e.scope ? e.scope : e.scope.uri : f.qNe.Workspace, r && a ? {
                        _id: e._id,
                        definition: r,
                        name: e.name,
                        source: {
                            extensionId: t.identifier.value,
                            label: e.source,
                            scope: a
                        },
                        execution: i,
                        isBackground: e.isBackground,
                        group: l.from(e.group),
                        presentationOptions: o.from(e.presentationOptions),
                        problemMatchers: e.problemMatchers,
                        hasDefinedMatchers: e.hasDefinedMatchers,
                        runOptions: e.runOptions ? e.runOptions : {
                            reevaluateOnRerun: !0
                        },
                        detail: e.detail
                    } : void 0
                }
                e.fromMany = function(e, i) {
                    if (null == e) return [];
                    const s = [];
                    for (const o of e) {
                        const e = t(o, i);
                        e && s.push(e)
                    }
                    return s
                }, e.from = t, e.to = async function(e, t, i) {
                    if (null == e) return;
                    let r;
                    n.is(e.execution) ? r = n.to(e.execution) : c.is(e.execution) ? r = c.to(e.execution) : d.is(e.execution) && (r = d.to(e._id, i));
                    const a = s.to(e.definition);
                    let l;
                    if (e.source && (l = void 0 !== e.source.scope ? "number" == typeof e.source.scope ? e.source.scope : await t.resolveWorkspaceFolder(m.ov.revive(e.source.scope)) : f.qNe.Workspace), !a || !l) return;
                    const h = new f.iQE(a, l, e.name, e.source.label, r, e.problemMatchers);
                    return void 0 !== e.isBackground && (h.isBackground = e.isBackground), void 0 !== e.group && (h.group = f.p5U.from(e.group._id), h.group && e.group.isDefault && (h.group = new f.p5U(h.group.id, h.group.label), !0 === e.group.isDefault && (h.group.isDefault = e.group.isDefault))), e.presentationOptions && (h.presentationOptions = o.to(e.presentationOptions)), e._id && (h._id = e._id), e.detail && (h.detail = e.detail), h
                }
            }(h || (h = {})),
            function(e) {
                e.from = function(e) {
                    return e
                }, e.to = function(e) {
                    if (e) return Object.assign(Object.create(null), e)
                }
            }(u || (u = {}));
            class $ {#
                a;
                constructor(e, t, i) {
                    this._id = t, this._task = i, this.#a = e
                }
                get task() {
                    return this._task
                }
                terminate() {
                    this.#a.terminateTask(this)
                }
                fireDidStartProcess(e) {}
                fireDidEndProcess(e) {}
            }
            let R = class {
                constructor(e, t, i, s, o, r, n, a) {
                    this._onDidExecuteTask = new v.Q5, this._onDidTerminateTask = new v.Q5, this._onDidTaskProcessStarted = new v.Q5, this._onDidTaskProcessEnded = new v.Q5, this._proxy = e.getProxy(_.Tr.MainThreadTask), this._workspaceProvider = i, this._editorService = s, this._configurationService = o, this._terminalService = r, this._handleCounter = 0, this._handlers = new Map, this._taskExecutions = new Map, this._taskExecutionPromises = new Map, this._providedCustomExecutions2 = new Map, this._notProvidedCustomExecutions = new Set, this._activeCustomExecutions2 = new Map, this._logService = n, this._deprecationService = a, this._proxy.$registerSupportedExecutions(!0)
                }
                registerTaskProvider(e, t, i) {
                    if (!i) return new f.JTr((() => {}));
                    const s = this.nextHandle();
                    return this._handlers.set(s, {
                        type: t,
                        provider: i,
                        extension: e
                    }), this._proxy.$registerTaskProvider(s, t), new f.JTr((() => {
                        this._handlers.delete(s), this._proxy.$unregisterTaskProvider(s)
                    }))
                }
                registerTaskSystem(e, t) {
                    this._proxy.$registerTaskSystem(e, t)
                }
                fetchTasks(e) {
                    return this._proxy.$fetchTasks(u.from(e)).then((async e => {
                        const t = [];
                        for (const i of e) {
                            const e = await h.to(i, this._workspaceProvider, this._providedCustomExecutions2);
                            e && t.push(e)
                        }
                        return t
                    }))
                }
                get taskExecutions() {
                    const e = [];
                    return this._taskExecutions.forEach((t => e.push(t))), e
                }
                terminateTask(e) {
                    if (!(e instanceof $)) throw new Error("No valid task execution provided");
                    return this._proxy.$terminateTask(e._id)
                }
                get onDidStartTask() {
                    return this._onDidExecuteTask.event
                }
                async $onDidStartTask(e, t, i) {
                    const s = this._providedCustomExecutions2.get(e.id);
                    s && (this._activeCustomExecutions2.set(e.id, s), this._terminalService.attachPtyToTerminal(t, await s.callback(i))), this._lastStartedTask = e.id, this._onDidExecuteTask.fire({
                        execution: await this.getTaskExecution(e)
                    })
                }
                get onDidEndTask() {
                    return this._onDidTerminateTask.event
                }
                async $OnDidEndTask(e) {
                    if (!this._taskExecutionPromises.has(e.id)) return;
                    const t = await this.getTaskExecution(e);
                    this._taskExecutionPromises.delete(e.id), this._taskExecutions.delete(e.id), this.customExecutionComplete(e), this._onDidTerminateTask.fire({
                        execution: t
                    })
                }
                get onDidStartTaskProcess() {
                    return this._onDidTaskProcessStarted.event
                }
                async $onDidStartTaskProcess(e) {
                    const t = await this.getTaskExecution(e.id);
                    this._onDidTaskProcessStarted.fire({
                        execution: t,
                        processId: e.processId
                    })
                }
                get onDidEndTaskProcess() {
                    return this._onDidTaskProcessEnded.event
                }
                async $onDidEndTaskProcess(e) {
                    const t = await this.getTaskExecution(e.id);
                    this._onDidTaskProcessEnded.fire({
                        execution: t,
                        exitCode: e.exitCode
                    })
                }
                $provideTasks(e, t) {
                    const i = this._handlers.get(e);
                    if (!i) return Promise.reject(new Error("no handler found"));
                    const s = [],
                        o = (0, g.OH)((() => i.provider.provideTasks(b.Ts.None))).then((e => this.provideTasksInternal(t, s, i, e)));
                    return new Promise((e => {
                        o.then((t => {
                            Promise.all(s).then((() => {
                                e(t)
                            }))
                        }))
                    }))
                }
                async $resolveTask(e, t) {
                    const i = this._handlers.get(e);
                    if (!i) return Promise.reject(new Error("no handler found"));
                    if (t.definition.type !== i.type) throw new Error(`Unexpected: Task of type [${t.definition.type}] cannot be resolved by provider of type [${i.type}].`);
                    const s = await h.to(t, this._workspaceProvider, this._providedCustomExecutions2);
                    if (!s) throw new Error("Unexpected: Task cannot be resolved.");
                    const o = await i.provider.resolveTask(s, b.Ts.None);
                    if (!o) return;
                    this.checkDeprecation(o, i);
                    const r = h.from(o, i.extension);
                    if (!r) throw new Error("Unexpected: Task cannot be resolved.");
                    if (o.definition !== s.definition) throw new Error("Unexpected: The resolved task definition must be the same object as the original task definition. The task definition cannot be changed.");
                    return d.is(r.execution) && await this.addCustomExecution(r, o, !0), await this.resolveTaskInternal(r)
                }
                nextHandle() {
                    return this._handleCounter++
                }
                async addCustomExecution(e, t, i) {
                    const s = await this._proxy.$createTaskId(e);
                    i || this._providedCustomExecutions2.has(s) || (this._notProvidedCustomExecutions.add(s), this._activeCustomExecutions2.set(s, t.execution)), this._providedCustomExecutions2.set(s, t.execution)
                }
                async getTaskExecution(e, t) {
                    if ("string" == typeof e) {
                        const t = this._taskExecutionPromises.get(e);
                        if (!t) throw new A.QD("Unexpected: The specified task is missing an execution");
                        return t
                    }
                    const i = this._taskExecutionPromises.get(e.id);
                    if (i) return i;
                    let s;
                    return s = t ? Promise.resolve(new $(this, e.id, t)) : h.to(e.task, this._workspaceProvider, this._providedCustomExecutions2).then((t => {
                        if (!t) throw new A.QD("Unexpected: Task does not exist.");
                        return new $(this, e.id, t)
                    })), this._taskExecutionPromises.set(e.id, s), s.then((t => (this._taskExecutions.set(e.id, t), t)))
                }
                checkDeprecation(e, t) {
                    e._deprecated && this._deprecationService.report("Task.constructor", t.extension, "Use the Task constructor that takes a `scope` instead.")
                }
                customExecutionComplete(e) {
                    this._activeCustomExecutions2.get(e.id) && this._activeCustomExecutions2.delete(e.id), this._notProvidedCustomExecutions.has(e.id) && this._lastStartedTask !== e.id && (this._providedCustomExecutions2.delete(e.id), this._notProvidedCustomExecutions.delete(e.id));
                    const t = this._notProvidedCustomExecutions.values();
                    let i = t.next();
                    for (; !i.done;) this._activeCustomExecutions2.has(i.value) || this._lastStartedTask === i.value || (this._providedCustomExecutions2.delete(i.value), this._notProvidedCustomExecutions.delete(i.value)), i = t.next()
                }
            };
            R = (0, p.g)([(0, p.f)(0, C.O), (0, p.f)(1, S.$), (0, p.f)(2, y.w), (0, p.f)(3, w.T), (0, p.f)(4, x.E1), (0, p.f)(5, D.$3), (0, p.f)(6, k.V), (0, p.f)(7, I.J)], R);
            let H = class extends R {
                constructor(e, t, i, s, o, r, n, a) {
                    super(e, t, i, s, o, r, n, a), this.registerTaskSystem(P.lg.vscodeRemote, {
                        scheme: P.lg.vscodeRemote,
                        authority: "",
                        platform: (0, T.PW)(T.t4.Web)
                    })
                }
                async executeTask(e, t) {
                    if (!t.execution) throw new Error("Tasks to execute must include an execution");
                    const i = h.from(t, e);
                    if (void 0 === i) throw new Error("Task is not valid");
                    if (!d.is(i.execution)) throw new A.B8;
                    await this.addCustomExecution(i, t, !1);
                    const s = await this.getTaskExecution(await this._proxy.$getTaskExecution(i), t);
                    return this._proxy.$executeTask(i).catch((e => {
                        throw new Error(e)
                    })), s
                }
                provideTasksInternal(e, t, i, s) {
                    const o = [];
                    if (s)
                        for (const r of s) {
                            if (this.checkDeprecation(r, i), !r.definition || !e[r.definition.type]) {
                                const e = r.source ? r.source : "No task source";
                                this._logService.warn(`The task [${e}, ${r.name}] uses an undefined task type. The task will be ignored in the future.`)
                            }
                            const s = h.from(r, i.extension);
                            s && d.is(s.execution) ? (o.push(s), t.push(this.addCustomExecution(s, r, !0))) : this._logService.warn("Only custom execution tasks supported.")
                        }
                    return {
                        tasks: o,
                        extension: i.extension
                    }
                }
                async resolveTaskInternal(e) {
                    if (d.is(e.execution)) return e;
                    this._logService.warn("Only custom execution tasks supported.")
                }
                async $resolveVariables(e, t) {
                    return {
                        process: void 0,
                        variables: Object.create(null)
                    }
                }
                async $jsonTasksSupported() {
                    return !1
                }
                async $findExecutable(e, t, i) {}
            };
            H = (0, p.g)([(0, p.f)(0, C.O), (0, p.f)(1, S.$), (0, p.f)(2, y.w), (0, p.f)(3, w.T), (0, p.f)(4, x.E1), (0, p.f)(5, D.$3), (0, p.f)(6, k.V), (0, p.f)(7, I.J)], H);
            const F = (0, E.yh)("IExtHostTask")
        },
        ofuf: (e, t, i) => {
            i.d(t, {
                fv: () => w,
                jQ: () => f,
                oI: () => y,
                wM: () => _
            });
            var s = i("t5wJ"),
                o = i("OYZR"),
                r = i("7icl"),
                n = i("9Z05"),
                a = i("7EzT"),
                c = i("Vvlp"),
                d = i("5h1i"),
                l = i("MQtx"),
                h = i("LjkX"),
                u = i("hL8p"),
                p = i("7eUP"),
                m = i("naIR"),
                g = i("RVdl"),
                v = i("yFKF");
            let _ = class extends g.JT {
                constructor(e, t) {
                    super(), this.initData = e, this.loggerService = t, this._onDidChangeTelemetryEnabled = this._register(new r.Q5), this.onDidChangeTelemetryEnabled = this._onDidChangeTelemetryEnabled.event, this._onDidChangeTelemetryConfiguration = this._register(new r.Q5), this.onDidChangeTelemetryConfiguration = this._onDidChangeTelemetryConfiguration.event, this._productConfig = {
                        usage: !0,
                        error: !0
                    }, this._level = n.g3.NONE, this._telemetryIsSupported = !1, this._inLoggingOnlyMode = !1, this._telemetryLoggers = new Map, this.extHostTelemetryLogFile = m.ov.revive(this.initData.environment.extensionTelemetryLogResource), this._inLoggingOnlyMode = this.initData.environment.isExtensionTelemetryLoggingOnly, this._outputLogger = t.createLogger(this.extHostTelemetryLogFile, {
                        id: u.kG,
                        name: (0, v.C$)("vs/workbench/api/common/extHostTelemetry", 0, "Extension Telemetry{0}", this._inLoggingOnlyMode ? " (Not Sent)" : ""),
                        hidden: !0
                    }), this._register(this._outputLogger), this._register(t.onDidChangeLogLevel((e => {
                        (0, a.w7)(e) && this.updateLoggerVisibility()
                    }))), this._outputLogger.info("Below are logs for extension telemetry events sent to the telemetry output channel API once the log level is set to trace."), this._outputLogger.info("===========================================================")
                }
                updateLoggerVisibility() {
                    this.loggerService.setVisibility(this.extHostTelemetryLogFile, this._telemetryIsSupported && this.loggerService.getLogLevel() === a.in.Trace)
                }
                getTelemetryConfiguration() {
                    return this._level === n.g3.USAGE
                }
                getTelemetryDetails() {
                    return {
                        isCrashEnabled: this._level >= n.g3.CRASH,
                        isErrorsEnabled: !!this._productConfig.error && this._level >= n.g3.ERROR,
                        isUsageEnabled: !!this._productConfig.usage && this._level >= n.g3.USAGE
                    }
                }
                instantiateLogger(e, t, i) {
                    const s = this.getTelemetryDetails(),
                        o = new f(t, i, e, this._outputLogger, this._inLoggingOnlyMode, this.getBuiltInCommonProperties(e), {
                            isUsageEnabled: s.isUsageEnabled,
                            isErrorsEnabled: s.isErrorsEnabled
                        }),
                        r = this._telemetryLoggers.get(e.identifier.value) ? ? [];
                    return this._telemetryLoggers.set(e.identifier.value, [...r, o]), o.apiTelemetryLogger
                }
                $initializeTelemetryLevel(e, t, i) {
                    this._level = e, this._telemetryIsSupported = t, this._productConfig = i ? ? {
                        usage: !0,
                        error: !0
                    }, this.updateLoggerVisibility()
                }
                getBuiltInCommonProperties(e) {
                    const t = Object.create(null);
                    switch (t["common.extname"] = `${e.publisher}.${e.name}`, t["common.extversion"] = e.version, t["common.vscodemachineid"] = this.initData.telemetryInfo.machineId, t["common.vscodesessionid"] = this.initData.telemetryInfo.sessionId, t["common.sqmid"] = this.initData.telemetryInfo.sqmId, t["common.devDeviceId"] = this.initData.telemetryInfo.devDeviceId, t["common.vscodeversion"] = this.initData.version, t["common.isnewappinstall"] = y(this.initData.telemetryInfo.firstSessionDate), t["common.product"] = this.initData.environment.appHost, this.initData.uiKind) {
                        case l.D$.Web:
                            t["common.uikind"] = "web";
                            break;
                        case l.D$.Desktop:
                            t["common.uikind"] = "desktop";
                            break;
                        default:
                            t["common.uikind"] = "unknown"
                    }
                    return t["common.remotename"] = (0, h.WX)((0, u.x0)(this.initData.remote.authority)), t
                }
                $onDidChangeTelemetryLevel(e) {
                    this._oldTelemetryEnablement = this.getTelemetryConfiguration(), this._level = e;
                    const t = this.getTelemetryDetails();
                    this._telemetryLoggers.forEach(((e, t) => {
                        const i = e.filter((e => !e.isDisposed));
                        0 === i.length ? this._telemetryLoggers.delete(t) : this._telemetryLoggers.set(t, i)
                    })), this._telemetryLoggers.forEach((e => {
                        for (const i of e) i.updateTelemetryEnablements(t.isUsageEnabled, t.isErrorsEnabled)
                    })), this._oldTelemetryEnablement !== this.getTelemetryConfiguration() && this._onDidChangeTelemetryEnabled.fire(this.getTelemetryConfiguration()), this._onDidChangeTelemetryConfiguration.fire(this.getTelemetryDetails()), this.updateLoggerVisibility()
                }
                onExtensionError(e, t) {
                    const i = this._telemetryLoggers.get(e.value),
                        s = i ? .filter((e => !e.isDisposed));
                    if (!s) return this._telemetryLoggers.delete(e.value), !1;
                    let o = !1;
                    for (const e of s) e.ignoreUnhandledExtHostErrors || (e.logError(t), o = !0);
                    return o
                }
            };
            _ = (0, s.g)([(0, s.f)(0, d.$), (0, s.f)(1, c.y)], _);
            class f {
                static validateSender(e) {
                    if ("object" != typeof e) throw new TypeError("TelemetrySender argument is invalid");
                    if ("function" != typeof e.sendEventData) throw new TypeError("TelemetrySender.sendEventData must be a function");
                    if ("function" != typeof e.sendErrorData) throw new TypeError("TelemetrySender.sendErrorData must be a function");
                    if (void 0 !== e.flush && "function" != typeof e.flush) throw new TypeError("TelemetrySender.flush must be a function or undefined")
                }
                constructor(e, t, i, s, o, n, a) {
                    this._extension = i, this._logger = s, this._inLoggingOnlyMode = o, this._commonProperties = n, this._onDidChangeEnableStates = new r.Q5, this.ignoreUnhandledExtHostErrors = t ? .ignoreUnhandledErrors ? ? !1, this._ignoreBuiltinCommonProperties = t ? .ignoreBuiltInCommonProperties ? ? !1, this._additionalCommonProperties = t ? .additionalCommonProperties, this._sender = e, this._telemetryEnablements = {
                        isUsageEnabled: a.isUsageEnabled,
                        isErrorsEnabled: a.isErrorsEnabled
                    }
                }
                updateTelemetryEnablements(e, t) {
                    this._apiObject && (this._telemetryEnablements = {
                        isUsageEnabled: e,
                        isErrorsEnabled: t
                    }, this._onDidChangeEnableStates.fire(this._apiObject))
                }
                mixInCommonPropsAndCleanData(e) {
                    let t = "properties" in e ? e.properties ? ? {} : e;
                    return t = (0, u.cG)(t, []), this._additionalCommonProperties && (t = (0, p.jB)(t, this._additionalCommonProperties)), this._ignoreBuiltinCommonProperties || (t = (0, p.jB)(t, this._commonProperties)), "properties" in e ? e.properties = t : e = t, e
                }
                logEvent(e, t) {
                    this._sender && (e = "vscode" === this._extension.publisher ? this._extension.name + "/" + e : this._extension.identifier.value + "/" + e, t = this.mixInCommonPropsAndCleanData(t || {}), this._inLoggingOnlyMode || this._sender ? .sendEventData(e, t), this._logger.trace(e, t))
                }
                logUsage(e, t) {
                    this._telemetryEnablements.isUsageEnabled && this.logEvent(e, t)
                }
                logError(e, t) {
                    if (this._telemetryEnablements.isErrorsEnabled && this._sender)
                        if ("string" == typeof e) this.logEvent(e, t);
                        else {
                            const i = {
                                    name: e.name,
                                    message: e.message,
                                    stack: e.stack,
                                    cause: e.cause
                                },
                                s = (0, u.cG)(i, []),
                                o = new Error(s.message, {
                                    cause: s.cause
                                });
                            o.stack = s.stack, o.name = s.name, t = this.mixInCommonPropsAndCleanData(t || {}), this._inLoggingOnlyMode || this._sender.sendErrorData(o, t), this._logger.trace("exception", t)
                        }
                }
                get apiTelemetryLogger() {
                    if (!this._apiObject) {
                        const e = this,
                            t = {
                                logUsage: e.logUsage.bind(e),
                                get isUsageEnabled() {
                                    return e._telemetryEnablements.isUsageEnabled
                                },
                                get isErrorsEnabled() {
                                    return e._telemetryEnablements.isErrorsEnabled
                                },
                                logError: e.logError.bind(e),
                                dispose: e.dispose.bind(e),
                                onDidChangeEnableStates: e._onDidChangeEnableStates.event.bind(e)
                            };
                        this._apiObject = Object.freeze(t)
                    }
                    return this._apiObject
                }
                get isDisposed() {
                    return !this._sender
                }
                dispose() {
                    if (this._sender ? .flush) {
                        let e = this._sender;
                        this._sender = void 0, Promise.resolve(e.flush()).then(e = void 0), this._apiObject = void 0
                    } else this._sender = void 0
                }
            }

            function y(e) {
                const t = Date.now() - new Date(e).getTime();
                return !isNaN(t) && t < 864e5
            }
            const w = (0, o.yh)("IExtHostTelemetry")
        },
        DvZ5: (e, t, i) => {
            i.d(t, {
                $3: () => D,
                Ry: () => I
            });
            var s = i("t5wJ"),
                o = i("7icl"),
                r = i("YrcG"),
                n = i("OYZR"),
                a = i("naIR"),
                c = i("Ayc8"),
                d = i("RVdl"),
                l = i("7NN/"),
                h = i("yFKF"),
                u = i("PUdK"),
                p = i("+E6I"),
                m = i("rJtg"),
                g = i("R7Dl"),
                v = i("Kqpk"),
                _ = i("E++z"),
                f = i("6JmM"),
                y = i("opu4"),
                w = i("IqsH"),
                x = i("0f12"),
                b = i("9HFd");
            const D = (0, n.yh)("IExtHostTerminalService");
            class C extends d.JT {
                constructor(e, t, i, s) {
                    super(), this._proxy = e, this._id = t, this._creationOptions = i, this._name = s, this._disposed = !1, this._state = {
                        isInteractedWith: !1
                    }, this.isOpen = !1, this._onWillDispose = this._register(new o.Q5), this.onWillDispose = this._onWillDispose.event, this._creationOptions = Object.freeze(this._creationOptions), this._pidPromise = new Promise((e => this._pidPromiseComplete = e));
                    const r = this;
                    this.value = {
                        get name() {
                            return r._name || ""
                        },
                        get processId() {
                            return r._pidPromise
                        },
                        get creationOptions() {
                            return r._creationOptions
                        },
                        get exitStatus() {
                            return r._exitStatus
                        },
                        get state() {
                            return r._state
                        },
                        get selection() {
                            return r._selection
                        },
                        get shellIntegration() {
                            return r.shellIntegration
                        },
                        sendText(e, t = !0) {
                            r._checkDisposed(), r._proxy.$sendText(r._id, e, t)
                        },
                        show(e) {
                            r._checkDisposed(), r._proxy.$show(r._id, e)
                        },
                        hide() {
                            r._checkDisposed(), r._proxy.$hide(r._id)
                        },
                        dispose() {
                            r._disposed || (r._disposed = !0, r._proxy.$dispose(r._id))
                        },
                        get dimensions() {
                            if (void 0 !== r._cols && void 0 !== r._rows) return {
                                columns: r._cols,
                                rows: r._rows
                            }
                        }
                    }
                }
                dispose() {
                    this._onWillDispose.fire(), super.dispose()
                }
                async create(e, t) {
                    if ("string" != typeof this._id) throw new Error("Terminal has already been created");
                    await this._proxy.$createTerminal(this._id, {
                        name: e.name,
                        shellPath: e.shellPath ? ? void 0,
                        shellArgs: e.shellArgs ? ? void 0,
                        cwd: e.cwd ? ? t ? .cwd ? ? void 0,
                        env: e.env ? ? void 0,
                        icon: A(e.iconPath) ? ? void 0,
                        color: f.tP.isThemeColor(e.color) ? e.color.id : void 0,
                        initialText: e.message ? ? void 0,
                        strictEnv: e.strictEnv ? ? void 0,
                        hideFromUser: e.hideFromUser ? ? void 0,
                        forceShellIntegration: t ? .forceShellIntegration ? ? void 0,
                        isFeatureTerminal: t ? .isFeatureTerminal ? ? void 0,
                        isExtensionOwnedTerminal: !0,
                        useShellEnvironment: t ? .useShellEnvironment ? ? void 0,
                        location: t ? .location || this._serializeParentTerminal(e.location, t ? .resolvedExtHostIdentifier),
                        isTransient: e.isTransient ? ? void 0
                    })
                }
                async createExtensionTerminal(e, t, i, s, o) {
                    if ("string" != typeof this._id) throw new Error("Terminal has already been created");
                    if (await this._proxy.$createTerminal(this._id, {
                            name: this._name,
                            isExtensionCustomPtyTerminal: !0,
                            icon: s,
                            color: f.tP.isThemeColor(o) ? o.id : void 0,
                            location: t ? .location || this._serializeParentTerminal(e, i),
                            isTransient: !0
                        }), "string" == typeof this._id) throw new Error("Terminal creation failed");
                    return this._id
                }
                _serializeParentTerminal(e, t) {
                    return "object" == typeof e ? "parentTerminal" in e && e.parentTerminal && t ? {
                        parentTerminal: t
                    } : "viewColumn" in e ? {
                        viewColumn: w.eI.from(e.viewColumn),
                        preserveFocus: e.preserveFocus
                    } : void 0 : e
                }
                _checkDisposed() {
                    if (this._disposed) throw new Error("Terminal has already been disposed")
                }
                set name(e) {
                    this._name = e
                }
                setExitStatus(e, t) {
                    this._exitStatus = Object.freeze({
                        code: e,
                        reason: t
                    })
                }
                setDimensions(e, t) {
                    return (e !== this._cols || t !== this._rows) && 0 !== e && 0 !== t && (this._cols = e, this._rows = t, !0)
                }
                setInteractedWith() {
                    return !this._state.isInteractedWith && (this._state = {
                        isInteractedWith: !0
                    }, !0)
                }
                setSelection(e) {
                    this._selection = e
                }
                _setProcessId(e) {
                    this._pidPromiseComplete ? (this._pidPromiseComplete(e), this._pidPromiseComplete = void 0) : this._pidPromise.then((t => {
                        t !== e && (this._pidPromise = Promise.resolve(e))
                    }))
                }
            }
            class S {
                get onProcessReady() {
                    return this._onProcessReady.event
                }
                constructor(e) {
                    this._pty = e, this.id = 0, this.shouldPersist = !1, this._onProcessData = new o.Q5, this.onProcessData = this._onProcessData.event, this._onProcessReady = new o.Q5, this._onDidChangeProperty = new o.Q5, this.onDidChangeProperty = this._onDidChangeProperty.event, this._onProcessExit = new o.Q5, this.onProcessExit = this._onProcessExit.event
                }
                refreshProperty(e) {
                    throw new Error(`refreshProperty is not suppported in extension owned terminals. property: ${e}`)
                }
                updateProperty(e, t) {
                    throw new Error(`updateProperty is not suppported in extension owned terminals. property: ${e}, value: ${t}`)
                }
                async start() {}
                shutdown() {
                    this._pty.close()
                }
                input(e) {
                    this._pty.handleInput ? .(e)
                }
                resize(e, t) {
                    this._pty.setDimensions ? .({
                        columns: e,
                        rows: t
                    })
                }
                clearBuffer() {}
                async processBinary(e) {}
                acknowledgeDataEvent(e) {}
                async setUnicodeVersion(e) {}
                getInitialCwd() {
                    return Promise.resolve("")
                }
                getCwd() {
                    return Promise.resolve("")
                }
                startSendingEvents(e) {
                    this._pty.onDidWrite((e => this._onProcessData.fire(e))), this._pty.onDidClose ? .(((e = undefined) => {
                        this._onProcessExit.fire(void 0 === e ? void 0 : e)
                    })), this._pty.onDidOverrideDimensions ? .((e => {
                        e && this._onDidChangeProperty.fire({
                            type: v.EX.OverrideDimensions,
                            value: {
                                cols: e.columns,
                                rows: e.rows
                            }
                        })
                    })), this._pty.onDidChangeName ? .((e => {
                        this._onDidChangeProperty.fire({
                            type: v.EX.Title,
                            value: e
                        })
                    })), this._pty.open(e || void 0), e && this._pty.setDimensions ? .(e), this._onProcessReady.fire({
                        pid: -1,
                        cwd: "",
                        windowsPty: void 0
                    })
                }
            }
            let E = 1,
                P = class extends d.JT {
                    get activeTerminal() {
                        return this._activeTerminal ? .value
                    }
                    get terminals() {
                        return this._terminals.map((e => e.value))
                    }
                    constructor(e, t, i) {
                        super(), this._extHostCommands = t, this._terminals = [], this._terminalProcesses = new Map, this._terminalProcessDisposables = {}, this._extensionTerminalAwaitingStart = {}, this._getTerminalPromises = {}, this._environmentVariableCollections = new Map, this._lastQuickFixCommands = this._register(new d.XK), this._linkProviders = new Set, this._profileProviders = new Map, this._quickFixProviders = new Map, this._terminalLinkCache = new Map, this._terminalLinkCancellationSource = new Map, this._onDidCloseTerminal = new o.Q5, this.onDidCloseTerminal = this._onDidCloseTerminal.event, this._onDidOpenTerminal = new o.Q5, this.onDidOpenTerminal = this._onDidOpenTerminal.event, this._onDidChangeActiveTerminal = new o.Q5, this.onDidChangeActiveTerminal = this._onDidChangeActiveTerminal.event, this._onDidChangeTerminalDimensions = new o.Q5, this.onDidChangeTerminalDimensions = this._onDidChangeTerminalDimensions.event, this._onDidChangeTerminalState = new o.Q5, this.onDidChangeTerminalState = this._onDidChangeTerminalState.event, this._onDidChangeShell = new o.Q5, this.onDidChangeShell = this._onDidChangeShell.event, this._onDidWriteTerminalData = new o.Q5({
                            onWillAddFirstListener: () => this._proxy.$startSendingDataEvents(),
                            onDidRemoveLastListener: () => this._proxy.$stopSendingDataEvents()
                        }), this.onDidWriteTerminalData = this._onDidWriteTerminalData.event, this._onDidExecuteCommand = new o.Q5({
                            onWillAddFirstListener: () => this._proxy.$startSendingCommandEvents(),
                            onDidRemoveLastListener: () => this._proxy.$stopSendingCommandEvents()
                        }), this.onDidExecuteTerminalCommand = this._onDidExecuteCommand.event, this._proxy = i.getProxy(r.Tr.MainThreadTerminalService), this._bufferer = new _.$(this._proxy.$sendProcessData), this._proxy.$registerProcessSupport(e), this._extHostCommands.registerArgumentProcessor({
                            processArgument: e => {
                                const t = e => {
                                    const t = e;
                                    return this.getTerminalById(t.instanceId) ? .value
                                };
                                if (e ? .$mid === b.m.TerminalContext) return t(e);
                                if (Array.isArray(e))
                                    for (let i = 0; i < e.length && e[i].$mid === b.m.TerminalContext; i++) e[i] = t(e[i]);
                                return e
                            }
                        }), this._register({
                            dispose: () => {
                                for (const [e, t] of this._terminalProcesses) t.shutdown(!0)
                            }
                        })
                    }
                    getDefaultShell(e) {
                        const t = e ? this._defaultAutomationProfile : this._defaultProfile;
                        return t ? .path || ""
                    }
                    getDefaultShellArgs(e) {
                        const t = e ? this._defaultAutomationProfile : this._defaultProfile;
                        return t ? .args || []
                    }
                    createExtensionTerminal(e, t) {
                        const i = new C(this._proxy, (0, g.R)(), e, e.name),
                            s = new S(e.pty);
                        var o;
                        return i.createExtensionTerminal(e.location, t, this._serializeParentTerminal(e, t).resolvedExtHostIdentifier, A(e.iconPath), (o = e.color, f.tP.isThemeColor(o) ? o : void 0)).then((e => {
                            const t = this._setupExtHostProcessListeners(e, s);
                            this._terminalProcessDisposables[e] = t
                        })), this._terminals.push(i), i.value
                    }
                    _serializeParentTerminal(e, t) {
                        if (t = t || {}, e.location && "object" == typeof e.location && "parentTerminal" in e.location) {
                            const i = e.location.parentTerminal;
                            if (i) {
                                const e = this._terminals.find((e => e.value === i));
                                e && (t.resolvedExtHostIdentifier = e._id)
                            }
                        } else e.location && "object" != typeof e.location ? t.location = e.location : t.location && "object" == typeof t.location && "splitActiveTerminal" in t.location && (t.location = {
                            splitActiveTerminal: !0
                        });
                        return t
                    }
                    attachPtyToTerminal(e, t) {
                        if (!this.getTerminalById(e)) throw new Error(`Cannot resolve terminal with id ${e} for virtual process`);
                        const i = new S(t),
                            s = this._setupExtHostProcessListeners(e, i);
                        this._terminalProcessDisposables[e] = s
                    }
                    async $acceptActiveTerminalChanged(e) {
                        const t = this._activeTerminal;
                        if (null === e) return this._activeTerminal = void 0, void(t !== this._activeTerminal && this._onDidChangeActiveTerminal.fire(this._activeTerminal));
                        const i = this.getTerminalById(e);
                        i && (this._activeTerminal = i, t !== this._activeTerminal && this._onDidChangeActiveTerminal.fire(this._activeTerminal.value))
                    }
                    async $acceptTerminalProcessData(e, t) {
                        const i = this.getTerminalById(e);
                        i && this._onDidWriteTerminalData.fire({
                            terminal: i.value,
                            data: t
                        })
                    }
                    async $acceptTerminalDimensions(e, t, i) {
                        const s = this.getTerminalById(e);
                        s && s.setDimensions(t, i) && this._onDidChangeTerminalDimensions.fire({
                            terminal: s.value,
                            dimensions: s.value.dimensions
                        })
                    }
                    async $acceptDidExecuteCommand(e, t) {
                        const i = this.getTerminalById(e);
                        i && this._onDidExecuteCommand.fire({
                            terminal: i.value,
                            ...t
                        })
                    }
                    async $acceptTerminalMaximumDimensions(e, t, i) {
                        this._terminalProcesses.get(e) ? .resize(t, i)
                    }
                    async $acceptTerminalTitleChange(e, t) {
                        const i = this.getTerminalById(e);
                        i && (i.name = t)
                    }
                    async $acceptTerminalClosed(e, t, i) {
                        const s = this._getTerminalObjectIndexById(this._terminals, e);
                        if (null !== s) {
                            const e = this._terminals.splice(s, 1)[0];
                            e.setExitStatus(t, i), this._onDidCloseTerminal.fire(e.value)
                        }
                    }
                    $acceptTerminalOpened(e, t, i, s) {
                        if (t) {
                            const i = this._getTerminalObjectIndexById(this._terminals, t);
                            if (null !== i) return this._terminals[i]._id = e, this._onDidOpenTerminal.fire(this.terminals[i]), void(this._terminals[i].isOpen = !0)
                        }
                        const o = {
                                name: s.name,
                                shellPath: s.executable,
                                shellArgs: s.args,
                                cwd: "string" == typeof s.cwd ? s.cwd : a.ov.revive(s.cwd),
                                env: s.env,
                                hideFromUser: s.hideFromUser
                            },
                            r = new C(this._proxy, e, o, i);
                        this._terminals.push(r), this._onDidOpenTerminal.fire(r.value), r.isOpen = !0
                    }
                    async $acceptTerminalProcessId(e, t) {
                        const i = this.getTerminalById(e);
                        i ? ._setProcessId(t)
                    }
                    async $startExtensionTerminal(e, t) {
                        const i = this.getTerminalById(e);
                        if (!i) return {
                            message: (0, h.C$)("vs/workbench/api/common/extHostTerminalService", 0, "Could not find the terminal with id {0} on the extension host", e)
                        };
                        i.isOpen || await new Promise((e => {
                            const t = this.onDidOpenTerminal((async s => {
                                s === i.value && (t.dispose(), e())
                            }))
                        }));
                        const s = this._terminalProcesses.get(e);
                        s ? s.startSendingEvents(t) : this._extensionTerminalAwaitingStart[e] = {
                            initialDimensions: t
                        }
                    }
                    _setupExtHostProcessListeners(e, t) {
                        const i = new d.SL;
                        i.add(t.onProcessReady((t => this._proxy.$sendProcessReady(e, t.pid, t.cwd, t.windowsPty)))), i.add(t.onDidChangeProperty((t => this._proxy.$sendProcessProperty(e, t)))), this._bufferer.startBuffering(e, t.onProcessData), i.add(t.onProcessExit((t => this._onProcessExit(e, t)))), this._terminalProcesses.set(e, t);
                        const s = this._extensionTerminalAwaitingStart[e];
                        return s && t instanceof S && (t.startSendingEvents(s.initialDimensions), delete this._extensionTerminalAwaitingStart[e]), i
                    }
                    $acceptProcessAckDataEvent(e, t) {
                        this._terminalProcesses.get(e) ? .acknowledgeDataEvent(t)
                    }
                    $acceptProcessInput(e, t) {
                        this._terminalProcesses.get(e) ? .input(t)
                    }
                    $acceptTerminalInteraction(e) {
                        const t = this.getTerminalById(e);
                        t ? .setInteractedWith() && this._onDidChangeTerminalState.fire(t.value)
                    }
                    $acceptTerminalSelection(e, t) {
                        this.getTerminalById(e) ? .setSelection(t)
                    }
                    $acceptProcessResize(e, t, i) {
                        try {
                            this._terminalProcesses.get(e) ? .resize(t, i)
                        } catch (e) {
                            if ("EPIPE" !== e.code && "ERR_IPC_CHANNEL_CLOSED" !== e.code) throw e
                        }
                    }
                    $acceptProcessShutdown(e, t) {
                        this._terminalProcesses.get(e) ? .shutdown(t)
                    }
                    $acceptProcessRequestInitialCwd(e) {
                        this._terminalProcesses.get(e) ? .getInitialCwd().then((t => this._proxy.$sendProcessProperty(e, {
                            type: v.EX.InitialCwd,
                            value: t
                        })))
                    }
                    $acceptProcessRequestCwd(e) {
                        this._terminalProcesses.get(e) ? .getCwd().then((t => this._proxy.$sendProcessProperty(e, {
                            type: v.EX.Cwd,
                            value: t
                        })))
                    }
                    $acceptProcessRequestLatency(e) {
                        return Promise.resolve(e)
                    }
                    registerLinkProvider(e) {
                        return this._linkProviders.add(e), 1 === this._linkProviders.size && this._proxy.$startLinkProvider(), new l.JTr((() => {
                            this._linkProviders.delete(e), 0 === this._linkProviders.size && this._proxy.$stopLinkProvider()
                        }))
                    }
                    registerProfileProvider(e, t, i) {
                        if (this._profileProviders.has(t)) throw new Error(`Terminal profile provider "${t}" already registered`);
                        return this._profileProviders.set(t, i), this._proxy.$registerProfileProvider(t, e.identifier.value), new l.JTr((() => {
                            this._profileProviders.delete(t), this._proxy.$unregisterProfileProvider(t)
                        }))
                    }
                    registerTerminalQuickFixProvider(e, t, i) {
                        if (this._quickFixProviders.has(e)) throw new Error(`Terminal quick fix provider "${e}" is already registered`);
                        return this._quickFixProviders.set(e, i), this._proxy.$registerQuickFixProvider(e, t), new l.JTr((() => {
                            this._quickFixProviders.delete(e), this._proxy.$unregisterQuickFixProvider(e)
                        }))
                    }
                    async $provideTerminalQuickFixes(e, t) {
                        const i = (new m.AU).token;
                        if (i.isCancellationRequested) return;
                        const s = this._quickFixProviders.get(e);
                        if (!s) return;
                        const o = await s.provideTerminalQuickFixes(t, i);
                        if (null === o || Array.isArray(o) && 0 === o.length) return;
                        const r = new d.SL;
                        if (this._lastQuickFixCommands.value = r, !Array.isArray(o)) return o ? w.w7.from(o, this._extHostCommands.converter, r) : void 0;
                        const n = [];
                        for (const e of o) {
                            const t = w.w7.from(e, this._extHostCommands.converter, r);
                            t && n.push(t)
                        }
                        return n
                    }
                    async $createContributedProfileTerminal(e, t) {
                        const i = (new m.AU).token;
                        let s = await (this._profileProviders.get(e) ? .provideTerminalProfile(i));
                        if (!i.isCancellationRequested) {
                            if (s && !("options" in s) && (s = {
                                    options: s
                                }), !s || !("options" in s)) throw new Error(`No terminal profile options provided for id "${e}"`);
                            "pty" in s.options ? this.createExtensionTerminal(s.options, t) : this.createTerminalFromOptions(s.options, t)
                        }
                    }
                    async $provideLinks(e, t) {
                        const i = this.getTerminalById(e);
                        if (!i) return [];
                        this._terminalLinkCache.delete(e);
                        const s = this._terminalLinkCancellationSource.get(e);
                        s ? .dispose(!0);
                        const o = new m.AU;
                        this._terminalLinkCancellationSource.set(e, o);
                        const r = [],
                            n = {
                                terminal: i.value,
                                line: t
                            },
                            a = [];
                        for (const e of this._linkProviders) a.push(y.jT.withAsyncBody((async t => {
                            o.token.onCancellationRequested((() => t({
                                provider: e,
                                links: []
                            })));
                            const i = await e.provideTerminalLinks(n, o.token) || [];
                            o.token.isCancellationRequested || t({
                                provider: e,
                                links: i
                            })
                        })));
                        const c = await Promise.all(a);
                        if (o.token.isCancellationRequested) return [];
                        const d = new Map;
                        for (const e of c) e && e.links.length > 0 && r.push(...e.links.map((t => {
                            const i = {
                                id: E++,
                                startIndex: t.startIndex,
                                length: t.length,
                                label: t.tooltip
                            };
                            return d.set(i.id, {
                                provider: e.provider,
                                link: t
                            }), i
                        })));
                        return this._terminalLinkCache.set(e, d), r
                    }
                    $activateLink(e, t) {
                        const i = this._terminalLinkCache.get(e) ? .get(t);
                        i && i.provider.handleTerminalLink(i.link)
                    }
                    _onProcessExit(e, t) {
                        this._bufferer.stopBuffering(e), this._terminalProcesses.delete(e), delete this._extensionTerminalAwaitingStart[e];
                        const i = this._terminalProcessDisposables[e];
                        i && (i.dispose(), delete this._terminalProcessDisposables[e]), this._proxy.$sendProcessExit(e, t)
                    }
                    getTerminalById(e) {
                        return this._getTerminalObjectById(this._terminals, e)
                    }
                    getTerminalIdByApiObject(e) {
                        const t = this._terminals.findIndex((t => t.value === e));
                        return t >= 0 ? t : null
                    }
                    _getTerminalObjectById(e, t) {
                        const i = this._getTerminalObjectIndexById(e, t);
                        return null !== i ? e[i] : null
                    }
                    _getTerminalObjectIndexById(e, t) {
                        const i = e.findIndex((e => e._id === t));
                        return i >= 0 ? i : null
                    }
                    getEnvironmentVariableCollection(e) {
                        let t = this._environmentVariableCollections.get(e.identifier.value);
                        return t || (t = this._register(new T), this._setEnvironmentVariableCollection(e.identifier.value, t)), t.getScopedEnvironmentVariableCollection(void 0)
                    }
                    _syncEnvironmentVariableCollection(e, t) {
                        const i = (0, p.Fi)(t.map),
                            s = (0, p.hd)(t.descriptionMap);
                        this._proxy.$setEnvironmentVariableCollection(e, t.persistent, 0 === i.length ? void 0 : i, s)
                    }
                    $initEnvironmentVariableCollections(e) {
                        e.forEach((e => {
                            const t = e[0],
                                i = this._register(new T(e[1]));
                            this._setEnvironmentVariableCollection(t, i)
                        }))
                    }
                    $acceptDefaultProfile(e, t) {
                        const i = this._defaultProfile;
                        this._defaultProfile = e, this._defaultAutomationProfile = t, i ? .path !== e.path && this._onDidChangeShell.fire(e.path)
                    }
                    _setEnvironmentVariableCollection(e, t) {
                        this._environmentVariableCollections.set(e, t), this._register(t.onDidChangeCollection((() => {
                            this._syncEnvironmentVariableCollection(e, t)
                        })))
                    }
                };
            P = (0, s.g)([(0, s.f)(1, x.f7), (0, s.f)(2, c.O)], P);
            class T extends d.JT {
                get persistent() {
                    return this._persistent
                }
                set persistent(e) {
                    this._persistent = e, this._onDidChangeCollection.fire()
                }
                get onDidChangeCollection() {
                    return this._onDidChangeCollection && this._onDidChangeCollection.event
                }
                constructor(e) {
                    super(), this.map = new Map, this.scopedCollections = new Map, this.descriptionMap = new Map, this._persistent = !0, this._onDidChangeCollection = new o.Q5, this.map = new Map(e)
                }
                getScopedEnvironmentVariableCollection(e) {
                    const t = this.getScopeKey(e);
                    let i = this.scopedCollections.get(t);
                    return i || (i = new k(this, e), this.scopedCollections.set(t, i), this._register(i.onDidChangeCollection((() => this._onDidChangeCollection.fire())))), i
                }
                replace(e, t, i, s) {
                    this._setIfDiffers(e, {
                        value: t,
                        type: l.vGG.Replace,
                        options: i ? ? {
                            applyAtProcessCreation: !0
                        },
                        scope: s
                    })
                }
                append(e, t, i, s) {
                    this._setIfDiffers(e, {
                        value: t,
                        type: l.vGG.Append,
                        options: i ? ? {
                            applyAtProcessCreation: !0
                        },
                        scope: s
                    })
                }
                prepend(e, t, i, s) {
                    this._setIfDiffers(e, {
                        value: t,
                        type: l.vGG.Prepend,
                        options: i ? ? {
                            applyAtProcessCreation: !0
                        },
                        scope: s
                    })
                }
                _setIfDiffers(e, t) {
                    if (t.options && !1 === t.options.applyAtProcessCreation && !t.options.applyAtShellIntegration) throw new Error("EnvironmentVariableMutatorOptions must apply at either process creation or shell integration");
                    const i = this.getKey(e, t.scope),
                        s = this.map.get(i),
                        o = t.options ? {
                            applyAtProcessCreation: t.options.applyAtProcessCreation ? ? !1,
                            applyAtShellIntegration: t.options.applyAtShellIntegration ? ? !1
                        } : {
                            applyAtProcessCreation: !0
                        };
                    if (!s || s.value !== t.value || s.type !== t.type || s.options ? .applyAtProcessCreation !== o.applyAtProcessCreation || s.options ? .applyAtShellIntegration !== o.applyAtShellIntegration || s.scope ? .workspaceFolder ? .index !== t.scope ? .workspaceFolder ? .index) {
                        const i = this.getKey(e, t.scope),
                            s = {
                                variable: e,
                                ...t,
                                options: o
                            };
                        this.map.set(i, s), this._onDidChangeCollection.fire()
                    }
                }
                get(e, t) {
                    const i = this.getKey(e, t),
                        s = this.map.get(i);
                    return s ? $(s) : void 0
                }
                getKey(e, t) {
                    const i = this.getScopeKey(t);
                    return i.length ? `${e}:::${i}` : e
                }
                getScopeKey(e) {
                    return this.getWorkspaceKey(e ? .workspaceFolder) ? ? ""
                }
                getWorkspaceKey(e) {
                    return e ? e.uri.toString() : void 0
                }
                getVariableMap(e) {
                    const t = new Map;
                    for (const [i, s] of this.map) this.getScopeKey(s.scope) === this.getScopeKey(e) && t.set(s.variable, $(s));
                    return t
                }
                delete(e, t) {
                    const i = this.getKey(e, t);
                    this.map.delete(i), this._onDidChangeCollection.fire()
                }
                clear(e) {
                    if (e ? .workspaceFolder) {
                        for (const [t, i] of this.map) i.scope ? .workspaceFolder ? .index === e.workspaceFolder.index && this.map.delete(t);
                        this.clearDescription(e)
                    } else this.map.clear(), this.descriptionMap.clear();
                    this._onDidChangeCollection.fire()
                }
                setDescription(e, t) {
                    const i = this.getScopeKey(t),
                        s = this.descriptionMap.get(i);
                    if (!s || s.description !== e) {
                        let s;
                        s = "string" == typeof e ? e : e ? .value.split("\n\n")[0];
                        const o = {
                            description: s,
                            scope: t
                        };
                        this.descriptionMap.set(i, o), this._onDidChangeCollection.fire()
                    }
                }
                getDescription(e) {
                    const t = this.getScopeKey(e);
                    return this.descriptionMap.get(t) ? .description
                }
                clearDescription(e) {
                    const t = this.getScopeKey(e);
                    this.descriptionMap.delete(t)
                }
            }
            class k {
                get persistent() {
                    return this.collection.persistent
                }
                set persistent(e) {
                    this.collection.persistent = e
                }
                get onDidChangeCollection() {
                    return this._onDidChangeCollection && this._onDidChangeCollection.event
                }
                constructor(e, t) {
                    this.collection = e, this.scope = t, this._onDidChangeCollection = new o.Q5
                }
                getScoped(e) {
                    return this.collection.getScopedEnvironmentVariableCollection(e)
                }
                replace(e, t, i) {
                    this.collection.replace(e, t, i, this.scope)
                }
                append(e, t, i) {
                    this.collection.append(e, t, i, this.scope)
                }
                prepend(e, t, i) {
                    this.collection.prepend(e, t, i, this.scope)
                }
                get(e) {
                    return this.collection.get(e, this.scope)
                }
                forEach(e, t) {
                    this.collection.getVariableMap(this.scope).forEach(((i, s) => e.call(t, s, i, this)), this.scope)
                }[Symbol.iterator]() {
                    return this.collection.getVariableMap(this.scope).entries()
                }
                delete(e) {
                    this.collection.delete(e, this.scope), this._onDidChangeCollection.fire(void 0)
                }
                clear() {
                    this.collection.clear(this.scope)
                }
                set description(e) {
                    this.collection.setDescription(e, this.scope)
                }
                get description() {
                    return this.collection.getDescription(this.scope)
                }
            }
            let I = class extends P {
                constructor(e, t) {
                    super(!1, e, t)
                }
                createTerminal(e, t, i) {
                    throw new u.B8
                }
                createTerminalFromOptions(e, t) {
                    throw new u.B8
                }
            };

            function A(e) {
                if (e && "string" != typeof e) return "id" in e ? {
                    id: e.id,
                    color: e.color
                } : e
            }

            function $(e) {
                const t = { ...e
                };
                return delete t.scope, t.options = t.options ? ? void 0, delete t.variable, t
            }
            I = (0, s.g)([(0, s.f)(0, x.f7), (0, s.f)(1, c.O)], I)
        },
        ocTE: (e, t, i) => {
            i.d(t, {
                C: () => m,
                P: () => p
            });
            var s = i("t5wJ"),
                o = i("7NN/"),
                r = i("RVdl"),
                n = i("OYZR"),
                a = i("YrcG"),
                c = i("Ayc8"),
                d = i("DvZ5"),
                l = i("7icl"),
                h = i("naIR"),
                u = i("opu4");
            const p = (0, n.yh)("IExtHostTerminalShellIntegration");
            let m = class extends r.JT {
                constructor(e, t) {
                    super(), this._extHostTerminalService = t, this._activeShellIntegrations = new Map, this._onDidChangeTerminalShellIntegration = new l.Q5, this.onDidChangeTerminalShellIntegration = this._onDidChangeTerminalShellIntegration.event, this._onDidStartTerminalShellExecution = new l.Q5, this.onDidStartTerminalShellExecution = this._onDidStartTerminalShellExecution.event, this._onDidEndTerminalShellExecution = new l.Q5, this.onDidEndTerminalShellExecution = this._onDidEndTerminalShellExecution.event, this._proxy = e.getProxy(a.Tr.MainThreadTerminalShellIntegration), this._register((0, r.OF)((() => {
                        for (const [e, t] of this._activeShellIntegrations) t.dispose();
                        this._activeShellIntegrations.clear()
                    })))
                }
                $shellIntegrationChange(e) {
                    const t = this._extHostTerminalService.getTerminalById(e);
                    if (!t) return;
                    const i = t.value;
                    let s = this._activeShellIntegrations.get(e);
                    s || (s = new g(t.value, this._onDidStartTerminalShellExecution), this._activeShellIntegrations.set(e, s), s.store.add(t.onWillDispose((() => this._activeShellIntegrations.get(e) ? .dispose()))), s.store.add(s.onDidRequestShellExecution((t => this._proxy.$executeCommand(e, t)))), s.store.add(s.onDidRequestEndExecution((e => this._onDidEndTerminalShellExecution.fire(e)))), s.store.add(s.onDidRequestChangeShellIntegration((e => this._onDidChangeTerminalShellIntegration.fire(e)))), t.shellIntegration = s.value), this._onDidChangeTerminalShellIntegration.fire({
                        terminal: i,
                        shellIntegration: s.value
                    })
                }
                $shellExecutionStart(e, t, i, s, o) {
                    this._activeShellIntegrations.has(e) || this.$shellIntegrationChange(e);
                    const r = {
                        value: t,
                        confidence: i,
                        isTrusted: s
                    };
                    this._activeShellIntegrations.get(e) ? .startShellExecution(r, o)
                }
                $shellExecutionEnd(e, t, i, s, o) {
                    const r = {
                        value: t,
                        confidence: i,
                        isTrusted: s
                    };
                    this._activeShellIntegrations.get(e) ? .endShellExecution(r, o)
                }
                $shellExecutionData(e, t) {
                    this._activeShellIntegrations.get(e) ? .emitData(t)
                }
                $cwdChange(e, t) {
                    this._activeShellIntegrations.get(e) ? .setCwd((0, h._9)(t) ? h.ov.revive(t) : t)
                }
                $closeTerminal(e) {
                    this._activeShellIntegrations.get(e) ? .dispose(), this._activeShellIntegrations.delete(e)
                }
            };
            m = (0, s.g)([(0, s.f)(0, c.O), (0, s.f)(1, d.$3)], m);
            class g extends r.JT {
                get currentExecution() {
                    return this._currentExecution
                }
                constructor(e, t) {
                    super(), this._terminal = e, this._onDidStartTerminalShellExecution = t, this._ignoreNextExecution = !1, this.store = this._register(new r.SL), this._onDidRequestChangeShellIntegration = this._register(new l.Q5), this.onDidRequestChangeShellIntegration = this._onDidRequestChangeShellIntegration.event, this._onDidRequestShellExecution = this._register(new l.Q5), this.onDidRequestShellExecution = this._onDidRequestShellExecution.event, this._onDidRequestEndExecution = this._register(new l.Q5), this.onDidRequestEndExecution = this._onDidRequestEndExecution.event;
                    const i = this;
                    this.value = {
                        get cwd() {
                            return i._cwd
                        },
                        executeCommand(e, t) {
                            let s = e;
                            t && (s += ` "${t.map((e=>`${e.replaceAll('"','\\"')}`)).join('" "')}"`), i._onDidRequestShellExecution.fire(s);
                            const r = {
                                    value: s,
                                    confidence: o.I82.High,
                                    isTrusted: !0
                                },
                                n = i.startShellExecution(r, i._cwd, !0).value;
                            return i._ignoreNextExecution = !0, n
                        }
                    }
                }
                startShellExecution(e, t, i) {
                    if (this._ignoreNextExecution && this._currentExecution) this._ignoreNextExecution = !1;
                    else {
                        this._currentExecution && (this._currentExecution.endExecution(void 0), this._onDidRequestEndExecution.fire({
                            terminal: this._terminal,
                            shellIntegration: this.value,
                            execution: this._currentExecution.value,
                            exitCode: void 0
                        }));
                        const s = this._currentExecution = new v(e, t);
                        i ? queueMicrotask((() => this._onDidStartTerminalShellExecution.fire({
                            terminal: this._terminal,
                            shellIntegration: this.value,
                            execution: s.value
                        }))) : this._onDidStartTerminalShellExecution.fire({
                            terminal: this._terminal,
                            shellIntegration: this.value,
                            execution: this._currentExecution.value
                        })
                    }
                    return this._currentExecution
                }
                emitData(e) {
                    this.currentExecution ? .emitData(e)
                }
                endShellExecution(e, t) {
                    this._currentExecution && (this._currentExecution.endExecution(e), this._onDidRequestEndExecution.fire({
                        terminal: this._terminal,
                        shellIntegration: this.value,
                        execution: this._currentExecution.value,
                        exitCode: t
                    }), this._currentExecution = void 0)
                }
                setCwd(e) {
                    let t = !1;
                    h.ov.isUri(this._cwd) ? t = !h.ov.isUri(e) || this._cwd.toString() !== e.toString() : this._cwd !== e && (t = !0), t && (this._cwd = e, this._onDidRequestChangeShellIntegration.fire({
                        terminal: this._terminal,
                        shellIntegration: this.value
                    }))
                }
            }
            class v {
                constructor(e, t) {
                    this._commandLine = e, this.cwd = t, this._ended = !1;
                    const i = this;
                    this.value = {
                        get commandLine() {
                            return i._commandLine
                        },
                        get cwd() {
                            return i.cwd
                        },
                        read: () => i._createDataStream()
                    }
                }
                _createDataStream() {
                    if (!this._dataStream) {
                        if (this._ended) return u.Aq.EMPTY;
                        this._dataStream = new _
                    }
                    return this._dataStream.createIterable()
                }
                emitData(e) {
                    this._dataStream ? .emitData(e)
                }
                endExecution(e) {
                    e && (this._commandLine = e), this._dataStream ? .endExecution(), this._dataStream = void 0, this._ended = !0
                }
            }
            class _ extends r.JT {
                constructor() {
                    super(...arguments), this._emitters = []
                }
                createIterable() {
                    this._barrier || (this._barrier = new u.U8);
                    const e = this._barrier;
                    return new u.Aq((async t => {
                        this._emitters.push(t), await e.wait()
                    }))
                }
                emitData(e) {
                    for (const t of this._emitters) t.emitOne(e)
                }
                endExecution() {
                    this._barrier ? .open(), this._barrier = void 0
                }
            }
        },
        qLp4: (e, t, i) => {
            i.d(t, {
                Hb: () => S,
                SJ: () => D,
                n2: () => b,
                qN: () => C
            });
            var s = i("Aw1u"),
                o = i("Jr0N"),
                r = i("2chr"),
                n = i("V6Y4"),
                a = i("Of1J"),
                c = i("IqsH"),
                d = i("naIR");
            const l = (e, t, i, s) => {
                    let o = t;
                    return {
                        enumerable: !0,
                        configurable: !1,
                        get: () => o,
                        set(t) {
                            if (!i(o, t)) {
                                const i = o;
                                o = t, e.listener ? .(s(t, i))
                            }
                        }
                    }
                },
                h = (e, t) => e === t,
                u = h,
                p = h,
                m = h,
                g = h,
                v = h,
                _ = h,
                f = (e, t) => e.length === t.length && !e.some((e => !t.find((t => e.id === t.id)))),
                y = e => t => ({
                    op: n.NU.SetProp,
                    update: e(t)
                }),
                w = (e, t) => ({
                    range: (() => {
                        let t;
                        const i = y((e => ({
                            range: s.e.lift(c.e6.from(e))
                        })));
                        return {
                            enumerable: !0,
                            configurable: !1,
                            get: () => t,
                            set(s) {
                                var o, r;
                                e.listener ? .({
                                    op: n.NU.DocumentSynced
                                }), (o = t) === (r = s) || o && r && o.isEqual(r) || (t = s, e.listener ? .(i(s)))
                            }
                        }
                    })(),
                    label: l(e, t, u, y((e => ({
                        label: e
                    })))),
                    description: l(e, void 0, p, y((e => ({
                        description: e
                    })))),
                    sortText: l(e, void 0, m, y((e => ({
                        sortText: e
                    })))),
                    canResolveChildren: l(e, !1, _, (e => ({
                        op: n.NU.UpdateCanResolveChildren,
                        state: e
                    }))),
                    busy: l(e, !1, g, y((e => ({
                        busy: e
                    })))),
                    error: l(e, void 0, v, y((e => ({
                        error: c.W5.fromStrict(e) || null
                    })))),
                    tags: l(e, [], f, ((e, t) => ({
                        op: n.NU.SetTags,
                        new: e.map(c.Ld.from),
                        old: t.map(c.Ld.from)
                    })))
                }),
                x = e => {
                    const t = r.u0.fromString(e.extId),
                        i = new D(t.controllerId, t.localId, e.label, d.ov.revive(e.uri) || void 0);
                    return i.range = c.e6.to(e.range || void 0), i.description = e.description || void 0, i.sortText = e.sortText || void 0, i.tags = e.tags.map((e => c.Ld.to({
                        id: (0, a._v)(e).tagId
                    }))), i
                },
                b = e => {
                    let t;
                    for (const i of e.tests) {
                        const e = x(i.item);
                        (0, o.l)(e).parent = t, t = e
                    }
                    return t
                };
            class D {
                constructor(e, t, i, s) {
                    if (t.includes(r.nc.Delimiter)) throw new Error(`Test IDs may not include the ${JSON.stringify(t)} symbol`);
                    const a = (0, o.b)(this, e);
                    Object.defineProperties(this, {
                        id: {
                            value: t,
                            enumerable: !0,
                            writable: !1
                        },
                        uri: {
                            value: s,
                            enumerable: !0,
                            writable: !1
                        },
                        parent: {
                            enumerable: !1,
                            get: () => a.parent instanceof C ? void 0 : a.parent
                        },
                        children: {
                            value: (0, n.Hx)(a, o.l, D),
                            enumerable: !0,
                            writable: !1
                        },
                        ...w(a, i)
                    })
                }
            }
            class C extends D {
                constructor(e, t) {
                    super(e, e, t, void 0), this._isRoot = !0
                }
            }
            class S extends n.$z {
                constructor(e, t, i) {
                    super({
                        controllerId: e,
                        getDocumentVersion: e => e && i.getDocument(e) ? .version,
                        getApiFor: o.l,
                        getChildren: e => e.children,
                        root: new C(e, t),
                        toITestItem: c.UK.from
                    })
                }
            }
        },
        "3BDB": (e, t, i) => {
            i.d(t, {
                Qp: () => N,
                s7: () => F
            });
            var s = i("t5wJ"),
                o = i("opu4"),
                r = i("jxI3"),
                n = i("rJtg"),
                a = i("7icl"),
                c = i("G9Uv"),
                d = i("6tPK"),
                l = i("RVdl"),
                h = i("9HFd"),
                u = i("K30K"),
                p = i("R7Dl"),
                m = i("OYZR"),
                g = i("Vvlp"),
                v = i("YrcG"),
                _ = i("0f12"),
                f = i("l6bu"),
                y = i("Ayc8"),
                w = i("qLp4"),
                x = i("IqsH"),
                b = i("7NN/"),
                D = (i("yT68"), i("yFKF")),
                C = i("Of1J");
            const S = "vs/workbench/contrib/testing/common/constants";
            var E, P, T, k;
            ! function(e) {
                e.ViewletId = "workbench.view.extension.test", e.ExplorerViewId = "workbench.view.testing", e.OutputPeekContributionId = "editor.contrib.testingOutputPeek", e.DecorationsContributionId = "editor.contrib.testingDecorations", e.CoverageDecorationsContributionId = "editor.contrib.coverageDecorations", e.CoverageViewId = "workbench.view.testCoverage", e.ResultsPanelId = "workbench.panel.testResults", e.ResultsViewId = "workbench.panel.testResults.view", e.MessageLanguageId = "vscodeInternalTestMessage"
            }(E || (E = {})),
            function(e) {
                e.List = "list", e.Tree = "true"
            }(P || (P = {})),
            function(e) {
                e.ByLocation = "location", e.ByStatus = "status", e.ByDuration = "duration"
            }(T || (T = {})), C.ZM.Errored, (0, D.C$)(S, 0, "Errored"), C.ZM.Failed, (0, D.C$)(S, 1, "Failed"), C.ZM.Passed, (0, D.C$)(S, 2, "Passed"), C.ZM.Queued, (0, D.C$)(S, 3, "Queued"), C.ZM.Running, (0, D.C$)(S, 4, "Running"), C.ZM.Skipped, (0, D.C$)(S, 5, "Skipped"), C.ZM.Unset, (0, D.C$)(S, 6, "Not yet run"), C.Fj.Debug, (0, D.C$)(S, 8, "Debug"), C.Fj.Run, (0, D.C$)(S, 9, "Run"), C.Fj.Coverage, (0, D.C$)(S, 10, "Coverage"),
                function(e) {
                    e.CancelTestRefreshAction = "testing.cancelTestRefresh", e.CancelTestRunAction = "testing.cancelRun", e.ClearTestResultsAction = "testing.clearTestResults", e.CollapseAllAction = "testing.collapseAll", e.ConfigureTestProfilesAction = "testing.configureProfile", e.ContinousRunUsingForTest = "testing.continuousRunUsingForTest", e.CoverageAtCursor = "testing.coverageAtCursor", e.CoverageByUri = "testing.coverage.uri", e.CoverageClear = "testing.coverage.close", e.CoverageCurrentFile = "testing.coverageCurrentFile", e.CoverageFilterToTest = "testing.coverageFilterToTest", e.CoverageFilterToTestInEditor = "testing.coverageFilterToTestInEditor", e.CoverageLastRun = "testing.coverageLastRun", e.CoverageSelectedAction = "testing.coverageSelected", e.CoverageToggleToolbar = "testing.coverageToggleToolbar", e.CoverageViewChangeSorting = "testing.coverageViewChangeSorting", e.DebugAction = "testing.debug", e.DebugAllAction = "testing.debugAll", e.DebugAtCursor = "testing.debugAtCursor", e.DebugByUri = "testing.debug.uri", e.DebugCurrentFile = "testing.debugCurrentFile", e.DebugFailedTests = "testing.debugFailTests", e.DebugLastRun = "testing.debugLastRun", e.DebugSelectedAction = "testing.debugSelected", e.FilterAction = "workbench.actions.treeView.testExplorer.filter", e.GetExplorerSelection = "_testing.getExplorerSelection", e.GetSelectedProfiles = "testing.getSelectedProfiles", e.GoToTest = "testing.editFocusedTest", e.HideTestAction = "testing.hideTest", e.OpenCoverage = "testing.openCoverage", e.OpenOutputPeek = "testing.openOutputPeek", e.RefreshTestsAction = "testing.refreshTests", e.ReRunFailedTests = "testing.reRunFailTests", e.ReRunLastRun = "testing.reRunLastRun", e.RunAction = "testing.run", e.RunAllAction = "testing.runAll", e.RunAllWithCoverageAction = "testing.coverageAll", e.RunAtCursor = "testing.runAtCursor", e.RunByUri = "testing.run.uri", e.RunCurrentFile = "testing.runCurrentFile", e.RunSelectedAction = "testing.runSelected", e.RunUsingProfileAction = "testing.runUsing", e.RunWithCoverageAction = "testing.coverage", e.SearchForTestExtension = "testing.searchForTestExtension", e.SelectDefaultTestProfiles = "testing.selectDefaultTestProfiles", e.ShowMostRecentOutputAction = "testing.showMostRecentOutput", e.StartContinousRun = "testing.startContinuousRun", e.StopContinousRun = "testing.stopContinuousRun", e.TestingSortByDurationAction = "testing.sortByDuration", e.TestingSortByLocationAction = "testing.sortByLocation", e.TestingSortByStatusAction = "testing.sortByStatus", e.TestingViewAsListAction = "testing.viewAsList", e.TestingViewAsTreeAction = "testing.viewAsTree", e.ToggleContinousRunForTest = "testing.toggleContinuousRunForTest", e.ToggleInlineTestOutput = "testing.toggleInlineTestOutput", e.UnhideAllTestsAction = "testing.unhideAllTests", e.UnhideTestAction = "testing.unhideTest"
                }(k || (k = {}));
            var I = i("2chr"),
                A = i("V6Y4"),
                $ = i("LE1I");
            let R = 0;
            const H = new WeakMap,
                F = (0, m.yh)("IExtHostTesting");
            let N = class extends l.JT {
                constructor(e, t, i, s) {
                    super(), this.logService = t, this.commands = i, this.editors = s, this.resultsChangedEmitter = this._register(new a.Q5), this.controllers = new Map, this.defaultProfilesChangedEmitter = this._register(new a.Q5), this.followupProviders = new Set, this.testFollowups = new Map, this.onResultsChanged = this.resultsChangedEmitter.event, this.results = [], this.proxy = e.getProxy(v.Tr.MainThreadTesting), this.observer = new z(this.proxy), this.runTracker = new O(this.proxy, t), i.registerArgumentProcessor({
                        processArgument: e => {
                            switch (e ? .$mid) {
                                case h.m.TestItemContext:
                                    {
                                        const t = e,
                                            i = t.tests[t.tests.length - 1].item.extId,
                                            s = this.controllers.get(I.u0.root(i));
                                        return s ? .collection.tree.get(i) ? .actual ? ? (0, w.n2)(e)
                                    }
                                case h.m.TestMessageMenuArgs:
                                    {
                                        const {
                                            test: t,
                                            message: i
                                        } = e,
                                        s = t.item.extId;
                                        return {
                                            test: this.controllers.get(I.u0.root(s)) ? .collection.tree.get(s) ? .actual ? ? (0, w.n2)({
                                                $mid: h.m.TestItemContext,
                                                tests: [t]
                                            }),
                                            message: x.lt.to(i)
                                        }
                                    }
                                default:
                                    return e
                            }
                        }
                    }), i.registerCommand(!1, "testing.getExplorerSelection", (async () => {
                        const e = await i.executeCommand(k.GetExplorerSelection),
                            t = e => {
                                const t = this.controllers.get(I.u0.root(e));
                                if (t) return I.u0.isRoot(e) ? t.controller : t.collection.tree.get(e) ? .actual
                            };
                        return {
                            include: e ? .include.map(t).filter(u.$K) || [],
                            exclude: e ? .exclude.map(t).filter(u.$K) || []
                        }
                    }))
                }
                createTestController(e, t, i, s) {
                    if (this.controllers.has(t)) throw new Error(`Attempt to insert a duplicate controller with ID "${t}"`);
                    const o = new l.SL,
                        r = o.add(new w.Hb(t, i, this.editors));
                    r.root.label = i;
                    const n = new Map,
                        a = new Set,
                        c = this.proxy,
                        h = {
                            items: r.root.children,
                            get label() {
                                return i
                            },
                            set label(e) {
                                i = e, r.root.label = e, c.$updateController(t, {
                                    label: i
                                })
                            },
                            get refreshHandler() {
                                return s
                            },
                            set refreshHandler(e) {
                                s = e, c.$updateController(t, {
                                    canRefresh: !!e
                                })
                            },
                            get id() {
                                return t
                            },
                            createRunProfile: (e, i, s, o, r, c) => {
                                let l = (0, d.vp)(e);
                                for (; n.has(l);) l++;
                                return new q(this.proxy, n, a, this.defaultProfilesChangedEmitter.event, t, l, e, i, s, o, r, c)
                            },
                            createTestItem: (e, i, s) => new w.SJ(t, e, i, s),
                            createTestRun: (i, s, o = !0) => this.runTracker.createTestRun(e, t, r, i, s, o),
                            invalidateTestResults: e => {
                                if (void 0 === e) this.proxy.$markTestRetired(void 0);
                                else {
                                    const i = e instanceof Array ? e : [e];
                                    this.proxy.$markTestRetired(i.map((e => I.u0.fromExtHostTestItem(e, t).toString())))
                                }
                            },
                            set resolveHandler(e) {
                                r.resolveHandler = e
                            },
                            get resolveHandler() {
                                return r.resolveHandler
                            },
                            dispose: () => {
                                o.dispose()
                            }
                        };
                    c.$registerTestController(t, i, !!s), o.add((0, l.OF)((() => c.$unregisterTestController(t))));
                    const u = {
                        controller: h,
                        collection: r,
                        profiles: n,
                        extension: e,
                        activeProfiles: a
                    };
                    return this.controllers.set(t, u), o.add((0, l.OF)((() => this.controllers.delete(t)))), o.add(r.onDidGenerateDiff((e => c.$publishDiff(t, e.map(C.cZ.serialize))))), h
                }
                createTestObserver() {
                    return this.observer.checkout()
                }
                async runTests(e, t = n.Ts.None) {
                    const i = U(e);
                    if (!i) throw new Error("The request passed to `vscode.test.runTests` must include a profile");
                    const s = this.controllers.get(i.controllerId);
                    if (!s) throw new Error("Controller not found");
                    await this.proxy.$runTests({
                        preserveFocus: e.preserveFocus ? ? !0,
                        group: K[i.kind],
                        targets: [{
                            testIds: e.include ? .map((e => I.u0.fromExtHostTestItem(e, s.collection.root.id).toString())) ? ? [s.collection.root.id],
                            profileId: i.profileId,
                            controllerId: i.controllerId
                        }],
                        exclude: e.exclude ? .map((e => e.id))
                    }, t)
                }
                registerTestFollowupProvider(e) {
                    return this.followupProviders.add(e), {
                        dispose: () => {
                            this.followupProviders.delete(e)
                        }
                    }
                }
                $syncTests() {
                    for (const {
                            collection: e
                        } of this.controllers.values()) e.flushDiff();
                    return Promise.resolve()
                }
                async $getCoverageDetails(e, t, i) {
                    const s = await this.runTracker.getCoverageDetails(e, t, i);
                    return s ? .map(x.xC.fromDetails)
                }
                async $disposeRun(e) {
                    this.runTracker.disposeTestRun(e)
                }
                $configureRunProfile(e, t) {
                    this.controllers.get(e) ? .profiles.get(t) ? .configureHandler ? .()
                }
                $setDefaultRunProfiles(e) {
                    const t = new Map;
                    for (const [i, s] of Object.entries(e)) {
                        const e = this.controllers.get(i);
                        if (!e) continue;
                        const o = new Map,
                            r = s.filter((t => !e.activeProfiles.has(t))),
                            n = [...e.activeProfiles].filter((e => !s.includes(e)));
                        for (const t of r) o.set(t, !0), e.activeProfiles.add(t);
                        for (const t of n) o.set(t, !1), e.activeProfiles.delete(t);
                        o.size && t.set(i, o)
                    }
                    this.defaultProfilesChangedEmitter.fire(t)
                }
                async $refreshTests(e, t) {
                    await (this.controllers.get(e) ? .controller.refreshHandler ? .(t))
                }
                $publishTestResults(e) {
                    this.results = Object.freeze(e.map((e => {
                        const t = x.P1.to(e);
                        return H.set(t, e.id), t
                    })).concat(this.results).sort(((e, t) => t.completedAt - e.completedAt)).slice(0, 32)), this.resultsChangedEmitter.fire()
                }
                async $expandTest(e, t) {
                    const i = this.controllers.get(I.u0.fromString(e).controllerId) ? .collection;
                    i && (await i.expand(e, t < 0 ? 1 / 0 : t), i.flushDiff())
                }
                $acceptDiff(e) {
                    this.observer.applyDiff(e.map((e => C.cZ.deserialize({
                        asCanonicalUri: e => e
                    }, e))))
                }
                async $runControllerTests(e, t) {
                    return Promise.all(e.map((e => this.runControllerTestRequest(e, !1, t))))
                }
                async $startContinuousRun(e, t) {
                    const i = new n.AU(t),
                        s = await Promise.all(e.map((e => this.runControllerTestRequest(e, !0, i.token))));
                    return t.isCancellationRequested || s.some((e => e.error)) || await new Promise((e => t.onCancellationRequested(e))), i.dispose(!0), s
                }
                async $provideTestFollowups(e, t) {
                    const i = this.results.find((t => H.get(t) === e.resultId)),
                        s = i && function(e, t) {
                            for (let i = 0; i < e.path.length; i++) {
                                const s = t.find((t => t.id === e.path[i]));
                                if (!s) return;
                                if (i === e.path.length - 1) return s;
                                t = s.children
                            }
                        }(I.u0.fromString(e.extId), i ? .results);
                    if (!s) return [];
                    let o = [];
                    return await Promise.all([...this.followupProviders].map((async r => {
                        try {
                            const n = await r.provideFollowup(i, s, e.taskIndex, e.messageIndex, t);
                            n && (o = o.concat(n))
                        } catch (e) {
                            this.logService.error("Error thrown while providing followup for test message", e)
                        }
                    }))), t.isCancellationRequested ? [] : o.map((e => {
                        const t = R++;
                        return this.testFollowups.set(t, e), {
                            title: e.title,
                            id: t
                        }
                    }))
                }
                $disposeTestFollowups(e) {
                    for (const t of e) this.testFollowups.delete(t)
                }
                $executeTestFollowup(e) {
                    const t = this.testFollowups.get(e);
                    return t ? this.commands.executeCommand(t.command, ...t.arguments || []) : Promise.resolve()
                }
                $cancelExtensionTestRun(e) {
                    void 0 === e ? this.runTracker.cancelAllRuns() : this.runTracker.cancelRunById(e)
                }
                getMetadataForRun(e) {
                    for (const t of this.runTracker.trackers) {
                        const i = t.getTaskIdForRun(e);
                        if (i) return {
                            taskId: i,
                            runId: t.id
                        }
                    }
                }
                async runControllerTestRequest(e, t, i) {
                    const s = this.controllers.get(e.controllerId);
                    if (!s) return {};
                    const {
                        collection: o,
                        profiles: r,
                        extension: n
                    } = s, c = r.get(e.profileId);
                    if (!c) return {};
                    const d = e.testIds.map((e => o.tree.get(e))).filter(u.$K),
                        l = e.excludeExtIds.map((e => s.collection.tree.get(e))).filter(u.$K).filter((e => d.some((t => t.fullId.compare(e.fullId) === I.Y5.IsChild))));
                    if (!d.length) return {};
                    const h = new b.$hL(d.some((e => e.actual instanceof w.qN)) ? void 0 : d.map((e => e.actual)), l.map((e => e.actual)), c, t),
                        p = (0, C.Gc)(e) && this.runTracker.prepareForMainThreadTestRun(n, h, V.fromInternal(e, s.collection), c, i);
                    try {
                        return await c.runHandler(h, i), {}
                    } catch (e) {
                        return {
                            error: String(e)
                        }
                    } finally {
                        p && p.hasRunningTasks && !i.isCancellationRequested && await a.ju.toPromise(p.onEnd)
                    }
                }
            };
            var M;
            N = (0, s.g)([(0, s.f)(0, y.O), (0, s.f)(1, g.V), (0, s.f)(2, _.f7), (0, s.f)(3, f.T)], N),
                function(e) {
                    e[e.Running = 0] = "Running", e[e.Cancelling = 1] = "Cancelling", e[e.Ended = 2] = "Ended"
                }(M || (M = {}));
            class L extends l.JT {
                get hasRunningTasks() {
                    return this.running > 0
                }
                get id() {
                    return this.dto.id
                }
                constructor(e, t, i, s, r, c) {
                    super(), this.dto = e, this.proxy = t, this.logService = i, this.profile = s, this.extension = r, this.state = M.Running, this.running = 0, this.tasks = new Map, this.sharedTestIds = new Set, this.endEmitter = this._register(new a.Q5), this.publishedCoverage = new Map, this.onEnd = this.endEmitter.event, this.cts = this._register(new n.AU(c));
                    const d = this._register(new o.pY((() => this.forciblyEndTasks()), 1e4));
                    this._register(this.cts.token.onCancellationRequested((() => d.schedule())));
                    const h = new a.Q5;
                    this.onDidDispose = h.event, this._register((0, l.OF)((() => {
                        h.fire(), h.dispose()
                    })))
                }
                getTaskIdForRun(e) {
                    for (const [t, {
                            run: i
                        }] of this.tasks)
                        if (i === e) return t
                }
                cancel() {
                    this.state === M.Running ? (this.cts.cancel(), this.state = M.Cancelling) : this.state === M.Cancelling && this.forciblyEndTasks()
                }
                async getCoverageDetails(e, t, i) {
                    const [, s] = I.u0.fromString(e).path, o = this.publishedCoverage.get(e);
                    if (!o) return [];
                    const {
                        report: r,
                        extIds: n
                    } = o, a = this.tasks.get(s);
                    if (!a) throw new Error("unreachable: run task was not found");
                    let c;
                    if (t && r instanceof b.XuI) {
                        const e = n.indexOf(t);
                        if (-1 === e) return [];
                        c = r.fromTests[e]
                    }
                    const d = c ? this.profile ? .loadDetailedCoverageForTest ? .(a.run, r, c, i) : this.profile ? .loadDetailedCoverage ? .(a.run, r, i);
                    return await d ? ? []
                }
                createRun(e) {
                    const t = this.dto.id,
                        i = this.dto.controllerId,
                        s = (0, p.R)(),
                        o = e => (t, ...i) => {
                            a ? this.logService.warn(`Setting the state of test "${t.id}" is a no-op after the run ends.`) : (this.ensureTestIsKnown(t), e(t, ...i))
                        },
                        n = (e, o) => {
                            const r = o instanceof Array ? o.map(x.lt.from) : [x.lt.from(o)];
                            if (e.uri && e.range) {
                                const t = {
                                    range: x.e6.from(e.range),
                                    uri: e.uri
                                };
                                for (const e of r) e.location = e.location || t
                            }
                            this.proxy.$appendTestMessagesInRun(t, s, I.u0.fromExtHostTestItem(e, i).toString(), r)
                        };
                    let a = !1;
                    const c = {
                        isPersisted: this.dto.isPersisted,
                        token: this.cts.token,
                        name: e,
                        onDidDispose: this.onDidDispose,
                        addCoverage: e => {
                            if (a) return;
                            const o = e instanceof b.XuI ? e.fromTests : [];
                            if (o.length) {
                                (0, $.H5)(this.extension, "attributableCoverage");
                                for (const e of o) this.ensureTestIsKnown(e)
                            }
                            const r = e.uri.toString(),
                                n = new I.u0([t, s, r]).toString();
                            this.publishedCoverage.set(n, {
                                report: e,
                                extIds: o.map((e => I.u0.fromExtHostTestItem(e, i).toString()))
                            }), this.proxy.$appendCoverage(t, s, x.xC.fromFile(i, n, e))
                        },
                        enqueued: o((e => {
                            this.proxy.$updateTestStateInRun(t, s, I.u0.fromExtHostTestItem(e, i).toString(), C.ZM.Queued)
                        })),
                        skipped: o((e => {
                            this.proxy.$updateTestStateInRun(t, s, I.u0.fromExtHostTestItem(e, i).toString(), C.ZM.Skipped)
                        })),
                        started: o((e => {
                            this.proxy.$updateTestStateInRun(t, s, I.u0.fromExtHostTestItem(e, i).toString(), C.ZM.Running)
                        })),
                        errored: o(((e, o, r) => {
                            n(e, o), this.proxy.$updateTestStateInRun(t, s, I.u0.fromExtHostTestItem(e, i).toString(), C.ZM.Errored, r)
                        })),
                        failed: o(((e, o, r) => {
                            n(e, o), this.proxy.$updateTestStateInRun(t, s, I.u0.fromExtHostTestItem(e, i).toString(), C.ZM.Failed, r)
                        })),
                        passed: o(((e, i) => {
                            this.proxy.$updateTestStateInRun(t, s, I.u0.fromExtHostTestItem(e, this.dto.controllerId).toString(), C.ZM.Passed, i)
                        })),
                        appendOutput: (e, o, n) => {
                            a || (n && this.ensureTestIsKnown(n), this.proxy.$appendOutputToRun(t, s, r.KN.fromString(e), o && x.xh.from(o), n && I.u0.fromExtHostTestItem(n, i).toString()))
                        },
                        end: () => {
                            a || (a = !0, this.proxy.$finishedTestRunTask(t, s), --this.running || this.markEnded())
                        }
                    };
                    return this.running++, this.tasks.set(s, {
                        run: c
                    }), this.proxy.$startedTestRunTask(t, {
                        id: s,
                        name: e,
                        running: !0
                    }), c
                }
                forciblyEndTasks() {
                    for (const {
                            run: e
                        } of this.tasks.values()) e.end()
                }
                markEnded() {
                    this.state !== M.Ended && (this.state = M.Ended, this.endEmitter.fire())
                }
                ensureTestIsKnown(e) {
                    if (!(e instanceof w.SJ)) throw new A.Mh(e.id);
                    if (this.sharedTestIds.has(I.u0.fromExtHostTestItem(e, this.dto.controllerId).toString())) return;
                    const t = [],
                        i = this.dto.colllection.root;
                    for (;;) {
                        const s = x.UK.from(e);
                        if (t.unshift(s), this.sharedTestIds.has(s.extId)) break;
                        if (this.sharedTestIds.add(s.extId), e === i) break;
                        e = e.parent || i
                    }
                    this.proxy.$addTestsToRun(this.dto.controllerId, this.dto.id, t)
                }
                dispose() {
                    this.markEnded(), super.dispose()
                }
            }
            class O {
                get trackers() {
                    return this.tracked.values()
                }
                constructor(e, t) {
                    this.proxy = e, this.logService = t, this.tracked = new Map, this.trackedById = new Map
                }
                getCoverageDetails(e, t, i) {
                    const s = I.u0.root(e);
                    return this.trackedById.get(s) ? .getCoverageDetails(e, t, i) || []
                }
                disposeTestRun(e) {
                    this.trackedById.get(e) ? .dispose(), this.trackedById.delete(e);
                    for (const [t, {
                            id: i
                        }] of this.tracked) i === e && this.tracked.delete(t)
                }
                prepareForMainThreadTestRun(e, t, i, s, o) {
                    return this.getTracker(t, i, s, e, o)
                }
                cancelRunById(e) {
                    this.trackedById.get(e) ? .cancel()
                }
                cancelAllRuns() {
                    for (const e of this.tracked.values()) e.cancel()
                }
                createTestRun(e, t, i, s, o, r) {
                    const n = this.tracked.get(s);
                    if (n) return n.createRun(o);
                    const c = V.fromPublic(t, i, s, r),
                        d = U(s);
                    this.proxy.$startedExtensionTestRun({
                        controllerId: t,
                        continuous: !!s.continuous,
                        profile: d && {
                            group: K[d.kind],
                            id: d.profileId
                        },
                        exclude: s.exclude ? .map((e => I.u0.fromExtHostTestItem(e, i.root.id).toString())) ? ? [],
                        id: c.id,
                        include: s.include ? .map((e => I.u0.fromExtHostTestItem(e, i.root.id).toString())) ? ? [i.root.id],
                        preserveFocus: s.preserveFocus ? ? !0,
                        persist: r
                    });
                    const l = this.getTracker(s, c, s.profile, e);
                    return a.ju.once(l.onEnd)((() => {
                        this.proxy.$finishedExtensionTestRun(c.id)
                    })), l.createRun(o)
                }
                getTracker(e, t, i, s, o) {
                    const r = new L(t, this.proxy, this.logService, i, s, o);
                    return this.tracked.set(e, r), this.trackedById.set(r.id, r), r
                }
            }
            const U = e => {
                if (e.profile) {
                    if (!(e.profile instanceof q)) throw new Error("TestRunRequest.profile is not an instance created from TestController.createRunProfile");
                    return e.profile
                }
            };
            class V {
                static fromPublic(e, t, i, s) {
                    return new V(e, (0, p.R)(), s, t)
                }
                static fromInternal(e, t) {
                    return new V(e.controllerId, e.runId, !0, t)
                }
                constructor(e, t, i, s) {
                    this.controllerId = e, this.id = t, this.isPersisted = i, this.colllection = s
                }
            }
            class W {
                get isEmpty() {
                    return 0 === this.added.size && 0 === this.removed.size && 0 === this.updated.size
                }
                constructor(e) {
                    this.emitter = e, this.added = new Set, this.updated = new Set, this.removed = new Set, this.alreadyRemoved = new Set
                }
                add(e) {
                    this.added.add(e)
                }
                update(e) {
                    Object.assign(e.revived, x.UK.toPlain(e.item)), this.added.has(e) || this.updated.add(e)
                }
                remove(e) {
                    if (this.added.has(e)) return void this.added.delete(e);
                    this.updated.delete(e);
                    const t = I.u0.parentId(e.item.extId);
                    t && this.alreadyRemoved.has(t.toString()) ? this.alreadyRemoved.add(e.item.extId) : this.removed.add(e)
                }
                getChangeEvent() {
                    const {
                        added: e,
                        updated: t,
                        removed: i
                    } = this;
                    return {
                        get added() {
                            return [...e].map((e => e.revived))
                        },
                        get updated() {
                            return [...t].map((e => e.revived))
                        },
                        get removed() {
                            return [...i].map((e => e.revived))
                        }
                    }
                }
                complete() {
                    this.isEmpty || this.emitter.fire(this.getChangeEvent())
                }
            }
            class B extends C.oc {
                constructor() {
                    super(...arguments), this.changeEmitter = new a.Q5, this.onDidChangeTests = this.changeEmitter.event
                }
                get rootTests() {
                    return this.roots
                }
                getMirroredTestDataById(e) {
                    return this.items.get(e)
                }
                getMirroredTestDataByReference(e) {
                    return this.items.get(e.id)
                }
                createItem(e, t) {
                    return { ...e,
                        revived: x.UK.toPlain(e.item),
                        depth: t ? t.depth + 1 : 0,
                        children: new Set
                    }
                }
                createChangeCollector() {
                    return new W(this.changeEmitter)
                }
            }
            class z {
                constructor(e) {
                    this.proxy = e
                }
                checkout() {
                    this.current || (this.current = this.createObserverData());
                    const e = this.current;
                    return e.observers++, {
                        onDidChangeTest: e.tests.onDidChangeTests,
                        get tests() {
                            return [...e.tests.rootTests].map((e => e.revived))
                        },
                        dispose: (0, c.M)((() => {
                            0 == --e.observers && (this.proxy.$unsubscribeFromDiffs(), this.current = void 0)
                        }))
                    }
                }
                getMirroredTestDataByReference(e) {
                    return this.current ? .tests.getMirroredTestDataByReference(e)
                }
                applyDiff(e) {
                    this.current ? .tests.apply(e)
                }
                createObserverData() {
                    const e = new B({
                        asCanonicalUri: e => e
                    });
                    return this.proxy.$subscribeToDiffs(), {
                        observers: 0,
                        tests: e
                    }
                }
            }
            const j = (e, t, i, s) => {
                i ? Object.assign(i, s) : t.$updateTestRunConfig(e.controllerId, e.profileId, s)
            };
            class q {#
                e;#
                c;#
                d;#
                l;#
                h;
                get label() {
                    return this._label
                }
                set label(e) {
                    e !== this._label && (this._label = e, j(this, this.#e, this.#l, {
                        label: e
                    }))
                }
                get supportsContinuousRun() {
                    return this._supportsContinuousRun
                }
                set supportsContinuousRun(e) {
                    e !== this._supportsContinuousRun && (this._supportsContinuousRun = e, j(this, this.#e, this.#l, {
                        supportsContinuousRun: e
                    }))
                }
                get isDefault() {
                    return this.#c.has(this.profileId)
                }
                set isDefault(e) {
                    e !== this.isDefault && (e ? this.#c.add(this.profileId) : this.#c.delete(this.profileId), j(this, this.#e, this.#l, {
                        isDefault: e
                    }))
                }
                get tag() {
                    return this._tag
                }
                set tag(e) {
                    e ? .id !== this._tag ? .id && (this._tag = e, j(this, this.#e, this.#l, {
                        tag: e ? x.Ld.namespace(this.controllerId, e.id) : null
                    }))
                }
                get configureHandler() {
                    return this._configureHandler
                }
                set configureHandler(e) {
                    e !== this._configureHandler && (this._configureHandler = e, j(this, this.#e, this.#l, {
                        hasConfigurationHandler: !!e
                    }))
                }
                get onDidChangeDefault() {
                    return a.ju.chain(this.#d, (e => e.map((e => e.get(this.controllerId) ? .get(this.profileId))).filter(u.$K)))
                }
                constructor(e, t, i, s, o, r, n, a, c, d = !1, l = undefined, h = !1) {
                    this.controllerId = o, this.profileId = r, this._label = n, this.kind = a, this.runHandler = c, this._tag = l, this._supportsContinuousRun = h, this.#e = e, this.#h = t, this.#c = i, this.#d = s, t.set(r, this);
                    const u = K[a];
                    if ("number" != typeof u) throw new Error(`Unknown TestRunProfile.group ${a}`);
                    d && i.add(r), this.#l = {
                        profileId: r,
                        controllerId: o,
                        tag: l ? x.Ld.namespace(this.controllerId, l.id) : null,
                        label: n,
                        group: u,
                        isDefault: d,
                        hasConfigurationHandler: !1,
                        supportsContinuousRun: h
                    }, queueMicrotask((() => {
                        this.#l && (this.#e.$publishTestRunProfile(this.#l), this.#l = void 0)
                    }))
                }
                dispose() {
                    this.#h ? .delete(this.profileId) && (this.#h = void 0, this.#e.$removeTestProfile(this.controllerId, this.profileId)), this.#l = void 0
                }
            }
            const K = {
                [b.InX.Coverage]: C.Fj.Coverage,
                [b.InX.Debug]: C.Fj.Debug,
                [b.InX.Run]: C.Fj.Run
            }
        },
        "4FWJ": (e, t, i) => {
            i.d(t, {
                TE: () => c,
                aQ: () => h
            });
            var s = i("/hu5"),
                o = i("PUdK"),
                r = i("La+/"),
                n = i("IqsH"),
                a = i("7NN/");
            class c {
                static {
                    this._Keys = new r.R("TextEditorDecorationType")
                }
                constructor(e, t, i) {
                    const s = c._Keys.nextId();
                    e.$registerTextEditorDecorationType(t.identifier, s, n.aw.from(i)), this.value = Object.freeze({
                        key: s,
                        dispose() {
                            e.$removeTextEditorDecorationType(s)
                        }
                    })
                }
            }
            class d {
                constructor(e, t) {
                    this._collectedEdits = [], this._setEndOfLine = void 0, this._finalized = !1, this._document = e, this._documentVersionId = e.version, this._undoStopBefore = t.undoStopBefore, this._undoStopAfter = t.undoStopAfter
                }
                finalize() {
                    return this._finalized = !0, {
                        documentVersionId: this._documentVersionId,
                        edits: this._collectedEdits,
                        setEndOfLine: this._setEndOfLine,
                        undoStopBefore: this._undoStopBefore,
                        undoStopAfter: this._undoStopAfter
                    }
                }
                _throwIfFinalized() {
                    if (this._finalized) throw new Error("Edit is only valid while callback runs")
                }
                replace(e, t) {
                    this._throwIfFinalized();
                    let i = null;
                    if (e instanceof a.Lyo) i = new a.e6w(e, e);
                    else {
                        if (!(e instanceof a.e6w)) throw new Error("Unrecognized location");
                        i = e
                    }
                    this._pushEdit(i, t, !1)
                }
                insert(e, t) {
                    this._throwIfFinalized(), this._pushEdit(new a.e6w(e, e), t, !0)
                }
                delete(e) {
                    this._throwIfFinalized();
                    let t = null;
                    if (!(e instanceof a.e6w)) throw new Error("Unrecognized location");
                    t = e, this._pushEdit(t, null, !0)
                }
                _pushEdit(e, t, i) {
                    const s = this._document.validateRange(e);
                    this._collectedEdits.push({
                        range: s,
                        text: t,
                        forceMoveMarkers: i
                    })
                }
                setEndOfLine(e) {
                    if (this._throwIfFinalized(), e !== a.b6q.LF && e !== a.b6q.CRLF) throw (0, o.b1)("endOfLine");
                    this._setEndOfLine = e
                }
            }
            class l {
                constructor(e, t, i, s) {
                    this._proxy = e, this._id = t, this._accept(i), this._logService = s;
                    const o = this;
                    this.value = {
                        get tabSize() {
                            return o._tabSize
                        },
                        set tabSize(e) {
                            o._setTabSize(e)
                        },
                        get indentSize() {
                            return o._indentSize
                        },
                        set indentSize(e) {
                            o._setIndentSize(e)
                        },
                        get insertSpaces() {
                            return o._insertSpaces
                        },
                        set insertSpaces(e) {
                            o._setInsertSpaces(e)
                        },
                        get cursorStyle() {
                            return o._cursorStyle
                        },
                        set cursorStyle(e) {
                            o._setCursorStyle(e)
                        },
                        get lineNumbers() {
                            return o._lineNumbers
                        },
                        set lineNumbers(e) {
                            o._setLineNumbers(e)
                        }
                    }
                }
                _accept(e) {
                    this._tabSize = e.tabSize, this._indentSize = e.indentSize, this._originalIndentSize = e.originalIndentSize, this._insertSpaces = e.insertSpaces, this._cursorStyle = e.cursorStyle, this._lineNumbers = n.lP.to(e.lineNumbers)
                }
                _validateTabSize(e) {
                    if ("auto" === e) return "auto";
                    if ("number" == typeof e) {
                        const t = Math.floor(e);
                        return t > 0 ? t : null
                    }
                    if ("string" == typeof e) {
                        const t = parseInt(e, 10);
                        return isNaN(t) ? null : t > 0 ? t : null
                    }
                    return null
                }
                _setTabSize(e) {
                    const t = this._validateTabSize(e);
                    if (null !== t) {
                        if ("number" == typeof t) {
                            if (this._tabSize === t) return;
                            this._tabSize = t
                        }
                        this._warnOnError("setTabSize", this._proxy.$trySetOptions(this._id, {
                            tabSize: t
                        }))
                    }
                }
                _validateIndentSize(e) {
                    if ("tabSize" === e) return "tabSize";
                    if ("number" == typeof e) {
                        const t = Math.floor(e);
                        return t > 0 ? t : null
                    }
                    if ("string" == typeof e) {
                        const t = parseInt(e, 10);
                        return isNaN(t) ? null : t > 0 ? t : null
                    }
                    return null
                }
                _setIndentSize(e) {
                    const t = this._validateIndentSize(e);
                    if (null !== t) {
                        if ("number" == typeof t) {
                            if (this._originalIndentSize === t) return;
                            this._indentSize = t, this._originalIndentSize = t
                        }
                        this._warnOnError("setIndentSize", this._proxy.$trySetOptions(this._id, {
                            indentSize: t
                        }))
                    }
                }
                _validateInsertSpaces(e) {
                    return "auto" === e ? "auto" : "false" !== e && Boolean(e)
                }
                _setInsertSpaces(e) {
                    const t = this._validateInsertSpaces(e);
                    if ("boolean" == typeof t) {
                        if (this._insertSpaces === t) return;
                        this._insertSpaces = t
                    }
                    this._warnOnError("setInsertSpaces", this._proxy.$trySetOptions(this._id, {
                        insertSpaces: t
                    }))
                }
                _setCursorStyle(e) {
                    this._cursorStyle !== e && (this._cursorStyle = e, this._warnOnError("setCursorStyle", this._proxy.$trySetOptions(this._id, {
                        cursorStyle: e
                    })))
                }
                _setLineNumbers(e) {
                    this._lineNumbers !== e && (this._lineNumbers = e, this._warnOnError("setLineNumbers", this._proxy.$trySetOptions(this._id, {
                        lineNumbers: n.lP.from(e)
                    })))
                }
                assign(e) {
                    const t = {};
                    let i = !1;
                    if (void 0 !== e.tabSize) {
                        const s = this._validateTabSize(e.tabSize);
                        "auto" === s ? (i = !0, t.tabSize = s) : "number" == typeof s && this._tabSize !== s && (this._tabSize = s, i = !0, t.tabSize = s)
                    }
                    if (void 0 !== e.indentSize) {
                        const s = this._validateIndentSize(e.indentSize);
                        "tabSize" === s ? (i = !0, t.indentSize = s) : "number" == typeof s && this._originalIndentSize !== s && (this._indentSize = s, this._originalIndentSize = s, i = !0, t.indentSize = s)
                    }
                    if (void 0 !== e.insertSpaces) {
                        const s = this._validateInsertSpaces(e.insertSpaces);
                        "auto" === s ? (i = !0, t.insertSpaces = s) : this._insertSpaces !== s && (this._insertSpaces = s, i = !0, t.insertSpaces = s)
                    }
                    void 0 !== e.cursorStyle && this._cursorStyle !== e.cursorStyle && (this._cursorStyle = e.cursorStyle, i = !0, t.cursorStyle = e.cursorStyle), void 0 !== e.lineNumbers && this._lineNumbers !== e.lineNumbers && (this._lineNumbers = e.lineNumbers, i = !0, t.lineNumbers = n.lP.from(e.lineNumbers)), i && this._warnOnError("setOptions", this._proxy.$trySetOptions(this._id, t))
                }
                _warnOnError(e, t) {
                    t.catch((t => {
                        this._logService.warn(`ExtHostTextEditorOptions '${e}' failed:'`), this._logService.warn(t)
                    }))
                }
            }
            class h {
                constructor(e, t, i, s, r, c, h, u) {
                    this.id = e, this._proxy = t, this._logService = i, this._disposed = !1, this._hasDecorationsForKey = new Set, this._selections = r, this._options = new l(this._proxy, this.id, c, i), this._visibleRanges = h, this._viewColumn = u;
                    const p = this;
                    this.value = Object.freeze({
                        get document() {
                            return s.value
                        },
                        set document(e) {
                            throw new o.Tu("document")
                        },
                        get selection() {
                            return p._selections && p._selections[0]
                        },
                        set selection(e) {
                            if (!(e instanceof a.Y19)) throw (0, o.b1)("selection");
                            p._selections = [e], p._trySetSelection()
                        },
                        get selections() {
                            return p._selections
                        },
                        set selections(e) {
                            if (!Array.isArray(e) || e.some((e => !(e instanceof a.Y19)))) throw (0, o.b1)("selections");
                            p._selections = e, p._trySetSelection()
                        },
                        get visibleRanges() {
                            return p._visibleRanges
                        },
                        set visibleRanges(e) {
                            throw new o.Tu("visibleRanges")
                        },
                        get options() {
                            return p._options.value
                        },
                        set options(e) {
                            p._disposed || p._options.assign(e)
                        },
                        get viewColumn() {
                            return p._viewColumn
                        },
                        set viewColumn(e) {
                            throw new o.Tu("viewColumn")
                        },
                        edit(e, t = {
                            undoStopBefore: !0,
                            undoStopAfter: !0
                        }) {
                            if (p._disposed) return Promise.reject(new Error("TextEditor#edit not possible on closed editors"));
                            const i = new d(s.value, t);
                            return e(i), p._applyEdit(i)
                        },
                        insertSnippet(i, o, r = {
                            undoStopBefore: !0,
                            undoStopAfter: !0
                        }) {
                            if (p._disposed) return Promise.reject(new Error("TextEditor#insertSnippet not possible on closed editors"));
                            let c;
                            if (!o || Array.isArray(o) && 0 === o.length) c = p._selections.map((e => n.e6.from(e)));
                            else if (o instanceof a.Lyo) {
                                const {
                                    lineNumber: e,
                                    column: t
                                } = n.Ly.from(o);
                                c = [{
                                    startLineNumber: e,
                                    startColumn: t,
                                    endLineNumber: e,
                                    endColumn: t
                                }]
                            } else if (o instanceof a.e6w) c = [n.e6.from(o)];
                            else {
                                c = [];
                                for (const e of o)
                                    if (e instanceof a.e6w) c.push(n.e6.from(e));
                                    else {
                                        const {
                                            lineNumber: t,
                                            column: i
                                        } = n.Ly.from(e);
                                        c.push({
                                            startLineNumber: t,
                                            startColumn: i,
                                            endLineNumber: t,
                                            endColumn: i
                                        })
                                    }
                            }
                            return t.$tryInsertSnippet(e, s.value.version, i.value, c, r)
                        },
                        setDecorations(i, s) {
                            const o = 0 === s.length;
                            o && !p._hasDecorationsForKey.has(i.key) || (o ? p._hasDecorationsForKey.delete(i.key) : p._hasDecorationsForKey.add(i.key), p._runOnProxy((() => {
                                if ((0, n.J1)(s)) return t.$trySetDecorations(e, i.key, (0, n.MA)(s)); {
                                    const o = new Array(4 * s.length);
                                    for (let e = 0, t = s.length; e < t; e++) {
                                        const t = s[e];
                                        o[4 * e] = t.start.line + 1, o[4 * e + 1] = t.start.character + 1, o[4 * e + 2] = t.end.line + 1, o[4 * e + 3] = t.end.character + 1
                                    }
                                    return t.$trySetDecorationsFast(e, i.key, o)
                                }
                            })))
                        },
                        revealRange(i, s) {
                            p._runOnProxy((() => t.$tryRevealRange(e, n.e6.from(i), s || a._VK.Default)))
                        },
                        show(i) {
                            t.$tryShowEditor(e, n.eI.from(i))
                        },
                        hide() {
                            t.$tryHideEditor(e)
                        }
                    })
                }
                dispose() {
                    (0, s.ok)(!this._disposed), this._disposed = !0
                }
                _acceptOptions(e) {
                    (0, s.ok)(!this._disposed), this._options._accept(e)
                }
                _acceptVisibleRanges(e) {
                    (0, s.ok)(!this._disposed), this._visibleRanges = e
                }
                _acceptViewColumn(e) {
                    (0, s.ok)(!this._disposed), this._viewColumn = e
                }
                _acceptSelections(e) {
                    (0, s.ok)(!this._disposed), this._selections = e
                }
                async _trySetSelection() {
                    const e = this._selections.map(n.Y1.from);
                    return await this._runOnProxy((() => this._proxy.$trySetSelections(this.id, e))), this.value
                }
                _applyEdit(e) {
                    const t = e.finalize();
                    if (0 === t.edits.length && !t.setEndOfLine) return Promise.resolve(!0);
                    const i = t.edits.map((e => e.range));
                    i.sort(((e, t) => e.end.line === t.end.line ? e.end.character === t.end.character ? e.start.line === t.start.line ? e.start.character - t.start.character : e.start.line - t.start.line : e.end.character - t.end.character : e.end.line - t.end.line));
                    for (let e = 0, t = i.length - 1; e < t; e++) {
                        const t = i[e].end;
                        if (i[e + 1].start.isBefore(t)) return Promise.reject(new Error("Overlapping ranges are not allowed!"))
                    }
                    const s = t.edits.map((e => ({
                        range: n.e6.from(e.range),
                        text: e.text,
                        forceMoveMarkers: e.forceMoveMarkers
                    })));
                    return this._proxy.$tryApplyEdits(this.id, t.documentVersionId, s, {
                        setEndOfLine: "number" == typeof t.setEndOfLine ? n.b6.from(t.setEndOfLine) : void 0,
                        undoStopBefore: t.undoStopBefore,
                        undoStopAfter: t.undoStopAfter
                    })
                }
                _runOnProxy(e) {
                    return this._disposed ? (this._logService.warn("TextEditor is closed/disposed"), Promise.resolve(void 0)) : e().then((() => this), (e => (e instanceof Error && "DISPOSED" === e.name || this._logService.warn(e), null)))
                }
            }
        },
        Rtpz: (e, t, i) => {
            i.d(t, {
                F: () => s,
                Z: () => o
            });
            const s = (0, i("OYZR").yh)("IURITransformerService");
            class o {
                constructor(e) {
                    e ? (this.transformIncoming = e.transformIncoming.bind(e), this.transformOutgoing = e.transformOutgoing.bind(e), this.transformOutgoingURI = e.transformOutgoingURI.bind(e), this.transformOutgoingScheme = e.transformOutgoingScheme.bind(e)) : (this.transformIncoming = e => e, this.transformOutgoing = e => e, this.transformOutgoingURI = e => e, this.transformOutgoingScheme = e => e)
                }
            }
        },
        L03f: (e, t, i) => {
            i.d(t, {
                Y: () => P,
                w: () => S
            });
            var s, o = i("t5wJ"),
                r = i("8HR7"),
                n = i("RVdl"),
                a = i("RRaN"),
                c = i("67cB"),
                d = i("OYZR"),
                l = i("l6bu"),
                h = i("PmF0"),
                u = i("spPY"),
                p = i("7NN/"),
                m = i("n9io"),
                g = i("K30K"),
                v = i("7eUP"),
                _ = i("pLPy"),
                f = i("BiAj"),
                y = i("yFKF");
            ! function(e) {
                e.Unknown = "unknown", e.Env = "env", e.Config = "config", e.Command = "command", e.Input = "input", e.ExtensionInstallFolder = "extensionInstallFolder", e.WorkspaceFolder = "workspaceFolder", e.Cwd = "cwd", e.WorkspaceFolderBasename = "workspaceFolderBasename", e.UserHome = "userHome", e.LineNumber = "lineNumber", e.SelectedText = "selectedText", e.File = "file", e.FileWorkspaceFolder = "fileWorkspaceFolder", e.FileWorkspaceFolderBasename = "fileWorkspaceFolderBasename", e.RelativeFile = "relativeFile", e.RelativeFileDirname = "relativeFileDirname", e.FileDirname = "fileDirname", e.FileExtname = "fileExtname", e.FileBasename = "fileBasename", e.FileBasenameNoExtension = "fileBasenameNoExtension", e.FileDirnameBasename = "fileDirnameBasename", e.ExecPath = "execPath", e.ExecInstallFolder = "execInstallFolder", e.PathSeparator = "pathSeparator", e.PathSeparatorAlias = "/"
            }(s || (s = {}));
            class w extends Error {
                constructor(e, t) {
                    super(t), this.variable = e
                }
            }
            var x = i("p044");
            const b = "vs/workbench/services/configurationResolver/common/variableResolver";
            class D {
                static {
                    this.VARIABLE_LHS = "${"
                }
                static {
                    this.VARIABLE_REGEXP = /\$\{(.*?)\}/g
                }
                constructor(e, t, i, s) {
                    this._contributedVariables = new Map, this._context = e, this._labelService = t, this._userHomePromise = i, s && (this._envVariablesPromise = s.then((e => this.prepareEnv(e))))
                }
                prepareEnv(e) {
                    if (_.ED) {
                        const t = Object.create(null);
                        return Object.keys(e).forEach((i => {
                            t[i.toLowerCase()] = e[i]
                        })), t
                    }
                    return e
                }
                resolveWithEnvironment(e, t, i) {
                    return this.recursiveResolve({
                        env: this.prepareEnv(e),
                        userHome: void 0
                    }, t ? t.uri : void 0, i)
                }
                async resolveAsync(e, t) {
                    const i = {
                        env: await this._envVariablesPromise,
                        userHome: await this._userHomePromise
                    };
                    return this.recursiveResolve(i, e ? e.uri : void 0, t)
                }
                async resolveAnyBase(e, t, i, s) {
                    const o = (0, v.I8)(t);
                    _.ED && o.windows ? Object.keys(o.windows).forEach((e => o[e] = o.windows[e])) : _.dz && o.osx ? Object.keys(o.osx).forEach((e => o[e] = o.osx[e])) : _.IJ && o.linux && Object.keys(o.linux).forEach((e => o[e] = o.linux[e])), delete o.windows, delete o.osx, delete o.linux;
                    const r = {
                        env: await this._envVariablesPromise,
                        userHome: await this._userHomePromise
                    };
                    return this.recursiveResolve(r, e ? e.uri : void 0, o, i, s)
                }
                async resolveAnyAsync(e, t, i) {
                    return this.resolveAnyBase(e, t, i)
                }
                async resolveAnyMap(e, t, i) {
                    const s = new Map;
                    return {
                        newConfig: await this.resolveAnyBase(e, t, i, s),
                        resolvedVariables: s
                    }
                }
                resolveWithInteractionReplace(e, t, i, s) {
                    throw new Error("resolveWithInteractionReplace not implemented.")
                }
                resolveWithInteraction(e, t, i, s) {
                    throw new Error("resolveWithInteraction not implemented.")
                }
                contributeVariable(e, t) {
                    if (this._contributedVariables.has(e)) throw new Error("Variable " + e + " is contributed twice.");
                    this._contributedVariables.set(e, t)
                }
                async recursiveResolve(e, t, i, s, o) {
                    if ((0, g.HD)(i)) return this.resolveString(e, t, i, s, o);
                    if (Array.isArray(i)) return Promise.all(i.map((i => this.recursiveResolve(e, t, i, s, o))));
                    if ((0, g.Kn)(i)) {
                        const r = Object.create(null),
                            n = await Promise.all(Object.keys(i).map((async r => [await this.resolveString(e, t, r, s, o), await this.recursiveResolve(e, t, i[r], s, o)])));
                        for (const [e, t] of n) r[e] = t;
                        return r
                    }
                    return i
                }
                resolveString(e, t, i, s, o) {
                    return (0, x.s$)(i, D.VARIABLE_REGEXP, (async (i, r) => {
                        if (r.includes(D.VARIABLE_LHS)) return i;
                        let n = await this.evaluateSingleVariable(e, i, r, t, s);
                        return o ? .set(r, n), n !== i && (0, g.HD)(n) && n.match(D.VARIABLE_REGEXP) && (n = await this.resolveString(e, t, n, s, o)), n
                    }))
                }
                fsPath(e) {
                    return this._labelService ? this._labelService.getUriLabel(e, {
                        noPrefix: !0
                    }) : e.fsPath
                }
                async evaluateSingleVariable(e, t, i, o, r) {
                    let n;
                    const d = i.split(":");
                    d.length > 1 && (i = d[0], n = d[1]);
                    const l = e => {
                            const i = this._context.getFilePath();
                            if (i) return (0, f.DT)(i);
                            throw new w(e, (0, y.C$)(b, 0, "Variable {0} can not be resolved. Please open an editor.", t))
                        },
                        h = e => {
                            const i = l(e);
                            if (this._context.getWorkspaceFolderPathForFile) {
                                const e = this._context.getWorkspaceFolderPathForFile();
                                if (e) return (0, f.DT)(e)
                            }
                            throw new w(e, (0, y.C$)(b, 1, "Variable {0}: can not find workspace folder of '{1}'.", t, (0, a.EZ)(i)))
                        },
                        u = e => {
                            if (n) {
                                const i = this._context.getFolderUri(n);
                                if (i) return i;
                                throw new w(e, (0, y.C$)(b, 2, "Variable {0} can not be resolved. No such folder '{1}'.", t, n))
                            }
                            if (o) return o;
                            if (this._context.getWorkspaceFolderCount() > 1) throw new w(e, (0, y.C$)(b, 3, "Variable {0} can not be resolved in a multi folder workspace. Scope this variable using ':' and a workspace folder name.", t));
                            throw new w(e, (0, y.C$)(b, 4, "Variable {0} can not be resolved. Please open a folder.", t))
                        };
                    switch (i) {
                        case "env":
                            if (n) {
                                if (e.env) {
                                    const t = e.env[_.ED ? n.toLowerCase() : n];
                                    if ((0, g.HD)(t)) return t
                                }
                                return ""
                            }
                            throw new w(s.Env, (0, y.C$)(b, 5, "Variable {0} can not be resolved because no environment variable name is given.", t));
                        case "config":
                            if (n) {
                                const e = this._context.getConfigurationValue(o, n);
                                if ((0, g.Jp)(e)) throw new w(s.Config, (0, y.C$)(b, 6, "Variable {0} can not be resolved because setting '{1}' not found.", t, n));
                                if ((0, g.Kn)(e)) throw new w(s.Config, (0, y.C$)(b, 7, "Variable {0} can not be resolved because '{1}' is a structured value.", t, n));
                                return e
                            }
                            throw new w(s.Config, (0, y.C$)(b, 8, "Variable {0} can not be resolved because no settings name is given.", t));
                        case "command":
                            return this.resolveFromMap(s.Command, t, n, r, "command");
                        case "input":
                            return this.resolveFromMap(s.Input, t, n, r, "input");
                        case "extensionInstallFolder":
                            if (n) {
                                const e = await this._context.getExtension(n);
                                if (!e) throw new w(s.ExtensionInstallFolder, (0, y.C$)(b, 9, "Variable {0} can not be resolved because the extension {1} is not installed.", t, n));
                                return this.fsPath(e.extensionLocation)
                            }
                            throw new w(s.ExtensionInstallFolder, (0, y.C$)(b, 10, "Variable {0} can not be resolved because no extension name is given.", t));
                        default:
                            switch (i) {
                                case "workspaceRoot":
                                case "workspaceFolder":
                                    return (0, f.DT)(this.fsPath(u(s.WorkspaceFolder)));
                                case "cwd":
                                    return o || n ? (0, f.DT)(this.fsPath(u(s.Cwd))) : (0, c.Vj)();
                                case "workspaceRootFolderName":
                                case "workspaceFolderBasename":
                                    return (0, f.DT)((0, a.EZ)(this.fsPath(u(s.WorkspaceFolderBasename))));
                                case "userHome":
                                    if (e.userHome) return e.userHome;
                                    throw new w(s.UserHome, (0, y.C$)(b, 11, "Variable {0} can not be resolved. UserHome path is not defined", t));
                                case "lineNumber":
                                    {
                                        const e = this._context.getLineNumber();
                                        if (e) return e;
                                        throw new w(s.LineNumber, (0, y.C$)(b, 12, "Variable {0} can not be resolved. Make sure to have a line selected in the active editor.", t))
                                    }
                                case "selectedText":
                                    {
                                        const e = this._context.getSelectedText();
                                        if (e) return e;
                                        throw new w(s.SelectedText, (0, y.C$)(b, 13, "Variable {0} can not be resolved. Make sure to have some text selected in the active editor.", t))
                                    }
                                case "file":
                                    return l(s.File);
                                case "fileWorkspaceFolder":
                                    return h(s.FileWorkspaceFolder);
                                case "fileWorkspaceFolderBasename":
                                    return (0, a.EZ)(h(s.FileWorkspaceFolderBasename));
                                case "relativeFile":
                                    return o || n ? (0, a.Gf)(this.fsPath(u(s.RelativeFile)), l(s.RelativeFile)) : l(s.RelativeFile);
                                case "relativeFileDirname":
                                    {
                                        const e = (0, a.XX)(l(s.RelativeFileDirname));
                                        if (o || n) {
                                            const t = (0, a.Gf)(this.fsPath(u(s.RelativeFileDirname)), e);
                                            return 0 === t.length ? "." : t
                                        }
                                        return e
                                    }
                                case "fileDirname":
                                    return (0, a.XX)(l(s.FileDirname));
                                case "fileExtname":
                                    return (0, a.DZ)(l(s.FileExtname));
                                case "fileBasename":
                                    return (0, a.EZ)(l(s.FileBasename));
                                case "fileBasenameNoExtension":
                                    {
                                        const e = (0, a.EZ)(l(s.FileBasenameNoExtension));
                                        return e.slice(0, e.length - (0, a.DZ)(e).length)
                                    }
                                case "fileDirnameBasename":
                                    return (0, a.EZ)((0, a.XX)(l(s.FileDirnameBasename)));
                                case "execPath":
                                    return this._context.getExecPath() || t;
                                case "execInstallFolder":
                                    return this._context.getAppRoot() || t;
                                case "pathSeparator":
                                case "/":
                                    return a.ir;
                                default:
                                    try {
                                        const e = n ? `${i}:${n}` : i;
                                        return this.resolveFromMap(s.Unknown, t, e, r, void 0)
                                    } catch (e) {
                                        return t
                                    }
                            }
                    }
                }
                resolveFromMap(e, t, i, s, o) {
                    if (i && s) {
                        const r = void 0 === o ? s[i] : s[o + ":" + i];
                        if ("string" == typeof r) return r;
                        throw new w(e, (0, y.C$)(b, 14, "Variable {0} can not be resolved because the command has no value.", t))
                    }
                    return t
                }
            }
            var C = i("45t+");
            const S = (0, d.yh)("IExtHostVariableResolverProvider");
            class E extends D {
                constructor(e, t, i, s, o, r, n) {
                    function d() {
                        if (i) {
                            const e = i.activeEditor();
                            if (e) return e.document.uri;
                            const t = s.tabGroups.all.find((e => e.isActive)) ? .activeTab;
                            if (void 0 !== t) {
                                if (t.input instanceof p.lF4 || t.input instanceof p.ogl) return t.input.modified;
                                if (t.input instanceof p.Y_o || t.input instanceof p.IAb || t.input instanceof p.zwE) return t.input.uri
                            }
                        }
                    }
                    super({
                        getFolderUri: e => {
                            const t = r.folders.filter((t => t.name === e));
                            if (t && t.length > 0) return t[0].uri
                        },
                        getWorkspaceFolderCount: () => r.folders.length,
                        getConfigurationValue: (e, t) => o.getConfiguration(void 0, e).get(t),
                        getAppRoot: () => (0, c.Vj)(),
                        getExecPath: () => c.OB.VSCODE_EXEC_PATH,
                        getFilePath: () => {
                            const e = d();
                            if (e) return (0, a.Fv)(e.fsPath)
                        },
                        getWorkspaceFolderPathForFile: () => {
                            if (t) {
                                const e = d();
                                if (e) {
                                    const i = t.getWorkspaceFolder(e);
                                    if (i) return (0, a.Fv)(i.uri.fsPath)
                                }
                            }
                        },
                        getSelectedText: () => {
                            if (i) {
                                const e = i.activeEditor();
                                if (e && !e.selection.isEmpty) return e.document.getText(e.selection)
                            }
                        },
                        getLineNumber: () => {
                            if (i) {
                                const e = i.activeEditor();
                                if (e) return String(e.selection.end.line + 1)
                            }
                        },
                        getExtension: t => e.getExtension(t)
                    }, void 0, n ? Promise.resolve(n) : void 0, Promise.resolve(c.OB))
                }
            }
            let P = class extends n.JT {
                constructor(e, t, i, s, o) {
                    super(), this.extensionService = e, this.workspaceService = t, this.editorService = i, this.configurationService = s, this.editorTabs = o, this._resolver = new r.o((async () => {
                        const e = await this.configurationService.getConfigProvider(),
                            t = {
                                folders: await this.workspaceService.getWorkspaceFolders2() || []
                            };
                        return this._register(this.workspaceService.onDidChangeWorkspace((async e => {
                            t.folders = await this.workspaceService.getWorkspaceFolders2() || []
                        }))), new E(this.extensionService, this.workspaceService, this.editorService, this.editorTabs, e, t, this.homeDir())
                    }))
                }
                getResolver() {
                    return this._resolver.value
                }
                homeDir() {}
            };
            P = (0, o.g)([(0, o.f)(0, u.k2), (0, o.f)(1, m.w), (0, o.f)(2, l.T), (0, o.f)(3, C.E1), (0, o.f)(4, h.v)], P)
        },
        GWyr: (e, t, i) => {
            i.d(t, {
                V: () => p,
                x: () => u
            });
            var s, o = i("t5wJ"),
                r = i("7icl"),
                n = i("PTqS"),
                a = i("p044"),
                c = i("naIR"),
                d = i("OYZR"),
                l = i("Ayc8"),
                h = i("YrcG");
            let u = class {
                static {
                    s = this
                }
                static {
                    this.InitialState = {
                        focused: !0,
                        active: !0
                    }
                }
                getState() {
                    const e = this._state;
                    return {
                        get focused() {
                            return e.focused
                        },
                        get active() {
                            return e.active
                        }
                    }
                }
                constructor(e) {
                    this._onDidChangeWindowState = new r.Q5, this.onDidChangeWindowState = this._onDidChangeWindowState.event, this._state = s.InitialState, this._proxy = e.getProxy(h.Tr.MainThreadWindow), this._proxy.$getInitialState().then((({
                        isFocused: e,
                        isActive: t
                    }) => {
                        this.onDidChangeWindowProperty("focused", e), this.onDidChangeWindowProperty("active", t)
                    }))
                }
                $onDidChangeWindowFocus(e) {
                    this.onDidChangeWindowProperty("focused", e)
                }
                $onDidChangeWindowActive(e) {
                    this.onDidChangeWindowProperty("active", e)
                }
                onDidChangeWindowProperty(e, t) {
                    t !== this._state[e] && (this._state = { ...this._state,
                        [e]: t
                    }, this._onDidChangeWindowState.fire(this._state))
                }
                openUri(e, t) {
                    let i;
                    if ("string" == typeof e) {
                        i = e;
                        try {
                            e = c.ov.parse(e)
                        } catch (t) {
                            return Promise.reject(`Invalid uri - '${e}'`)
                        }
                    }
                    return (0, a.m5)(e.scheme) ? Promise.reject("Invalid scheme - cannot be empty") : e.scheme === n.lg.command ? Promise.reject(`Invalid scheme '${e.scheme}'`) : this._proxy.$openUri(e, i, t)
                }
                async asExternalUri(e, t) {
                    if ((0, a.m5)(e.scheme)) return Promise.reject("Invalid scheme - cannot be empty");
                    const i = await this._proxy.$asExternalUri(e, t);
                    return c.ov.from(i)
                }
            };
            u = s = (0, o.g)([(0, o.f)(0, l.O)], u);
            const p = (0, d.yh)("IExtHostWindow")
        },
        n9io: (e, t, i) => {
            i.d(t, {
                M: () => N,
                w: () => M
            });
            var s = i("t5wJ"),
                o = i("iDmX"),
                r = i("opu4"),
                n = i("rJtg"),
                a = i("7icl"),
                c = i("RVdl"),
                d = i("cd+3"),
                l = i("PTqS"),
                h = i("xN1x"),
                u = i("oVnE"),
                p = i("p044"),
                m = i("naIR"),
                g = i("yFKF"),
                v = i("ts6x"),
                _ = i("OYZR"),
                f = i("Vvlp"),
                y = (i("GKqz"), i("ejdX")),
                w = i("CRYY"),
                x = i("5h1i"),
                b = i("Ayc8"),
                D = i("IqsH"),
                C = i("7NN/"),
                S = i("Rtpz"),
                E = i("GbR3"),
                P = i("YrcG"),
                T = i("GHax"),
                k = i("R6K4");

            function I(e, t, i) {
                return new u.U9((e => H(e, i))).isEqual(e, t)
            }

            function A(e, t, i) {
                return I(e.uri, t.uri, i) ? 0 : (0, p.qu)(e.uri.toString(), t.uri.toString())
            }

            function $(e, t, i) {
                return e.index !== t.index ? e.index < t.index ? -1 : 1 : I(e.uri, t.uri, i) ? (0, p.qu)(e.name, t.name) : (0, p.qu)(e.uri.toString(), t.uri.toString())
            }

            function R(e, t, i, s) {
                const r = e.slice(0).sort(((e, t) => i(e, t, s))),
                    n = t.slice(0).sort(((e, t) => i(e, t, s)));
                return (0, o.pY)(r, n, ((e, t) => i(e, t, s)))
            }

            function H(e, t) {
                const i = t.getCapabilities(e.scheme);
                return !(i && i & v.Bb.PathCaseSensitive)
            }
            class F extends y.j$ {
                static toExtHostWorkspace(e, t, i, s) {
                    if (!e) return {
                        workspace: null,
                        added: [],
                        removed: []
                    };
                    const {
                        id: o,
                        name: r,
                        folders: n,
                        configuration: a,
                        transient: c,
                        isUntitled: d
                    } = e, l = [], h = t;
                    t ? n.forEach(((e, o) => {
                        const r = m.ov.revive(e.uri),
                            n = F._findFolder(i || t, r, s);
                        n ? (n.name = e.name, n.index = e.index, l.push(n)) : l.push({
                            uri: r,
                            name: e.name,
                            index: o
                        })
                    })) : l.push(...n.map((({
                        uri: e,
                        name: t,
                        index: i
                    }) => ({
                        uri: m.ov.revive(e),
                        name: t,
                        index: i
                    })))), l.sort(((e, t) => e.index < t.index ? -1 : 1));
                    const u = new F(o, r, l, !!c, a ? m.ov.revive(a) : null, !!d, (e => H(e, s))),
                        {
                            added: p,
                            removed: g
                        } = R(h ? h.workspaceFolders : [], u.workspaceFolders, A, s);
                    return {
                        workspace: u,
                        added: p,
                        removed: g
                    }
                }
                static _findFolder(e, t, i) {
                    for (let s = 0; s < e.folders.length; s++) {
                        const o = e.workspaceFolders[s];
                        if (I(o.uri, t, i)) return o
                    }
                }
                constructor(e, t, i, s, o, r, n) {
                    super(e, i.map((e => new y.md(e))), s, o, n), this._name = t, this._isUntitled = r, this._workspaceFolders = [], this._structure = d.Id.forUris(n, (() => !0)), i.forEach((e => {
                        this._workspaceFolders.push(e), this._structure.set(e.uri, e)
                    }))
                }
                get name() {
                    return this._name
                }
                get isUntitled() {
                    return this._isUntitled
                }
                get workspaceFolders() {
                    return this._workspaceFolders.slice(0)
                }
                getWorkspaceFolder(e, t) {
                    return t && this._structure.get(e) && (e = (0, u.XX)(e)), this._structure.findSubstr(e)
                }
                resolveWorkspaceFolder(e) {
                    return this._structure.get(e)
                }
            }
            let N = class {
                constructor(e, t, i, s, o) {
                    this._onDidChangeWorkspace = new a.Q5, this.onDidChangeWorkspace = this._onDidChangeWorkspace.event, this._onDidGrantWorkspaceTrust = new a.Q5, this.onDidGrantWorkspaceTrust = this._onDidGrantWorkspaceTrust.event, this._activeSearchCallbacks = [], this._trusted = !1, this._editSessionIdentityProviders = new Map, this._providerHandlePool = 0, this._onWillCreateEditSessionIdentityEvent = new a.Qz, this._canonicalUriProviders = new Map, this._logService = s, this._extHostFileSystemInfo = i, this._uriTransformerService = o, this._requestIdProvider = new h.AT, this._barrier = new r.U8, this._proxy = e.getProxy(P.Tr.MainThreadWorkspace), this._messageService = e.getProxy(P.Tr.MainThreadMessageService);
                    const n = t.workspace;
                    this._confirmedWorkspace = n ? new F(n.id, n.name, [], !!n.transient, n.configuration ? m.ov.revive(n.configuration) : null, !!n.isUntitled, (e => H(e, i))) : void 0
                }
                $initializeWorkspace(e, t) {
                    this._trusted = t, this.$acceptWorkspaceData(e), this._barrier.open()
                }
                waitForInitializeCall() {
                    return this._barrier.wait()
                }
                get workspace() {
                    return this._actualWorkspace
                }
                get name() {
                    return this._actualWorkspace ? this._actualWorkspace.name : void 0
                }
                get workspaceFile() {
                    if (this._actualWorkspace && this._actualWorkspace.configuration) return this._actualWorkspace.isUntitled ? m.ov.from({
                        scheme: l.lg.untitled,
                        path: (0, u.EZ)((0, u.XX)(this._actualWorkspace.configuration))
                    }) : this._actualWorkspace.configuration
                }
                get _actualWorkspace() {
                    return this._unconfirmedWorkspace || this._confirmedWorkspace
                }
                getWorkspaceFolders() {
                    if (this._actualWorkspace) return this._actualWorkspace.workspaceFolders.slice(0)
                }
                async getWorkspaceFolders2() {
                    if (await this._barrier.wait(), this._actualWorkspace) return this._actualWorkspace.workspaceFolders.slice(0)
                }
                updateWorkspaceFolders(e, t, i, ...s) {
                    const o = [];
                    if (Array.isArray(s) && s.forEach((e => {
                            m.ov.isUri(e.uri) && !o.some((t => I(t.uri, e.uri, this._extHostFileSystemInfo))) && o.push({
                                uri: e.uri,
                                name: e.name || (0, u.Hx)(e.uri)
                            })
                        })), this._unconfirmedWorkspace) return !1;
                    if ([t, i].some((e => "number" != typeof e || e < 0))) return !1;
                    if (0 === i && 0 === o.length) return !1;
                    const r = this._actualWorkspace ? this._actualWorkspace.workspaceFolders : [];
                    if (t + i > r.length) return !1;
                    const n = r.slice(0);
                    n.splice(t, i, ...o.map((e => ({
                        uri: e.uri,
                        name: e.name || (0, u.Hx)(e.uri),
                        index: void 0
                    }))));
                    for (let e = 0; e < n.length; e++) {
                        const t = n[e];
                        if (n.some(((i, s) => s !== e && I(t.uri, i.uri, this._extHostFileSystemInfo)))) return !1
                    }
                    n.forEach(((e, t) => e.index = t));
                    const {
                        added: a,
                        removed: c
                    } = R(r, n, $, this._extHostFileSystemInfo);
                    if (0 === a.length && 0 === c.length) return !1;
                    if (this._proxy) {
                        const s = e.displayName || e.name;
                        this._proxy.$updateWorkspaceFolders(s, t, i, o).then(void 0, (t => {
                            this._unconfirmedWorkspace = void 0;
                            const i = {
                                source: {
                                    identifier: e.identifier,
                                    label: e.displayName || e.name
                                }
                            };
                            this._messageService.$showMessage(k.Z.Error, (0, g.C$)("vs/workbench/api/common/extHostWorkspace", 0, "Extension '{0}' failed to update workspace folders: {1}", s, t.toString()), i, [])
                        }))
                    }
                    return this.trySetWorkspaceFolders(n), !0
                }
                getWorkspaceFolder(e, t) {
                    if (this._actualWorkspace) return this._actualWorkspace.getWorkspaceFolder(e, t)
                }
                async getWorkspaceFolder2(e, t) {
                    if (await this._barrier.wait(), this._actualWorkspace) return this._actualWorkspace.getWorkspaceFolder(e, t)
                }
                async resolveWorkspaceFolder(e) {
                    if (await this._barrier.wait(), this._actualWorkspace) return this._actualWorkspace.resolveWorkspaceFolder(e)
                }
                getPath() {
                    if (!this._actualWorkspace) return;
                    const {
                        folders: e
                    } = this._actualWorkspace;
                    return 0 !== e.length ? e[0].uri.fsPath : void 0
                }
                getRelativePath(e, t) {
                    let i, s = "";
                    if ("string" == typeof e ? (i = m.ov.file(e), s = e) : void 0 !== e && (i = e, s = e.fsPath), !i) return s;
                    const o = this.getWorkspaceFolder(i, !0);
                    if (!o) return s;
                    void 0 === t && this._actualWorkspace && (t = this._actualWorkspace.folders.length > 1);
                    let r = (0, u.lX)(o.uri, i);
                    return t && o.name && (r = `${o.name}/${r}`), r
                }
                trySetWorkspaceFolders(e) {
                    this._actualWorkspace && (this._unconfirmedWorkspace = F.toExtHostWorkspace({
                        id: this._actualWorkspace.id,
                        name: this._actualWorkspace.name,
                        configuration: this._actualWorkspace.configuration,
                        folders: e,
                        isUntitled: this._actualWorkspace.isUntitled
                    }, this._actualWorkspace, void 0, this._extHostFileSystemInfo).workspace || void 0)
                }
                $acceptWorkspaceData(e) {
                    const {
                        workspace: t,
                        added: i,
                        removed: s
                    } = F.toExtHostWorkspace(e, this._confirmedWorkspace, this._unconfirmedWorkspace, this._extHostFileSystemInfo);
                    this._confirmedWorkspace = t || void 0, this._unconfirmedWorkspace = void 0, this._onDidChangeWorkspace.fire(Object.freeze({
                        added: i,
                        removed: s
                    }))
                }
                findFiles(e, t, i, s, o = n.Ts.None) {
                    this._logService.trace(`extHostWorkspace#findFiles: fileSearch, extension: ${s.value}, entryPoint: findFiles`);
                    let r = "",
                        a = !0;
                    return null === t ? a = !1 : void 0 !== t && (r = "string" == typeof t ? t : t.pattern), this._findFilesImpl(e, void 0, {
                        exclude: r,
                        maxResults: i,
                        useDefaultExcludes: a,
                        useDefaultSearchExcludes: !1,
                        useIgnoreFiles: !1
                    }, o)
                }
                findFiles2(e, t = {}, i, s = n.Ts.None) {
                    return this._logService.trace(`extHostWorkspace#findFiles2: fileSearch, extension: ${i.value}, entryPoint: findFiles2`), this._findFilesImpl(void 0, e, t, s)
                }
                async _findFilesImpl(e, t, i, s = n.Ts.None) {
                    if (s && s.isCancellationRequested) return Promise.resolve([]);
                    const o = "string" == typeof i.exclude ? i.exclude : i.exclude ? i.exclude.pattern : void 0,
                        r = {
                            ignoreSymlinks: "boolean" == typeof i.followSymlinks ? !i.followSymlinks : void 0,
                            disregardIgnoreFiles: "boolean" == typeof i.useIgnoreFiles ? !i.useIgnoreFiles : void 0,
                            disregardGlobalIgnoreFiles: "boolean" == typeof i.useGlobalIgnoreFiles ? !i.useGlobalIgnoreFiles : void 0,
                            disregardParentIgnoreFiles: "boolean" == typeof i.useParentIgnoreFiles ? !i.useParentIgnoreFiles : void 0,
                            disregardExcludeSettings: "boolean" == typeof i.useDefaultExcludes && !i.useDefaultExcludes,
                            disregardSearchExcludeSettings: "boolean" == typeof i.useDefaultSearchExcludes && !i.useDefaultSearchExcludes,
                            maxResults: i.maxResults,
                            excludePattern: o,
                            shouldGlobSearch: "boolean" != typeof i.fuzzy || !i.fuzzy,
                            _reason: "startFileSearch"
                        };
                    let a;
                    if (e) {
                        const {
                            includePattern: t,
                            folder: i
                        } = L(D.RW.from(e));
                        a = i, r.includePattern = t
                    } else {
                        const {
                            includePattern: e,
                            folder: i
                        } = L(D.RW.from(t));
                        a = i, r.filePattern = e
                    }
                    return this._proxy.$startFileSearch(a ? ? null, r, s).then((e => Array.isArray(e) ? e.map((e => m.ov.revive(e))) : []))
                }
                async findTextInFiles(e, t, i, s, r = n.Ts.None) {
                    this._logService.trace(`extHostWorkspace#findTextInFiles: textSearch, extension: ${s.value}, entryPoint: findTextInFiles`);
                    const a = this._requestIdProvider.getNext(),
                        c = void 0 === t.previewOptions ? {
                            matchLines: 100,
                            charsPerLine: 1e4
                        } : t.previewOptions,
                        {
                            includePattern: d,
                            folder: l
                        } = L(D.RW.from(t.include)),
                        h = "string" == typeof t.exclude ? t.exclude : t.exclude ? t.exclude.pattern : void 0,
                        u = {
                            ignoreSymlinks: "boolean" == typeof t.followSymlinks ? !t.followSymlinks : void 0,
                            disregardIgnoreFiles: "boolean" == typeof t.useIgnoreFiles ? !t.useIgnoreFiles : void 0,
                            disregardGlobalIgnoreFiles: "boolean" == typeof t.useGlobalIgnoreFiles ? !t.useGlobalIgnoreFiles : void 0,
                            disregardParentIgnoreFiles: "boolean" == typeof t.useParentIgnoreFiles ? !t.useParentIgnoreFiles : void 0,
                            disregardExcludeSettings: "boolean" != typeof t.useDefaultExcludes || !t.useDefaultExcludes,
                            fileEncoding: t.encoding,
                            maxResults: t.maxResults,
                            previewOptions: c,
                            afterContext: t.afterContext,
                            beforeContext: t.beforeContext,
                            includePattern: d,
                            excludePattern: h
                        };
                    if (this._activeSearchCallbacks[a] = e => {
                            const t = m.ov.revive(e.resource);
                            e.results.forEach((e => {
                                const s = (0, T.wL)(e);
                                (0, E.k5)(s) ? i({
                                    uri: t,
                                    preview: {
                                        text: s.preview.text,
                                        matches: (0, o.Gb)(s.preview.matches, (e => new C.e6w(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn)))
                                    },
                                    ranges: (0, o.Gb)(s.ranges, (e => new C.e6w(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn)))
                                }): i({
                                    uri: t,
                                    text: s.text,
                                    lineNumber: s.lineNumber
                                })
                            }))
                        }, r.isCancellationRequested) return {};
                    try {
                        const t = await this._proxy.$startTextSearch(e, l ? ? null, u, a, r);
                        return delete this._activeSearchCallbacks[a], t || {}
                    } catch (e) {
                        throw delete this._activeSearchCallbacks[a], e
                    }
                }
                $handleTextSearchResult(e, t) {
                    this._activeSearchCallbacks[t] ? .(e)
                }
                async save(e) {
                    const t = await this._proxy.$save(e, {
                        saveAs: !1
                    });
                    return m.ov.revive(t)
                }
                async saveAs(e) {
                    const t = await this._proxy.$save(e, {
                        saveAs: !0
                    });
                    return m.ov.revive(t)
                }
                saveAll(e) {
                    return this._proxy.$saveAll(e)
                }
                resolveProxy(e) {
                    return this._proxy.$resolveProxy(e)
                }
                loadCertificates() {
                    return this._proxy.$loadCertificates()
                }
                get trusted() {
                    return this._trusted
                }
                requestWorkspaceTrust(e) {
                    return this._proxy.$requestWorkspaceTrust(e)
                }
                $onDidGrantWorkspaceTrust() {
                    this._trusted || (this._trusted = !0, this._onDidGrantWorkspaceTrust.fire())
                }
                registerEditSessionIdentityProvider(e, t) {
                    if (this._editSessionIdentityProviders.has(e)) throw new Error(`A provider has already been registered for scheme ${e}`);
                    this._editSessionIdentityProviders.set(e, t);
                    const i = this._uriTransformerService.transformOutgoingScheme(e),
                        s = this._providerHandlePool++;
                    return this._proxy.$registerEditSessionIdentityProvider(s, i), (0, c.OF)((() => {
                        this._editSessionIdentityProviders.delete(e), this._proxy.$unregisterEditSessionIdentityProvider(s)
                    }))
                }
                async $getEditSessionIdentifier(e, t) {
                    this._logService.info("Getting edit session identifier for workspaceFolder", e);
                    const i = await this.resolveWorkspaceFolder(m.ov.revive(e));
                    if (!i) return void this._logService.warn("Unable to resolve workspace folder");
                    this._logService.info("Invoking #provideEditSessionIdentity for workspaceFolder", i);
                    const s = this._editSessionIdentityProviders.get(i.uri.scheme);
                    if (this._logService.info(`Provider for scheme ${i.uri.scheme} is defined: `, !!s), !s) return;
                    const o = await s.provideEditSessionIdentity(i, t);
                    return this._logService.info("Provider returned edit session identifier: ", o), o || void 0
                }
                async $provideEditSessionIdentityMatch(e, t, i, s) {
                    this._logService.info("Getting edit session identifier for workspaceFolder", e);
                    const o = await this.resolveWorkspaceFolder(m.ov.revive(e));
                    if (!o) return void this._logService.warn("Unable to resolve workspace folder");
                    this._logService.info("Invoking #provideEditSessionIdentity for workspaceFolder", o);
                    const r = this._editSessionIdentityProviders.get(o.uri.scheme);
                    if (this._logService.info(`Provider for scheme ${o.uri.scheme} is defined: `, !!r), !r) return;
                    const n = await (r.provideEditSessionIdentityMatch ? .(t, i, s));
                    return this._logService.info("Provider returned edit session identifier match result: ", n), n || void 0
                }
                getOnWillCreateEditSessionIdentityEvent(e) {
                    return (t, i, s) => {
                        const o = function(e) {
                            t.call(i, e)
                        };
                        return o.extension = e, this._onWillCreateEditSessionIdentityEvent.event(o, void 0, s)
                    }
                }
                async $onWillCreateEditSessionIdentity(e, t, i) {
                    const s = await this.resolveWorkspaceFolder(m.ov.revive(e));
                    if (void 0 === s) throw new Error("Unable to resolve workspace folder");
                    await this._onWillCreateEditSessionIdentityEvent.fireAsync({
                        workspaceFolder: s
                    }, t, (async (e, t) => {
                        const s = Date.now();
                        await Promise.resolve(e), Date.now() - s > i && this._logService.warn("SLOW edit session create-participant", t.extension.identifier)
                    })), t.isCancellationRequested
                }
                registerCanonicalUriProvider(e, t) {
                    if (this._canonicalUriProviders.has(e)) throw new Error(`A provider has already been registered for scheme ${e}`);
                    this._canonicalUriProviders.set(e, t);
                    const i = this._uriTransformerService.transformOutgoingScheme(e),
                        s = this._providerHandlePool++;
                    return this._proxy.$registerCanonicalUriProvider(s, i), (0, c.OF)((() => {
                        this._canonicalUriProviders.delete(e), this._proxy.$unregisterCanonicalUriProvider(s)
                    }))
                }
                async provideCanonicalUri(e, t, i) {
                    const s = this._canonicalUriProviders.get(e.scheme);
                    if (!s) return;
                    return await (s.provideCanonicalUri ? .(m.ov.revive(e), t, i)) || void 0
                }
                async $provideCanonicalUri(e, t, i) {
                    return this.provideCanonicalUri(m.ov.revive(e), {
                        targetScheme: t
                    }, i)
                }
            };
            N = (0, s.g)([(0, s.f)(0, b.O), (0, s.f)(1, x.$), (0, s.f)(2, w.G), (0, s.f)(3, f.V), (0, s.f)(4, S.F)], N);
            const M = (0, _.yh)("IExtHostWorkspace");

            function L(e) {
                let t, i;
                return e && ("string" == typeof e ? t = e : (t = e.pattern, i = m.ov.revive(e.baseUri))), {
                    includePattern: t,
                    folder: i
                }
            }
        },
        "j/1u": (e, t, i) => {
            i.d(t, {
                m: () => E
            });
            var s = i("PUdK"),
                o = i("JKRA"),
                r = i("naIR"),
                n = i("YrcG"),
                a = i("JxLe"),
                c = i("Vvlp"),
                d = i("yJ/l"),
                l = i("5g4k"),
                h = i("5h1i"),
                u = i("D2uF"),
                p = i("Ayc8"),
                m = i("Rtpz"),
                g = i("spPY"),
                v = i("ofuf"),
                _ = i("pLPy"),
                f = i("t5wJ"),
                y = i("yFKF"),
                w = i("Pz4e");
            const x = "vs/workbench/api/common/extHostLogService";
            let b = class extends w.$ {
                constructor(e, t, i) {
                    const s = i.remote.isRemote ? "remoteexthost" : e ? "workerexthost" : "exthost",
                        o = i.remote.isRemote ? (0, y.C$)(x, 0, "Extension Host (Remote)") : e ? (0, y.C$)(x, 1, "Extension Host (Worker)") : (0, y.C$)(x, 2, "Extension Host");
                    super(t.createLogger(s, {
                        name: o
                    }))
                }
            };
            b = (0, f.g)([(0, f.f)(1, c.y), (0, f.f)(2, h.$)], b);
            var D = i("9r3b"),
                C = i("P+6B");
            class S {
                static async installEarlyHandler(e) {
                    Error.stackTraceLimit = 100;
                    const t = e.get(c.V),
                        i = e.get(p.O).getProxy(n.Tr.MainThreadErrors);
                    (0, s.sH)((e => {
                        t.error(e);
                        const o = (0, s.ri)(e);
                        i.$onUnexpectedError(o)
                    }))
                }
                static async installFullHandler(e) {
                    const t = e.get(c.V),
                        i = e.get(p.O),
                        o = e.get(g.k2),
                        a = e.get(v.fv),
                        d = i.getProxy(n.Tr.MainThreadExtensionService),
                        l = i.getProxy(n.Tr.MainThreadErrors),
                        h = await o.getExtensionPathIndex(),
                        u = new WeakMap;

                    function m(e, t) {
                        if (u.has(e)) return u.get(e).stack;
                        let i, s, o = "";
                        for (const e of t) o += `\n\tat ${e.toString()}`, s = e.getFileName(), !i && s && (i = h.findSubstr(r.ov.file(s)));
                        const n = `${e.name||"Error"}: ${e.message||""}${o}`;
                        return u.set(e, {
                            extensionIdentifier: i ? .identifier,
                            stack: n
                        }), n
                    }
                    const _ = Symbol("prepareStackTrace wrapped");
                    let f = m;
                    Object.defineProperty(Error, "prepareStackTrace", {
                        configurable: !1,
                        get: () => f,
                        set(e) {
                            e !== m && e && !e[_] ? (f = function(t, i) {
                                return m(t, i), e.call(Error, t, i)
                            }, Object.assign(f, {
                                [_]: !0
                            })) : f = e || m
                        }
                    }), (0, s.sH)((e => {
                        t.error(e);
                        const i = (0, s.ri)(e),
                            o = u.get(e);
                        if (!o ? .extensionIdentifier) return void l.$onUnexpectedError(i);
                        d.$onExtensionRuntimeError(o.extensionIdentifier, i);
                        const r = a.onExtensionError(o.extensionIdentifier, e);
                        t.trace("forwarded error to extension?", r, o)
                    }))
                }
            }
            class E {
                constructor(e, t, i, s, r) {
                    this._hostUtils = i, this._rpcProtocol = new a.Ui(e, null, s), t = E._transform(t, this._rpcProtocol);
                    const n = new l.y(...(0, d.dh)());
                    n.set(h.$, {
                        _serviceBrand: void 0,
                        ...t,
                        messagePorts: r
                    }), n.set(p.O, new p.i(this._rpcProtocol)), n.set(m.F, new m.Z(s)), n.set(g.vM, i), n.set(c.V, new D.M(b, [!0], !0)), n.set(c.y, new D.M(C.m, [], !0));
                    const v = new u.F(n, !0);
                    _.n2 && v.invokeFunction(S.installEarlyHandler), this._logService = v.invokeFunction((e => e.get(c.V))), (0, o.B)("code/extHost/didCreateServices"), this._hostUtils.pid ? this._logService.info(`Extension host with pid ${this._hostUtils.pid} started`) : this._logService.info("Extension host started"), this._logService.trace("initData", t), this._extensionService = v.invokeFunction((e => e.get(g.k2))), this._extensionService.initialize(), _.n2 && v.invokeFunction(S.installFullHandler)
                }
                async asBrowserUri(e) {
                    const t = this._rpcProtocol.getProxy(n.Tr.MainThreadExtensionService);
                    return r.ov.revive(await t.$asBrowserUri(e))
                }
                async getAllStaticBrowserUris() {
                    const e = this._rpcProtocol.getProxy(n.Tr.MainThreadExtensionService);
                    return (await e.$getAllStaticBrowserUris()).map((([e, t]) => [r.ov.revive(e), r.ov.revive(t)]))
                }
                terminate(e) {
                    this._extensionService.terminate(e)
                }
                getExtHostExtensionService() {
                    return this._extensionService
                }
                static _transform(e, t) {
                    e.extensions.allExtensions.forEach((e => {
                        e.extensionLocation = r.ov.revive(t.transformIncomingURIs(e.extensionLocation))
                    })), e.environment.appRoot = r.ov.revive(t.transformIncomingURIs(e.environment.appRoot));
                    const i = e.environment.extensionDevelopmentLocationURI;
                    return i && (e.environment.extensionDevelopmentLocationURI = i.map((e => r.ov.revive(t.transformIncomingURIs(e))))), e.environment.extensionTestsLocationURI = r.ov.revive(t.transformIncomingURIs(e.environment.extensionTestsLocationURI)), e.environment.globalStorageHome = r.ov.revive(t.transformIncomingURIs(e.environment.globalStorageHome)), e.environment.workspaceStorageHome = r.ov.revive(t.transformIncomingURIs(e.environment.workspaceStorageHome)), e.environment.extensionTelemetryLogResource = r.ov.revive(t.transformIncomingURIs(e.environment.extensionTelemetryLogResource)), e.nlsBaseUrl = r.ov.revive(t.transformIncomingURIs(e.nlsBaseUrl)), e.logsLocation = r.ov.revive(t.transformIncomingURIs(e.logsLocation)), e.workspace = t.transformIncomingURIs(e.workspace), e
                }
            }
        },
        DF9R: (e, t, i) => {
            i.d(t, {
                x: () => lo
            });
            var s = i("rJtg"),
                o = i("PUdK"),
                r = i("7icl"),
                n = i("RVdl"),
                a = i("PTqS"),
                c = i("R6K4"),
                d = i("naIR"),
                l = i("xxnL"),
                h = i("4kee"),
                u = i("9pA0"),
                p = i("PLiU"),
                m = i("6zxw"),
                g = i("ts6x"),
                v = i("7EzT"),
                _ = i("Vvlp"),
                f = i("LjkX"),
                y = i("hL8p"),
                w = i("t5JL"),
                x = i("YrcG"),
                b = i("7NN/");
            class D {
                constructor(e) {
                    this._relatedInformationProviders = new Map, this._nextHandle = 0, this._proxy = e.getProxy(x.Tr.MainThreadAiRelatedInformation)
                }
                async $provideAiRelatedInformation(e, t, i) {
                    if (0 === this._relatedInformationProviders.size) throw new Error("No related information providers registered");
                    const s = this._relatedInformationProviders.get(e);
                    if (!s) throw new Error("related information provider not found");
                    return await s.provideRelatedInformation(t, i) ? ? []
                }
                getRelatedInformation(e, t, i) {
                    return this._proxy.$getAiRelatedInformation(t, i)
                }
                registerRelatedInformationProvider(e, t, i) {
                    const s = this._nextHandle;
                    return this._nextHandle++, this._relatedInformationProviders.set(s, i), this._proxy.$registerAiRelatedInformationProvider(s, t), new b.JTr((() => {
                        this._proxy.$unregisterAiRelatedInformationProvider(s), this._relatedInformationProviders.delete(s)
                    }))
                }
            }
            var C = i("iDmX"),
                S = i("Oe9y"),
                E = i("UMYg"),
                P = i("U0fV"),
                T = i("0f12"),
                k = i("IqsH");
            const I = [new T.b9("vscode.executeDocumentHighlights", "_executeDocumentHighlights", "Execute document highlight provider.", [T.SF.Uri, T.SF.Position], new T._m("A promise that resolves to an array of DocumentHighlight-instances.", $(k.eh.to))), new T.b9("vscode.executeDocumentSymbolProvider", "_executeDocumentSymbolProvider", "Execute document symbol provider.", [T.SF.Uri], new T._m("A promise that resolves to an array of SymbolInformation and DocumentSymbol instances.", ((e, t) => {
                if (!(0, C.XY)(e)) {
                    class i extends b.JNW {
                        static to(e) {
                            const s = new i(e.name, k.cR.to(e.kind), e.containerName || "", new b.YeX(t[0], k.e6.to(e.range)));
                            return s.detail = e.detail, s.range = s.location.range, s.selectionRange = k.e6.to(e.selectionRange), s.children = e.children ? e.children.map(i.to) : [], s
                        }
                    }
                    return e.map(i.to)
                }
            }))), new T.b9("vscode.executeFormatDocumentProvider", "_executeFormatDocumentProvider", "Execute document format provider.", [T.SF.Uri, new T.SF("options", "Formatting options", (e => !0), (e => e))], new T._m("A promise that resolves to an array of TextEdits.", $(k.PY.to))), new T.b9("vscode.executeFormatRangeProvider", "_executeFormatRangeProvider", "Execute range format provider.", [T.SF.Uri, T.SF.Range, new T.SF("options", "Formatting options", (e => !0), (e => e))], new T._m("A promise that resolves to an array of TextEdits.", $(k.PY.to))), new T.b9("vscode.executeFormatOnTypeProvider", "_executeFormatOnTypeProvider", "Execute format on type provider.", [T.SF.Uri, T.SF.Position, new T.SF("ch", "Trigger character", (e => "string" == typeof e), (e => e)), new T.SF("options", "Formatting options", (e => !0), (e => e))], new T._m("A promise that resolves to an array of TextEdits.", $(k.PY.to))), new T.b9("vscode.executeDefinitionProvider", "_executeDefinitionProvider", "Execute all definition providers.", [T.SF.Uri, T.SF.Position], new T._m("A promise that resolves to an array of Location or LocationLink instances.", R)), new T.b9("vscode.executeTypeDefinitionProvider", "_executeTypeDefinitionProvider", "Execute all type definition providers.", [T.SF.Uri, T.SF.Position], new T._m("A promise that resolves to an array of Location or LocationLink instances.", R)), new T.b9("vscode.executeDeclarationProvider", "_executeDeclarationProvider", "Execute all declaration providers.", [T.SF.Uri, T.SF.Position], new T._m("A promise that resolves to an array of Location or LocationLink instances.", R)), new T.b9("vscode.executeImplementationProvider", "_executeImplementationProvider", "Execute all implementation providers.", [T.SF.Uri, T.SF.Position], new T._m("A promise that resolves to an array of Location or LocationLink instances.", R)), new T.b9("vscode.executeReferenceProvider", "_executeReferenceProvider", "Execute all reference providers.", [T.SF.Uri, T.SF.Position], new T._m("A promise that resolves to an array of Location-instances.", $(k.xh.to))), new T.b9("vscode.executeHoverProvider", "_executeHoverProvider", "Execute all hover providers.", [T.SF.Uri, T.SF.Position], new T._m("A promise that resolves to an array of Hover-instances.", $(k.TM.to))), new T.b9("vscode.executeSelectionRangeProvider", "_executeSelectionRangeProvider", "Execute selection range provider.", [T.SF.Uri, new T.SF("position", "A position in a text document", (e => Array.isArray(e) && e.every((e => b.Lyo.isPosition(e)))), (e => e.map(k.Ly.from)))], new T._m("A promise that resolves to an array of ranges.", (e => e.map((e => {
                let t;
                for (const i of e.reverse()) t = new b.xm7(k.e6.to(i), t);
                return t
            }))))), new T.b9("vscode.executeWorkspaceSymbolProvider", "_executeWorkspaceSymbolProvider", "Execute all workspace symbol providers.", [T.SF.String.with("query", "Search string")], new T._m("A promise that resolves to an array of SymbolInformation-instances.", (e => e.map(k.$P.to)))), new T.b9("vscode.prepareCallHierarchy", "_executePrepareCallHierarchy", "Prepare call hierarchy at a position inside a document", [T.SF.Uri, T.SF.Position], new T._m("A promise that resolves to an array of CallHierarchyItem-instances", (e => e.map(k.ll.to)))), new T.b9("vscode.provideIncomingCalls", "_executeProvideIncomingCalls", "Compute incoming calls for an item", [T.SF.CallHierarchyItem], new T._m("A promise that resolves to an array of CallHierarchyIncomingCall-instances", (e => e.map(k.MP.to)))), new T.b9("vscode.provideOutgoingCalls", "_executeProvideOutgoingCalls", "Compute outgoing calls for an item", [T.SF.CallHierarchyItem], new T._m("A promise that resolves to an array of CallHierarchyOutgoingCall-instances", (e => e.map(k.RV.to)))), new T.b9("vscode.prepareRename", "_executePrepareRename", "Execute the prepareRename of rename provider.", [T.SF.Uri, T.SF.Position], new T._m("A promise that resolves to a range and placeholder text.", (e => {
                if (e) return {
                    range: k.e6.to(e.range),
                    placeholder: e.text
                }
            }))), new T.b9("vscode.executeDocumentRenameProvider", "_executeDocumentRenameProvider", "Execute rename provider.", [T.SF.Uri, T.SF.Position, T.SF.String.with("newName", "The new symbol name")], new T._m("A promise that resolves to a WorkspaceEdit.", (e => {
                if (e) {
                    if (e.rejectReason) throw new Error(e.rejectReason);
                    return k.Db.to(e)
                }
            }))), new T.b9("vscode.executeLinkProvider", "_executeLinkProvider", "Execute document link provider.", [T.SF.Uri, T.SF.Number.with("linkResolveCount", "Number of links that should be resolved, only when links are unresolved.").optional()], new T._m("A promise that resolves to an array of DocumentLink-instances.", (e => e.map(k.jW.to)))), new T.b9("vscode.provideDocumentSemanticTokensLegend", "_provideDocumentSemanticTokensLegend", "Provide semantic tokens legend for a document", [T.SF.Uri], new T._m("A promise that resolves to SemanticTokensLegend.", (e => {
                if (e) return new b.Pts(e.tokenTypes, e.tokenModifiers)
            }))), new T.b9("vscode.provideDocumentSemanticTokens", "_provideDocumentSemanticTokens", "Provide semantic tokens for a document", [T.SF.Uri], new T._m("A promise that resolves to SemanticTokens.", (e => {
                if (!e) return;
                const t = (0, E.O)(e);
                return "full" === t.type ? new b.Uzh(t.data, void 0) : void 0
            }))), new T.b9("vscode.provideDocumentRangeSemanticTokensLegend", "_provideDocumentRangeSemanticTokensLegend", "Provide semantic tokens legend for a document range", [T.SF.Uri, T.SF.Range.optional()], new T._m("A promise that resolves to SemanticTokensLegend.", (e => {
                if (e) return new b.Pts(e.tokenTypes, e.tokenModifiers)
            }))), new T.b9("vscode.provideDocumentRangeSemanticTokens", "_provideDocumentRangeSemanticTokens", "Provide semantic tokens for a document range", [T.SF.Uri, T.SF.Range], new T._m("A promise that resolves to SemanticTokens.", (e => {
                if (!e) return;
                const t = (0, E.O)(e);
                return "full" === t.type ? new b.Uzh(t.data, void 0) : void 0
            }))), new T.b9("vscode.executeCompletionItemProvider", "_executeCompletionItemProvider", "Execute completion item provider.", [T.SF.Uri, T.SF.Position, T.SF.String.with("triggerCharacter", "Trigger completion when the user types the character, like `,` or `(`").optional(), T.SF.Number.with("itemResolveCount", "Number of completions to resolve (too large numbers slow down completions)").optional()], new T._m("A promise that resolves to a CompletionList-instance.", ((e, t, i) => {
                if (!e) return new b.Ub$([]);
                const s = e.suggestions.map((e => k.FG.to(e, i)));
                return new b.Ub$(s, e.incomplete)
            }))), new T.b9("vscode.executeSignatureHelpProvider", "_executeSignatureHelpProvider", "Execute signature help provider.", [T.SF.Uri, T.SF.Position, T.SF.String.with("triggerCharacter", "Trigger signature help when the user types the character, like `,` or `(`").optional()], new T._m("A promise that resolves to SignatureHelp.", (e => {
                if (e) return k.vy.to(e)
            }))), new T.b9("vscode.executeCodeLensProvider", "_executeCodeLensProvider", "Execute code lens provider.", [T.SF.Uri, T.SF.Number.with("itemResolveCount", "Number of lenses that should be resolved and returned. Will only return resolved lenses, will impact performance)").optional()], new T._m("A promise that resolves to an array of CodeLens-instances.", ((e, t, i) => $((e => new b.JFR(k.e6.to(e.range), e.command && i.fromInternal(e.command))))(e)))), new T.b9("vscode.executeCodeActionProvider", "_executeCodeActionProvider", "Execute code action provider.", [T.SF.Uri, new T.SF("rangeOrSelection", "Range in a text document. Some refactoring provider requires Selection object.", (e => b.e6w.isRange(e)), (e => b.Y19.isSelection(e) ? k.Y1.from(e) : k.e6.from(e))), T.SF.String.with("kind", "Code action kind to return code actions for").optional(), T.SF.Number.with("itemResolveCount", "Number of code actions to resolve (too large numbers slow down code actions)").optional()], new T._m("A promise that resolves to an array of Command-instances.", ((e, t, i) => $((e => {
                if (e._isSynthetic) {
                    if (!e.command) throw new Error("Synthetic code actions must have a command");
                    return i.fromInternal(e.command)
                } {
                    const t = new b.B2n(e.title, e.kind ? new b.yNd(e.kind) : void 0);
                    return e.edit && (t.edit = k.Db.to(e.edit)), e.command && (t.command = i.fromInternal(e.command)), t.isPreferred = e.isPreferred, t
                }
            }))(e)))), new T.b9("vscode.executeDocumentColorProvider", "_executeDocumentColorProvider", "Execute document color provider.", [T.SF.Uri], new T._m("A promise that resolves to an array of ColorInformation objects.", (e => e ? e.map((e => new b.pr0(k.e6.to(e.range), k.Il.to(e.color)))) : []))), new T.b9("vscode.executeColorPresentationProvider", "_executeColorPresentationProvider", "Execute color presentation provider.", [new T.SF("color", "The color to show and insert", (e => e instanceof b.Ilk), k.Il.from), new T.SF("context", "Context object with uri and range", (e => !0), (e => ({
                uri: e.uri,
                range: k.e6.from(e.range)
            })))], new T._m("A promise that resolves to an array of ColorPresentation objects.", (e => e ? e.map(k.oi.to) : []))), new T.b9("vscode.executeInlayHintProvider", "_executeInlayHintProvider", "Execute inlay hints provider", [T.SF.Uri, T.SF.Range], new T._m("A promise that resolves to an array of Inlay objects", ((e, t, i) => e.map(k.t7.to.bind(void 0, i))))), new T.b9("vscode.executeFoldingRangeProvider", "_executeFoldingRangeProvider", "Execute folding range provider", [T.SF.Uri], new T._m("A promise that resolves to an array of FoldingRange objects", ((e, t) => {
                if (e) return e.map(k.so.to)
            }))), new T.b9("vscode.resolveNotebookContentProviders", "_resolveNotebookContentProvider", "Resolve Notebook Content Providers", [], new T._m("A promise that resolves to an array of NotebookContentProvider static info objects.", $((e => ({
                viewType: e.viewType,
                displayName: e.displayName,
                options: {
                    transientOutputs: e.options.transientOutputs,
                    transientCellMetadata: e.options.transientCellMetadata,
                    transientDocumentMetadata: e.options.transientDocumentMetadata
                },
                filenamePattern: e.filenamePattern.map((e => k.wN.to(e)))
            }))))), new T.b9("vscode.executeInlineValueProvider", "_executeInlineValueProvider", "Execute inline value provider", [T.SF.Uri, T.SF.Range, new T.SF("context", "An InlineValueContext", (e => e && "number" == typeof e.frameId && e.stoppedLocation instanceof b.e6w), (e => k.GS.from(e)))], new T._m("A promise that resolves to an array of InlineValue objects", (e => e.map(k.CR.to)))), new T.b9("vscode.open", "_workbench.open", "Opens the provided resource in the editor. Can be a text or binary file, or an http(s) URL. If you need more control over the options for opening a text file, use vscode.window.showTextDocument instead.", [new T.SF("uriOrString", "Uri-instance or string (only http/https)", (e => d.ov.isUri(e) || "string" == typeof e && (0, a.Gs)(e, a.lg.http, a.lg.https)), (e => e)), new T.SF("columnOrOptions", "Either the column in which to open or editor options, see vscode.TextDocumentShowOptions", (e => void 0 === e || "number" == typeof e || "object" == typeof e), (e => e ? "number" == typeof e ? [k.eI.from(e), void 0] : [k.eI.from(e.viewColumn), k.P5.from(e)] : e)).optional(), T.SF.String.with("label", "").optional()], T._m.Void), new T.b9("vscode.openWith", "_workbench.openWith", "Opens the provided resource with a specific editor.", [T.SF.Uri.with("resource", "Resource to open"), T.SF.String.with("viewId", "Custom editor view id. This should be the viewType string for custom editors or the notebookType string for notebooks. Use 'default' to use VS Code's default text editor"), new T.SF("columnOrOptions", "Either the column in which to open or editor options, see vscode.TextDocumentShowOptions", (e => void 0 === e || "number" == typeof e || "object" == typeof e), (e => e ? "number" == typeof e ? [k.eI.from(e), void 0] : [k.eI.from(e.viewColumn), k.P5.from(e)] : e)).optional()], T._m.Void), new T.b9("vscode.diff", "_workbench.diff", "Opens the provided resources in the diff editor to compare their contents.", [T.SF.Uri.with("left", "Left-hand side resource of the diff editor"), T.SF.Uri.with("right", "Right-hand side resource of the diff editor"), T.SF.String.with("title", "Human readable title for the diff editor").optional(), new T.SF("columnOrOptions", "Either the column in which to open or editor options, see vscode.TextDocumentShowOptions", (e => void 0 === e || "object" == typeof e), (e => e && [k.eI.from(e.viewColumn), k.P5.from(e)])).optional()], T._m.Void), new T.b9("vscode.changes", "_workbench.changes", "Opens a list of resources in the changes editor to compare their contents.", [T.SF.String.with("title", "Human readable title for the changes editor"), new T.SF("resourceList", "List of resources to compare", (e => {
                for (const t of e) {
                    if (3 !== t.length) return !1;
                    const [e, i, s] = t;
                    if (!d.ov.isUri(e) || !d.ov.isUri(i) && null != i || !d.ov.isUri(s) && null != s) return !1
                }
                return !0
            }), (e => e))], T._m.Void), new T.b9("vscode.prepareTypeHierarchy", "_executePrepareTypeHierarchy", "Prepare type hierarchy at a position inside a document", [T.SF.Uri, T.SF.Position], new T._m("A promise that resolves to an array of TypeHierarchyItem-instances", (e => e.map(k.fQ.to)))), new T.b9("vscode.provideSupertypes", "_executeProvideSupertypes", "Compute supertypes for an item", [T.SF.TypeHierarchyItem], new T._m("A promise that resolves to an array of TypeHierarchyItem-instances", (e => e.map(k.fQ.to)))), new T.b9("vscode.provideSubtypes", "_executeProvideSubtypes", "Compute subtypes for an item", [T.SF.TypeHierarchyItem], new T._m("A promise that resolves to an array of TypeHierarchyItem-instances", (e => e.map(k.fQ.to)))), new T.b9("vscode.revealTestInExplorer", "_revealTestInExplorer", "Reveals a test instance in the explorer", [T.SF.TestItem], T._m.Void), new T.b9("vscode.experimental.editSession.continue", "_workbench.editSessions.actions.continueEditSession", "Continue the current edit session in a different workspace", [T.SF.Uri.with("workspaceUri", "The target workspace to continue the current edit session in")], T._m.Void), new T.b9("setContext", "_setContext", "Set a custom context key value that can be used in when clauses.", [T.SF.String.with("name", "The context key name"), new T.SF("value", "The context key value", (() => !0), (e => e))], T._m.Void), new T.b9("vscode.executeMappedEditsProvider", "_executeMappedEditsProvider", "Execute Mapped Edits Provider", [T.SF.Uri, T.SF.StringArray, new T.SF("MappedEditsContext", "Mapped Edits Context", (e => k.OU.is(e)), (e => k.OU.from(e)))], new T._m("A promise that resolves to a workspace edit or null", (e => e ? k.Db.to(e) : null))), new T.b9("vscode.editorChat.start", "inlineChat.start", "Invoke a new editor chat session", [new T.SF("Run arguments", "", (e => !0), (e => {
                if (e) return {
                    initialRange: e.initialRange ? k.e6.from(e.initialRange) : void 0,
                    initialSelection: b.Y19.isSelection(e.initialSelection) ? k.Y1.from(e.initialSelection) : void 0,
                    message: e.message,
                    autoSend: e.autoSend,
                    position: e.position ? k.Ly.from(e.position) : void 0
                }
            }))], T._m.Void)];
            class A {
                static register(e) {
                    I.forEach(e.registerApiCommand, e), this._registerValidateWhenClausesCommand(e)
                }
                static _registerValidateWhenClausesCommand(e) {
                    e.registerCommand(!1, "_validateWhenClauses", P.iw)
                }
            }

            function $(e) {
                return t => {
                    if (Array.isArray(t)) return t.map(e)
                }
            }

            function R(e) {
                if (!Array.isArray(e)) return;
                const t = [];
                for (const i of e)(0, S.vx)(i) ? t.push(k.nc.to(i)) : t.push(k.xh.to(i));
                return t
            }
            var H = i("jTbC"),
                F = i("ZXjZ"),
                N = i("t5wJ"),
                M = i("Ayc8"),
                L = i("43lI");
            let O = class {
                constructor(e, t) {
                    this._proxy = e.getProxy(x.Tr.MainThreadBulkEdits), this._versionInformationProvider = {
                        getTextDocumentVersion: e => t.getDocument(e) ? .version,
                        getNotebookDocumentVersion: () => {}
                    }
                }
                applyWorkspaceEdit(e, t, i) {
                    const s = new L.ky(k.Db.from(e, this._versionInformationProvider));
                    return this._proxy.$tryApplyWorkspaceEdit(s, void 0, i ? .isRefactoring ? ? !1)
                }
            };
            O = (0, N.g)([(0, N.f)(0, M.O)], O);
            var U = i("opu4"),
                V = i("R1fN"),
                W = i("wBFb"),
                B = i("V2Gl"),
                z = i("K30K"),
                j = i("kzVZ"),
                q = i("LE1I");
            class K {
                constructor(e, t, i, s, o) {
                    this._extension = e, this._request = t, this._proxy = i, this._commandsConverter = s, this._sessionDisposables = o, this._stopWatch = B.G.create(!1), this._isClosed = !1
                }
                close() {
                    this._isClosed = !0
                }
                get timings() {
                    return {
                        firstProgress: this._firstProgress,
                        totalElapsed: this._stopWatch.elapsed()
                    }
                }
                get apiObject() {
                    if (!this._apiObject) {
                        const e = this;

                        function t(t) {
                            if (e._isClosed) {
                                const e = new Error("Response stream has been closed");
                                throw Error.captureStackTrace(e, t), e
                            }
                        }
                        this._stopWatch.reset();
                        const i = (e, t) => {
                            if (void 0 === this._firstProgress && "content" in e && (this._firstProgress = this._stopWatch.elapsed()), t) {
                                const i = this._proxy.$handleProgressChunk(this._request.requestId, e),
                                    s = {
                                        report: e => {
                                            i ? .then((t => {
                                                t && (b.W5C.isMarkdownString(e.value) ? this._proxy.$handleProgressChunk(this._request.requestId, k.fk.from(e), t) : this._proxy.$handleProgressChunk(this._request.requestId, k.Ht.from(e), t))
                                            }))
                                        }
                                    };
                                Promise.all([i, t ? .(s)]).then((([e, t]) => {
                                    void 0 !== e && void 0 !== t && this._proxy.$handleProgressChunk(this._request.requestId, k.cq.from(t), e)
                                }))
                            } else this._proxy.$handleProgressChunk(this._request.requestId, e)
                        };
                        this._apiObject = {
                            markdown(e) {
                                t(this.markdown);
                                const s = new b.HYr(e),
                                    o = k.HY.from(s);
                                return i(o), this
                            },
                            markdownWithVulnerabilities(s, o) {
                                t(this.markdown), o && (0, q.H5)(e._extension, "chatParticipantAdditions");
                                const r = new b.Zgy(s, o),
                                    n = k.Zg.from(r);
                                return i(n), this
                            },
                            filetree(e, s) {
                                t(this.filetree);
                                const o = new b.Y08(e, s),
                                    r = k.ZJ.from(o);
                                return i(r), this
                            },
                            anchor(e, s) {
                                t(this.anchor);
                                const o = new b.trJ(e, s),
                                    r = k.tr.from(o);
                                return i(r), this
                            },
                            button(s) {
                                t(this.anchor);
                                const o = new b.WTw(s),
                                    r = k.WT.from(o, e._commandsConverter, e._sessionDisposables);
                                return i(r), this
                            },
                            progress(e, s) {
                                t(this.progress);
                                const o = new b.meY(e, s),
                                    r = s ? k.JL.from(o) : k.Gl.from(o);
                                return i(r, s), this
                            },
                            warning(s) {
                                t(this.progress), (0, q.H5)(e._extension, "chatParticipantAdditions");
                                const o = new b.fkf(s),
                                    r = k.fk.from(o);
                                return i(r), this
                            },
                            reference(s, o) {
                                if (t(this.reference), "variableName" in s && (0, q.H5)(e._extension, "chatParticipantAdditions"), "variableName" in s && !s.value) {
                                    const t = e._request.variables.variables.find((e => e.name === s.variableName));
                                    if (t) {
                                        let e;
                                        if (t.references ? .length) e = t.references.map((e => ({
                                            kind: "reference",
                                            reference: {
                                                variableName: s.variableName,
                                                value: e.reference
                                            }
                                        })));
                                        else {
                                            const t = new b.Ht3(s, o);
                                            e = [k.Ht.from(t)]
                                        }
                                        return e.forEach((e => i(e))), this
                                    }
                                } else {
                                    const e = new b.Ht3(s, o),
                                        t = k.Ht.from(e);
                                    i(t)
                                }
                                return this
                            },
                            textEdit(s, o) {
                                t(this.textEdit), (0, q.H5)(e._extension, "chatParticipantAdditions");
                                const r = new b.cGf(s, o),
                                    n = k.cG.from(r);
                                return i(n), this
                            },
                            detectedParticipant(s, o) {
                                t(this.detectedParticipant), (0, q.H5)(e._extension, "chatParticipantAdditions");
                                const r = new b.s8P(s, o),
                                    n = k.s8.from(r);
                                return i(n), this
                            },
                            confirmation(s, o, r) {
                                t(this.confirmation), (0, q.H5)(e._extension, "chatParticipantAdditions");
                                const n = new b.Ik8(s, o, r),
                                    a = k.Ik.from(n);
                                return i(a), this
                            },
                            push(s) {
                                if (t(this.push), (s instanceof b.cGf || s instanceof b.Zgy || s instanceof b.s8P || s instanceof b.fkf || s instanceof b.Ik8) && (0, q.H5)(e._extension, "chatParticipantAdditions"), s instanceof b.Ht3) this.reference(s.value, s.iconPath);
                                else {
                                    const t = k.Sm.from(s, e._commandsConverter, e._sessionDisposables);
                                    i(t)
                                }
                                return this
                            }
                        }
                    }
                    return this._apiObject
                }
            }
            class J extends n.JT {
                static {
                    this._idPool = 0
                }
                constructor(e, t, i) {
                    super(), this._logService = t, this.commands = i, this._agents = new Map, this._sessionDisposables = this._register(new n.b2), this._completionDisposables = this._register(new n.b2), this._proxy = e.getProxy(x.Tr.MainThreadChatAgents2)
                }
                transferActiveChat(e) {
                    this._proxy.$transferActiveChatSession(e)
                }
                createChatAgent(e, t, i) {
                    const s = J._idPool++,
                        o = new G(e, t, this._proxy, s, i);
                    return this._agents.set(s, o), this._proxy.$registerAgent(s, e.identifier, t, {}, void 0), o.apiAgent
                }
                createDynamicChatAgent(e, t, i, s) {
                    const o = J._idPool++,
                        r = new G(e, t, this._proxy, o, s);
                    return this._agents.set(o, r), this._proxy.$registerAgent(o, e.identifier, t, {
                        isSticky: !0
                    }, i), r.apiAgent
                }
                async $invokeAgent(e, t, i, s) {
                    const o = this._agents.get(e);
                    if (!o) throw new Error(`[CHAT](${e}) CANNOT invoke agent because the agent is not registered`);
                    let r = this._sessionDisposables.get(t.sessionId);
                    r || (r = new n.SL, this._sessionDisposables.set(t.sessionId, r));
                    const a = new K(o.extension, t, this._proxy, this.commands.converter, r);
                    try {
                        const e = await this.prepareHistoryTurns(t.agentId, i),
                            r = o.invoke(k.TU.to(t), {
                                history: e
                            }, a.apiObject, s);
                        return await (0, U.eP)(Promise.resolve(r).then((e => {
                            if (e ? .metadata) try {
                                JSON.stringify(e.metadata)
                            } catch (e) {
                                const t = `result.metadata MUST be JSON.stringify-able. Got error: ${e.message}`;
                                return this._logService.error(`[${o.extension.identifier.value}] [@${o.id}] ${t}`, o.extension), {
                                    errorDetails: {
                                        message: t
                                    },
                                    timings: a.timings
                                }
                            }
                            let t;
                            return e ? .errorDetails && (t = { ...e.errorDetails,
                                responseIsIncomplete: !0
                            }), t ? .responseIsRedacted && (0, q.H5)(o.extension, "chatParticipantPrivate"), {
                                errorDetails: t,
                                timings: a.timings,
                                metadata: e ? .metadata
                            }
                        })), s)
                    } catch (e) {
                        return this._logService.error(e, o.extension), e instanceof b.tHl && e.cause && (e = e.cause), {
                            errorDetails: {
                                message: (0, V.yJ)(e),
                                responseIsIncomplete: !0
                            }
                        }
                    } finally {
                        a.close()
                    }
                }
                async prepareHistoryTurns(e, t) {
                    const i = [];
                    for (const s of t.history) {
                        const t = k.hq.to(s.result),
                            o = e === s.request.agentId ? t : { ...t,
                                metadata: void 0
                            };
                        i.push(new b.eg0(s.request.message, s.request.command, s.request.variables.variables.map(k.IE.to), s.request.agentId));
                        const r = (0, C.kX)(s.response.map((e => k.Sm.toContent(e, this.commands.converter))));
                        i.push(new b.IQN(r, o, s.request.agentId, s.request.command))
                    }
                    return i
                }
                $releaseSession(e) {
                    this._sessionDisposables.deleteAndDispose(e)
                }
                async $provideFollowups(e, t, i, s, o) {
                    const r = this._agents.get(t);
                    if (!r) return Promise.resolve([]);
                    const n = await this.prepareHistoryTurns(r.id, s),
                        a = k.hq.to(i);
                    return (await r.provideFollowups(a, {
                        history: n
                    }, o)).filter((e => {
                        const t = !e.participant || W.$.some(this._agents.values(), (t => t.id === e.participant && m.kP.equals(t.extension.identifier, r.extension.identifier)));
                        return t || this._logService.warn(`[@${r.id}] ChatFollowup refers to an unknown participant: ${e.participant}`), t
                    })).map((t => k.a8.from(t, e)))
                }
                $acceptFeedback(e, t, i, s) {
                    const o = this._agents.get(e);
                    if (!o) return;
                    const r = k.hq.to(t);
                    let n;
                    switch (i) {
                        case j.uV.Down:
                            n = b.u8m.Unhelpful;
                            break;
                        case j.uV.Up:
                            n = b.u8m.Helpful
                    }
                    o.acceptFeedback(s ? Object.freeze({
                        result: r,
                        kind: n,
                        reportIssue: s
                    }) : Object.freeze({
                        result: r,
                        kind: n
                    }))
                }
                $acceptAction(e, t, i) {
                    const s = this._agents.get(e);
                    if (!s) return;
                    if ("vote" === i.action.kind) return;
                    const o = k.$l.to(t, i, this.commands.converter);
                    o && s.acceptAction(Object.freeze(o))
                }
                async $invokeCompletionProvider(e, t, i) {
                    const s = this._agents.get(e);
                    if (!s) return [];
                    let o = this._completionDisposables.get(e);
                    return o ? o.clear() : (o = new n.SL, this._completionDisposables.set(e, o)), (await s.invokeCompletionProvider(t, i)).map((e => k.e5.from(e, this.commands.converter, o)))
                }
                async $provideWelcomeMessage(e, t, i) {
                    const s = this._agents.get(e);
                    if (s) return await s.provideWelcomeMessage(k.oY.to(t), i)
                }
                async $provideSampleQuestions(e, t, i) {
                    const s = this._agents.get(e);
                    if (s) return (await s.provideSampleQuestions(k.oY.to(t), i)).map((e => k.a8.from(e, void 0)))
                }
            }
            class G {
                constructor(e, t, i, s, o) {
                    this.extension = e, this.id = t, this._proxy = i, this._handle = s, this._requestHandler = o, this._onDidReceiveFeedback = new r.Q5, this._onDidPerformAction = new r.Q5
                }
                acceptFeedback(e) {
                    this._onDidReceiveFeedback.fire(e)
                }
                acceptAction(e) {
                    this._onDidPerformAction.fire(e)
                }
                async invokeCompletionProvider(e, t) {
                    return this._agentVariableProvider ? await this._agentVariableProvider.provider.provideCompletionItems(e, t) ? ? [] : []
                }
                async provideFollowups(e, t, i) {
                    if (!this._followupProvider) return [];
                    const s = await this._followupProvider.provideFollowups(e, t, i);
                    return s ? s.filter((e => !(e && "commandId" in e))).filter((e => !(e && "message" in e))) : []
                }
                async provideWelcomeMessage(e, t) {
                    if (!this._welcomeMessageProvider) return [];
                    const i = await this._welcomeMessageProvider.provideWelcomeMessage(e, t);
                    return i ? i.map((e => "string" == typeof e ? e : k.W5.from(e))) : []
                }
                async provideSampleQuestions(e, t) {
                    if (!this._welcomeMessageProvider || !this._welcomeMessageProvider.provideSampleQuestions) return [];
                    return await this._welcomeMessageProvider.provideSampleQuestions(e, t) || []
                }
                get apiAgent() {
                    let e = !1,
                        t = !1;
                    const i = () => {
                            e || t || (t = !0, queueMicrotask((() => {
                                this._proxy.$updateAgent(this._handle, {
                                    icon: this._iconPath ? this._iconPath instanceof d.ov ? this._iconPath : "light" in this._iconPath ? this._iconPath.light : void 0 : void 0,
                                    iconDark: this._iconPath && "dark" in this._iconPath ? this._iconPath.dark : void 0,
                                    themeIcon: this._iconPath instanceof b.kS8 ? this._iconPath : void 0,
                                    hasFollowups: void 0 !== this._followupProvider,
                                    isSecondary: this._isSecondary,
                                    helpTextPrefix: this._helpTextPrefix && "string" != typeof this._helpTextPrefix ? k.W5.from(this._helpTextPrefix) : this._helpTextPrefix,
                                    helpTextVariablesPrefix: this._helpTextVariablesPrefix && "string" != typeof this._helpTextVariablesPrefix ? k.W5.from(this._helpTextVariablesPrefix) : this._helpTextVariablesPrefix,
                                    helpTextPostfix: this._helpTextPostfix && "string" != typeof this._helpTextPostfix ? k.W5.from(this._helpTextPostfix) : this._helpTextPostfix,
                                    supportIssueReporting: this._supportIssueReporting,
                                    requester: this._requester,
                                    supportsSlowVariables: this._supportsSlowReferences
                                }), t = !1
                            })))
                        },
                        s = this;
                    return {
                        get id() {
                            return s.id
                        },
                        get iconPath() {
                            return s._iconPath
                        },
                        set iconPath(e) {
                            s._iconPath = e, i()
                        },
                        get requestHandler() {
                            return s._requestHandler
                        },
                        set requestHandler(e) {
                            (0, z.p_)("function" == typeof e, "Invalid request handler"), s._requestHandler = e
                        },
                        get followupProvider() {
                            return s._followupProvider
                        },
                        set followupProvider(e) {
                            s._followupProvider = e, i()
                        },
                        get isDefault() {
                            return (0, q.H5)(s.extension, "defaultChatParticipant"), s._isDefault
                        },
                        set isDefault(e) {
                            (0, q.H5)(s.extension, "defaultChatParticipant"), s._isDefault = e, i()
                        },
                        get helpTextPrefix() {
                            return (0, q.H5)(s.extension, "defaultChatParticipant"), s._helpTextPrefix
                        },
                        set helpTextPrefix(e) {
                            (0, q.H5)(s.extension, "defaultChatParticipant"), s._helpTextPrefix = e, i()
                        },
                        get helpTextVariablesPrefix() {
                            return (0, q.H5)(s.extension, "defaultChatParticipant"), s._helpTextVariablesPrefix
                        },
                        set helpTextVariablesPrefix(e) {
                            (0, q.H5)(s.extension, "defaultChatParticipant"), s._helpTextVariablesPrefix = e, i()
                        },
                        get helpTextPostfix() {
                            return (0, q.H5)(s.extension, "defaultChatParticipant"), s._helpTextPostfix
                        },
                        set helpTextPostfix(e) {
                            (0, q.H5)(s.extension, "defaultChatParticipant"), s._helpTextPostfix = e, i()
                        },
                        get isSecondary() {
                            return (0, q.H5)(s.extension, "defaultChatParticipant"), s._isSecondary
                        },
                        set isSecondary(e) {
                            (0, q.H5)(s.extension, "defaultChatParticipant"), s._isSecondary = e, i()
                        },
                        get supportIssueReporting() {
                            return (0, q.H5)(s.extension, "chatParticipantPrivate"), s._supportIssueReporting
                        },
                        set supportIssueReporting(e) {
                            (0, q.H5)(s.extension, "chatParticipantPrivate"), s._supportIssueReporting = e, i()
                        },
                        get onDidReceiveFeedback() {
                            return s._onDidReceiveFeedback.event
                        },
                        set participantVariableProvider(e) {
                            if ((0, q.H5)(s.extension, "chatParticipantAdditions"), s._agentVariableProvider = e, e) {
                                if (!e.triggerCharacters.length) throw new Error("triggerCharacters are required");
                                s._proxy.$registerAgentCompletionsProvider(s._handle, s.id, e.triggerCharacters)
                            } else s._proxy.$unregisterAgentCompletionsProvider(s._handle, s.id)
                        },
                        get participantVariableProvider() {
                            return (0, q.H5)(s.extension, "chatParticipantAdditions"), s._agentVariableProvider
                        },
                        set welcomeMessageProvider(e) {
                            (0, q.H5)(s.extension, "defaultChatParticipant"), s._welcomeMessageProvider = e, i()
                        },
                        get welcomeMessageProvider() {
                            return (0, q.H5)(s.extension, "defaultChatParticipant"), s._welcomeMessageProvider
                        },
                        onDidPerformAction: (0, q.$x)(this.extension, "chatParticipantAdditions") ? this._onDidPerformAction.event : void 0,
                        set requester(e) {
                            s._requester = e, i()
                        },
                        get requester() {
                            return s._requester
                        },
                        set supportsSlowReferences(e) {
                            (0, q.H5)(s.extension, "chatParticipantPrivate"), s._supportsSlowReferences = e, i()
                        },
                        get supportsSlowReferences() {
                            return (0, q.H5)(s.extension, "chatParticipantPrivate"), s._supportsSlowReferences
                        },
                        dispose() {
                            e = !0, s._followupProvider = void 0, s._onDidReceiveFeedback.dispose(), s._proxy.$unregisterAgent(s._handle)
                        }
                    }
                }
                invoke(e, t, i, s) {
                    return this._requestHandler(e, t, i, s)
                }
            }
            var Q = i("6JmM");
            class Z {
                static {
                    this._idPool = 0
                }
                constructor(e) {
                    this._resolver = new Map, this._proxy = e.getProxy(x.Tr.MainThreadChatVariables)
                }
                async $resolveVariable(e, t, i, s) {
                    const r = this._resolver.get(e);
                    if (r) try {
                        if (r.resolver.resolve2) {
                            (0, q.H5)(r.extension, "chatParticipantAdditions");
                            const e = new Y(t, this._proxy),
                                o = await r.resolver.resolve2(r.data.name, {
                                    prompt: i
                                }, e.apiObject, s);
                            if (o && o[0]) return o[0].value
                        } else {
                            const e = await r.resolver.resolve(r.data.name, {
                                prompt: i
                            }, s);
                            if (e && e[0]) return e[0].value
                        }
                    } catch (e) {
                        (0, o.Cp)(e)
                    }
                }
                registerVariableResolver(e, t, i, s, o, r, a, c, d) {
                    const l = Z._idPool++,
                        h = d ? Q.kS.fromId(d) : void 0;
                    return this._resolver.set(l, {
                        extension: e,
                        data: {
                            id: t,
                            name: i,
                            description: s,
                            modelDescription: o,
                            icon: h
                        },
                        resolver: a
                    }), this._proxy.$registerVariable(l, {
                        id: t,
                        name: i,
                        description: s,
                        modelDescription: o,
                        isSlow: r,
                        fullName: c,
                        icon: h
                    }), (0, n.OF)((() => {
                        this._resolver.delete(l), this._proxy.$unregisterVariable(l)
                    }))
                }
            }
            class Y {
                constructor(e, t) {
                    this._requestId = e, this._proxy = t, this._isClosed = !1
                }
                close() {
                    this._isClosed = !0
                }
                get apiObject() {
                    if (!this._apiObject) {
                        const e = this;

                        function t(t) {
                            if (e._isClosed) {
                                const e = new Error("Response stream has been closed");
                                throw Error.captureStackTrace(e, t), e
                            }
                        }
                        const i = e => {
                            this._proxy.$handleProgressChunk(this._requestId, e)
                        };
                        this._apiObject = {
                            progress(e) {
                                t(this.progress);
                                const s = new b.Gli(e),
                                    o = k.Gl.from(s);
                                return i(o), this
                            },
                            reference(e) {
                                t(this.reference);
                                const s = new b.Ht3(e),
                                    o = k.Ht.from(s);
                                return i(o), this
                            },
                            push(e) {
                                return t(this.push), e instanceof b.Ht3 ? i(k.Ht.from(e)) : e instanceof b.Gli && i(k.Gl.from(e)), this
                            }
                        }
                    }
                    return this._apiObject
                }
            }
            class X {
                constructor(e) {
                    const t = e.getProxy(x.Tr.MainThreadClipboard);
                    this.value = Object.freeze({
                        readText: () => t.$readText(),
                        writeText: e => t.$writeText(e)
                    })
                }
            }
            var ee = i("U7Xe");
            const te = "vscode-cdn.net",
                ie = `vscode-resource.${te}`,
                se = `'self' https://*.${te}`;

            function oe(e, t) {
                return e.scheme === a.lg.http || e.scheme === a.lg.https ? e : (t && t.authority && t.isRemote && e.scheme === a.lg.file && (e = d.ov.from({
                    scheme: a.lg.vscodeRemote,
                    authority: t.authority,
                    path: e.path
                })), d.ov.from({
                    scheme: a.lg.https,
                    authority: `${e.scheme}+${i=e.authority,i.replace(/./g,(e=>{const t=e.charCodeAt(0);return t>=ee.m.a&&t<=ee.m.z||t>=ee.m.A&&t<=ee.m.Z||t>=ee.m.Digit0&&t<=ee.m.Digit9?e:"-"+t.toString(16).padStart(4,"0")}))}.${ie}`,
                    path: e.path,
                    fragment: e.fragment,
                    query: e.query
                }));
                var i
            }
            class re {
                constructor(e, t, i) {
                    this._proxy = e, this._editors = t, this._remoteInfo = i, this._handlePool = 0, this._disposables = new n.SL, this._insets = new Map, this._disposables.add(t.onDidChangeVisibleTextEditors((() => {
                        const e = t.getVisibleTextEditors();
                        for (const t of this._insets.values()) e.indexOf(t.editor) < 0 && t.inset.dispose()
                    })))
                }
                dispose() {
                    this._insets.forEach((e => e.inset.dispose())), this._disposables.dispose()
                }
                createWebviewEditorInset(e, t, i, s, o) {
                    let n;
                    for (const t of this._editors.getVisibleTextEditors(!0))
                        if (t.value === e) {
                            n = t;
                            break
                        }
                    if (!n) throw new Error("not a visible editor");
                    const a = this,
                        c = this._handlePool++,
                        d = new r.Q5,
                        l = new r.Q5,
                        h = new class {
                            constructor() {
                                this._html = "", this._options = Object.create(null)
                            }
                            asWebviewUri(e) {
                                return oe(e, a._remoteInfo)
                            }
                            get cspSource() {
                                return se
                            }
                            set options(e) {
                                this._options = e, a._proxy.$setOptions(c, e)
                            }
                            get options() {
                                return this._options
                            }
                            set html(e) {
                                this._html = e, a._proxy.$setHtml(c, e)
                            }
                            get html() {
                                return this._html
                            }
                            get onDidReceiveMessage() {
                                return d.event
                            }
                            postMessage(e) {
                                return a._proxy.$postMessage(c, e)
                            }
                        },
                        u = new class {
                            constructor() {
                                this.editor = e, this.line = t, this.height = i, this.webview = h, this.onDidDispose = l.event
                            }
                            dispose() {
                                a._insets.has(c) && (a._insets.delete(c), a._proxy.$disposeEditorInset(c), l.fire(), l.dispose(), d.dispose())
                            }
                        };
                    return this._proxy.$createEditorInset(c, n.id, n.value.document.uri, t + 1, i, s || {}, o.identifier, o.extensionLocation), this._insets.set(c, {
                        editor: e,
                        inset: u,
                        onDidReceiveMessage: d
                    }), u
                }
                $onDidDispose(e) {
                    const t = this._insets.get(e);
                    t && t.inset.dispose()
                }
                $onDidReceiveMessage(e, t) {
                    const i = this._insets.get(e);
                    i ? .onDidReceiveMessage.fire(t)
                }
            }
            var ne = i("9HFd");
            var ae = i("45t+"),
                ce = i("6tPK"),
                de = i("oVnE"),
                le = i("7eUP"),
                he = i("W9Mz"),
                ue = i("Tg2V");
            class pe {#
                u;#
                e;#
                p;#
                m;#
                g;#
                v;#
                _;#
                f;#
                y;#
                w;#
                x;#
                b;
                constructor(e, t, i, s, o, n, a) {
                    this.#_ = "", this.#y = !1, this.#w = !1, this._onMessageEmitter = new r.Q5, this.onDidReceiveMessage = this._onMessageEmitter.event, this.#D = new r.Q5, this._onDidDispose = this.#D.event, this.#u = e, this.#e = t, this.#f = i, this.#m = s, this.#g = o, this.#v = n, this.#x = me(n), this.#b = function(e) {
                        try {
                            const t = (0, he.Kt)((0, he.wy)(e.engines.vscode));
                            return !!t && (t.majorBase < 1 || 1 === t.majorBase && t.minorBase < 60)
                        } catch {
                            return !1
                        }
                    }(n), this.#p = a
                }#
                D;
                dispose() {
                    this.#y = !0, this.#D.fire(), this.#D.dispose(), this._onMessageEmitter.dispose()
                }
                asWebviewUri(e) {
                    return this.#w = !0, oe(e, this.#m)
                }
                get cspSource() {
                    const e = this.#v.extensionLocation;
                    if (e.scheme === a.lg.https || e.scheme === a.lg.http) {
                        let t = e.toString();
                        return t.endsWith("/") || (t += "/"), t + " " + se
                    }
                    return se
                }
                get html() {
                    return this.assertNotDisposed(), this.#_
                }
                set html(e) {
                    this.assertNotDisposed(), this.#_ !== e && (this.#_ = e, this.#b && !this.#w && /(["'])vscode-resource:([^\s'"]+?)(["'])/i.test(e) && (this.#w = !0, this.#p.report("Webview vscode-resource: uris", this.#v, "Please migrate to use the 'webview.asWebviewUri' api instead: https://aka.ms/vscode-webview-use-aswebviewuri")), this.#e.$setHtml(this.#u, this.rewriteOldResourceUrlsIfNeeded(e)))
                }
                get options() {
                    return this.assertNotDisposed(), this.#f
                }
                set options(e) {
                    this.assertNotDisposed(), (0, le.fS)(this.#f, e) || this.#e.$setOptions(this.#u, _e(this.#v, this.#g, e)), this.#f = e
                }
                async postMessage(e) {
                    if (this.#y) return !1;
                    const t = (0, ue.m)(e, {
                        serializeBuffersForPostMessage: this.#x
                    });
                    return this.#e.$postMessage(this.#u, t.message, ...t.buffers)
                }
                assertNotDisposed() {
                    if (this.#y) throw new Error("Webview is disposed")
                }
                rewriteOldResourceUrlsIfNeeded(e) {
                    if (!this.#b) return e;
                    const t = this.#v.extensionLocation ? .scheme === a.lg.vscodeRemote,
                        i = this.#v.extensionLocation.scheme === a.lg.vscodeRemote ? this.#v.extensionLocation.authority : void 0;
                    return e.replace(/(["'])(?:vscode-resource):(\/\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi, ((e, s, o, r, n, a) => `${s}${oe(d.ov.from({scheme:r||"file",path:decodeURIComponent(n)}),{isRemote:t,authority:i}).toString()}${a}`)).replace(/(["'])(?:vscode-webview-resource):(\/\/[^\s\/'"]+\/([^\s\/'"]+?)(?=\/))?([^\s'"]+?)(["'])/gi, ((e, s, o, r, n, a) => `${s}${oe(d.ov.from({scheme:r||"file",path:decodeURIComponent(n)}),{isRemote:t,authority:i}).toString()}${a}`))
                }
            }

            function me(e) {
                try {
                    const t = (0, he.Kt)((0, he.wy)(e.engines.vscode));
                    return !!t && t.majorBase >= 1 && t.minorBase >= 57
                } catch {
                    return !1
                }
            }
            class ge extends n.JT {
                constructor(e, t, i, s, o) {
                    super(), this.remoteInfo = t, this.workspace = i, this._logService = s, this._deprecationService = o, this._webviews = new Map, this._webviewProxy = e.getProxy(x.Tr.MainThreadWebviews)
                }
                dispose() {
                    super.dispose();
                    for (const e of this._webviews.values()) e.dispose();
                    this._webviews.clear()
                }
                $onMessage(e, t, i) {
                    const s = this.getWebview(e);
                    if (s) {
                        const {
                            message: e
                        } = (0, ue.j)(t, i.value);
                        s._onMessageEmitter.fire(e)
                    }
                }
                $onMissingCsp(e, t) {
                    this._logService.warn(`${t} created a webview without a content security policy: https://aka.ms/vscode-webview-missing-csp`)
                }
                createNewWebview(e, t, i) {
                    const s = new pe(e, this._webviewProxy, function(e) {
                        return {
                            enableCommandUris: e.enableCommandUris,
                            enableScripts: e.enableScripts,
                            enableForms: e.enableForms,
                            portMapping: e.portMapping,
                            localResourceRoots: e.localResourceRoots ? .map((e => d.ov.from(e)))
                        }
                    }(t), this.remoteInfo, this.workspace, i, this._deprecationService);
                    this._webviews.set(e, s);
                    const o = s._onDidDispose((() => {
                        o.dispose(), this.deleteWebview(e)
                    }));
                    return s
                }
                deleteWebview(e) {
                    this._webviews.delete(e)
                }
                getWebview(e) {
                    return this._webviews.get(e)
                }
            }

            function ve(e) {
                return {
                    id: e.identifier,
                    location: e.extensionLocation
                }
            }

            function _e(e, t, i) {
                return {
                    enableCommandUris: i.enableCommandUris,
                    enableScripts: i.enableScripts,
                    enableForms: i.enableForms,
                    portMapping: i.portMapping,
                    localResourceRoots: i.localResourceRoots || fe(e, t)
                }
            }

            function fe(e, t) {
                return [...(t ? .getWorkspaceFolders() || []).map((e => e.uri)), e.extensionLocation]
            }
            var ye, we = i("ziTh");
            class xe {
                static {
                    this.enableDebugLogging = !1
                }
                constructor(e) {
                    this.id = e, this._data = new Map, this._idPool = 1
                }
                add(e) {
                    const t = this._idPool++;
                    return this._data.set(t, e), this.logDebugInfo(), t
                }
                get(e, t) {
                    return this._data.has(e) ? this._data.get(e)[t] : void 0
                }
                delete(e) {
                    this._data.delete(e), this.logDebugInfo()
                }
                logDebugInfo() {
                    xe.enableDebugLogging && we.log(`${this.id} cache size - ${this._data.size}`)
                }
            }
            class be {
                constructor(e, t) {
                    this.document = e, this._storagePath = t, this._backupCounter = 1, this._edits = new xe("custom documents")
                }
                addEdit(e) {
                    return this._edits.add([e])
                }
                async undo(e, t) {
                    await this.getEdit(e).undo(), t || this.disposeBackup()
                }
                async redo(e, t) {
                    await this.getEdit(e).redo(), t || this.disposeBackup()
                }
                disposeEdits(e) {
                    for (const t of e) this._edits.delete(t)
                }
                getNewBackupUri() {
                    if (!this._storagePath) throw new Error("Backup requires a valid storage path");
                    const e = function(e) {
                        const t = e.scheme === a.lg.file || e.scheme === a.lg.untitled ? e.fsPath : e.toString();
                        return (0, ce.vp)(t) + ""
                    }(this.document.uri) + this._backupCounter++;
                    return (0, de.Vo)(this._storagePath, e)
                }
                updateBackup(e) {
                    this._backup ? .delete(), this._backup = e
                }
                disposeBackup() {
                    this._backup ? .delete(), this._backup = void 0
                }
                getEdit(e) {
                    const t = this._edits.get(e, 0);
                    if (!t) throw new Error("No edit found");
                    return t
                }
            }
            class De {
                constructor() {
                    this._documents = new Map
                }
                get(e, t) {
                    return this._documents.get(this.key(e, t))
                }
                add(e, t, i) {
                    const s = this.key(e, t.uri);
                    if (this._documents.has(s)) throw new Error(`Document already exists for viewType:${e} resource:${t.uri}`);
                    const o = new be(t, i);
                    return this._documents.set(s, o), o
                }
                delete(e, t) {
                    const i = this.key(e, t.uri);
                    this._documents.delete(i)
                }
                key(e, t) {
                    return `${e}@@@${t}`
                }
            }! function(e) {
                e[e.Text = 0] = "Text", e[e.Custom = 1] = "Custom"
            }(ye || (ye = {}));
            class Ce {
                constructor() {
                    this._providers = new Map
                }
                addTextProvider(e, t, i) {
                    return this.add(e, {
                        type: ye.Text,
                        extension: t,
                        provider: i
                    })
                }
                addCustomProvider(e, t, i) {
                    return this.add(e, {
                        type: ye.Custom,
                        extension: t,
                        provider: i
                    })
                }
                get(e) {
                    return this._providers.get(e)
                }
                add(e, t) {
                    if (this._providers.has(e)) throw new Error(`Provider for viewType:${e} already registered`);
                    return this._providers.set(e, t), new b.JTr((() => this._providers.delete(e)))
                }
            }
            class Se {
                constructor(e, t, i, s, o) {
                    this._extHostDocuments = t, this._extensionStoragePaths = i, this._extHostWebview = s, this._extHostWebviewPanels = o, this._editorProviders = new Ce, this._documents = new De, this._proxy = e.getProxy(x.Tr.MainThreadCustomEditors)
                }
                registerCustomEditorProvider(e, t, i, s) {
                    const o = new n.SL;
                    return function(e) {
                        return "function" == typeof e.resolveCustomTextEditor
                    }(i) ? (o.add(this._editorProviders.addTextProvider(t, e, i)), this._proxy.$registerTextEditorProvider(ve(e), t, s.webviewOptions || {}, {
                        supportsMove: !!i.moveCustomTextEditor
                    }, me(e))) : (o.add(this._editorProviders.addCustomProvider(t, e, i)), Ee(i) && o.add(i.onDidChangeCustomDocument((e => {
                        const i = this.getCustomDocumentEntry(t, e.document.uri);
                        if (function(e) {
                                return "function" == typeof e.undo && "function" == typeof e.redo
                            }(e)) {
                            const s = i.addEdit(e);
                            this._proxy.$onDidEdit(e.document.uri, t, s, e.label)
                        } else this._proxy.$onContentChange(e.document.uri, t)
                    }))), this._proxy.$registerCustomEditorProvider(ve(e), t, s.webviewOptions || {}, !!s.supportsMultipleEditorsPerDocument, me(e))), b.JTr.from(o, new b.JTr((() => {
                        this._proxy.$unregisterEditorProvider(t)
                    })))
                }
                async $createCustomDocument(e, t, i, s, o) {
                    const r = this._editorProviders.get(t);
                    if (!r) throw new Error(`No provider found for '${t}'`);
                    if (r.type !== ye.Custom) throw new Error(`Invalid provide type for '${t}'`);
                    const n = d.ov.revive(e),
                        a = await r.provider.openCustomDocument(n, {
                            backupId: i,
                            untitledDocumentData: s ? .buffer
                        }, o);
                    let c;
                    return Ee(r.provider) && this._extensionStoragePaths && (c = this._extensionStoragePaths.workspaceValue(r.extension) ? ? this._extensionStoragePaths.globalValue(r.extension)), this._documents.add(t, a, c), {
                        editable: Ee(r.provider)
                    }
                }
                async $disposeCustomDocument(e, t) {
                    const i = this._editorProviders.get(t);
                    if (!i) throw new Error(`No provider found for '${t}'`);
                    if (i.type !== ye.Custom) throw new Error(`Invalid provider type for '${t}'`);
                    const s = d.ov.revive(e),
                        {
                            document: o
                        } = this.getCustomDocumentEntry(t, s);
                    this._documents.delete(t, o), o.dispose()
                }
                async $resolveCustomEditor(e, t, i, s, o, r) {
                    const n = this._editorProviders.get(i);
                    if (!n) throw new Error(`No provider found for '${i}'`);
                    const a = k.eI.to(o),
                        c = this._extHostWebview.createNewWebview(t, s.contentOptions, n.extension),
                        l = this._extHostWebviewPanels.createNewWebviewPanel(t, i, s.title, a, s.options, c, s.active),
                        h = d.ov.revive(e);
                    switch (n.type) {
                        case ye.Custom:
                            {
                                const {
                                    document: e
                                } = this.getCustomDocumentEntry(i, h);
                                return n.provider.resolveCustomEditor(e, l, r)
                            }
                        case ye.Text:
                            {
                                const e = this._extHostDocuments.getDocument(h);
                                return n.provider.resolveCustomTextEditor(e, l, r)
                            }
                        default:
                            throw new Error("Unknown webview provider type")
                    }
                }
                $disposeEdits(e, t, i) {
                    this.getCustomDocumentEntry(t, e).disposeEdits(i)
                }
                async $onMoveCustomEditor(e, t, i) {
                    const o = this._editorProviders.get(i);
                    if (!o) throw new Error(`No provider found for '${i}'`);
                    if (!o.provider.moveCustomTextEditor) throw new Error(`Provider does not implement move '${i}'`);
                    const r = this._extHostWebviewPanels.getWebviewPanel(e);
                    if (!r) throw new Error("No webview found");
                    const n = d.ov.revive(t),
                        a = this._extHostDocuments.getDocument(n);
                    await o.provider.moveCustomTextEditor(a, r, s.Ts.None)
                }
                async $undo(e, t, i, s) {
                    return this.getCustomDocumentEntry(t, e).undo(i, s)
                }
                async $redo(e, t, i, s) {
                    return this.getCustomDocumentEntry(t, e).redo(i, s)
                }
                async $revert(e, t, i) {
                    const s = this.getCustomDocumentEntry(t, e),
                        o = this.getCustomEditorProvider(t);
                    await o.revertCustomDocument(s.document, i), s.disposeBackup()
                }
                async $onSave(e, t, i) {
                    const s = this.getCustomDocumentEntry(t, e),
                        o = this.getCustomEditorProvider(t);
                    await o.saveCustomDocument(s.document, i), s.disposeBackup()
                }
                async $onSaveAs(e, t, i, s) {
                    const o = this.getCustomDocumentEntry(t, e);
                    return this.getCustomEditorProvider(t).saveCustomDocumentAs(o.document, d.ov.revive(i), s)
                }
                async $backup(e, t, i) {
                    const s = this.getCustomDocumentEntry(t, e),
                        o = this.getCustomEditorProvider(t),
                        r = await o.backupCustomDocument(s.document, {
                            destination: s.getNewBackupUri()
                        }, i);
                    return s.updateBackup(r), r.id
                }
                getCustomDocumentEntry(e, t) {
                    const i = this._documents.get(e, d.ov.revive(t));
                    if (!i) throw new Error("No custom document found");
                    return i
                }
                getCustomEditorProvider(e) {
                    const t = this._editorProviders.get(e),
                        i = t ? .provider;
                    if (!i || !Ee(i)) throw new Error("Custom document is not editable");
                    return i
                }
            }

            function Ee(e) {
                return !!e.onDidChangeCustomDocument
            }
            var Pe, Te = i("ri7g"),
                ke = i("rx29"),
                Ie = i("yFKF"),
                Ae = i("Ekjh"),
                $e = i("Ef4y"),
                Re = i("CRYY");
            class He {#
                e;#
                C;#
                S;
                constructor(e, t, i, s, o, r, n, a) {
                    this._name = e, this._owner = t, this._maxDiagnosticsTotal = i, this._maxDiagnosticsPerFile = s, this._modelVersionIdProvider = o, this._isDisposed = !1, this._maxDiagnosticsTotal = Math.max(s, i), this.#S = new $e.Y9((e => r.getComparisonKey(e))), this.#e = n, this.#C = a
                }
                dispose() {
                    this._isDisposed || (this.#C.fire([...this.#S.keys()]), this.#e ? .$clear(this._owner), this.#S.clear(), this._isDisposed = !0)
                }
                get name() {
                    return this._checkDisposed(), this._name
                }
                set(e, t) {
                    if (!e) return void this.clear();
                    this._checkDisposed();
                    let i = [];
                    if (d.ov.isUri(e)) {
                        if (!t) return void this.delete(e);
                        this.#S.set(e, t.slice()), i = [e]
                    } else if (Array.isArray(e)) {
                        let t;
                        i = [], e = [...e].sort(He._compareIndexedTuplesByUri);
                        for (const s of e) {
                            const [e, o] = s;
                            if (t && e.toString() === t.toString() || (t && 0 === this.#S.get(t).length && this.#S.delete(t), t = e, i.push(e), this.#S.set(e, [])), o) {
                                const t = this.#S.get(e);
                                t ? .push(...o)
                            } else {
                                const t = this.#S.get(e);
                                t && (t.length = 0)
                            }
                        }
                    }
                    if (this.#C.fire(i), !this.#e) return;
                    const s = [];
                    let o = 0;
                    for (const e of i) {
                        let t = [];
                        const i = this.#S.get(e);
                        if (i)
                            if (i.length > this._maxDiagnosticsPerFile) {
                                t = [];
                                const s = [b.H_B.Error, b.H_B.Warning, b.H_B.Information, b.H_B.Hint];
                                e: for (let o = 0; o < 4; o++)
                                    for (const r of i)
                                        if (r.severity === s[o] && t.push({ ...k.R9.from(r),
                                                modelVersionId: this._modelVersionIdProvider(e)
                                            }) === this._maxDiagnosticsPerFile) break e;
                                t.push({
                                    severity: Ae.ZL.Info,
                                    message: (0, Ie.C$)("vs/workbench/api/common/extHostDiagnostics", 0, "Not showing {0} further errors and warnings.", i.length - this._maxDiagnosticsPerFile),
                                    startLineNumber: t[t.length - 1].startLineNumber,
                                    startColumn: t[t.length - 1].startColumn,
                                    endLineNumber: t[t.length - 1].endLineNumber,
                                    endColumn: t[t.length - 1].endColumn
                                })
                            } else t = i.map((t => ({ ...k.R9.from(t),
                                modelVersionId: this._modelVersionIdProvider(e)
                            })));
                        if (s.push([e, t]), o += t.length, o > this._maxDiagnosticsTotal) break
                    }
                    this.#e.$changeMany(this._owner, s)
                }
                delete(e) {
                    this._checkDisposed(), this.#C.fire([e]), this.#S.delete(e), this.#e ? .$changeMany(this._owner, [
                        [e, void 0]
                    ])
                }
                clear() {
                    this._checkDisposed(), this.#C.fire([...this.#S.keys()]), this.#S.clear(), this.#e ? .$clear(this._owner)
                }
                forEach(e, t) {
                    this._checkDisposed();
                    for (const [i, s] of this) e.call(t, i, s, this)
                }*[Symbol.iterator]() {
                    this._checkDisposed();
                    for (const e of this.#S.keys()) yield [e, this.get(e)]
                }
                get(e) {
                    this._checkDisposed();
                    const t = this.#S.get(e);
                    return Array.isArray(t) ? Object.freeze(t.slice(0)) : []
                }
                has(e) {
                    return this._checkDisposed(), Array.isArray(this.#S.get(e))
                }
                _checkDisposed() {
                    if (this._isDisposed) throw new Error("illegal state - object is disposed")
                }
                static _compareIndexedTuplesByUri(e, t) {
                    return e[0].toString() < t[0].toString() ? -1 : e[0].toString() > t[0].toString() ? 1 : 0
                }
            }
            let Fe = class {
                static {
                    Pe = this
                }
                static {
                    this._idPool = 0
                }
                static {
                    this._maxDiagnosticsPerFile = 1e3
                }
                static {
                    this._maxDiagnosticsTotal = 1.1 * Pe._maxDiagnosticsPerFile
                }
                static _mapper(e) {
                    const t = new $e.Y9;
                    for (const i of e) t.set(i, i);
                    return {
                        uris: Object.freeze(Array.from(t.values()))
                    }
                }
                constructor(e, t, i, s) {
                    this._logService = t, this._fileSystemInfoService = i, this._extHostDocumentsAndEditors = s, this._collections = new Map, this._onDidChangeDiagnostics = new r.D0({
                        merge: e => e.flat(),
                        delay: 50
                    }), this.onDidChangeDiagnostics = r.ju.map(this._onDidChangeDiagnostics.event, Pe._mapper), this._proxy = e.getProxy(x.Tr.MainThreadDiagnostics)
                }
                createDiagnosticCollection(e, t) {
                    const {
                        _collections: i,
                        _proxy: s,
                        _onDidChangeDiagnostics: o,
                        _logService: r,
                        _fileSystemInfoService: n,
                        _extHostDocumentsAndEditors: a
                    } = this, c = new class {
                        $changeMany(t, i) {
                            s.$changeMany(t, i), r.trace("[DiagnosticCollection] change many (extension, owner, uris)", e.value, t, 0 === i.length ? "CLEARING" : i)
                        }
                        $clear(t) {
                            s.$clear(t), r.trace("[DiagnosticCollection] remove all (extension, owner)", e.value, t)
                        }
                        dispose() {
                            s.dispose()
                        }
                    };
                    let d;
                    if (t)
                        if (i.has(t)) {
                            this._logService.warn(`DiagnosticCollection with name '${t}' does already exist.`);
                            do {
                                d = t + Pe._idPool++
                            } while (i.has(d))
                        } else d = t;
                    else t = "_generated_diagnostic_collection_name_#" + Pe._idPool++, d = t;
                    return new class extends He {
                        constructor() {
                            super(t, d, Pe._maxDiagnosticsTotal, Pe._maxDiagnosticsPerFile, (e => a.getDocument(e) ? .version), n.extUri, c, o), i.set(d, this)
                        }
                        dispose() {
                            super.dispose(), i.delete(d)
                        }
                    }
                }
                getDiagnostics(e) {
                    if (e) return this._getDiagnostics(e); {
                        const e = new Map,
                            t = [];
                        for (const i of this._collections.values()) i.forEach(((i, s) => {
                            let o = e.get(i.toString());
                            void 0 === o && (o = t.length, e.set(i.toString(), o), t.push([i, []])), t[o][1] = t[o][1].concat(...s)
                        }));
                        return t
                    }
                }
                _getDiagnostics(e) {
                    let t = [];
                    for (const i of this._collections.values()) i.has(e) && (t = t.concat(i.get(e)));
                    return t
                }
                $acceptMarkersChange(e) {
                    if (!this._mirrorCollection) {
                        const e = "_generated_mirror",
                            t = new He(e, e, Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, (e => {}), this._fileSystemInfoService.extUri, void 0, this._onDidChangeDiagnostics);
                        this._collections.set(e, t), this._mirrorCollection = t
                    }
                    for (const [t, i] of e) this._mirrorCollection.set(d.ov.revive(t), i.map(k.R9.to))
                }
            };
            Fe = Pe = (0, N.g)([(0, N.f)(1, _.V), (0, N.f)(2, Re.G)], Fe);
            class Ne {
                constructor(e) {
                    this._proxy = e.getProxy(x.Tr.MainThreadDialogs)
                }
                showOpenDialog(e, t) {
                    return t ? .allowUIResources && (0, q.H5)(e, "showLocal"), this._proxy.$showOpenDialog(t).then((e => e ? e.map((e => d.ov.revive(e))) : void 0))
                }
                showSaveDialog(e) {
                    return this._proxy.$showSaveDialog(e).then((e => e ? d.ov.revive(e) : void 0))
                }
            }
            var Me = i("p044");
            class Le {
                static {
                    this._handlePool = 0
                }
                constructor(e, t, i) {
                    this._documentsAndEditors = t, this._logService = i, this._documentContentProviders = new Map, this._proxy = e.getProxy(x.Tr.MainThreadDocumentContentProviders)
                }
                registerTextDocumentContentProvider(e, t) {
                    if (Object.keys(a.lg).indexOf(e) >= 0) throw new Error(`scheme '${e}' already registered`);
                    const i = Le._handlePool++;
                    let s;
                    if (this._documentContentProviders.set(i, t), this._proxy.$registerTextContentProvider(i, e), "function" == typeof t.onDidChange) {
                        let r;
                        s = t.onDidChange((async t => {
                            if (t.scheme !== e) return void this._logService.warn(`Provider for scheme '${e}' is firing event for schema '${t.scheme}' which will be IGNORED`);
                            if (!this._documentsAndEditors.getDocument(t)) return;
                            r && await r;
                            const s = this.$provideTextDocumentContent(i, t).then((async e => {
                                if (!e && "string" != typeof e) return;
                                const i = this._documentsAndEditors.getDocument(t);
                                if (!i) return;
                                const s = (0, Me.uq)(e);
                                return i.equalLines(s) ? void 0 : this._proxy.$onVirtualDocumentChange(t, e)
                            })).catch(o.dL).finally((() => {
                                r === s && (r = void 0)
                            }));
                            r = s
                        }))
                    }
                    return new b.JTr((() => {
                        this._documentContentProviders.delete(i) && this._proxy.$unregisterTextContentProvider(i), s && (s.dispose(), s = void 0)
                    }))
                }
                $provideTextDocumentContent(e, t) {
                    const i = this._documentContentProviders.get(e);
                    return i ? Promise.resolve(i.provideTextDocumentContent(d.ov.revive(t), s.Ts.None)) : Promise.reject(new Error(`unsupported uri-scheme: ${t.scheme}`))
                }
            }
            var Oe = i("U+Fb");
            class Ue {
                constructor(e, t, i, s = {
                    timeout: 1500,
                    errors: 3
                }) {
                    this._logService = e, this._documents = t, this._mainThreadBulkEdits = i, this._thresholds = s, this._callbacks = new Oe.S, this._badListeners = new WeakMap
                }
                dispose() {
                    this._callbacks.clear()
                }
                getOnWillSaveTextDocumentEvent(e) {
                    return (t, i, s) => {
                        const o = {
                            dispose: this._callbacks.push([t, i, e])
                        };
                        return Array.isArray(s) && s.push(o), o
                    }
                }
                async $participateInSave(e, t) {
                    const i = d.ov.revive(e);
                    let s = !1;
                    const o = setTimeout((() => s = !0), this._thresholds.timeout),
                        r = [];
                    try {
                        for (const e of [...this._callbacks]) {
                            if (s) break;
                            const o = this._documents.getDocument(i),
                                n = await this._deliverEventAsyncAndBlameBadListeners(e, {
                                    document: o,
                                    reason: k.wD.to(t)
                                });
                            r.push(n)
                        }
                    } finally {
                        clearTimeout(o)
                    }
                    return r
                }
                _deliverEventAsyncAndBlameBadListeners([e, t, i], s) {
                    const o = this._badListeners.get(e);
                    return "number" == typeof o && o > this._thresholds.errors ? Promise.resolve(!1) : this._deliverEventAsync(i, e, t, s).then((() => !0), (t => {
                        if (this._logService.error(`onWillSaveTextDocument-listener from extension '${i.identifier.value}' threw ERROR`), this._logService.error(t), !(t instanceof Error) || "concurrent_edits" !== t.message) {
                            const t = this._badListeners.get(e);
                            this._badListeners.set(e, t ? t + 1 : 1), "number" == typeof t && t > this._thresholds.errors && this._logService.info(`onWillSaveTextDocument-listener from extension '${i.identifier.value}' will now be IGNORED because of timeouts and/or errors`)
                        }
                        return !1
                    }))
                }
                _deliverEventAsync(e, t, i, s) {
                    const r = [],
                        n = Date.now(),
                        {
                            document: a,
                            reason: c
                        } = s,
                        {
                            version: d
                        } = a,
                        l = Object.freeze({
                            document: a,
                            reason: c,
                            waitUntil(e) {
                                if (Object.isFrozen(r)) throw (0, o.L6)("waitUntil can not be called async");
                                r.push(Promise.resolve(e))
                            }
                        });
                    try {
                        t.apply(i, [l])
                    } catch (e) {
                        return Promise.reject(e)
                    }
                    return new Promise(((t, i) => {
                        const s = setTimeout((() => i(new Error("timeout"))), this._thresholds.timeout);
                        return Promise.all(r).then((i => {
                            this._logService.debug(`onWillSaveTextDocument-listener from extension '${e.identifier.value}' finished after ${Date.now()-n}ms`), clearTimeout(s), t(i)
                        })).catch((e => {
                            clearTimeout(s), i(e)
                        }))
                    })).then((e => {
                        const t = {
                            edits: []
                        };
                        for (const i of e)
                            if (Array.isArray(i) && i.every((e => e instanceof b.PYv)))
                                for (const {
                                        newText: e,
                                        newEol: s,
                                        range: o
                                    } of i) t.edits.push({
                                    resource: a.uri,
                                    versionId: void 0,
                                    textEdit: {
                                        range: o && k.e6.from(o),
                                        text: e,
                                        eol: s && k.b6.from(s)
                                    }
                                });
                        if (0 !== t.edits.length) return d === a.version ? this._mainThreadBulkEdits.$tryApplyWorkspaceEdit(new L.ky(t)) : Promise.reject(new Error("concurrent_edits"))
                    }))
                }
            }
            var Ve = i("7rMg");
            class We {
                constructor(e, t) {
                    this._onDidAddDocument = new r.Q5, this._onDidRemoveDocument = new r.Q5, this._onDidChangeDocument = new r.Q5, this._onDidSaveDocument = new r.Q5, this.onDidAddDocument = this._onDidAddDocument.event, this.onDidRemoveDocument = this._onDidRemoveDocument.event, this.onDidChangeDocument = this._onDidChangeDocument.event, this.onDidSaveDocument = this._onDidSaveDocument.event, this._toDispose = new n.SL, this._documentLoader = new Map, this._proxy = e.getProxy(x.Tr.MainThreadDocuments), this._documentsAndEditors = t, this._documentsAndEditors.onDidRemoveDocuments((e => {
                        for (const t of e) this._onDidRemoveDocument.fire(t.document)
                    }), void 0, this._toDispose), this._documentsAndEditors.onDidAddDocuments((e => {
                        for (const t of e) this._onDidAddDocument.fire(t.document)
                    }), void 0, this._toDispose)
                }
                dispose() {
                    this._toDispose.dispose()
                }
                getAllDocumentData() {
                    return [...this._documentsAndEditors.allDocuments()]
                }
                getDocumentData(e) {
                    if (!e) return;
                    return this._documentsAndEditors.getDocument(e) || void 0
                }
                getDocument(e) {
                    const t = this.getDocumentData(e);
                    if (!t ? .document) throw new Error(`Unable to retrieve document from URI '${e}'`);
                    return t.document
                }
                ensureDocumentData(e) {
                    const t = this._documentsAndEditors.getDocument(e);
                    if (t) return Promise.resolve(t);
                    let i = this._documentLoader.get(e.toString());
                    return i || (i = this._proxy.$tryOpenDocument(e).then((t => {
                        this._documentLoader.delete(e.toString());
                        const i = d.ov.revive(t);
                        return (0, z.cW)(this._documentsAndEditors.getDocument(i))
                    }), (t => (this._documentLoader.delete(e.toString()), Promise.reject(t)))), this._documentLoader.set(e.toString(), i)), i
                }
                createDocumentData(e) {
                    return this._proxy.$tryCreateDocument(e).then((e => d.ov.revive(e)))
                }
                $acceptModelLanguageChanged(e, t) {
                    const i = d.ov.revive(e),
                        s = this._documentsAndEditors.getDocument(i);
                    if (!s) throw new Error("unknown document");
                    this._onDidRemoveDocument.fire(s.document), s._acceptLanguageId(t), this._onDidAddDocument.fire(s.document)
                }
                $acceptModelSaved(e) {
                    const t = d.ov.revive(e),
                        i = this._documentsAndEditors.getDocument(t);
                    if (!i) throw new Error("unknown document");
                    this.$acceptDirtyStateChanged(e, !1), this._onDidSaveDocument.fire(i.document)
                }
                $acceptDirtyStateChanged(e, t) {
                    const i = d.ov.revive(e),
                        s = this._documentsAndEditors.getDocument(i);
                    if (!s) throw new Error("unknown document");
                    s._acceptIsDirty(t), this._onDidChangeDocument.fire({
                        document: s.document,
                        contentChanges: [],
                        reason: void 0
                    })
                }
                $acceptModelChanged(e, t, i) {
                    const s = d.ov.revive(e),
                        o = this._documentsAndEditors.getDocument(s);
                    if (!o) throw new Error("unknown document");
                    let r;
                    o._acceptIsDirty(i), o.onEvents(t), t.isUndoing ? r = b.bur.Undo : t.isRedoing && (r = b.bur.Redo), this._onDidChangeDocument.fire((0, le._A)({
                        document: o.document,
                        contentChanges: t.changes.map((e => ({
                            range: k.e6.to(e.range),
                            rangeOffset: e.rangeOffset,
                            rangeLength: e.rangeLength,
                            text: e.text
                        }))),
                        reason: r
                    }))
                }
                setWordDefinitionFor(e, t) {
                    (0, Ve.T7)(e, t)
                }
            }
            var Be = i("l6bu"),
                ze = i("PmF0");
            class je {
                constructor(e) {
                    this._provider = new Map, this._onDidChange = new r.Q5, this.onDidChange = this._onDidChange.event, this._allKnownModels = new Set, this._handlePool = 0, this._proxy = e.getProxy(x.Tr.MainThreadEmbeddings)
                }
                registerEmbeddingsProvider(e, t, i) {
                    if (this._allKnownModels.has(t)) throw new Error("An embeddings provider for this model is already registered");
                    const s = this._handlePool++;
                    return this._proxy.$registerEmbeddingProvider(s, t), this._provider.set(s, {
                        id: t,
                        provider: i
                    }), (0, n.OF)((() => {
                        this._proxy.$unregisterEmbeddingProvider(s), this._provider.delete(s)
                    }))
                }
                async computeEmbeddings(e, t, i) {
                    i ? ? = s.Ts.None;
                    let o = !1;
                    "string" == typeof t && (t = [t], o = !0);
                    const r = await this._proxy.$computeEmbeddings(e, t, i);
                    if (r.length !== t.length) throw new Error;
                    if (o) {
                        if (1 !== r.length) throw new Error;
                        return r[0]
                    }
                    return r
                }
                async $provideEmbeddings(e, t, i) {
                    const s = this._provider.get(e);
                    if (!s) return [];
                    return await s.provider.provideEmbeddings(t, i) || []
                }
                get embeddingsModels() {
                    return Array.from(this._allKnownModels)
                }
                $acceptEmbeddingModels(e) {
                    this._allKnownModels = new Set(e), this._onDidChange.fire()
                }
            }
            class qe {
                constructor(e) {
                    this._AiEmbeddingVectorProviders = new Map, this._nextHandle = 0, this._proxy = e.getProxy(x.Tr.MainThreadAiEmbeddingVector)
                }
                async $provideAiEmbeddingVector(e, t, i) {
                    if (0 === this._AiEmbeddingVectorProviders.size) throw new Error("No embedding vector providers registered");
                    const s = this._AiEmbeddingVectorProviders.get(e);
                    if (!s) throw new Error("Embedding vector provider not found");
                    const o = await s.provideEmbeddingVector(t, i);
                    if (!o) throw new Error("Embedding vector provider returned undefined");
                    return o
                }
                registerEmbeddingVectorProvider(e, t, i) {
                    const s = this._nextHandle;
                    return this._nextHandle++, this._AiEmbeddingVectorProviders.set(s, i), this._proxy.$registerAiEmbeddingVectorProvider(t, s), new b.JTr((() => {
                        this._proxy.$unregisterAiEmbeddingVectorProvider(s), this._AiEmbeddingVectorProviders.delete(s)
                    }))
                }
            }
            var Ke = i("spPY"),
                Je = i("5hxU"),
                Ge = i("jxI3"),
                Qe = i("o1+4"),
                Ze = i("ziTh");
            class Ye {
                constructor() {
                    this._schemes = []
                }
                add(e) {
                    this._stateMachine = void 0, this._schemes.push(e)
                }
                delete(e) {
                    const t = this._schemes.indexOf(e);
                    t >= 0 && (this._schemes.splice(t, 1), this._stateMachine = void 0)
                }
                _initStateMachine() {
                    if (!this._stateMachine) {
                        const e = this._schemes.sort(),
                            t = [];
                        let i, s, o = Je.ZM.LastKnownState,
                            r = Je.ZM.LastKnownState;
                        for (const n of e) {
                            let e = i ? (0, Me.Mh)(i, n) : 0;
                            for (s = 0 === e ? Je.ZM.Start : r; e < n.length; e++) e + 1 === n.length ? (o = r, r = Je.ZM.BeforeColon) : r += 1, t.push([s, n.toUpperCase().charCodeAt(e), r]), t.push([s, n.toLowerCase().charCodeAt(e), r]), s = r;
                            i = n, r = o
                        }
                        t.push([Je.ZM.BeforeColon, ee.m.Colon, Je.ZM.AfterColon]), t.push([Je.ZM.AfterColon, ee.m.Slash, Je.ZM.End]), this._stateMachine = new Je.DV(t)
                    }
                }
                provideDocumentLinks(e) {
                    this._initStateMachine();
                    const t = [],
                        i = Je.VD.computeLinks({
                            getLineContent: t => e.lineAt(t - 1).text,
                            getLineCount: () => e.lineCount
                        }, this._stateMachine);
                    for (const e of i) {
                        const i = k.jW.to(e);
                        i.target && t.push(i)
                    }
                    return t
                }
            }
            class Xe {
                constructor(e, t) {
                    this._extHostLanguageFeatures = t, this._linkProvider = new Ye, this._fsProvider = new Map, this._registeredSchemes = new Set, this._watches = new Map, this._handlePool = 0, this._proxy = e.getProxy(x.Tr.MainThreadFileSystem)
                }
                dispose() {
                    this._linkProviderRegistration ? .dispose()
                }
                registerFileSystemProvider(e, t, i, s = {}) {
                    if (Xe._validateFileSystemProvider(i), this._registeredSchemes.has(t)) throw new Error(`a provider for the scheme '${t}' is already registered`);
                    this._linkProviderRegistration || (this._linkProviderRegistration = this._extHostLanguageFeatures.registerDocumentLinkProvider(e, "*", this._linkProvider));
                    const o = this._handlePool++;
                    this._linkProvider.add(t), this._registeredSchemes.add(t), this._fsProvider.set(o, i);
                    let r, a = g.Bb.FileReadWrite;
                    s.isCaseSensitive && (a += g.Bb.PathCaseSensitive), s.isReadonly && (a += g.Bb.Readonly), "function" == typeof i.copy && (a += g.Bb.FileFolderCopy), "function" == typeof i.open && "function" == typeof i.close && "function" == typeof i.read && "function" == typeof i.write && ((0, q.H5)(e, "fsChunks"), a += g.Bb.FileOpenReadWriteClose), s.isReadonly && (0, Qe.Fr)(s.isReadonly) && "" !== s.isReadonly.value && (r = {
                        value: s.isReadonly.value,
                        isTrusted: s.isReadonly.isTrusted,
                        supportThemeIcons: s.isReadonly.supportThemeIcons,
                        supportHtml: s.isReadonly.supportHtml,
                        baseUri: s.isReadonly.baseUri,
                        uris: s.isReadonly.uris
                    }), this._proxy.$registerFileSystemProvider(o, t, a, r).catch((i => {
                        Ze.error(`FAILED to register filesystem provider of ${e.identifier.value}-extension for the scheme ${t}`), Ze.error(i)
                    }));
                    const c = i.onDidChangeFile((e => {
                        const i = [];
                        for (const s of e) {
                            const {
                                uri: e,
                                type: o
                            } = s;
                            if (e.scheme !== t) continue;
                            let r;
                            switch (o) {
                                case b.zR2.Changed:
                                    r = g.zR.UPDATED;
                                    break;
                                case b.zR2.Created:
                                    r = g.zR.ADDED;
                                    break;
                                case b.zR2.Deleted:
                                    r = g.zR.DELETED;
                                    break;
                                default:
                                    throw new Error("Unknown FileChangeType")
                            }
                            i.push({
                                resource: e,
                                type: r
                            })
                        }
                        this._proxy.$onFileSystemChange(o, i)
                    }));
                    return (0, n.OF)((() => {
                        c.dispose(), this._linkProvider.delete(t), this._registeredSchemes.delete(t), this._fsProvider.delete(o), this._proxy.$unregisterProvider(o)
                    }))
                }
                static _validateFileSystemProvider(e) {
                    if (!e) throw new Error("MISSING provider");
                    if ("function" != typeof e.watch) throw new Error("Provider does NOT implement watch");
                    if ("function" != typeof e.stat) throw new Error("Provider does NOT implement stat");
                    if ("function" != typeof e.readDirectory) throw new Error("Provider does NOT implement readDirectory");
                    if ("function" != typeof e.createDirectory) throw new Error("Provider does NOT implement createDirectory");
                    if ("function" != typeof e.readFile) throw new Error("Provider does NOT implement readFile");
                    if ("function" != typeof e.writeFile) throw new Error("Provider does NOT implement writeFile");
                    if ("function" != typeof e.delete) throw new Error("Provider does NOT implement delete");
                    if ("function" != typeof e.rename) throw new Error("Provider does NOT implement rename")
                }
                static _asIStat(e) {
                    const {
                        type: t,
                        ctime: i,
                        mtime: s,
                        size: o,
                        permissions: r
                    } = e;
                    return {
                        type: t,
                        ctime: i,
                        mtime: s,
                        size: o,
                        permissions: r
                    }
                }
                $stat(e, t) {
                    return Promise.resolve(this._getFsProvider(e).stat(d.ov.revive(t))).then((e => Xe._asIStat(e)))
                }
                $readdir(e, t) {
                    return Promise.resolve(this._getFsProvider(e).readDirectory(d.ov.revive(t)))
                }
                $readFile(e, t) {
                    return Promise.resolve(this._getFsProvider(e).readFile(d.ov.revive(t))).then((e => Ge.KN.wrap(e)))
                }
                $writeFile(e, t, i, s) {
                    return Promise.resolve(this._getFsProvider(e).writeFile(d.ov.revive(t), i.buffer, s))
                }
                $delete(e, t, i) {
                    return Promise.resolve(this._getFsProvider(e).delete(d.ov.revive(t), i))
                }
                $rename(e, t, i, s) {
                    return Promise.resolve(this._getFsProvider(e).rename(d.ov.revive(t), d.ov.revive(i), s))
                }
                $copy(e, t, i, s) {
                    const o = this._getFsProvider(e);
                    if (!o.copy) throw new Error('FileSystemProvider does not implement "copy"');
                    return Promise.resolve(o.copy(d.ov.revive(t), d.ov.revive(i), s))
                }
                $mkdir(e, t) {
                    return Promise.resolve(this._getFsProvider(e).createDirectory(d.ov.revive(t)))
                }
                $watch(e, t, i, s) {
                    const o = this._getFsProvider(e).watch(d.ov.revive(i), s);
                    this._watches.set(t, o)
                }
                $unwatch(e, t) {
                    const i = this._watches.get(t);
                    i && (i.dispose(), this._watches.delete(t))
                }
                $open(e, t, i) {
                    const s = this._getFsProvider(e);
                    if (!s.open) throw new Error('FileSystemProvider does not implement "open"');
                    return Promise.resolve(s.open(d.ov.revive(t), i))
                }
                $close(e, t) {
                    const i = this._getFsProvider(e);
                    if (!i.close) throw new Error('FileSystemProvider does not implement "close"');
                    return Promise.resolve(i.close(t))
                }
                $read(e, t, i, s) {
                    const o = this._getFsProvider(e);
                    if (!o.read) throw new Error('FileSystemProvider does not implement "read"');
                    const r = Ge.KN.alloc(s);
                    return Promise.resolve(o.read(t, i, r.buffer, 0, s)).then((e => r.slice(0, e)))
                }
                $write(e, t, i, s) {
                    const o = this._getFsProvider(e);
                    if (!o.write) throw new Error('FileSystemProvider does not implement "write"');
                    return Promise.resolve(o.write(t, i, s.buffer, 0, s.byteLength))
                }
                _getFsProvider(e) {
                    const t = this._fsProvider.get(e);
                    if (!t) {
                        const e = new Error;
                        throw e.name = "ENOPRO", e.message = "no provider", e
                    }
                    return t
                }
            }
            var et = i("nG0x"),
                tt = i("y5Nw"),
                it = i("8HR7");
            class st {
                get ignoreCreateEvents() {
                    return Boolean(1 & this._config)
                }
                get ignoreChangeEvents() {
                    return Boolean(2 & this._config)
                }
                get ignoreDeleteEvents() {
                    return Boolean(4 & this._config)
                }
                constructor(e, t, i, s, o, n) {
                    this.session = Math.random(), this._onDidCreate = new r.Q5, this._onDidChange = new r.Q5, this._onDidDelete = new r.Q5, this._config = 0, n ? .ignoreCreateEvents && (this._config += 1), n ? .ignoreChangeEvents && (this._config += 2), n ? .ignoreDeleteEvents && (this._config += 4);
                    const a = (0, tt.Qc)(o),
                        c = "string" == typeof o,
                        l = n ? .correlate,
                        h = s((e => {
                            if (!("number" == typeof e.session && e.session !== this.session || l && void 0 === e.session)) {
                                if (!n ? .ignoreCreateEvents)
                                    for (const i of e.created) {
                                        const e = d.ov.revive(i);
                                        !a(e.fsPath) || c && !t.getWorkspaceFolder(e) || this._onDidCreate.fire(e)
                                    }
                                if (!n ? .ignoreChangeEvents)
                                    for (const i of e.changed) {
                                        const e = d.ov.revive(i);
                                        !a(e.fsPath) || c && !t.getWorkspaceFolder(e) || this._onDidChange.fire(e)
                                    }
                                if (!n ? .ignoreDeleteEvents)
                                    for (const i of e.deleted) {
                                        const e = d.ov.revive(i);
                                        !a(e.fsPath) || c && !t.getWorkspaceFolder(e) || this._onDidDelete.fire(e)
                                    }
                            }
                        }));
                    this._disposable = b.JTr.from(this.ensureWatching(e, i, o, n, n ? .correlate), this._onDidCreate, this._onDidChange, this._onDidDelete, h)
                }
                ensureWatching(e, t, i, s, o) {
                    const r = b.JTr.from();
                    if ("string" == typeof i) return r;
                    if (s ? .ignoreChangeEvents && s ? .ignoreCreateEvents && s ? .ignoreDeleteEvents) return r;
                    const n = e.getProxy(x.Tr.MainThreadFileSystemEventService);
                    let a, c = !1;
                    return (i.pattern.includes(tt.k1) || i.pattern.includes(tt.dn)) && (c = !0), o && (s ? .ignoreChangeEvents || s ? .ignoreCreateEvents || s ? .ignoreDeleteEvents) && (a = g.pT.UPDATED | g.pT.ADDED | g.pT.DELETED, s ? .ignoreChangeEvents && (a &= ~g.pT.UPDATED), s ? .ignoreCreateEvents && (a &= ~g.pT.ADDED), s ? .ignoreDeleteEvents && (a &= ~g.pT.DELETED)), n.$watch(t.identifier.value, this.session, i.baseUri, {
                        recursive: c,
                        excludes: s ? .excludes ? ? [],
                        filter: a
                    }, Boolean(o)), b.JTr.from({
                        dispose: () => n.$unwatch(this.session)
                    })
                }
                dispose() {
                    this._disposable.dispose()
                }
                get onDidCreate() {
                    return this._onDidCreate.event
                }
                get onDidChange() {
                    return this._onDidChange.event
                }
                get onDidDelete() {
                    return this._onDidDelete.event
                }
            }
            class ot {
                constructor(e) {
                    this._events = e, this.session = this._events.session, this._created = new it.o((() => this._events.created.map(d.ov.revive))), this._changed = new it.o((() => this._events.changed.map(d.ov.revive))), this._deleted = new it.o((() => this._events.deleted.map(d.ov.revive)))
                }
                get created() {
                    return this._created.value
                }
                get changed() {
                    return this._changed.value
                }
                get deleted() {
                    return this._deleted.value
                }
            }
            class rt {
                constructor(e, t, i) {
                    this._mainContext = e, this._logService = t, this._extHostDocumentsAndEditors = i, this._onFileSystemEvent = new r.Q5, this._onDidRenameFile = new r.Q5, this._onDidCreateFile = new r.Q5, this._onDidDeleteFile = new r.Q5, this._onWillRenameFile = new r.Qz, this._onWillCreateFile = new r.Qz, this._onWillDeleteFile = new r.Qz, this.onDidRenameFile = this._onDidRenameFile.event, this.onDidCreateFile = this._onDidCreateFile.event, this.onDidDeleteFile = this._onDidDeleteFile.event
                }
                createFileSystemWatcher(e, t, i, s) {
                    return new st(this._mainContext, e, t, this._onFileSystemEvent.event, k.RW.from(i), s)
                }
                $onFileEvent(e) {
                    this._onFileSystemEvent.fire(new ot(e))
                }
                $onDidRunFileOperation(e, t) {
                    switch (e) {
                        case g.si.MOVE:
                            this._onDidRenameFile.fire(Object.freeze({
                                files: t.map((e => ({
                                    oldUri: d.ov.revive(e.source),
                                    newUri: d.ov.revive(e.target)
                                })))
                            }));
                            break;
                        case g.si.DELETE:
                            this._onDidDeleteFile.fire(Object.freeze({
                                files: t.map((e => d.ov.revive(e.target)))
                            }));
                            break;
                        case g.si.CREATE:
                        case g.si.COPY:
                            this._onDidCreateFile.fire(Object.freeze({
                                files: t.map((e => d.ov.revive(e.target)))
                            }))
                    }
                }
                getOnWillRenameFileEvent(e) {
                    return this._createWillExecuteEvent(e, this._onWillRenameFile)
                }
                getOnWillCreateFileEvent(e) {
                    return this._createWillExecuteEvent(e, this._onWillCreateFile)
                }
                getOnWillDeleteFileEvent(e) {
                    return this._createWillExecuteEvent(e, this._onWillDeleteFile)
                }
                _createWillExecuteEvent(e, t) {
                    return (i, s, o) => {
                        const r = function(e) {
                            i.call(s, e)
                        };
                        return r.extension = e, t.event(r, void 0, o)
                    }
                }
                async $onWillRunFileOperation(e, t, i, s) {
                    switch (e) {
                        case g.si.MOVE:
                            return await this._fireWillEvent(this._onWillRenameFile, {
                                files: t.map((e => ({
                                    oldUri: d.ov.revive(e.source),
                                    newUri: d.ov.revive(e.target)
                                })))
                            }, i, s);
                        case g.si.DELETE:
                            return await this._fireWillEvent(this._onWillDeleteFile, {
                                files: t.map((e => d.ov.revive(e.target)))
                            }, i, s);
                        case g.si.CREATE:
                        case g.si.COPY:
                            return await this._fireWillEvent(this._onWillCreateFile, {
                                files: t.map((e => d.ov.revive(e.target)))
                            }, i, s)
                    }
                }
                async _fireWillEvent(e, t, i, s) {
                    const o = new Set,
                        r = [];
                    if (await e.fireAsync(t, s, (async (e, t) => {
                            const s = Date.now(),
                                n = await Promise.resolve(e);
                            n instanceof b.DbP && (r.push([t.extension, n]), o.add(t.extension.displayName ? ? t.extension.identifier.value)), Date.now() - s > i && this._logService.warn("SLOW file-participant", t.extension.identifier)
                        })), s.isCancellationRequested) return;
                    if (0 === r.length) return;
                    const n = {
                        edits: []
                    };
                    for (const [, e] of r) {
                        const {
                            edits: t
                        } = k.Db.from(e, {
                            getTextDocumentVersion: e => this._extHostDocumentsAndEditors.getDocument(e) ? .version,
                            getNotebookDocumentVersion: () => {}
                        });
                        n.edits = n.edits.concat(t)
                    }
                    return {
                        edit: n,
                        extensionNames: Array.from(o)
                    }
                }
            }
            var nt = i("5h1i");
            class at {
                constructor(e, t, i, s, o) {
                    this._extHostNotebooks = t, this._textDocumentsAndEditors = i, this._commands = s;
                    const r = new T.b9("interactive.open", "_interactive.open", "Open interactive window and return notebook editor and input URI", [new T.SF("showOptions", "Show Options", (e => !0), (e => e)), new T.SF("resource", "Interactive resource Uri", (e => !0), (e => e)), new T.SF("controllerId", "Notebook controller Id", (e => !0), (e => e)), new T.SF("title", "Interactive editor title", (e => !0), (e => e))], new T._m("Notebook and input URI", (e => {
                        if (o.debug("[ExtHostInteractive] open iw with notebook editor id", e.notebookEditorId), void 0 !== e.notebookEditorId) {
                            const t = this._extHostNotebooks.getEditorById(e.notebookEditorId);
                            return o.debug("[ExtHostInteractive] notebook editor found", t.id), {
                                notebookUri: d.ov.revive(e.notebookUri),
                                inputUri: d.ov.revive(e.inputUri),
                                notebookEditor: t.apiEditor
                            }
                        }
                        return o.debug("[ExtHostInteractive] notebook editor not found, uris for the interactive document", e.notebookUri, e.inputUri), {
                            notebookUri: d.ov.revive(e.notebookUri),
                            inputUri: d.ov.revive(e.inputUri)
                        }
                    })));
                    this._commands.registerApiCommand(r)
                }
                $willAddInteractiveDocument(e, t, i, s) {
                    this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({
                        addedDocuments: [{
                            EOL: t,
                            lines: [""],
                            languageId: i,
                            uri: e,
                            isDirty: !1,
                            versionId: 1
                        }]
                    })
                }
                $willRemoveInteractiveDocument(e, t) {
                    this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({
                        removedDocuments: [e]
                    })
                }
            }
            class ct {
                constructor(e) {
                    this._handlePool = 0, this._proxy = e.getProxy(x.Tr.MainThreadLabelService)
                }
                $registerResourceLabelFormatter(e) {
                    const t = this._handlePool++;
                    return this._proxy.$registerResourceLabelFormatter(t, e), (0, n.OF)((() => {
                        this._proxy.$unregisterResourceLabelFormatter(t)
                    }))
                }
            }
            var dt = i("La+/"),
                lt = i("Aw1u"),
                ht = i("j3Ei"),
                ut = i("ziTh");
            const pt = "vs/workbench/api/common/extHostLanguageFeatures";
            class mt {
                constructor(e, t) {
                    this._documents = e, this._provider = t
                }
                async provideDocumentSymbols(e, t) {
                    const i = this._documents.getDocument(e),
                        s = await this._provider.provideDocumentSymbols(i, t);
                    return (0, C.XY)(s) ? void 0 : s[0] instanceof b.w6Q ? s.map(k.w6.from) : mt._asDocumentSymbolTree(s)
                }
                static _asDocumentSymbolTree(e) {
                    e = e.slice(0).sort(((e, t) => {
                        let i = e.location.range.start.compareTo(t.location.range.start);
                        return 0 === i && (i = t.location.range.end.compareTo(e.location.range.end)), i
                    }));
                    const t = [],
                        i = [];
                    for (const s of e) {
                        const e = {
                            name: s.name || "!!MISSING: name!!",
                            kind: k.cR.from(s.kind),
                            tags: s.tags ? .map(k.r4.from) || [],
                            detail: "",
                            containerName: s.containerName,
                            range: k.e6.from(s.location.range),
                            selectionRange: k.e6.from(s.location.range),
                            children: []
                        };
                        for (;;) {
                            if (0 === i.length) {
                                i.push(e), t.push(e);
                                break
                            }
                            const s = i[i.length - 1];
                            if (lt.e.containsRange(s.range, e.range) && !lt.e.equalsRange(s.range, e.range)) {
                                s.children ? .push(e), i.push(e);
                                break
                            }
                            i.pop()
                        }
                    }
                    return t
                }
            }
            class gt {
                constructor(e, t, i, s, o, r) {
                    this._documents = e, this._commands = t, this._provider = i, this._extension = s, this._extTelemetry = o, this._logService = r, this._cache = new xe("CodeLens"), this._disposables = new Map
                }
                async provideCodeLenses(e, t) {
                    const i = this._documents.getDocument(e),
                        s = await this._provider.provideCodeLenses(i, t);
                    if (!s || t.isCancellationRequested) return;
                    const o = this._cache.add(s),
                        r = new n.SL;
                    this._disposables.set(o, r);
                    const a = {
                        cacheId: o,
                        lenses: []
                    };
                    for (let e = 0; e < s.length; e++) a.lenses.push({
                        cacheId: [o, e],
                        range: k.e6.from(s[e].range),
                        command: this._commands.toInternal(s[e].command, r)
                    });
                    return a
                }
                async resolveCodeLens(e, t) {
                    const i = e.cacheId && this._cache.get(...e.cacheId);
                    if (!i) return;
                    let s;
                    if (s = "function" != typeof this._provider.resolveCodeLens || i.isResolved ? i : await this._provider.resolveCodeLens(i, t), s || (s = i), t.isCancellationRequested) return;
                    const o = e.cacheId && this._disposables.get(e.cacheId[0]);
                    if (o) {
                        if (!s.command) {
                            const e = new Error("INVALID code lens resolved, lacks command: " + this._extension.identifier.value);
                            return this._extTelemetry.onExtensionError(this._extension.identifier, e), void this._logService.error(e)
                        }
                        return e.command = this._commands.toInternal(s.command, o), e
                    }
                }
                releaseCodeLenses(e) {
                    this._disposables.get(e) ? .dispose(), this._disposables.delete(e), this._cache.delete(e)
                }
            }

            function vt(e) {
                return Array.isArray(e) ? e.map(k.nc.from) : e ? [k.nc.from(e)] : []
            }
            class _t {
                constructor(e, t) {
                    this._documents = e, this._provider = t
                }
                async provideDefinition(e, t, i) {
                    const s = this._documents.getDocument(e),
                        o = k.Ly.to(t);
                    return vt(await this._provider.provideDefinition(s, o, i))
                }
            }
            class ft {
                constructor(e, t) {
                    this._documents = e, this._provider = t
                }
                async provideDeclaration(e, t, i) {
                    const s = this._documents.getDocument(e),
                        o = k.Ly.to(t);
                    return vt(await this._provider.provideDeclaration(s, o, i))
                }
            }
            class yt {
                constructor(e, t) {
                    this._documents = e, this._provider = t
                }
                async provideImplementation(e, t, i) {
                    const s = this._documents.getDocument(e),
                        o = k.Ly.to(t);
                    return vt(await this._provider.provideImplementation(s, o, i))
                }
            }
            class wt {
                constructor(e, t) {
                    this._documents = e, this._provider = t
                }
                async provideTypeDefinition(e, t, i) {
                    const s = this._documents.getDocument(e),
                        o = k.Ly.to(t);
                    return vt(await this._provider.provideTypeDefinition(s, o, i))
                }
            }
            class xt {
                static {
                    this.HOVER_MAP_MAX_SIZE = 10
                }
                constructor(e, t) {
                    this._documents = e, this._provider = t, this._hoverCounter = 0, this._hoverMap = new Map
                }
                async provideHover(e, t, i, s) {
                    const o = this._documents.getDocument(e),
                        r = k.Ly.to(t);
                    let n;
                    if (i && i.verbosityRequest) {
                        const e = i.verbosityRequest.previousHover.id,
                            t = this._hoverMap.get(e);
                        if (!t) throw new Error(`Hover with id ${e} not found`);
                        const a = {
                            verbosityDelta: i.verbosityRequest.verbosityDelta,
                            previousHover: t
                        };
                        n = await this._provider.provideHover(o, r, s, a)
                    } else n = await this._provider.provideHover(o, r, s);
                    if (!n || (0, C.XY)(n.contents)) return;
                    n.range || (n.range = o.getWordRangeAtPosition(r)), n.range || (n.range = new b.e6w(r, r));
                    const a = k.TM.from(n),
                        c = this._hoverCounter;
                    if (this._hoverMap.size === xt.HOVER_MAP_MAX_SIZE) {
                        const e = Math.min(...this._hoverMap.keys());
                        this._hoverMap.delete(e)
                    }
                    return this._hoverMap.set(c, n), this._hoverCounter += 1, { ...a,
                        id: c
                    }
                }
                releaseHover(e) {
                    this._hoverMap.delete(e)
                }
            }
            class bt {
                constructor(e, t) {
                    this._documents = e, this._provider = t
                }
                async provideEvaluatableExpression(e, t, i) {
                    const s = this._documents.getDocument(e),
                        o = k.Ly.to(t),
                        r = await this._provider.provideEvaluatableExpression(s, o, i);
                    if (r) return k.hf.from(r)
                }
            }
            class Dt {
                constructor(e, t) {
                    this._documents = e, this._provider = t
                }
                async provideInlineValues(e, t, i, s) {
                    const o = this._documents.getDocument(e),
                        r = await this._provider.provideInlineValues(o, k.e6.to(t), k.GS.to(i), s);
                    if (Array.isArray(r)) return r.map((e => k.CR.from(e)))
                }
            }
            class Ct {
                constructor(e, t) {
                    this._documents = e, this._provider = t
                }
                async provideDocumentHighlights(e, t, i) {
                    const s = this._documents.getDocument(e),
                        o = k.Ly.to(t),
                        r = await this._provider.provideDocumentHighlights(s, o, i);
                    if (Array.isArray(r)) return r.map(k.eh.from)
                }
            }
            class St {
                constructor(e, t) {
                    this._documents = e, this._provider = t
                }
                async provideMultiDocumentHighlights(e, t, i, s) {
                    const o = this._documents.getDocument(e),
                        r = i.map((e => this._documents.getDocument(e))),
                        n = k.Ly.to(t),
                        a = await this._provider.provideMultiDocumentHighlights(o, n, r, s);
                    if (Array.isArray(a)) return a.map(k.lM.from)
                }
            }
            class Et {
                constructor(e, t) {
                    this._documents = e, this._provider = t
                }
                async provideLinkedEditingRanges(e, t, i) {
                    const s = this._documents.getDocument(e),
                        o = k.Ly.to(t),
                        r = await this._provider.provideLinkedEditingRanges(s, o, i);
                    if (r && Array.isArray(r.ranges)) return {
                        ranges: (0, C.kX)(r.ranges.map(k.e6.from)),
                        wordPattern: r.wordPattern
                    }
                }
            }
            class Pt {
                constructor(e, t) {
                    this._documents = e, this._provider = t
                }
                async provideReferences(e, t, i, s) {
                    const o = this._documents.getDocument(e),
                        r = k.Ly.to(t),
                        n = await this._provider.provideReferences(o, r, i, s);
                    if (Array.isArray(n)) return n.map(k.xh.from)
                }
            }
            class Tt {
                static {
                    this._maxCodeActionsPerFile = 1e3
                }
                constructor(e, t, i, s, o, r, n) {
                    this._documents = e, this._commands = t, this._diagnostics = i, this._provider = s, this._logService = o, this._extension = r, this._apiDeprecation = n, this._cache = new xe("CodeAction"), this._disposables = new Map
                }
                async provideCodeActions(e, t, i, s) {
                    const o = this._documents.getDocument(e),
                        r = ht.Y.isISelection(t) ? k.Y1.to(t) : k.e6.to(t),
                        a = [];
                    for (const t of this._diagnostics.getDiagnostics(e))
                        if (r.intersection(t.range) && a.push(t) > Tt._maxCodeActionsPerFile) break;
                    const c = {
                            diagnostics: a,
                            only: i.only ? new b.yNd(i.only) : void 0,
                            triggerKind: k.CD.to(i.trigger)
                        },
                        d = await this._provider.provideCodeActions(o, r, c, s);
                    if (!(0, C.Of)(d) || s.isCancellationRequested) return;
                    const l = this._cache.add(d),
                        h = new n.SL;
                    this._disposables.set(l, h);
                    const u = [];
                    for (let e = 0; e < d.length; e++) {
                        const t = d[e];
                        if (t)
                            if (Tt._isCommand(t)) this._apiDeprecation.report("CodeActionProvider.provideCodeActions - return commands", this._extension, "Return 'CodeAction' instances instead."), u.push({
                                _isSynthetic: !0,
                                title: t.title,
                                command: this._commands.toInternal(t, h)
                            });
                            else {
                                c.only && (t.kind ? c.only.contains(t.kind) || this._logService.warn(`${this._extension.identifier.value} - Code actions of kind '${c.only.value}' requested but returned code action is of kind '${t.kind.value}'. Code action will be dropped. Please check 'CodeActionContext.only' to only return requested code actions.`) : this._logService.warn(`${this._extension.identifier.value} - Code actions of kind '${c.only.value}' requested but returned code action does not have a 'kind'. Code action will be dropped. Please set 'CodeAction.kind'.`));
                                const i = t.ranges ? ? [];
                                u.push({
                                    cacheId: [l, e],
                                    title: t.title,
                                    command: t.command && this._commands.toInternal(t.command, h),
                                    diagnostics: t.diagnostics && t.diagnostics.map(k.R9.from),
                                    edit: t.edit && k.Db.from(t.edit, void 0),
                                    kind: t.kind && t.kind.value,
                                    isPreferred: t.isPreferred,
                                    isAI: !!(0, q.$x)(this._extension, "codeActionAI") && t.isAI,
                                    ranges: (0, q.$x)(this._extension, "codeActionRanges") ? (0, C.kX)(i.map(k.e6.from)) : void 0,
                                    disabled: t.disabled ? .reason
                                })
                            }
                    }
                    return {
                        cacheId: l,
                        actions: u
                    }
                }
                async resolveCodeAction(e, t) {
                    const [i, s] = e, o = this._cache.get(i, s);
                    if (!o || Tt._isCommand(o)) return {};
                    if (!this._provider.resolveCodeAction) return {};
                    const r = await this._provider.resolveCodeAction(o, t) ? ? o;
                    let n, a;
                    if (r.edit && (n = k.Db.from(r.edit, void 0)), r.command) {
                        const e = this._disposables.get(i);
                        e && (a = this._commands.toInternal(r.command, e))
                    }
                    return {
                        edit: n,
                        command: a
                    }
                }
                releaseCodeActions(e) {
                    this._disposables.get(e) ? .dispose(), this._disposables.delete(e), this._cache.delete(e)
                }
                static _isCommand(e) {
                    return "string" == typeof e.command && "string" == typeof e.title
                }
            }
            class kt {
                constructor(e, t, i, s, o) {
                    this._proxy = e, this._documents = t, this._provider = i, this._handle = s, this._extension = o, this._cache = new xe("DocumentPasteEdit")
                }
                async prepareDocumentPaste(e, t, i, s) {
                    if (!this._provider.prepareDocumentPaste) return;
                    const r = this._documents.getDocument(e),
                        n = t.map((e => k.e6.to(e))),
                        a = k.tn.toDataTransfer(i, (() => {
                            throw new o.nj
                        }));
                    if (await this._provider.prepareDocumentPaste(r, n, a, s), s.isCancellationRequested) return;
                    const c = Array.from(a).filter((([, e]) => !(e instanceof b.qDr)));
                    return k.tn.from(c)
                }
                async providePasteEdits(e, t, i, s, o, r) {
                    if (!this._provider.provideDocumentPasteEdits) return [];
                    const n = this._documents.getDocument(t),
                        a = i.map((e => k.e6.to(e))),
                        c = k.tn.toDataTransfer(s, (async t => (await this._proxy.$resolvePasteFileData(this._handle, e, t)).buffer)),
                        d = await this._provider.provideDocumentPasteEdits(n, a, c, {
                            only: o.only ? new b.MXZ(o.only) : void 0,
                            triggerKind: o.triggerKind
                        }, r);
                    if (!d || r.isCancellationRequested) return [];
                    const l = this._cache.add(d);
                    return d.map(((e, t) => ({
                        _cacheId: [l, t],
                        title: e.title ? ? (0, Ie.C$)(pt, 0, "Paste using '{0}' extension", this._extension.displayName || this._extension.name),
                        kind: e.kind,
                        yieldTo: e.yieldTo ? .map((e => e.value)),
                        insertText: "string" == typeof e.insertText ? e.insertText : {
                            snippet: e.insertText.value
                        },
                        additionalEdit: e.additionalEdit ? k.Db.from(e.additionalEdit, void 0) : void 0
                    })))
                }
                async resolvePasteEdit(e, t) {
                    const [i, s] = e, o = this._cache.get(i, s);
                    if (!o || !this._provider.resolveDocumentPasteEdit) return {};
                    const r = await this._provider.resolveDocumentPasteEdit(o, t) ? ? o;
                    return {
                        additionalEdit: r.additionalEdit ? k.Db.from(r.additionalEdit, void 0) : void 0
                    }
                }
                releasePasteEdits(e) {
                    this._cache.delete(e)
                }
            }
            class It {
                constructor(e, t) {
                    this._documents = e, this._provider = t
                }
                async provideDocumentFormattingEdits(e, t, i) {
                    const s = this._documents.getDocument(e),
                        o = await this._provider.provideDocumentFormattingEdits(s, t, i);
                    if (Array.isArray(o)) return o.map(k.PY.from)
                }
            }
            class At {
                constructor(e, t) {
                    this._documents = e, this._provider = t
                }
                async provideDocumentRangeFormattingEdits(e, t, i, s) {
                    const o = this._documents.getDocument(e),
                        r = k.e6.to(t),
                        n = await this._provider.provideDocumentRangeFormattingEdits(o, r, i, s);
                    if (Array.isArray(n)) return n.map(k.PY.from)
                }
                async provideDocumentRangesFormattingEdits(e, t, i, s) {
                    (0, z.p_)("function" == typeof this._provider.provideDocumentRangesFormattingEdits, "INVALID invocation of `provideDocumentRangesFormattingEdits`");
                    const o = this._documents.getDocument(e),
                        r = t.map(k.e6.to),
                        n = await this._provider.provideDocumentRangesFormattingEdits(o, r, i, s);
                    if (Array.isArray(n)) return n.map(k.PY.from)
                }
            }
            class $t {
                constructor(e, t) {
                    this._documents = e, this._provider = t, this.autoFormatTriggerCharacters = []
                }
                async provideOnTypeFormattingEdits(e, t, i, s, o) {
                    const r = this._documents.getDocument(e),
                        n = k.Ly.to(t),
                        a = await this._provider.provideOnTypeFormattingEdits(r, n, i, s, o);
                    if (Array.isArray(a)) return a.map(k.PY.from)
                }
            }
            class Rt {
                constructor(e, t) {
                    this._provider = e, this._logService = t, this._cache = new xe("WorkspaceSymbols")
                }
                async provideWorkspaceSymbols(e, t) {
                    const i = await this._provider.provideWorkspaceSymbols(e, t);
                    if (!(0, C.Of)(i)) return {
                        symbols: []
                    };
                    const s = this._cache.add(i),
                        o = {
                            cacheId: s,
                            symbols: []
                        };
                    for (let e = 0; e < i.length; e++) {
                        const t = i[e];
                        t && t.name ? o.symbols.push({ ...k.$P.from(t),
                            cacheId: [s, e]
                        }) : this._logService.warn("INVALID SymbolInformation", t)
                    }
                    return o
                }
                async resolveWorkspaceSymbol(e, t) {
                    if ("function" != typeof this._provider.resolveWorkspaceSymbol) return e;
                    if (!e.cacheId) return e;
                    const i = this._cache.get(...e.cacheId);
                    if (i) {
                        const s = await this._provider.resolveWorkspaceSymbol(i, t);
                        return s && (0, le.jB)(e, k.$P.from(s), !0)
                    }
                }
                releaseWorkspaceSymbols(e) {
                    this._cache.delete(e)
                }
            }
            class Ht {
                static supportsResolving(e) {
                    return "function" == typeof e.prepareRename
                }
                constructor(e, t, i) {
                    this._documents = e, this._provider = t, this._logService = i
                }
                async provideRenameEdits(e, t, i, s) {
                    const o = this._documents.getDocument(e),
                        r = k.Ly.to(t);
                    try {
                        const e = await this._provider.provideRenameEdits(o, r, i, s);
                        if (!e) return;
                        return k.Db.from(e)
                    } catch (e) {
                        const t = Ht._asMessage(e);
                        return t ? {
                            rejectReason: t,
                            edits: void 0
                        } : Promise.reject(e)
                    }
                }
                async resolveRenameLocation(e, t, i) {
                    if ("function" != typeof this._provider.prepareRename) return Promise.resolve(void 0);
                    const s = this._documents.getDocument(e),
                        o = k.Ly.to(t);
                    try {
                        const e = await this._provider.prepareRename(s, o, i);
                        let t, r;
                        if (b.e6w.isRange(e) ? (t = e, r = s.getText(e)) : (0, z.Kn)(e) && (t = e.range, r = e.placeholder), !t || !r) return;
                        return t.start.line > o.line || t.end.line < o.line ? void this._logService.warn("INVALID rename location: position line must be within range start/end lines") : {
                            range: k.e6.from(t),
                            text: r
                        }
                    } catch (e) {
                        const t = Ht._asMessage(e);
                        return t ? {
                            rejectReason: t,
                            range: void 0,
                            text: void 0
                        } : Promise.reject(e)
                    }
                }
                static _asMessage(e) {
                    return "string" == typeof e ? e : e instanceof Error && "string" == typeof e.message ? e.message : void 0
                }
            }
            class Ft {
                static {
                    this.languageTriggerKindToVSCodeTriggerKind = {
                        [S.Ll.Invoke]: b.Llw.Invoke,
                        [S.Ll.Automatic]: b.Llw.Automatic
                    }
                }
                constructor(e, t, i) {
                    this._documents = e, this._provider = t, this._logService = i
                }
                async supportsAutomaticNewSymbolNamesTriggerKind() {
                    return this._provider.supportsAutomaticTriggerKind
                }
                async provideNewSymbolNames(e, t, i, s) {
                    const o = this._documents.getDocument(e),
                        r = k.e6.to(t);
                    try {
                        const e = Ft.languageTriggerKindToVSCodeTriggerKind[i],
                            t = await this._provider.provideNewSymbolNames(o, r, e, s);
                        if (!t) return;
                        return t.map((e => "string" == typeof e ? {
                            newSymbolName: e
                        } : {
                            newSymbolName: e.newSymbolName,
                            tags: e.tags
                        }))
                    } catch (e) {
                        return void this._logService.error(Ft._asMessage(e) ? ? JSON.stringify(e, null, "\t"))
                    }
                }
                static _asMessage(e) {
                    return "string" == typeof e ? e : e instanceof Error && "string" == typeof e.message ? e.message : void 0
                }
            }
            class Nt {
                constructor(e, t) {
                    this.resultId = e, this.tokens = t
                }
            }
            class Mt {
                constructor(e, t) {
                    this._documents = e, this._provider = t, this._nextResultId = 1, this._previousResults = new Map
                }
                async provideDocumentSemanticTokens(e, t, i) {
                    const s = this._documents.getDocument(e),
                        o = 0 !== t ? this._previousResults.get(t) : null;
                    let r = "string" == typeof o ? .resultId && "function" == typeof this._provider.provideDocumentSemanticTokensEdits ? await this._provider.provideDocumentSemanticTokensEdits(s, o.resultId, i) : await this._provider.provideDocumentSemanticTokens(s, i);
                    return o && this._previousResults.delete(t), r ? (r = Mt._fixProvidedSemanticTokens(r), this._send(Mt._convertToEdits(o, r), r)) : null
                }
                async releaseDocumentSemanticColoring(e) {
                    this._previousResults.delete(e)
                }
                static _fixProvidedSemanticTokens(e) {
                    return Mt._isSemanticTokens(e) ? Mt._isCorrectSemanticTokens(e) ? e : new b.Uzh(new Uint32Array(e.data), e.resultId) : Mt._isSemanticTokensEdits(e) ? Mt._isCorrectSemanticTokensEdits(e) ? e : new b.JQb(e.edits.map((e => new b.FR$(e.start, e.deleteCount, e.data ? new Uint32Array(e.data) : e.data))), e.resultId) : e
                }
                static _isSemanticTokens(e) {
                    return e && !!e.data
                }
                static _isCorrectSemanticTokens(e) {
                    return e.data instanceof Uint32Array
                }
                static _isSemanticTokensEdits(e) {
                    return e && Array.isArray(e.edits)
                }
                static _isCorrectSemanticTokensEdits(e) {
                    for (const t of e.edits)
                        if (!(t.data instanceof Uint32Array)) return !1;
                    return !0
                }
                static _convertToEdits(e, t) {
                    if (!Mt._isSemanticTokens(t)) return t;
                    if (!e || !e.tokens) return t;
                    const i = e.tokens,
                        s = i.length,
                        o = t.data,
                        r = o.length;
                    let n = 0;
                    const a = Math.min(s, r);
                    for (; n < a && i[n] === o[n];) n++;
                    if (n === s && n === r) return new b.JQb([], t.resultId);
                    let c = 0;
                    const d = a - n;
                    for (; c < d && i[s - c - 1] === o[r - c - 1];) c++;
                    return new b.JQb([{
                        start: n,
                        deleteCount: s - n - c,
                        data: o.subarray(n, r - c)
                    }], t.resultId)
                }
                _send(e, t) {
                    if (Mt._isSemanticTokens(e)) {
                        const t = this._nextResultId++;
                        return this._previousResults.set(t, new Nt(e.resultId, e.data)), (0, E.C)({
                            id: t,
                            type: "full",
                            data: e.data
                        })
                    }
                    if (Mt._isSemanticTokensEdits(e)) {
                        const i = this._nextResultId++;
                        return Mt._isSemanticTokens(t) ? this._previousResults.set(i, new Nt(t.resultId, t.data)) : this._previousResults.set(i, new Nt(e.resultId)), (0, E.C)({
                            id: i,
                            type: "delta",
                            deltas: (e.edits || []).map((e => ({
                                start: e.start,
                                deleteCount: e.deleteCount,
                                data: e.data
                            })))
                        })
                    }
                    return null
                }
            }
            class Lt {
                constructor(e, t) {
                    this._documents = e, this._provider = t
                }
                async provideDocumentRangeSemanticTokens(e, t, i) {
                    const s = this._documents.getDocument(e),
                        o = await this._provider.provideDocumentRangeSemanticTokens(s, k.e6.to(t), i);
                    return o ? this._send(o) : null
                }
                _send(e) {
                    return (0, E.C)({
                        id: 0,
                        type: "full",
                        data: e.data
                    })
                }
            }
            class Ot {
                static supportsResolving(e) {
                    return "function" == typeof e.resolveCompletionItem
                }
                constructor(e, t, i, s, o) {
                    this._documents = e, this._commands = t, this._provider = i, this._apiDeprecation = s, this._extension = o, this._cache = new xe("CompletionItem"), this._disposables = new Map
                }
                async provideCompletionItems(e, t, i, s) {
                    const o = this._documents.getDocument(e),
                        r = k.Ly.to(t),
                        a = o.getWordRangeAtPosition(r) || new b.e6w(r, r),
                        c = a.with({
                            end: r
                        }),
                        d = new B.G,
                        l = await this._provider.provideCompletionItems(o, r, s, k.TK.to(i));
                    if (!l) return;
                    if (s.isCancellationRequested) return;
                    const h = Array.isArray(l) ? new b.Ub$(l) : l,
                        u = Ot.supportsResolving(this._provider) ? this._cache.add(h.items) : this._cache.add([]),
                        p = new n.SL;
                    this._disposables.set(u, p);
                    const m = [],
                        g = {
                            x: u,
                            [x.Sm.completions]: m,
                            [x.Sm.defaultRanges]: {
                                replace: k.e6.from(a),
                                insert: k.e6.from(c)
                            },
                            [x.Sm.isIncomplete]: h.isIncomplete || void 0,
                            [x.Sm.duration]: d.elapsed()
                        };
                    for (let e = 0; e < h.items.length; e++) {
                        const t = h.items[e],
                            i = this._convertCompletionItem(t, [u, e], c, a);
                        m.push(i)
                    }
                    return g
                }
                async resolveCompletionItem(e, t) {
                    if ("function" != typeof this._provider.resolveCompletionItem) return;
                    const i = this._cache.get(...e);
                    if (!i) return;
                    const s = this._convertCompletionItem(i, e),
                        o = await this._provider.resolveCompletionItem(i, t);
                    if (!o) return;
                    const r = this._convertCompletionItem(o, e);
                    return s[x.Jv.insertText] === r[x.Jv.insertText] && s[x.Jv.insertTextRules] === r[x.Jv.insertTextRules] || this._apiDeprecation.report("CompletionItem.insertText", this._extension, "extension MAY NOT change 'insertText' of a CompletionItem during resolve"), s[x.Jv.commandIdent] === r[x.Jv.commandIdent] && s[x.Jv.commandId] === r[x.Jv.commandId] && (0, le.fS)(s[x.Jv.commandArguments], r[x.Jv.commandArguments]) || this._apiDeprecation.report("CompletionItem.command", this._extension, "extension MAY NOT change 'command' of a CompletionItem during resolve"), { ...s,
                        [x.Jv.documentation]: r[x.Jv.documentation],
                        [x.Jv.detail]: r[x.Jv.detail],
                        [x.Jv.additionalTextEdits]: r[x.Jv.additionalTextEdits],
                        [x.Jv.insertText]: r[x.Jv.insertText],
                        [x.Jv.insertTextRules]: r[x.Jv.insertTextRules],
                        [x.Jv.commandIdent]: r[x.Jv.commandIdent],
                        [x.Jv.commandId]: r[x.Jv.commandId],
                        [x.Jv.commandArguments]: r[x.Jv.commandArguments]
                    }
                }
                releaseCompletionItems(e) {
                    this._disposables.get(e) ? .dispose(), this._disposables.delete(e), this._cache.delete(e)
                }
                _convertCompletionItem(e, t, i, s) {
                    const o = this._disposables.get(t[0]);
                    if (!o) throw Error("DisposableStore is missing...");
                    const r = this._commands.toInternal(e.command, o),
                        n = {
                            x: t,
                            [x.Jv.label]: e.label,
                            [x.Jv.kind]: void 0 !== e.kind ? k.cm.from(e.kind) : void 0,
                            [x.Jv.kindModifier]: e.tags && e.tags.map(k.we.from),
                            [x.Jv.detail]: e.detail,
                            [x.Jv.documentation]: void 0 === e.documentation ? void 0 : k.W5.fromStrict(e.documentation),
                            [x.Jv.sortText]: e.sortText !== e.label ? e.sortText : void 0,
                            [x.Jv.filterText]: e.filterText !== e.label ? e.filterText : void 0,
                            [x.Jv.preselect]: e.preselect || void 0,
                            [x.Jv.insertTextRules]: e.keepWhitespace ? S.a7.KeepWhitespace : S.a7.None,
                            [x.Jv.commitCharacters]: e.commitCharacters ? .join(""),
                            [x.Jv.additionalTextEdits]: e.additionalTextEdits && e.additionalTextEdits.map(k.PY.from),
                            [x.Jv.commandIdent]: r ? .$ident,
                            [x.Jv.commandId]: r ? .id,
                            [x.Jv.commandArguments]: r ? .$ident ? void 0 : r ? .arguments
                        };
                    let a;
                    return e.textEdit ? (this._apiDeprecation.report("CompletionItem.textEdit", this._extension, "Use 'CompletionItem.insertText' and 'CompletionItem.range' instead."), n[x.Jv.insertText] = e.textEdit.newText) : "string" == typeof e.insertText ? n[x.Jv.insertText] = e.insertText : e.insertText instanceof b.EG5 && (n[x.Jv.insertText] = e.insertText.value, n[x.Jv.insertTextRules] |= S.a7.InsertAsSnippet), e.textEdit ? a = e.textEdit.range : e.range && (a = e.range), b.e6w.isRange(a) ? n[x.Jv.range] = k.e6.from(a) : !a || i ? .isEqual(a.inserting) && s ? .isEqual(a.replacing) || (n[x.Jv.range] = {
                        insert: k.e6.from(a.inserting),
                        replace: k.e6.from(a.replacing)
                    }), n
                }
            }
            class Ut {
                async provideInlineCompletions(e, t, i, s) {}
                async provideInlineEdits(e, t, i, s) {}
                disposeCompletions(e) {}
                handleDidShowCompletionItem(e, t, i) {}
                handlePartialAccept(e, t, i, s) {}
            }
            class Vt extends Ut {
                constructor(e, t, i, s) {
                    super(), this._extension = e, this._documents = t, this._provider = i, this._commands = s, this._references = new Bt, this._isAdditionsProposedApiEnabled = (0, q.$x)(this._extension, "inlineCompletionsAdditions"), this.languageTriggerKindToVSCodeTriggerKind = {
                        [S.bw.Automatic]: b.bwv.Automatic,
                        [S.bw.Explicit]: b.bwv.Invoke
                    }
                }
                get supportsHandleEvents() {
                    return (0, q.$x)(this._extension, "inlineCompletionsAdditions") && ("function" == typeof this._provider.handleDidShowCompletionItem || "function" == typeof this._provider.handleDidPartiallyAcceptCompletionItem)
                }
                async provideInlineCompletions(e, t, i, s) {
                    const o = this._documents.getDocument(e),
                        r = k.Ly.to(t),
                        a = await this._provider.provideInlineCompletionItems(o, r, {
                            selectedCompletionInfo: i.selectedSuggestionInfo ? {
                                range: k.e6.to(i.selectedSuggestionInfo.range),
                                text: i.selectedSuggestionInfo.text
                            } : void 0,
                            triggerKind: this.languageTriggerKindToVSCodeTriggerKind[i.triggerKind]
                        }, s);
                    if (!a) return;
                    if (s.isCancellationRequested) return;
                    const c = Array.isArray(a) ? a : a.items,
                        d = this._isAdditionsProposedApiEnabled ? Array.isArray(a) ? [] : a.commands || [] : [],
                        l = this._isAdditionsProposedApiEnabled && !Array.isArray(a) ? a.enableForwardStability : void 0;
                    let h;
                    return {
                        pid: this._references.createReferenceId({
                            dispose() {
                                h ? .dispose()
                            },
                            items: c
                        }),
                        items: c.map(((e, t) => {
                            let i;
                            e.command && (h || (h = new n.SL), i = this._commands.toInternal(e.command, h));
                            const s = e.insertText;
                            return {
                                insertText: "string" == typeof s ? s : {
                                    snippet: s.value
                                },
                                filterText: e.filterText,
                                range: e.range ? k.e6.from(e.range) : void 0,
                                command: i,
                                idx: t,
                                completeBracketPairs: !!this._isAdditionsProposedApiEnabled && e.completeBracketPairs
                            }
                        })),
                        commands: d.map((e => (h || (h = new n.SL), this._commands.toInternal(e, h)))),
                        suppressSuggestions: !1,
                        enableForwardStability: l
                    }
                }
                async provideInlineEdits(e, t, i, s) {
                    if (!this._provider.provideInlineEdits) return;
                    (0, q.H5)(this._extension, "inlineCompletionsAdditions");
                    const o = this._documents.getDocument(e),
                        r = k.e6.to(t),
                        a = await this._provider.provideInlineEdits(o, r, {
                            selectedCompletionInfo: i.selectedSuggestionInfo ? {
                                range: k.e6.to(i.selectedSuggestionInfo.range),
                                text: i.selectedSuggestionInfo.text
                            } : void 0,
                            triggerKind: this.languageTriggerKindToVSCodeTriggerKind[i.triggerKind],
                            userPrompt: i.userPrompt
                        }, s);
                    if (!a) return;
                    if (s.isCancellationRequested) return;
                    const c = Array.isArray(a) ? a : a.items,
                        d = this._isAdditionsProposedApiEnabled ? Array.isArray(a) ? [] : a.commands || [] : [],
                        l = this._isAdditionsProposedApiEnabled && !Array.isArray(a) ? a.enableForwardStability : void 0;
                    let h;
                    return {
                        pid: this._references.createReferenceId({
                            dispose() {
                                h ? .dispose()
                            },
                            items: c
                        }),
                        items: c.map(((e, t) => {
                            let i;
                            e.command && (h || (h = new n.SL), i = this._commands.toInternal(e.command, h));
                            const s = e.insertText;
                            return {
                                insertText: "string" == typeof s ? s : {
                                    snippet: s.value
                                },
                                filterText: e.filterText,
                                range: e.range ? k.e6.from(e.range) : void 0,
                                command: i,
                                idx: t,
                                completeBracketPairs: !!this._isAdditionsProposedApiEnabled && e.completeBracketPairs
                            }
                        })),
                        commands: d.map((e => (h || (h = new n.SL), this._commands.toInternal(e, h)))),
                        suppressSuggestions: !1,
                        enableForwardStability: l
                    }
                }
                disposeCompletions(e) {
                    const t = this._references.disposeReferenceId(e);
                    t ? .dispose()
                }
                handleDidShowCompletionItem(e, t, i) {
                    const s = this._references.get(e) ? .items[t];
                    s && this._provider.handleDidShowCompletionItem && this._isAdditionsProposedApiEnabled && this._provider.handleDidShowCompletionItem(s, i)
                }
                handlePartialAccept(e, t, i, s) {
                    const o = this._references.get(e) ? .items[t];
                    o && this._provider.handleDidPartiallyAcceptCompletionItem && this._isAdditionsProposedApiEnabled && (this._provider.handleDidPartiallyAcceptCompletionItem(o, i), this._provider.handleDidPartiallyAcceptCompletionItem(o, k.hI.to(s)))
                }
            }
            class Wt {
                async provideInlineEdits(e, t, i) {
                    const s = this._documents.getDocument(e),
                        o = await this._provider.provideInlineEdit(s, {
                            triggerKind: this.languageTriggerKindToVSCodeTriggerKind[t.triggerKind]
                        }, i);
                    if (!o) return;
                    if (i.isCancellationRequested) return;
                    let r;
                    const a = this._references.createReferenceId({
                        dispose() {
                            r ? .dispose()
                        },
                        item: o
                    });
                    let c, d;
                    return o.accepted && (r || (r = new n.SL), c = this._commands.toInternal(o.accepted, r)), o.rejected && (r || (r = new n.SL), d = this._commands.toInternal(o.rejected, r)), {
                        pid: a,
                        text: o.text,
                        range: k.e6.from(o.range),
                        accepted: c,
                        rejected: d
                    }
                }
                disposeEdit(e) {
                    const t = this._references.disposeReferenceId(e);
                    t ? .dispose()
                }
                constructor(e, t, i, s) {
                    this._documents = t, this._provider = i, this._commands = s, this._references = new Bt, this.languageTriggerKindToVSCodeTriggerKind = {
                        [S.rn.Automatic]: b.rnR.Automatic,
                        [S.rn.Invoke]: b.rnR.Invoke
                    }
                }
            }
            class Bt {
                constructor() {
                    this._references = new Map, this._idPool = 1
                }
                createReferenceId(e) {
                    const t = this._idPool++;
                    return this._references.set(t, e), t
                }
                disposeReferenceId(e) {
                    const t = this._references.get(e);
                    return this._references.delete(e), t
                }
                get(e) {
                    return this._references.get(e)
                }
            }
            class zt {
                constructor(e, t) {
                    this._documents = e, this._provider = t, this._cache = new xe("SignatureHelp")
                }
                async provideSignatureHelp(e, t, i, s) {
                    const o = this._documents.getDocument(e),
                        r = k.Ly.to(t),
                        n = this.reviveContext(i),
                        a = await this._provider.provideSignatureHelp(o, r, s, n);
                    if (a) {
                        const e = this._cache.add([a]);
                        return { ...k.vy.from(a),
                            id: e
                        }
                    }
                }
                reviveContext(e) {
                    let t;
                    if (e.activeSignatureHelp) {
                        const i = k.vy.to(e.activeSignatureHelp),
                            s = this._cache.get(e.activeSignatureHelp.id, 0);
                        s ? (t = s, t.activeSignature = i.activeSignature, t.activeParameter = i.activeParameter) : t = i
                    }
                    return { ...e,
                        activeSignatureHelp: t
                    }
                }
                releaseSignatureHelp(e) {
                    this._cache.delete(e)
                }
            }
            class jt {
                constructor(e, t, i, s, o) {
                    this._documents = e, this._commands = t, this._provider = i, this._logService = s, this._extension = o, this._cache = new xe("InlayHints"), this._disposables = new Map
                }
                async provideInlayHints(e, t, i) {
                    const s = this._documents.getDocument(e),
                        o = k.e6.to(t),
                        r = await this._provider.provideInlayHints(s, o, i);
                    if (!Array.isArray(r) || 0 === r.length) return void this._logService.trace(`[InlayHints] NO inlay hints from '${this._extension.identifier.value}' for range ${JSON.stringify(t)}`);
                    if (i.isCancellationRequested) return;
                    const a = this._cache.add(r);
                    this._disposables.set(a, new n.SL);
                    const c = {
                        hints: [],
                        cacheId: a
                    };
                    for (let e = 0; e < r.length; e++) this._isValidInlayHint(r[e], o) && c.hints.push(this._convertInlayHint(r[e], [a, e]));
                    return this._logService.trace(`[InlayHints] ${c.hints.length} inlay hints from '${this._extension.identifier.value}' for range ${JSON.stringify(t)}`), c
                }
                async resolveInlayHint(e, t) {
                    if ("function" != typeof this._provider.resolveInlayHint) return;
                    const i = this._cache.get(...e);
                    if (!i) return;
                    const s = await this._provider.resolveInlayHint(i, t);
                    return s && this._isValidInlayHint(s) ? this._convertInlayHint(s, e) : void 0
                }
                releaseHints(e) {
                    this._disposables.get(e) ? .dispose(), this._disposables.delete(e), this._cache.delete(e)
                }
                _isValidInlayHint(e, t) {
                    return 0 === e.label.length || Array.isArray(e.label) && e.label.every((e => 0 === e.value.length)) ? (ut.log("INVALID inlay hint, empty label", e), !1) : !(t && !t.contains(e.position))
                }
                _convertInlayHint(e, t) {
                    const i = this._disposables.get(t[0]);
                    if (!i) throw Error("DisposableStore is missing...");
                    const s = {
                        label: "",
                        cacheId: t,
                        tooltip: k.W5.fromStrict(e.tooltip),
                        position: k.Ly.from(e.position),
                        textEdits: e.textEdits && e.textEdits.map(k.PY.from),
                        kind: e.kind && k.gl.from(e.kind),
                        paddingLeft: e.paddingLeft,
                        paddingRight: e.paddingRight
                    };
                    if ("string" == typeof e.label) s.label = e.label;
                    else {
                        const t = [];
                        s.label = t;
                        for (const s of e.label) {
                            if (!s.value) {
                                ut.warn("INVALID inlay hint, empty label part", this._extension.identifier.value);
                                continue
                            }
                            const e = {
                                label: s.value,
                                tooltip: k.W5.fromStrict(s.tooltip)
                            };
                            b.YeX.isLocation(s.location) && (e.location = k.xh.from(s.location)), s.command && (e.command = this._commands.toInternal(s.command, i)), t.push(e)
                        }
                    }
                    return s
                }
            }
            class qt {
                constructor(e, t) {
                    this._documents = e, this._provider = t, this._cache = new xe("DocumentLink")
                }
                async provideLinks(e, t) {
                    const i = this._documents.getDocument(e),
                        s = await this._provider.provideDocumentLinks(i, t);
                    if (Array.isArray(s) && 0 !== s.length && !t.isCancellationRequested) {
                        if ("function" != typeof this._provider.resolveDocumentLink) return {
                            links: s.filter(qt._validateLink).map(k.jW.from)
                        }; {
                            const e = this._cache.add(s),
                                t = {
                                    links: [],
                                    cacheId: e
                                };
                            for (let i = 0; i < s.length; i++) {
                                if (!qt._validateLink(s[i])) continue;
                                const o = k.jW.from(s[i]);
                                o.cacheId = [e, i], t.links.push(o)
                            }
                            return t
                        }
                    }
                }
                static _validateLink(e) {
                    return !(e.target && e.target.path.length > 5e4 && (ut.warn("DROPPING link because it is too long"), 1))
                }
                async resolveLink(e, t) {
                    if ("function" != typeof this._provider.resolveDocumentLink) return;
                    const i = this._cache.get(...e);
                    if (!i) return;
                    const s = await this._provider.resolveDocumentLink(i, t);
                    return s && qt._validateLink(s) ? k.jW.from(s) : void 0
                }
                releaseLinks(e) {
                    this._cache.delete(e)
                }
            }
            class Kt {
                constructor(e, t) {
                    this._documents = e, this._provider = t
                }
                async provideColors(e, t) {
                    const i = this._documents.getDocument(e),
                        s = await this._provider.provideDocumentColors(i, t);
                    return Array.isArray(s) ? s.map((e => ({
                        color: k.Il.from(e.color),
                        range: k.e6.from(e.range)
                    }))) : []
                }
                async provideColorPresentations(e, t, i) {
                    const s = this._documents.getDocument(e),
                        o = k.e6.to(t.range),
                        r = k.Il.to(t.color),
                        n = await this._provider.provideColorPresentations(r, {
                            document: s,
                            range: o
                        }, i);
                    if (Array.isArray(n)) return n.map(k.oi.from)
                }
            }
            class Jt {
                constructor(e, t) {
                    this._documents = e, this._provider = t
                }
                async provideFoldingRanges(e, t, i) {
                    const s = this._documents.getDocument(e),
                        o = await this._provider.provideFoldingRanges(s, t, i);
                    if (Array.isArray(o)) return o.map(k.so.from)
                }
            }
            class Gt {
                constructor(e, t, i) {
                    this._documents = e, this._provider = t, this._logService = i
                }
                async provideSelectionRanges(e, t, i) {
                    const s = this._documents.getDocument(e),
                        o = t.map(k.Ly.to),
                        r = await this._provider.provideSelectionRanges(s, o, i);
                    if (!(0, C.Of)(r)) return [];
                    if (r.length !== o.length) return this._logService.warn("BAD selection ranges, provider must return ranges for each position"), [];
                    const n = [];
                    for (let e = 0; e < o.length; e++) {
                        const t = [];
                        n.push(t);
                        let i = o[e],
                            s = r[e];
                        for (;;) {
                            if (!s.range.contains(i)) throw new Error("INVALID selection range, must contain the previous range");
                            if (t.push(k.xm.from(s)), !s.parent) break;
                            i = s.range, s = s.parent
                        }
                    }
                    return n
                }
            }
            class Qt {
                constructor(e, t) {
                    this._documents = e, this._provider = t, this._idPool = new dt.R(""), this._cache = new Map
                }
                async prepareSession(e, t, i) {
                    const s = this._documents.getDocument(e),
                        o = k.Ly.to(t),
                        r = await this._provider.prepareCallHierarchy(s, o, i);
                    if (!r) return;
                    const n = this._idPool.nextId();
                    return this._cache.set(n, new Map), Array.isArray(r) ? r.map((e => this._cacheAndConvertItem(n, e))) : [this._cacheAndConvertItem(n, r)]
                }
                async provideCallsTo(e, t, i) {
                    const s = this._itemFromCache(e, t);
                    if (!s) throw new Error("missing call hierarchy item");
                    const o = await this._provider.provideCallHierarchyIncomingCalls(s, i);
                    if (o) return o.map((t => ({
                        from: this._cacheAndConvertItem(e, t.from),
                        fromRanges: t.fromRanges.map((e => k.e6.from(e)))
                    })))
                }
                async provideCallsFrom(e, t, i) {
                    const s = this._itemFromCache(e, t);
                    if (!s) throw new Error("missing call hierarchy item");
                    const o = await this._provider.provideCallHierarchyOutgoingCalls(s, i);
                    if (o) return o.map((t => ({
                        to: this._cacheAndConvertItem(e, t.to),
                        fromRanges: t.fromRanges.map((e => k.e6.from(e)))
                    })))
                }
                releaseSession(e) {
                    this._cache.delete(e)
                }
                _cacheAndConvertItem(e, t) {
                    const i = this._cache.get(e),
                        s = k.ll.from(t, e, i.size.toString(36));
                    return i.set(s._itemId, t), s
                }
                _itemFromCache(e, t) {
                    const i = this._cache.get(e);
                    return i ? .get(t)
                }
            }
            class Zt {
                constructor(e, t) {
                    this._documents = e, this._provider = t, this._idPool = new dt.R(""), this._cache = new Map
                }
                async prepareSession(e, t, i) {
                    const s = this._documents.getDocument(e),
                        o = k.Ly.to(t),
                        r = await this._provider.prepareTypeHierarchy(s, o, i);
                    if (!r) return;
                    const n = this._idPool.nextId();
                    return this._cache.set(n, new Map), Array.isArray(r) ? r.map((e => this._cacheAndConvertItem(n, e))) : [this._cacheAndConvertItem(n, r)]
                }
                async provideSupertypes(e, t, i) {
                    const s = this._itemFromCache(e, t);
                    if (!s) throw new Error("missing type hierarchy item");
                    const o = await this._provider.provideTypeHierarchySupertypes(s, i);
                    if (o) return o.map((t => this._cacheAndConvertItem(e, t)))
                }
                async provideSubtypes(e, t, i) {
                    const s = this._itemFromCache(e, t);
                    if (!s) throw new Error("missing type hierarchy item");
                    const o = await this._provider.provideTypeHierarchySubtypes(s, i);
                    if (o) return o.map((t => this._cacheAndConvertItem(e, t)))
                }
                releaseSession(e) {
                    this._cache.delete(e)
                }
                _cacheAndConvertItem(e, t) {
                    const i = this._cache.get(e),
                        s = k.fQ.from(t, e, i.size.toString(36));
                    return i.set(s._itemId, t), s
                }
                _itemFromCache(e, t) {
                    const i = this._cache.get(e);
                    return i ? .get(t)
                }
            }
            class Yt {
                constructor(e, t, i, s, o) {
                    this._proxy = e, this._documents = t, this._provider = i, this._handle = s, this._extension = o, this._cache = new xe("DocumentDropEdit")
                }
                async provideDocumentOnDropEdits(e, t, i, s, o) {
                    const r = this._documents.getDocument(t),
                        n = k.Ly.to(i),
                        a = k.tn.toDataTransfer(s, (async t => (await this._proxy.$resolveDocumentOnDropFileData(this._handle, e, t)).buffer)),
                        c = await this._provider.provideDocumentDropEdits(r, n, a, o);
                    if (!c) return;
                    const d = (0, C._2)(c),
                        l = this._cache.add(d);
                    return d.map(((e, t) => ({
                        _cacheId: [l, t],
                        title: e.title ? ? (0, Ie.C$)(pt, 1, "Drop using '{0}' extension", this._extension.displayName || this._extension.name),
                        kind: e.kind ? .value,
                        yieldTo: e.yieldTo ? .map((e => e.value)),
                        insertText: "string" == typeof e.insertText ? e.insertText : {
                            snippet: e.insertText.value
                        },
                        additionalEdit: e.additionalEdit ? k.Db.from(e.additionalEdit, void 0) : void 0
                    })))
                }
                async resolveDropEdit(e, t) {
                    const [i, s] = e, o = this._cache.get(i, s);
                    if (!o || !this._provider.resolveDocumentDropEdit) return {};
                    const r = await this._provider.resolveDocumentDropEdit(o, t) ? ? o;
                    return {
                        additionalEdit: r.additionalEdit ? k.Db.from(r.additionalEdit, void 0) : void 0
                    }
                }
                releaseDropEdits(e) {
                    this._cache.delete(e)
                }
            }
            class Xt {
                constructor(e, t) {
                    this._documents = e, this._provider = t
                }
                async provideMappedEdits(e, t, i, s) {
                    const o = d.ov.revive(e),
                        r = this._documents.getDocument(o),
                        n = i.documents.map((e => e.map((e => ({
                            uri: d.ov.revive(e.uri),
                            version: e.version,
                            ranges: e.ranges.map((e => k.e6.to(e)))
                        }))))),
                        a = {
                            documents: n,
                            selections: n[0] ? .[0] ? .ranges ? ? []
                        },
                        c = await this._provider.provideMappedEdits(r, t, a, s);
                    return c ? k.Db.from(c) : null
                }
            }
            class ei {
                constructor(e, t) {
                    this.adapter = e, this.extension = t
                }
            }
            class ti {
                static {
                    this._handlePool = 0
                }
                constructor(e, t, i, s, o, r, n, a) {
                    this._uriTransformer = t, this._documents = i, this._commands = s, this._diagnostics = o, this._logService = r, this._apiDeprecation = n, this._extensionTelemetry = a, this._adapter = new Map, this._proxy = e.getProxy(x.Tr.MainThreadLanguageFeatures)
                }
                _transformDocumentSelector(e, t) {
                    return k.Lq.from(e, this._uriTransformer, t)
                }
                _createDisposable(e) {
                    return new b.JTr((() => {
                        this._adapter.delete(e), this._proxy.$unregister(e)
                    }))
                }
                _nextHandle() {
                    return ti._handlePool++
                }
                async _withAdapter(e, t, i, r, n, a = !1) {
                    const c = this._adapter.get(e);
                    if (!(c && c.adapter instanceof t)) return r;
                    const d = Date.now();
                    a || this._logService.trace(`[${c.extension.identifier.value}] INVOKE provider '${i.toString().replace(/[\r\n]/g,"")}'`);
                    const l = i(c.adapter, c.extension);
                    return Promise.resolve(l).catch((e => {
                        (0, o.n2)(e) || (this._logService.error(`[${c.extension.identifier.value}] provider FAILED`), this._logService.error(e), this._extensionTelemetry.onExtensionError(c.extension.identifier, e))
                    })).finally((() => {
                        a || this._logService.trace(`[${c.extension.identifier.value}] provider DONE after ${Date.now()-d}ms`)
                    })), s.Ts.isCancellationToken(n) ? (0, U.k0)(l, n) : l
                }
                _addNewAdapter(e, t) {
                    const i = this._nextHandle();
                    return this._adapter.set(i, new ei(e, t)), i
                }
                static _extLabel(e) {
                    return e.displayName || e.name
                }
                static _extId(e) {
                    return e.identifier.value
                }
                registerDocumentSymbolProvider(e, t, i, s) {
                    const o = this._addNewAdapter(new mt(this._documents, i), e),
                        r = s && s.label || ti._extLabel(e);
                    return this._proxy.$registerDocumentSymbolProvider(o, this._transformDocumentSelector(t, e), r), this._createDisposable(o)
                }
                $provideDocumentSymbols(e, t, i) {
                    return this._withAdapter(e, mt, (e => e.provideDocumentSymbols(d.ov.revive(t), i)), void 0, i)
                }
                registerCodeLensProvider(e, t, i) {
                    const s = this._nextHandle(),
                        o = "function" == typeof i.onDidChangeCodeLenses ? this._nextHandle() : void 0;
                    this._adapter.set(s, new ei(new gt(this._documents, this._commands.converter, i, e, this._extensionTelemetry, this._logService), e)), this._proxy.$registerCodeLensSupport(s, this._transformDocumentSelector(t, e), o);
                    let r = this._createDisposable(s);
                    if (void 0 !== o) {
                        const e = i.onDidChangeCodeLenses((e => this._proxy.$emitCodeLensEvent(o)));
                        r = b.JTr.from(r, e)
                    }
                    return r
                }
                $provideCodeLenses(e, t, i) {
                    return this._withAdapter(e, gt, (e => e.provideCodeLenses(d.ov.revive(t), i)), void 0, i)
                }
                $resolveCodeLens(e, t, i) {
                    return this._withAdapter(e, gt, (e => e.resolveCodeLens(t, i)), void 0, void 0)
                }
                $releaseCodeLenses(e, t) {
                    this._withAdapter(e, gt, (e => Promise.resolve(e.releaseCodeLenses(t))), void 0, void 0)
                }
                registerDefinitionProvider(e, t, i) {
                    const s = this._addNewAdapter(new _t(this._documents, i), e);
                    return this._proxy.$registerDefinitionSupport(s, this._transformDocumentSelector(t, e)), this._createDisposable(s)
                }
                $provideDefinition(e, t, i, s) {
                    return this._withAdapter(e, _t, (e => e.provideDefinition(d.ov.revive(t), i, s)), [], s)
                }
                registerDeclarationProvider(e, t, i) {
                    const s = this._addNewAdapter(new ft(this._documents, i), e);
                    return this._proxy.$registerDeclarationSupport(s, this._transformDocumentSelector(t, e)), this._createDisposable(s)
                }
                $provideDeclaration(e, t, i, s) {
                    return this._withAdapter(e, ft, (e => e.provideDeclaration(d.ov.revive(t), i, s)), [], s)
                }
                registerImplementationProvider(e, t, i) {
                    const s = this._addNewAdapter(new yt(this._documents, i), e);
                    return this._proxy.$registerImplementationSupport(s, this._transformDocumentSelector(t, e)), this._createDisposable(s)
                }
                $provideImplementation(e, t, i, s) {
                    return this._withAdapter(e, yt, (e => e.provideImplementation(d.ov.revive(t), i, s)), [], s)
                }
                registerTypeDefinitionProvider(e, t, i) {
                    const s = this._addNewAdapter(new wt(this._documents, i), e);
                    return this._proxy.$registerTypeDefinitionSupport(s, this._transformDocumentSelector(t, e)), this._createDisposable(s)
                }
                $provideTypeDefinition(e, t, i, s) {
                    return this._withAdapter(e, wt, (e => e.provideTypeDefinition(d.ov.revive(t), i, s)), [], s)
                }
                registerHoverProvider(e, t, i, s) {
                    const o = this._addNewAdapter(new xt(this._documents, i), e);
                    return this._proxy.$registerHoverProvider(o, this._transformDocumentSelector(t, e)), this._createDisposable(o)
                }
                $provideHover(e, t, i, s, o) {
                    return this._withAdapter(e, xt, (e => e.provideHover(d.ov.revive(t), i, s, o)), void 0, o)
                }
                $releaseHover(e, t) {
                    this._withAdapter(e, xt, (e => Promise.resolve(e.releaseHover(t))), void 0, void 0)
                }
                registerEvaluatableExpressionProvider(e, t, i, s) {
                    const o = this._addNewAdapter(new bt(this._documents, i), e);
                    return this._proxy.$registerEvaluatableExpressionProvider(o, this._transformDocumentSelector(t, e)), this._createDisposable(o)
                }
                $provideEvaluatableExpression(e, t, i, s) {
                    return this._withAdapter(e, bt, (e => e.provideEvaluatableExpression(d.ov.revive(t), i, s)), void 0, s)
                }
                registerInlineValuesProvider(e, t, i, s) {
                    const o = "function" == typeof i.onDidChangeInlineValues ? this._nextHandle() : void 0,
                        r = this._addNewAdapter(new Dt(this._documents, i), e);
                    this._proxy.$registerInlineValuesProvider(r, this._transformDocumentSelector(t, e), o);
                    let n = this._createDisposable(r);
                    if (void 0 !== o) {
                        const e = i.onDidChangeInlineValues((e => this._proxy.$emitInlineValuesEvent(o)));
                        n = b.JTr.from(n, e)
                    }
                    return n
                }
                $provideInlineValues(e, t, i, s, o) {
                    return this._withAdapter(e, Dt, (e => e.provideInlineValues(d.ov.revive(t), i, s, o)), void 0, o)
                }
                registerDocumentHighlightProvider(e, t, i) {
                    const s = this._addNewAdapter(new Ct(this._documents, i), e);
                    return this._proxy.$registerDocumentHighlightProvider(s, this._transformDocumentSelector(t, e)), this._createDisposable(s)
                }
                registerMultiDocumentHighlightProvider(e, t, i) {
                    const s = this._addNewAdapter(new St(this._documents, i), e);
                    return this._proxy.$registerMultiDocumentHighlightProvider(s, this._transformDocumentSelector(t, e)), this._createDisposable(s)
                }
                $provideDocumentHighlights(e, t, i, s) {
                    return this._withAdapter(e, Ct, (e => e.provideDocumentHighlights(d.ov.revive(t), i, s)), void 0, s)
                }
                $provideMultiDocumentHighlights(e, t, i, s, o) {
                    return this._withAdapter(e, St, (e => e.provideMultiDocumentHighlights(d.ov.revive(t), i, s.map((e => d.ov.revive(e))), o)), void 0, o)
                }
                registerLinkedEditingRangeProvider(e, t, i) {
                    const s = this._addNewAdapter(new Et(this._documents, i), e);
                    return this._proxy.$registerLinkedEditingRangeProvider(s, this._transformDocumentSelector(t, e)), this._createDisposable(s)
                }
                $provideLinkedEditingRanges(e, t, i, s) {
                    return this._withAdapter(e, Et, (async e => {
                        const o = await e.provideLinkedEditingRanges(d.ov.revive(t), i, s);
                        if (o) return {
                            ranges: o.ranges,
                            wordPattern: o.wordPattern ? ti._serializeRegExp(o.wordPattern) : void 0
                        }
                    }), void 0, s)
                }
                registerReferenceProvider(e, t, i) {
                    const s = this._addNewAdapter(new Pt(this._documents, i), e);
                    return this._proxy.$registerReferenceSupport(s, this._transformDocumentSelector(t, e)), this._createDisposable(s)
                }
                $provideReferences(e, t, i, s, o) {
                    return this._withAdapter(e, Pt, (e => e.provideReferences(d.ov.revive(t), i, s, o)), void 0, o)
                }
                registerCodeActionProvider(e, t, i, s) {
                    const o = new n.SL,
                        r = this._addNewAdapter(new Tt(this._documents, this._commands.converter, this._diagnostics, i, this._logService, e, this._apiDeprecation), e);
                    return this._proxy.$registerCodeActionSupport(r, this._transformDocumentSelector(t, e), {
                        providedKinds: s ? .providedCodeActionKinds ? .map((e => e.value)),
                        documentation: s ? .documentation ? .map((e => ({
                            kind: e.kind.value,
                            command: this._commands.converter.toInternal(e.command, o)
                        })))
                    }, ti._extLabel(e), ti._extId(e), Boolean(i.resolveCodeAction)), o.add(this._createDisposable(r)), o
                }
                $provideCodeActions(e, t, i, s, o) {
                    return this._withAdapter(e, Tt, (e => e.provideCodeActions(d.ov.revive(t), i, s, o)), void 0, o)
                }
                $resolveCodeAction(e, t, i) {
                    return this._withAdapter(e, Tt, (e => e.resolveCodeAction(t, i)), {}, void 0)
                }
                $releaseCodeActions(e, t) {
                    this._withAdapter(e, Tt, (e => Promise.resolve(e.releaseCodeActions(t))), void 0, void 0)
                }
                registerDocumentFormattingEditProvider(e, t, i) {
                    const s = this._addNewAdapter(new It(this._documents, i), e);
                    return this._proxy.$registerDocumentFormattingSupport(s, this._transformDocumentSelector(t, e), e.identifier, e.displayName || e.name), this._createDisposable(s)
                }
                $provideDocumentFormattingEdits(e, t, i, s) {
                    return this._withAdapter(e, It, (e => e.provideDocumentFormattingEdits(d.ov.revive(t), i, s)), void 0, s)
                }
                registerDocumentRangeFormattingEditProvider(e, t, i) {
                    const s = "function" == typeof i.provideDocumentRangesFormattingEdits,
                        o = this._addNewAdapter(new At(this._documents, i), e);
                    return this._proxy.$registerRangeFormattingSupport(o, this._transformDocumentSelector(t, e), e.identifier, e.displayName || e.name, s), this._createDisposable(o)
                }
                $provideDocumentRangeFormattingEdits(e, t, i, s, o) {
                    return this._withAdapter(e, At, (e => e.provideDocumentRangeFormattingEdits(d.ov.revive(t), i, s, o)), void 0, o)
                }
                $provideDocumentRangesFormattingEdits(e, t, i, s, o) {
                    return this._withAdapter(e, At, (e => e.provideDocumentRangesFormattingEdits(d.ov.revive(t), i, s, o)), void 0, o)
                }
                registerOnTypeFormattingEditProvider(e, t, i, s) {
                    const o = this._addNewAdapter(new $t(this._documents, i), e);
                    return this._proxy.$registerOnTypeFormattingSupport(o, this._transformDocumentSelector(t, e), s, e.identifier), this._createDisposable(o)
                }
                $provideOnTypeFormattingEdits(e, t, i, s, o, r) {
                    return this._withAdapter(e, $t, (e => e.provideOnTypeFormattingEdits(d.ov.revive(t), i, s, o, r)), void 0, r)
                }
                registerWorkspaceSymbolProvider(e, t) {
                    const i = this._addNewAdapter(new Rt(t, this._logService), e);
                    return this._proxy.$registerNavigateTypeSupport(i, "function" == typeof t.resolveWorkspaceSymbol), this._createDisposable(i)
                }
                $provideWorkspaceSymbols(e, t, i) {
                    return this._withAdapter(e, Rt, (e => e.provideWorkspaceSymbols(t, i)), {
                        symbols: []
                    }, i)
                }
                $resolveWorkspaceSymbol(e, t, i) {
                    return this._withAdapter(e, Rt, (e => e.resolveWorkspaceSymbol(t, i)), void 0, void 0)
                }
                $releaseWorkspaceSymbols(e, t) {
                    this._withAdapter(e, Rt, (e => e.releaseWorkspaceSymbols(t)), void 0, void 0)
                }
                registerRenameProvider(e, t, i) {
                    const s = this._addNewAdapter(new Ht(this._documents, i, this._logService), e);
                    return this._proxy.$registerRenameSupport(s, this._transformDocumentSelector(t, e), Ht.supportsResolving(i)), this._createDisposable(s)
                }
                $provideRenameEdits(e, t, i, s, o) {
                    return this._withAdapter(e, Ht, (e => e.provideRenameEdits(d.ov.revive(t), i, s, o)), void 0, o)
                }
                $resolveRenameLocation(e, t, i, s) {
                    return this._withAdapter(e, Ht, (e => e.resolveRenameLocation(d.ov.revive(t), i, s)), void 0, s)
                }
                registerNewSymbolNamesProvider(e, t, i) {
                    const s = this._addNewAdapter(new Ft(this._documents, i, this._logService), e);
                    return this._proxy.$registerNewSymbolNamesProvider(s, this._transformDocumentSelector(t, e)), this._createDisposable(s)
                }
                $supportsAutomaticNewSymbolNamesTriggerKind(e) {
                    return this._withAdapter(e, Ft, (e => e.supportsAutomaticNewSymbolNamesTriggerKind()), !1, void 0)
                }
                $provideNewSymbolNames(e, t, i, s, o) {
                    return this._withAdapter(e, Ft, (e => e.provideNewSymbolNames(d.ov.revive(t), i, s, o)), void 0, o)
                }
                registerDocumentSemanticTokensProvider(e, t, i, s) {
                    const o = this._addNewAdapter(new Mt(this._documents, i), e),
                        r = "function" == typeof i.onDidChangeSemanticTokens ? this._nextHandle() : void 0;
                    this._proxy.$registerDocumentSemanticTokensProvider(o, this._transformDocumentSelector(t, e), s, r);
                    let n = this._createDisposable(o);
                    if (r) {
                        const e = i.onDidChangeSemanticTokens((e => this._proxy.$emitDocumentSemanticTokensEvent(r)));
                        n = b.JTr.from(n, e)
                    }
                    return n
                }
                $provideDocumentSemanticTokens(e, t, i, s) {
                    return this._withAdapter(e, Mt, (e => e.provideDocumentSemanticTokens(d.ov.revive(t), i, s)), null, s)
                }
                $releaseDocumentSemanticTokens(e, t) {
                    this._withAdapter(e, Mt, (e => e.releaseDocumentSemanticColoring(t)), void 0, void 0)
                }
                registerDocumentRangeSemanticTokensProvider(e, t, i, s) {
                    const o = this._addNewAdapter(new Lt(this._documents, i), e);
                    return this._proxy.$registerDocumentRangeSemanticTokensProvider(o, this._transformDocumentSelector(t, e), s), this._createDisposable(o)
                }
                $provideDocumentRangeSemanticTokens(e, t, i, s) {
                    return this._withAdapter(e, Lt, (e => e.provideDocumentRangeSemanticTokens(d.ov.revive(t), i, s)), null, s)
                }
                registerCompletionItemProvider(e, t, i, s) {
                    const o = this._addNewAdapter(new Ot(this._documents, this._commands.converter, i, this._apiDeprecation, e), e);
                    return this._proxy.$registerCompletionsProvider(o, this._transformDocumentSelector(t, e), s, Ot.supportsResolving(i), e.identifier), this._createDisposable(o)
                }
                $provideCompletionItems(e, t, i, s, o) {
                    return this._withAdapter(e, Ot, (e => e.provideCompletionItems(d.ov.revive(t), i, s, o)), void 0, o)
                }
                $resolveCompletionItem(e, t, i) {
                    return this._withAdapter(e, Ot, (e => e.resolveCompletionItem(t, i)), void 0, i)
                }
                $releaseCompletionItems(e, t) {
                    this._withAdapter(e, Ot, (e => e.releaseCompletionItems(t)), void 0, void 0)
                }
                registerInlineCompletionsProvider(e, t, i, s) {
                    const o = new Vt(e, this._documents, i, this._commands.converter),
                        r = this._addNewAdapter(o, e);
                    return this._proxy.$registerInlineCompletionsSupport(r, this._transformDocumentSelector(t, e), o.supportsHandleEvents, m.kP.toKey(e.identifier.value), s ? .yieldTo ? .map((e => m.kP.toKey(e))) || []), this._createDisposable(r)
                }
                $provideInlineCompletions(e, t, i, s, o) {
                    return this._withAdapter(e, Ut, (e => e.provideInlineCompletions(d.ov.revive(t), i, s, o)), void 0, o)
                }
                $provideInlineEdits(e, t, i, s, o) {
                    return this._withAdapter(e, Ut, (e => e.provideInlineEdits(d.ov.revive(t), i, s, o)), void 0, o)
                }
                $handleInlineCompletionDidShow(e, t, i, s) {
                    this._withAdapter(e, Ut, (async e => {
                        e.handleDidShowCompletionItem(t, i, s)
                    }), void 0, void 0)
                }
                $handleInlineCompletionPartialAccept(e, t, i, s, o) {
                    this._withAdapter(e, Ut, (async e => {
                        e.handlePartialAccept(t, i, s, o)
                    }), void 0, void 0)
                }
                $freeInlineCompletionsList(e, t) {
                    this._withAdapter(e, Ut, (async e => {
                        e.disposeCompletions(t)
                    }), void 0, void 0)
                }
                registerInlineEditProvider(e, t, i) {
                    const s = new Wt(e, this._documents, i, this._commands.converter),
                        o = this._addNewAdapter(s, e);
                    return this._proxy.$registerInlineEditProvider(o, this._transformDocumentSelector(t, e), e.identifier), this._createDisposable(o)
                }
                $provideInlineEdit(e, t, i, s) {
                    return this._withAdapter(e, Wt, (e => e.provideInlineEdits(d.ov.revive(t), i, s)), void 0, s)
                }
                $freeInlineEdit(e, t) {
                    this._withAdapter(e, Wt, (async e => {
                        e.disposeEdit(t)
                    }), void 0, void 0)
                }
                registerSignatureHelpProvider(e, t, i, s) {
                    const o = Array.isArray(s) ? {
                            triggerCharacters: s,
                            retriggerCharacters: []
                        } : s,
                        r = this._addNewAdapter(new zt(this._documents, i), e);
                    return this._proxy.$registerSignatureHelpProvider(r, this._transformDocumentSelector(t, e), o), this._createDisposable(r)
                }
                $provideSignatureHelp(e, t, i, s, o) {
                    return this._withAdapter(e, zt, (e => e.provideSignatureHelp(d.ov.revive(t), i, s, o)), void 0, o)
                }
                $releaseSignatureHelp(e, t) {
                    this._withAdapter(e, zt, (e => e.releaseSignatureHelp(t)), void 0, void 0)
                }
                registerInlayHintsProvider(e, t, i) {
                    const s = "function" == typeof i.onDidChangeInlayHints ? this._nextHandle() : void 0,
                        o = this._addNewAdapter(new jt(this._documents, this._commands.converter, i, this._logService, e), e);
                    this._proxy.$registerInlayHintsProvider(o, this._transformDocumentSelector(t, e), "function" == typeof i.resolveInlayHint, s, ti._extLabel(e));
                    let r = this._createDisposable(o);
                    if (void 0 !== s) {
                        const e = i.onDidChangeInlayHints((e => this._proxy.$emitInlayHintsEvent(s)));
                        r = b.JTr.from(r, e)
                    }
                    return r
                }
                $provideInlayHints(e, t, i, s) {
                    return this._withAdapter(e, jt, (e => e.provideInlayHints(d.ov.revive(t), i, s)), void 0, s)
                }
                $resolveInlayHint(e, t, i) {
                    return this._withAdapter(e, jt, (e => e.resolveInlayHint(t, i)), void 0, i)
                }
                $releaseInlayHints(e, t) {
                    this._withAdapter(e, jt, (e => e.releaseHints(t)), void 0, void 0)
                }
                registerDocumentLinkProvider(e, t, i) {
                    const s = this._addNewAdapter(new qt(this._documents, i), e);
                    return this._proxy.$registerDocumentLinkProvider(s, this._transformDocumentSelector(t, e), "function" == typeof i.resolveDocumentLink), this._createDisposable(s)
                }
                $provideDocumentLinks(e, t, i) {
                    return this._withAdapter(e, qt, (e => e.provideLinks(d.ov.revive(t), i)), void 0, i, "output" === t.scheme)
                }
                $resolveDocumentLink(e, t, i) {
                    return this._withAdapter(e, qt, (e => e.resolveLink(t, i)), void 0, void 0, !0)
                }
                $releaseDocumentLinks(e, t) {
                    this._withAdapter(e, qt, (e => e.releaseLinks(t)), void 0, void 0, !0)
                }
                registerColorProvider(e, t, i) {
                    const s = this._addNewAdapter(new Kt(this._documents, i), e);
                    return this._proxy.$registerDocumentColorProvider(s, this._transformDocumentSelector(t, e)), this._createDisposable(s)
                }
                $provideDocumentColors(e, t, i) {
                    return this._withAdapter(e, Kt, (e => e.provideColors(d.ov.revive(t), i)), [], i)
                }
                $provideColorPresentations(e, t, i, s) {
                    return this._withAdapter(e, Kt, (e => e.provideColorPresentations(d.ov.revive(t), i, s)), void 0, s)
                }
                registerFoldingRangeProvider(e, t, i) {
                    const s = this._nextHandle(),
                        o = "function" == typeof i.onDidChangeFoldingRanges ? this._nextHandle() : void 0;
                    this._adapter.set(s, new ei(new Jt(this._documents, i), e)), this._proxy.$registerFoldingRangeProvider(s, this._transformDocumentSelector(t, e), e.identifier, o);
                    let r = this._createDisposable(s);
                    if (void 0 !== o) {
                        const e = i.onDidChangeFoldingRanges((() => this._proxy.$emitFoldingRangeEvent(o)));
                        r = b.JTr.from(r, e)
                    }
                    return r
                }
                $provideFoldingRanges(e, t, i, s) {
                    return this._withAdapter(e, Jt, (e => e.provideFoldingRanges(d.ov.revive(t), i, s)), void 0, s)
                }
                registerSelectionRangeProvider(e, t, i) {
                    const s = this._addNewAdapter(new Gt(this._documents, i, this._logService), e);
                    return this._proxy.$registerSelectionRangeProvider(s, this._transformDocumentSelector(t, e)), this._createDisposable(s)
                }
                $provideSelectionRanges(e, t, i, s) {
                    return this._withAdapter(e, Gt, (e => e.provideSelectionRanges(d.ov.revive(t), i, s)), [], s)
                }
                registerCallHierarchyProvider(e, t, i) {
                    const s = this._addNewAdapter(new Qt(this._documents, i), e);
                    return this._proxy.$registerCallHierarchyProvider(s, this._transformDocumentSelector(t, e)), this._createDisposable(s)
                }
                $prepareCallHierarchy(e, t, i, s) {
                    return this._withAdapter(e, Qt, (e => Promise.resolve(e.prepareSession(d.ov.revive(t), i, s))), void 0, s)
                }
                $provideCallHierarchyIncomingCalls(e, t, i, s) {
                    return this._withAdapter(e, Qt, (e => e.provideCallsTo(t, i, s)), void 0, s)
                }
                $provideCallHierarchyOutgoingCalls(e, t, i, s) {
                    return this._withAdapter(e, Qt, (e => e.provideCallsFrom(t, i, s)), void 0, s)
                }
                $releaseCallHierarchy(e, t) {
                    this._withAdapter(e, Qt, (e => Promise.resolve(e.releaseSession(t))), void 0, void 0)
                }
                registerTypeHierarchyProvider(e, t, i) {
                    const s = this._addNewAdapter(new Zt(this._documents, i), e);
                    return this._proxy.$registerTypeHierarchyProvider(s, this._transformDocumentSelector(t, e)), this._createDisposable(s)
                }
                $prepareTypeHierarchy(e, t, i, s) {
                    return this._withAdapter(e, Zt, (e => Promise.resolve(e.prepareSession(d.ov.revive(t), i, s))), void 0, s)
                }
                $provideTypeHierarchySupertypes(e, t, i, s) {
                    return this._withAdapter(e, Zt, (e => e.provideSupertypes(t, i, s)), void 0, s)
                }
                $provideTypeHierarchySubtypes(e, t, i, s) {
                    return this._withAdapter(e, Zt, (e => e.provideSubtypes(t, i, s)), void 0, s)
                }
                $releaseTypeHierarchy(e, t) {
                    this._withAdapter(e, Zt, (e => Promise.resolve(e.releaseSession(t))), void 0, void 0)
                }
                registerDocumentOnDropEditProvider(e, t, i, s) {
                    const o = this._nextHandle();
                    return this._adapter.set(o, new ei(new Yt(this._proxy, this._documents, i, o, e), e)), this._proxy.$registerDocumentOnDropEditProvider(o, this._transformDocumentSelector(t, e), (0, q.$x)(e, "documentPaste") && s ? {
                        supportsResolve: !!i.resolveDocumentDropEdit,
                        dropMimeTypes: s.dropMimeTypes
                    } : void 0), this._createDisposable(o)
                }
                $provideDocumentOnDropEdits(e, t, i, s, o, r) {
                    return this._withAdapter(e, Yt, (e => Promise.resolve(e.provideDocumentOnDropEdits(t, d.ov.revive(i), s, o, r))), void 0, void 0)
                }
                $resolveDropEdit(e, t, i) {
                    return this._withAdapter(e, Yt, (e => e.resolveDropEdit(t, i)), {}, void 0)
                }
                $releaseDocumentOnDropEdits(e, t) {
                    this._withAdapter(e, Yt, (e => Promise.resolve(e.releaseDropEdits(t))), void 0, void 0)
                }
                registerMappedEditsProvider(e, t, i) {
                    const s = this._addNewAdapter(new Xt(this._documents, i), e);
                    return this._proxy.$registerMappedEditsProvider(s, this._transformDocumentSelector(t, e)), this._createDisposable(s)
                }
                $provideMappedEdits(e, t, i, s, o) {
                    return this._withAdapter(e, Xt, (e => Promise.resolve(e.provideMappedEdits(t, i, s, o))), null, o)
                }
                registerDocumentPasteEditProvider(e, t, i, s) {
                    const o = this._nextHandle();
                    return this._adapter.set(o, new ei(new kt(this._proxy, this._documents, i, o, e), e)), this._proxy.$registerPasteEditProvider(o, this._transformDocumentSelector(t, e), {
                        supportsCopy: !!i.prepareDocumentPaste,
                        supportsPaste: !!i.provideDocumentPasteEdits,
                        supportsResolve: !!i.resolveDocumentPasteEdit,
                        providedPasteEditKinds: s.providedPasteEditKinds ? .map((e => e.value)),
                        copyMimeTypes: s.copyMimeTypes,
                        pasteMimeTypes: s.pasteMimeTypes
                    }), this._createDisposable(o)
                }
                $prepareDocumentPaste(e, t, i, s, o) {
                    return this._withAdapter(e, kt, (e => e.prepareDocumentPaste(d.ov.revive(t), i, s, o)), void 0, o)
                }
                $providePasteEdits(e, t, i, s, o, r, n) {
                    return this._withAdapter(e, kt, (e => e.providePasteEdits(t, d.ov.revive(i), s, o, r, n)), void 0, n)
                }
                $resolvePasteEdit(e, t, i) {
                    return this._withAdapter(e, kt, (e => e.resolvePasteEdit(t, i)), {}, void 0)
                }
                $releasePasteEdits(e, t) {
                    this._withAdapter(e, kt, (e => Promise.resolve(e.releasePasteEdits(t))), void 0, void 0)
                }
                static _serializeRegExp(e) {
                    return {
                        pattern: e.source,
                        flags: e.flags
                    }
                }
                static _serializeIndentationRule(e) {
                    return {
                        decreaseIndentPattern: ti._serializeRegExp(e.decreaseIndentPattern),
                        increaseIndentPattern: ti._serializeRegExp(e.increaseIndentPattern),
                        indentNextLinePattern: e.indentNextLinePattern ? ti._serializeRegExp(e.indentNextLinePattern) : void 0,
                        unIndentedLinePattern: e.unIndentedLinePattern ? ti._serializeRegExp(e.unIndentedLinePattern) : void 0
                    }
                }
                static _serializeOnEnterRule(e) {
                    return {
                        beforeText: ti._serializeRegExp(e.beforeText),
                        afterText: e.afterText ? ti._serializeRegExp(e.afterText) : void 0,
                        previousLineText: e.previousLineText ? ti._serializeRegExp(e.previousLineText) : void 0,
                        action: e.action
                    }
                }
                static _serializeOnEnterRules(e) {
                    return e.map(ti._serializeOnEnterRule)
                }
                static _serializeAutoClosingPair(e) {
                    return {
                        open: e.open,
                        close: e.close,
                        notIn: e.notIn ? e.notIn.map((e => b.wxO.toString(e))) : void 0
                    }
                }
                static _serializeAutoClosingPairs(e) {
                    return e.map(ti._serializeAutoClosingPair)
                }
                setLanguageConfiguration(e, t, i) {
                    const {
                        wordPattern: s
                    } = i;
                    if (s && (0, Me.IO)(s)) throw new Error(`Invalid language configuration: wordPattern '${s}' is not allowed to match the empty string.`);
                    s ? this._documents.setWordDefinitionFor(t, s) : this._documents.setWordDefinitionFor(t, void 0), i.__electricCharacterSupport && this._apiDeprecation.report("LanguageConfiguration.__electricCharacterSupport", e, "Do not use."), i.__characterPairSupport && this._apiDeprecation.report("LanguageConfiguration.__characterPairSupport", e, "Do not use.");
                    const o = this._nextHandle(),
                        r = {
                            comments: i.comments,
                            brackets: i.brackets,
                            wordPattern: i.wordPattern ? ti._serializeRegExp(i.wordPattern) : void 0,
                            indentationRules: i.indentationRules ? ti._serializeIndentationRule(i.indentationRules) : void 0,
                            onEnterRules: i.onEnterRules ? ti._serializeOnEnterRules(i.onEnterRules) : void 0,
                            __electricCharacterSupport: i.__electricCharacterSupport,
                            __characterPairSupport: i.__characterPairSupport,
                            autoClosingPairs: i.autoClosingPairs ? ti._serializeAutoClosingPairs(i.autoClosingPairs) : void 0
                        };
                    return this._proxy.$setLanguageConfiguration(o, t, r), this._createDisposable(o)
                }
                $setWordDefinitions(e) {
                    for (const t of e) this._documents.setWordDefinitionFor(t.languageId, new RegExp(t.regexSource, t.regexFlags))
                }
            }
            class ii {
                constructor(e) {
                    this._registeredTools = new Map, this._allTools = new Map, this._proxy = e.getProxy(x.Tr.MainThreadLanguageModelTools), this._proxy.$getTools().then((e => {
                        for (const t of e) this._allTools.set(t.name, t)
                    }))
                }
                async invokeTool(e, t, i) {
                    return await this._proxy.$invokeTool(e, t, i)
                }
                async $acceptToolDelta(e) {
                    e.added && this._allTools.set(e.added.name, e.added), e.removed && this._allTools.delete(e.removed)
                }
                get tools() {
                    return Array.from(this._allTools.values()).map((e => k.Hv.to(e)))
                }
                async $invokeTool(e, t, i) {
                    const s = this._registeredTools.get(e);
                    if (!s) throw new Error(`Unknown tool ${e}`);
                    return await s.tool.invoke(t, i)
                }
                registerTool(e, t, i) {
                    return this._registeredTools.set(t, {
                        extension: e,
                        tool: i
                    }), this._proxy.$registerTool(t), (0, n.OF)((() => {
                        this._registeredTools.delete(t), this._proxy.$unregisterTool(t)
                    }))
                }
            }
            var si = i("9STo"),
                oi = i("ziTh");
            class ri {
                constructor(e, t, i, s) {
                    this._documents = t, this._commands = i, this._uriTransformer = s, this._languageIds = [], this._handlePool = 0, this._ids = new Set, this._proxy = e.getProxy(x.Tr.MainThreadLanguages)
                }
                $acceptLanguageIds(e) {
                    this._languageIds = e
                }
                async getLanguages() {
                    return this._languageIds.slice(0)
                }
                async changeLanguage(e, t) {
                    await this._proxy.$changeLanguage(e, t);
                    const i = this._documents.getDocumentData(e);
                    if (!i) throw new Error(`document '${e.toString()}' NOT found`);
                    return i.document
                }
                async tokenAtPosition(e, t) {
                    const i = e.version,
                        s = k.Ly.from(t),
                        o = await this._proxy.$tokensAtPosition(e.uri, s),
                        r = {
                            type: b.xJH.Other,
                            range: e.getWordRangeAtPosition(t) ? ? new b.e6w(t.line, t.character, t.line, t.character)
                        };
                    if (!o) return r;
                    const n = {
                        range: k.e6.to(o.range),
                        type: k.iv.to(o.type)
                    };
                    return n.range.contains(t) ? i !== e.version ? r : n : r
                }
                createLanguageStatusItem(e, t, i) {
                    const s = this._handlePool++,
                        o = this._proxy,
                        r = this._ids,
                        a = `${e.identifier.value}/${t}`;
                    if (r.has(a)) throw new Error(`LanguageStatusItem with id '${t}' ALREADY exists`);
                    r.add(a);
                    const d = {
                        selector: i,
                        id: t,
                        name: e.displayName ? ? e.name,
                        severity: b.Rxm.Information,
                        command: void 0,
                        text: "",
                        detail: "",
                        busy: !1
                    };
                    let l;
                    const h = new n.SL,
                        u = () => {
                            l ? .dispose(), r.has(a) ? l = (0, U.Vg)((() => {
                                h.clear(), this._proxy.$setLanguageStatus(s, {
                                    id: a,
                                    name: d.name ? ? e.displayName ? ? e.name,
                                    source: e.displayName ? ? e.name,
                                    selector: k.Lq.from(d.selector, this._uriTransformer),
                                    label: d.text,
                                    detail: d.detail ? ? "",
                                    severity: d.severity === b.Rxm.Error ? c.Z.Error : d.severity === b.Rxm.Warning ? c.Z.Warning : c.Z.Info,
                                    command: d.command && this._commands.toInternal(d.command, h),
                                    accessibilityInfo: d.accessibilityInformation,
                                    busy: d.busy
                                })
                            }), 0) : oi.warn(`LanguageStatusItem (${t}) from ${e.identifier.value} has been disposed and CANNOT be updated anymore`)
                        },
                        p = {
                            dispose() {
                                h.dispose(), l ? .dispose(), o.$removeLanguageStatus(s), r.delete(a)
                            },
                            get id() {
                                return d.id
                            },
                            get name() {
                                return d.name
                            },
                            set name(e) {
                                d.name = e, u()
                            },
                            get selector() {
                                return d.selector
                            },
                            set selector(e) {
                                d.selector = e, u()
                            },
                            get text() {
                                return d.text
                            },
                            set text(e) {
                                d.text = e, u()
                            },
                            set text2(t) {
                                (0, q.H5)(e, "languageStatusText"), d.text = t, u()
                            },
                            get text2() {
                                return (0, q.H5)(e, "languageStatusText"), d.text
                            },
                            get detail() {
                                return d.detail
                            },
                            set detail(e) {
                                d.detail = e, u()
                            },
                            get severity() {
                                return d.severity
                            },
                            set severity(e) {
                                d.severity = e, u()
                            },
                            get accessibilityInformation() {
                                return d.accessibilityInformation
                            },
                            set accessibilityInformation(e) {
                                d.accessibilityInformation = e, u()
                            },
                            get command() {
                                return d.command
                            },
                            set command(e) {
                                d.command = e, u()
                            },
                            get busy() {
                                return d.busy
                            },
                            set busy(e) {
                                d.busy = e, u()
                            }
                        };
                    return u(), p
                }
            }
            var ni = i("0eYU"),
                ai = i("CbIF");
            let ci = class {
                constructor(e, t) {
                    this._logService = t, this._proxy = e.getProxy(x.Tr.MainThreadMessageService)
                }
                showMessage(e, t, i, s, o) {
                    const r = {
                        source: {
                            identifier: e.identifier,
                            label: e.displayName || e.name
                        }
                    };
                    let n;
                    var a;
                    "string" == typeof s || (a = s) && a.title ? n = [s, ...o] : (r.modal = s ? .modal, r.useCustom = s ? .useCustom, r.detail = s ? .detail, n = o), r.useCustom && (0, q.H5)(e, "resolvers");
                    const c = [];
                    let d = !1;
                    for (let t = 0; t < n.length; t++) {
                        const i = n[t];
                        if ("string" == typeof i) c.push({
                            title: i,
                            handle: t,
                            isCloseAffordance: !1
                        });
                        else if ("object" == typeof i) {
                            const {
                                title: s,
                                isCloseAffordance: o
                            } = i;
                            c.push({
                                title: s,
                                isCloseAffordance: !!o,
                                handle: t
                            }), o && (d ? this._logService.warn(`[${e.identifier}] Only one message item can have 'isCloseAffordance':`, i) : d = !0)
                        } else this._logService.warn(`[${e.identifier}] Invalid message item:`, i)
                    }
                    return this._proxy.$showMessage(t, i, r, c).then((e => {
                        if ("number" == typeof e) return n[e]
                    }))
                }
            };
            ci = (0, N.g)([(0, N.f)(1, _.V)], ci);
            var di = i("O9sO");
            class li {
                constructor(e, t, i, s) {
                    this.start = e, this.deletedCount = t, this.deletedItems = i, this.items = s
                }
                asApiEvent() {
                    return {
                        range: new b.XsU(this.start, this.start + this.deletedCount),
                        addedCells: this.items.map((e => e.apiCell)),
                        removedCells: this.deletedItems
                    }
                }
            }
            class hi {
                static asModelAddData(e) {
                    return {
                        EOL: e.eol,
                        lines: e.source,
                        languageId: e.language,
                        uri: e.uri,
                        isDirty: !1,
                        versionId: 1
                    }
                }
                constructor(e, t, i) {
                    this.notebook = e, this._extHostDocument = t, this._cellData = i, this.handle = i.handle, this.uri = d.ov.revive(i.uri), this.cellKind = i.cellKind, this._outputs = i.outputs.map(k.JO.to), this._internalMetadata = i.internalMetadata ? ? {}, this._metadata = Object.freeze(i.metadata ? ? {}), this._previousResult = Object.freeze(k._2.to(i.internalMetadata ? ? {}))
                }
                get internalMetadata() {
                    return this._internalMetadata
                }
                get apiCell() {
                    if (!this._apiCell) {
                        const e = this,
                            t = this._extHostDocument.getDocument(this.uri);
                        if (!t) throw new Error(`MISSING extHostDocument for notebook cell: ${this.uri}`);
                        const i = {
                            get index() {
                                return e.notebook.getCellIndex(e)
                            },
                            notebook: e.notebook.apiNotebook,
                            kind: k.wU.to(this._cellData.cellKind),
                            document: t.document,
                            get mime() {
                                return e._mime
                            },
                            set mime(t) {
                                e._mime = t
                            },
                            get outputs() {
                                return e._outputs.slice(0)
                            },
                            get metadata() {
                                return e._metadata
                            },
                            get executionSummary() {
                                return e._previousResult
                            }
                        };
                        this._apiCell = Object.freeze(i)
                    }
                    return this._apiCell
                }
                setOutputs(e) {
                    this._outputs = e.map(k.JO.to)
                }
                setOutputItems(e, t, i) {
                    const s = i.map(k.x$.to),
                        o = this._outputs.find((t => t.id === e));
                    if (o && (t || (o.items.length = 0), o.items.push(...s), o.items.length > 1 && o.items.every((e => (0, di.OT)(e.mime))))) {
                        const e = new Map,
                            t = [];
                        o.items.forEach((i => {
                            let s;
                            e.has(i.mime) ? s = e.get(i.mime) : (s = [], e.set(i.mime, s), t.push(i.mime)), s.push(i.data)
                        })), o.items.length = 0, t.forEach((t => {
                            const i = (0, di.Jp)(e.get(t));
                            o.items.push({
                                mime: t,
                                data: i.data.buffer
                            })
                        }))
                    }
                }
                setMetadata(e) {
                    this._metadata = Object.freeze(e)
                }
                setInternalMetadata(e) {
                    this._internalMetadata = e, this._previousResult = Object.freeze(k._2.to(e))
                }
                setMime(e) {}
            }
            class ui {
                static {
                    this._handlePool = 0
                }
                constructor(e, t, i, s, o) {
                    this._proxy = e, this._textDocumentsAndEditors = t, this._textDocuments = i, this.uri = s, this.handle = ui._handlePool++, this._cells = [], this._versionId = 0, this._isDirty = !1, this._disposed = !1, this._notebookType = o.viewType, this._metadata = Object.freeze(o.metadata ? ? Object.create(null)), this._spliceNotebookCells([
                        [0, 0, o.cells]
                    ], !0, void 0), this._versionId = o.versionId
                }
                dispose() {
                    this._disposed = !0
                }
                get versionId() {
                    return this._versionId
                }
                get apiNotebook() {
                    if (!this._notebook) {
                        const e = this,
                            t = {
                                get uri() {
                                    return e.uri
                                },
                                get version() {
                                    return e._versionId
                                },
                                get notebookType() {
                                    return e._notebookType
                                },
                                get isDirty() {
                                    return e._isDirty
                                },
                                get isUntitled() {
                                    return e.uri.scheme === a.lg.untitled
                                },
                                get isClosed() {
                                    return e._disposed
                                },
                                get metadata() {
                                    return e._metadata
                                },
                                get cellCount() {
                                    return e._cells.length
                                },
                                cellAt: t => (t = e._validateIndex(t), e._cells[t].apiCell),
                                getCells: t => (t ? e._getCells(t) : e._cells).map((e => e.apiCell)),
                                save: () => e._save()
                            };
                        this._notebook = Object.freeze(t)
                    }
                    return this._notebook
                }
                acceptDocumentPropertiesChanged(e) {
                    e.metadata && (this._metadata = Object.freeze({ ...this._metadata,
                        ...e.metadata
                    }))
                }
                acceptDirty(e) {
                    this._isDirty = e
                }
                acceptModelChanged(e, t, i) {
                    this._versionId = e.versionId, this._isDirty = t, this.acceptDocumentPropertiesChanged({
                        metadata: i
                    });
                    const s = {
                            notebook: this.apiNotebook,
                            metadata: i,
                            cellChanges: [],
                            contentChanges: []
                        },
                        o = [];
                    for (const t of e.rawEvents) t.kind === di.s5.ModelChange ? this._spliceNotebookCells(t.changes, !1, s.contentChanges) : t.kind === di.s5.Move ? this._moveCells(t.index, t.length, t.newIdx, s.contentChanges) : t.kind === di.s5.Output ? (this._setCellOutputs(t.index, t.outputs), o.push({
                        cell: this._cells[t.index].apiCell,
                        outputs: this._cells[t.index].apiCell.outputs
                    })) : t.kind === di.s5.OutputItem ? (this._setCellOutputItems(t.index, t.outputId, t.append, t.outputItems), o.push({
                        cell: this._cells[t.index].apiCell,
                        outputs: this._cells[t.index].apiCell.outputs
                    })) : t.kind === di.s5.ChangeCellLanguage ? (this._changeCellLanguage(t.index, t.language), o.push({
                        cell: this._cells[t.index].apiCell,
                        document: this._cells[t.index].apiCell.document
                    })) : t.kind === di.s5.ChangeCellContent ? o.push({
                        cell: this._cells[t.index].apiCell,
                        document: this._cells[t.index].apiCell.document
                    }) : t.kind === di.s5.ChangeCellMime ? this._changeCellMime(t.index, t.mime) : t.kind === di.s5.ChangeCellMetadata ? (this._changeCellMetadata(t.index, t.metadata), o.push({
                        cell: this._cells[t.index].apiCell,
                        metadata: this._cells[t.index].apiCell.metadata
                    })) : t.kind === di.s5.ChangeCellInternalMetadata && (this._changeCellInternalMetadata(t.index, t.internalMetadata), o.push({
                        cell: this._cells[t.index].apiCell,
                        executionSummary: this._cells[t.index].apiCell.executionSummary
                    }));
                    const r = new Map;
                    for (let e = 0; e < o.length; e++) {
                        const t = o[e],
                            i = r.get(t.cell);
                        if (void 0 === i) {
                            const e = s.cellChanges.push({
                                document: void 0,
                                executionSummary: void 0,
                                metadata: void 0,
                                outputs: void 0,
                                ...t
                            });
                            r.set(t.cell, e - 1)
                        } else s.cellChanges[i] = { ...s.cellChanges[i],
                            ...t
                        }
                    }
                    return s
                }
                _validateIndex(e) {
                    return (e |= 0) < 0 ? 0 : e >= this._cells.length ? this._cells.length - 1 : e
                }
                _validateRange(e) {
                    let t = 0 | e.start,
                        i = 0 | e.end;
                    return t < 0 && (t = 0), i > this._cells.length && (i = this._cells.length), e.with({
                        start: t,
                        end: i
                    })
                }
                _getCells(e) {
                    const t = [];
                    for (let i = (e = this._validateRange(e)).start; i < e.end; i++) t.push(this._cells[i]);
                    return t
                }
                async _save() {
                    return this._disposed ? Promise.reject(new Error("Notebook has been closed")) : this._proxy.$trySaveNotebook(this.uri)
                }
                _spliceNotebookCells(e, t, i) {
                    if (this._disposed) return;
                    const s = [],
                        o = [],
                        r = [];
                    if (e.reverse().forEach((e => {
                            const i = e[2].map((e => {
                                    const i = new hi(this, this._textDocumentsAndEditors, e);
                                    return t || o.push(hi.asModelAddData(e)), i
                                })),
                                n = new li(e[0], e[1], [], i),
                                a = this._cells.splice(e[0], e[1], ...i);
                            for (const e of a) r.push(e.uri), n.deletedItems.push(e.apiCell);
                            s.push(n)
                        })), this._textDocumentsAndEditors.acceptDocumentsAndEditorsDelta({
                            addedDocuments: o,
                            removedDocuments: r
                        }), i)
                        for (const e of s) i.push(e.asApiEvent())
                }
                _moveCells(e, t, i, s) {
                    const o = this._cells.splice(e, t);
                    this._cells.splice(i, 0, ...o);
                    const r = [new li(e, t, o.map((e => e.apiCell)), []), new li(i, 0, [], o)];
                    for (const e of r) s.push(e.asApiEvent())
                }
                _setCellOutputs(e, t) {
                    this._cells[e].setOutputs(t)
                }
                _setCellOutputItems(e, t, i, s) {
                    this._cells[e].setOutputItems(t, i, s)
                }
                _changeCellLanguage(e, t) {
                    const i = this._cells[e];
                    i.apiCell.document.languageId !== t && this._textDocuments.$acceptModelLanguageChanged(i.uri, t)
                }
                _changeCellMime(e, t) {
                    this._cells[e].apiCell.mime = t
                }
                _changeCellMetadata(e, t) {
                    this._cells[e].setMetadata(t)
                }
                _changeCellInternalMetadata(e, t) {
                    this._cells[e].setInternalMetadata(t)
                }
                getCellFromApiCell(e) {
                    return this._cells.find((t => t.apiCell === e))
                }
                getCellFromIndex(e) {
                    return this._cells[e]
                }
                getCell(e) {
                    return this._cells.find((t => t.handle === e))
                }
                getCellIndex(e) {
                    return this._cells.indexOf(e)
                }
            }
            class pi {
                static {
                    this.apiEditorsToExtHost = new WeakMap
                }
                constructor(e, t, i, s, o, r) {
                    this.id = e, this._proxy = t, this.notebookData = i, this._selections = [], this._visibleRanges = [], this._visible = !1, this._selections = o, this._visibleRanges = s, this._viewColumn = r
                }
                get apiEditor() {
                    if (!this._editor) {
                        const e = this;
                        this._editor = {
                            get notebook() {
                                return e.notebookData.apiNotebook
                            },
                            get selection() {
                                return e._selections[0]
                            },
                            set selection(e) {
                                this.selections = [e]
                            },
                            get selections() {
                                return e._selections
                            },
                            set selections(t) {
                                if (!Array.isArray(t) || !t.every(b.XsU.isNotebookRange)) throw (0, o.b1)("selections");
                                e._selections = t, e._trySetSelections(t)
                            },
                            get visibleRanges() {
                                return e._visibleRanges
                            },
                            revealRange(t, i) {
                                e._proxy.$tryRevealRange(e.id, k.Xs.from(t), i ? ? b.Ay.Default)
                            },
                            get viewColumn() {
                                return e._viewColumn
                            }
                        }, pi.apiEditorsToExtHost.set(this._editor, this)
                    }
                    return this._editor
                }
                get visible() {
                    return this._visible
                }
                _acceptVisibility(e) {
                    this._visible = e
                }
                _acceptVisibleRanges(e) {
                    this._visibleRanges = e
                }
                _acceptSelections(e) {
                    this._selections = e
                }
                _trySetSelections(e) {
                    this._proxy.$trySetSelections(this.id, e.map(k.Xs.from))
                }
                _acceptViewColumn(e) {
                    this._viewColumn = e
                }
            }
            var mi = i("GbR3"),
                gi = i("3Ld1"),
                vi = i("KZ22");
            class _i extends n.JT {
                constructor(e, t, i) {
                    super(), this._source = e, this._inputTextBuffer = t, this._outputs = i, this._outputTextBuffers = void 0
                }
                _getFullModelRange(e) {
                    const t = e.getLineCount();
                    return new lt.e(1, 1, t, this._getLineMaxColumn(e, t))
                }
                _getLineMaxColumn(e, t) {
                    if (t < 1 || t > e.getLineCount()) throw new Error("Illegal value for lineNumber");
                    return e.getLineLength(t) + 1
                }
                get inputTextBuffer() {
                    if (!this._inputTextBuffer) {
                        const e = new gi.M;
                        e.acceptChunk(this._source);
                        const t = e.finish(!0),
                            {
                                textBuffer: i,
                                disposable: s
                            } = t.create(p._x.LF);
                        this._inputTextBuffer = i, this._register(s)
                    }
                    return this._inputTextBuffer
                }
                get outputTextBuffers() {
                    return this._outputTextBuffers || (this._outputTextBuffers = this._outputs.map((e => {
                        const t = new gi.M;
                        t.acceptChunk(e);
                        const i = t.finish(!0),
                            {
                                textBuffer: s,
                                disposable: o
                            } = i.create(p._x.LF);
                        return this._register(o), s
                    }))), this._outputTextBuffers
                }
                findInInputs(e) {
                    const t = new vi.bc(e, !1, !1, null).parseSearchRequest();
                    if (!t) return [];
                    const i = this._getFullModelRange(this.inputTextBuffer);
                    return this.inputTextBuffer.findMatchesLineByLine(i, t, !0, 5e3)
                }
                findInOutputs(e) {
                    const t = new vi.bc(e, !1, !1, null).parseSearchRequest();
                    return t ? this.outputTextBuffers.map((e => {
                        const i = e.findMatchesLineByLine(this._getFullModelRange(e), t, !0, 5e3);
                        if (0 !== i.length) return {
                            textBuffer: e,
                            matches: i
                        }
                    })).filter((e => !!e)) : []
                }
            }

            function fi(e, t) {
                let i = -1;
                const s = [];
                let o = [];
                return e.forEach((e => {
                    e.range.startLineNumber !== i && o.length > 0 && (s.push([...o]), o = []), o.push(e), i = e.range.endLineNumber
                })), o.length > 0 && s.push([...o]), s.map((e => {
                    const i = [],
                        s = e[0].range.startLineNumber,
                        o = e[e.length - 1].range.endLineNumber;
                    for (let e = s; e <= o; e++) i.push(t.getLineContent(e));
                    return new mi.Aw(i.join("\n") + "\n", e.map((e => new lt.e(e.range.startLineNumber - 1, e.range.startColumn - 1, e.range.endLineNumber - 1, e.range.endColumn - 1))))
                }))
            }
            var yi = i("3WHm"),
                wi = i("ziTh");
            const xi = "vs/workbench/api/common/extHostNotebook";
            class bi {
                static {
                    this._notebookStatusBarItemProviderHandlePool = 0
                }
                get activeNotebookEditor() {
                    return this._activeNotebookEditor ? .apiEditor
                }
                get visibleNotebookEditors() {
                    return this._visibleNotebookEditors.map((e => e.apiEditor))
                }
                constructor(e, t, i, s, o, n, a) {
                    this._textDocumentsAndEditors = i, this._textDocuments = s, this._extHostFileSystem = o, this._extHostSearch = n, this._logService = a, this._notebookStatusBarItemProviders = new Map, this._documents = new $e.Y9, this._editors = new Map, this._onDidChangeActiveNotebookEditor = new r.Q5, this.onDidChangeActiveNotebookEditor = this._onDidChangeActiveNotebookEditor.event, this._visibleNotebookEditors = [], this._onDidOpenNotebookDocument = new r.Q5, this.onDidOpenNotebookDocument = this._onDidOpenNotebookDocument.event, this._onDidCloseNotebookDocument = new r.Q5, this.onDidCloseNotebookDocument = this._onDidCloseNotebookDocument.event, this._onDidChangeVisibleNotebookEditors = new r.Q5, this.onDidChangeVisibleNotebookEditors = this._onDidChangeVisibleNotebookEditors.event, this._statusBarCache = new xe("NotebookCellStatusBarCache"), this._handlePool = 0, this._notebookSerializer = new Map, this._notebookProxy = e.getProxy(x.Tr.MainThreadNotebook), this._notebookDocumentsProxy = e.getProxy(x.Tr.MainThreadNotebookDocuments), this._notebookEditorsProxy = e.getProxy(x.Tr.MainThreadNotebookEditors), this._commandsConverter = t.converter, t.registerArgumentProcessor({
                        processArgument: e => {
                            if (e && e.$mid === ne.m.NotebookCellActionContext) {
                                const t = e.notebookEditor ? .notebookUri,
                                    i = e.cell.handle,
                                    s = this._documents.get(t),
                                    o = s ? .getCell(i);
                                if (o) return o.apiCell
                            }
                            if (e && e.$mid === ne.m.NotebookActionContext) {
                                const t = e.uri,
                                    i = this._documents.get(t);
                                if (i) return i.apiNotebook
                            }
                            return e
                        }
                    }), bi._registerApiCommands(t)
                }
                getEditorById(e) {
                    const t = this._editors.get(e);
                    if (!t) throw new Error(`unknown text editor: ${e}. known editors: ${[...this._editors.keys()]} `);
                    return t
                }
                getIdByEditor(e) {
                    for (const [t, i] of this._editors)
                        if (i.apiEditor === e) return t
                }
                get notebookDocuments() {
                    return [...this._documents.values()]
                }
                getNotebookDocument(e, t) {
                    const i = this._documents.get(e);
                    if (!i && !t) throw new Error(`NO notebook document for '${e}'`);
                    return i
                }
                static _convertNotebookRegistrationData(e, t) {
                    if (!t) return;
                    const i = t.filenamePattern.map((e => k.wN.from(e))).filter((e => void 0 !== e));
                    if (!t.filenamePattern || i) return {
                        extension: e.identifier,
                        providerDisplayName: e.displayName || e.name,
                        displayName: t.displayName,
                        filenamePattern: i,
                        priority: t.exclusive ? yi.OP.exclusive : void 0
                    };
                    wi.warn(`Notebook content provider view options file name pattern is invalid ${t.filenamePattern}`)
                }
                registerNotebookCellStatusBarItemProvider(e, t, i) {
                    const s = bi._notebookStatusBarItemProviderHandlePool++,
                        o = "function" == typeof i.onDidChangeCellStatusBarItems ? bi._notebookStatusBarItemProviderHandlePool++ : void 0;
                    let r;
                    return this._notebookStatusBarItemProviders.set(s, i), this._notebookProxy.$registerNotebookCellStatusBarItemProvider(s, o, t), void 0 !== o && (r = i.onDidChangeCellStatusBarItems((e => this._notebookProxy.$emitCellStatusBarEvent(o)))), new b.JTr((() => {
                        this._notebookStatusBarItemProviders.delete(s), this._notebookProxy.$unregisterNotebookCellStatusBarItemProvider(s, o), r ? .dispose()
                    }))
                }
                async createNotebookDocument(e) {
                    const t = await this._notebookDocumentsProxy.$tryCreateNotebook({
                        viewType: e.viewType,
                        content: e.content && k.c4.from(e.content)
                    });
                    return d.ov.revive(t)
                }
                async openNotebookDocument(e) {
                    const t = this._documents.get(e);
                    if (t) return t.apiNotebook;
                    const i = await this._notebookDocumentsProxy.$tryOpenNotebook(e),
                        s = this._documents.get(d.ov.revive(i));
                    return (0, z.cW)(s ? .apiNotebook)
                }
                async showNotebookDocument(e, t) {
                    let i;
                    d.ov.isUri(e) && (e = await this.openNotebookDocument(e)), i = "object" == typeof t ? {
                        position: k.eI.from(t.viewColumn),
                        preserveFocus: t.preserveFocus,
                        selections: t.selections && t.selections.map(k.Xs.from),
                        pinned: "boolean" == typeof t.preview ? !t.preview : void 0
                    } : {
                        preserveFocus: !1
                    };
                    const s = await this._notebookEditorsProxy.$tryShowNotebookDocument(e.uri, e.notebookType, i),
                        o = s && this._editors.get(s) ? .apiEditor;
                    if (o) return o;
                    throw s ? new Error(`Could NOT open editor for "${e.uri.toString()}" because another editor opened in the meantime.`) : new Error(`Could NOT open editor for "${e.uri.toString()}".`)
                }
                async $provideNotebookCellStatusBarItems(e, t, i, s) {
                    const o = this._notebookStatusBarItemProviders.get(e),
                        r = d.ov.revive(t),
                        a = this._documents.get(r);
                    if (!a || !o) return;
                    const c = a.getCellFromIndex(i);
                    if (!c) return;
                    const l = await o.provideCellStatusBarItems(c.apiCell, s);
                    if (!l) return;
                    const h = new n.SL;
                    return {
                        cacheId: this._statusBarCache.add([h]),
                        items: (Array.isArray(l) ? l : [l]).map((e => k.b$.from(e, this._commandsConverter, h)))
                    }
                }
                $releaseNotebookCellStatusBarItems(e) {
                    this._statusBarCache.delete(e)
                }
                registerNotebookSerializer(e, t, i, s, o) {
                    if ((0, Me.m5)(t)) throw new Error("viewType cannot be empty or just whitespace");
                    const r = this._handlePool++;
                    return this._notebookSerializer.set(r, {
                        viewType: t,
                        serializer: i,
                        options: s
                    }), this._notebookProxy.$registerNotebookSerializer(r, {
                        id: e.identifier,
                        location: e.extensionLocation
                    }, t, k.RG.from(s), bi._convertNotebookRegistrationData(e, o)), (0, n.OF)((() => {
                        this._notebookProxy.$unregisterNotebookSerializer(r)
                    }))
                }
                async $dataToNotebook(e, t, i) {
                    const s = this._notebookSerializer.get(e);
                    if (!s) throw new Error("NO serializer found");
                    const o = await s.serializer.deserializeNotebook(t.buffer, i);
                    return new L.ky(k.c4.from(o))
                }
                async $notebookToData(e, t, i) {
                    const s = this._notebookSerializer.get(e);
                    if (!s) throw new Error("NO serializer found");
                    const o = await s.serializer.serializeNotebook(k.c4.to(t.value), i);
                    return Ge.KN.wrap(o)
                }
                async $saveNotebook(e, t, i, s, o) {
                    const r = d.ov.revive(t),
                        n = this._notebookSerializer.get(e);
                    if (this.trace(`enter saveNotebook(versionId: ${i}, ${r.toString()})`), !n) throw new Error("NO serializer found");
                    const a = this._documents.get(r);
                    if (!a) throw new Error("Document NOT found");
                    if (a.versionId !== i) throw new Error("Document version mismatch");
                    if (!this._extHostFileSystem.value.isWritableFileSystem(r.scheme)) throw new g.Ym((0, Ie.C$)(xi, 0, "Unable to modify read-only file '{0}'", this._resourceForError(r)), g.PK.FILE_PERMISSION_DENIED);
                    const c = {
                        metadata: (0, le.hX)(a.apiNotebook.metadata, (e => !(n.options ? .transientDocumentMetadata ? ? {})[e])),
                        cells: []
                    };
                    for (const e of a.apiNotebook.getCells()) {
                        const t = new b.Ul(e.kind, e.document.getText(), e.document.languageId, e.mime, n.options ? .transientOutputs ? [] : [...e.outputs], e.metadata, e.executionSummary);
                        t.metadata = (0, le.hX)(e.metadata, (e => !(n.options ? .transientCellMetadata ? ? {})[e])), c.cells.push(t)
                    }
                    if (await this._validateWriteFile(r, s), o.isCancellationRequested) throw new Error("canceled");
                    const l = await n.serializer.serializeNotebook(c, o);
                    if (o.isCancellationRequested) throw new Error("canceled");
                    this.trace(`serialized versionId: ${i} ${r.toString()}`), await this._extHostFileSystem.value.writeFile(r, l), this.trace(`Finished write versionId: ${i} ${r.toString()}`);
                    const h = this._extHostFileSystem.getFileSystemProviderExtUri(r.scheme),
                        u = await this._extHostFileSystem.value.stat(r),
                        p = {
                            name: h.basename(r),
                            isFile: 0 != (u.type & g.Tv.File),
                            isDirectory: 0 != (u.type & g.Tv.Directory),
                            isSymbolicLink: 0 != (u.type & g.Tv.SymbolicLink),
                            mtime: u.mtime,
                            ctime: u.ctime,
                            size: u.size,
                            readonly: Boolean((u.permissions ? ? 0) & g.rM.Readonly) || !this._extHostFileSystem.value.isWritableFileSystem(r.scheme),
                            locked: Boolean((u.permissions ? ? 0) & g.rM.Locked),
                            etag: (0, g.AT)({
                                mtime: u.mtime,
                                size: u.size
                            }),
                            children: void 0
                        };
                    return this.trace(`exit saveNotebook(versionId: ${i}, ${r.toString()})`), p
                }
                async $searchInNotebooks(e, t, i, s, o) {
                    const r = this._notebookSerializer.get(e) ? .serializer;
                    if (!r) return {
                        limitHit: !1,
                        results: []
                    };
                    const n = new $e.XV;
                    await (async (e, t, i) => {
                        await Promise.all(e.map((async e => await Promise.all(e.filenamePatterns.map((o => {
                            const r = {
                                _reason: i._reason,
                                folderQueries: i.folderQueries,
                                includePattern: i.includePattern,
                                excludePattern: i.excludePattern,
                                maxResults: i.maxResults,
                                type: mi.xL.File,
                                filePattern: o
                            };
                            return this._extHostSearch.doInternalFileSearchWithCustomCallback(r, t, (t => {
                                t.forEach((t => {
                                    n.has(t) || s.some((i => !(e.isFromSettings && !i.isFromSettings) && i.filenamePatterns.some((e => (0, yi.M9)(e, t))))) || n.add(t)
                                }))
                            })).catch((e => {
                                if ("ENOENT" === e.code) return wi.warn("Could not find notebook search results, ignoring notebook results."), {
                                    limitHit: !1,
                                    messages: []
                                };
                                throw e
                            }))
                        }))))))
                    })(i, o, t);
                    const a = new $e.Y9;
                    let c = !1;
                    const d = Array.from(n).map((async e => {
                        const i = [];
                        try {
                            if (o.isCancellationRequested) return;
                            if (t.maxResults && [...a.values()].reduce(((e, t) => e + t.cellResults.length), 0) > t.maxResults) return void(c = !0);
                            const s = [],
                                n = this._documents.get(e);
                            if (n) n.apiNotebook.getCells().forEach((e => s.push({
                                input: e.document.getText(),
                                outputs: e.outputs.flatMap((e => e.items.map((e => e.data.toString()))))
                            })));
                            else {
                                const t = await this._extHostFileSystem.value.readFile(e),
                                    i = Ge.KN.fromString(t.toString()),
                                    n = await r.deserializeNotebook(i.buffer, o);
                                if (o.isCancellationRequested) return;
                                k.c4.from(n).cells.forEach((e => s.push({
                                    input: e.source,
                                    outputs: e.outputs.flatMap((e => e.items.map((e => e.valueBytes.toString()))))
                                })))
                            }
                            if (o.isCancellationRequested) return;
                            s.forEach(((e, s) => {
                                const o = t.contentPattern.pattern,
                                    r = new _i(e.input, void 0, e.outputs),
                                    n = r.findInInputs(o),
                                    a = r.findInOutputs(o),
                                    c = a.flatMap((e => fi(e.matches, e.textBuffer))).map(((e, t) => (e.webviewIndex = t, e)));
                                if (n.length > 0 || a.length > 0) {
                                    const e = {
                                        index: s,
                                        contentResults: fi(n, r.inputTextBuffer),
                                        webviewResults: c
                                    };
                                    i.push(e)
                                }
                            }));
                            const d = {
                                resource: e,
                                cellResults: i
                            };
                            return void a.set(e, d)
                        } catch (e) {
                            return
                        }
                    }));
                    return await Promise.all(d), {
                        limitHit: c,
                        results: [...a.values()]
                    }
                }
                async _validateWriteFile(e, t) {
                    const i = await this._extHostFileSystem.value.stat(e);
                    if ("number" == typeof t ? .mtime && "string" == typeof t.etag && t.etag !== g.jG && "number" == typeof i.mtime && "number" == typeof i.size && t.mtime < i.mtime && t.etag !== (0, g.AT)({
                            mtime: t.mtime,
                            size: i.size
                        })) throw new g.Ym((0, Ie.C$)(xi, 1, "File Modified Since"), g.PK.FILE_MODIFIED_SINCE, t)
                }
                _resourceForError(e) {
                    return e.scheme === a.lg.file ? e.fsPath : e.toString()
                }
                _createExtHostEditor(e, t, i) {
                    if (this._editors.has(t)) throw new Error(`editor with id ALREADY EXSIST: ${t}`);
                    const s = new pi(t, this._notebookEditorsProxy, e, i.visibleRanges.map(k.Xs.to), i.selections.map(k.Xs.to), "number" == typeof i.viewColumn ? k.eI.to(i.viewColumn) : void 0);
                    this._editors.set(t, s)
                }
                $acceptDocumentAndEditorsDelta(e) {
                    if (e.value.removedDocuments)
                        for (const t of e.value.removedDocuments) {
                            const e = d.ov.revive(t),
                                i = this._documents.get(e);
                            i && (i.dispose(), this._documents.delete(e), this._textDocumentsAndEditors.$acceptDocumentsAndEditorsDelta({
                                removedDocuments: i.apiNotebook.getCells().map((e => e.document.uri))
                            }), this._onDidCloseNotebookDocument.fire(i.apiNotebook));
                            for (const t of this._editors.values()) t.notebookData.uri.toString() === e.toString() && this._editors.delete(t.id)
                        }
                    if (e.value.addedDocuments) {
                        const t = [];
                        for (const i of e.value.addedDocuments) {
                            const e = d.ov.revive(i.uri);
                            if (this._documents.has(e)) throw new Error(`adding EXISTING notebook ${e} `);
                            const s = new ui(this._notebookDocumentsProxy, this._textDocumentsAndEditors, this._textDocuments, e, i);
                            t.push(...i.cells.map((e => hi.asModelAddData(e)))), this._documents.get(e) ? .dispose(), this._documents.set(e, s), this._textDocumentsAndEditors.$acceptDocumentsAndEditorsDelta({
                                addedDocuments: t
                            }), this._onDidOpenNotebookDocument.fire(s.apiNotebook)
                        }
                    }
                    if (e.value.addedEditors)
                        for (const t of e.value.addedEditors) {
                            if (this._editors.has(t.id)) return;
                            const e = d.ov.revive(t.documentUri),
                                i = this._documents.get(e);
                            i && this._createExtHostEditor(i, t.id, t)
                        }
                    if (e.value.removedEditors)
                        for (const t of e.value.removedEditors) {
                            const e = this._editors.get(t);
                            e && (this._editors.delete(t), this._activeNotebookEditor ? .id === e.id && (this._activeNotebookEditor = void 0))
                        }
                    if (e.value.visibleEditors) {
                        this._visibleNotebookEditors = e.value.visibleEditors.map((e => this._editors.get(e))).filter((e => !!e));
                        const t = new Set;
                        this._visibleNotebookEditors.forEach((e => t.add(e.id)));
                        for (const e of this._editors.values()) {
                            const i = t.has(e.id);
                            e._acceptVisibility(i)
                        }
                        this._visibleNotebookEditors = [...this._editors.values()].map((e => e)).filter((e => e.visible)), this._onDidChangeVisibleNotebookEditors.fire(this.visibleNotebookEditors)
                    }
                    null === e.value.newActiveEditor ? this._activeNotebookEditor = void 0 : e.value.newActiveEditor && (this._editors.get(e.value.newActiveEditor) || wi.error(`FAILED to find active notebook editor ${e.value.newActiveEditor}`), this._activeNotebookEditor = this._editors.get(e.value.newActiveEditor)), void 0 !== e.value.newActiveEditor && this._onDidChangeActiveNotebookEditor.fire(this._activeNotebookEditor ? .apiEditor)
                }
                static _registerApiCommands(e) {
                    const t = T.SF.String.with("notebookType", "A notebook type"),
                        i = new T.b9("vscode.executeDataToNotebook", "_executeDataToNotebook", "Invoke notebook serializer", [t, new T.SF("data", "Bytes to convert to data", (e => e instanceof Uint8Array), (e => Ge.KN.wrap(e)))], new T._m("Notebook Data", (e => k.c4.to(e.value)))),
                        s = new T.b9("vscode.executeNotebookToData", "_executeNotebookToData", "Invoke notebook serializer", [t, new T.SF("NotebookData", "Notebook data to convert to bytes", (e => !0), (e => new L.ky(k.c4.from(e))))], new T._m("Bytes", (e => e.buffer)));
                    e.registerApiCommand(i), e.registerApiCommand(s)
                }
                trace(e) {
                    this._logService.trace(`[Extension Host Notebook] ${e}`)
                }
            }
            class Di {
                constructor(e, t, i, s = {
                    timeout: 1500,
                    errors: 3
                }) {
                    this._logService = e, this._notebooksAndEditors = t, this._mainThreadBulkEdits = i, this._thresholds = s, this._onWillSaveNotebookDocumentEvent = new r.Qz
                }
                dispose() {}
                getOnWillSaveNotebookDocumentEvent(e) {
                    return (t, i, s) => {
                        const o = function(e) {
                            t.call(i, e)
                        };
                        return o.extension = e, this._onWillSaveNotebookDocumentEvent.event(o, void 0, s)
                    }
                }
                async $participateInSave(e, t, i) {
                    const s = d.ov.revive(e),
                        o = this._notebooksAndEditors.getNotebookDocument(s);
                    if (!o) throw new Error("Unable to resolve notebook document");
                    const r = [];
                    if (await this._onWillSaveNotebookDocumentEvent.fireAsync({
                            notebook: o.apiNotebook,
                            reason: k.wD.to(t)
                        }, i, (async (e, t) => {
                            const s = Date.now(),
                                o = await await Promise.resolve(e);
                            Date.now() - s > this._thresholds.timeout && this._logService.warn("onWillSaveNotebookDocument-listener from extension", t.extension.identifier), i.isCancellationRequested || o && (o instanceof b.DbP ? r.push(o) : this._logService.warn("onWillSaveNotebookDocument-listener from extension", t.extension.identifier, "ignored due to invalid data"))
                        })), i.isCancellationRequested) return !1;
                    if (0 === r.length) return !0;
                    const n = {
                        edits: []
                    };
                    for (const e of r) {
                        const {
                            edits: t
                        } = k.Db.from(e);
                        n.edits = n.edits.concat(t)
                    }
                    return this._mainThreadBulkEdits.$tryApplyWorkspaceEdit(new L.ky(n))
                }
            }
            class Ci {
                constructor(e) {
                    this._notebooksAndEditors = e, this._onDidSaveNotebookDocument = new r.Q5, this.onDidSaveNotebookDocument = this._onDidSaveNotebookDocument.event, this._onDidChangeNotebookDocument = new r.Q5, this.onDidChangeNotebookDocument = this._onDidChangeNotebookDocument.event
                }
                $acceptModelChanged(e, t, i, s) {
                    const o = this._notebooksAndEditors.getNotebookDocument(d.ov.revive(e)).acceptModelChanged(t.value, i, s);
                    this._onDidChangeNotebookDocument.fire(o)
                }
                $acceptDirtyStateChanged(e, t) {
                    this._notebooksAndEditors.getNotebookDocument(d.ov.revive(e)).acceptDirty(t)
                }
                $acceptModelSaved(e) {
                    const t = this._notebooksAndEditors.getNotebookDocument(d.ov.revive(e));
                    this._onDidSaveNotebookDocument.fire(t.apiNotebook)
                }
            }
            let Si = class {
                constructor(e, t) {
                    this._logService = e, this._notebooksAndEditors = t, this._onDidChangeNotebookEditorSelection = new r.Q5, this._onDidChangeNotebookEditorVisibleRanges = new r.Q5, this.onDidChangeNotebookEditorSelection = this._onDidChangeNotebookEditorSelection.event, this.onDidChangeNotebookEditorVisibleRanges = this._onDidChangeNotebookEditorVisibleRanges.event
                }
                $acceptEditorPropertiesChanged(e, t) {
                    this._logService.debug("ExtHostNotebook#$acceptEditorPropertiesChanged", e, t);
                    const i = this._notebooksAndEditors.getEditorById(e);
                    t.visibleRanges && i._acceptVisibleRanges(t.visibleRanges.ranges.map(k.Xs.to)), t.selections && i._acceptSelections(t.selections.selections.map(k.Xs.to)), t.visibleRanges && this._onDidChangeNotebookEditorVisibleRanges.fire({
                        notebookEditor: i.apiEditor,
                        visibleRanges: i.apiEditor.visibleRanges
                    }), t.selections && this._onDidChangeNotebookEditorSelection.fire(Object.freeze({
                        notebookEditor: i.apiEditor,
                        selections: i.apiEditor.selections
                    }))
                }
                $acceptEditorViewColumns(e) {
                    for (const t in e) this._notebooksAndEditors.getEditorById(t)._acceptViewColumn(k.eI.to(e[t]))
                }
            };
            Si = (0, N.g)([(0, N.f)(0, _.V)], Si);
            var Ei = i("gXH3"),
                Pi = i("ziTh");
            let Ti = class {
                constructor(e, t, i, s, o) {
                    this._initData = t, this._extHostNotebook = i, this._commands = s, this._logService = o, this._activeExecutions = new $e.Y9, this._activeNotebookExecutions = new $e.Y9, this._kernelDetectionTask = new Map, this._kernelDetectionTaskHandlePool = 0, this._kernelSourceActionProviders = new Map, this._kernelSourceActionProviderHandlePool = 0, this._kernelData = new Map, this._handlePool = 0, this._onDidChangeCellExecutionState = new r.Q5, this.onDidChangeNotebookCellExecutionState = this._onDidChangeCellExecutionState.event, this.id = 0, this.variableStore = {}, this._proxy = e.getProxy(x.Tr.MainThreadNotebookKernels);
                    const n = new T.b9("notebook.selectKernel", "_notebook.selectKernel", "Trigger kernel picker for specified notebook editor widget", [new T.SF("options", "Select kernel options", (e => !0), (e => {
                            if (e && "notebookEditor" in e && "id" in e) {
                                const t = this._extHostNotebook.getIdByEditor(e.notebookEditor);
                                return {
                                    id: e.id,
                                    extension: e.extension,
                                    notebookEditorId: t
                                }
                            }
                            if (e && "notebookEditor" in e) {
                                const t = this._extHostNotebook.getIdByEditor(e.notebookEditor);
                                if (void 0 === t) throw new Error(`Cannot invoke 'notebook.selectKernel' for unrecognized notebook editor ${e.notebookEditor.notebook.uri.toString()}`);
                                return {
                                    notebookEditorId: t
                                }
                            }
                            return e
                        }))], T._m.Void),
                        a = new T.b9("vscode.executeNotebookVariableProvider", "_executeNotebookVariableProvider", "Execute notebook variable provider", [T.SF.Uri], new T._m("A promise that resolves to an array of variables", ((e, t) => e.map((e => ({
                            variable: {
                                name: e.name,
                                value: e.value,
                                expression: e.expression,
                                type: e.type,
                                language: e.language
                            },
                            hasNamedChildren: e.hasNamedChildren,
                            indexedChildrenCount: e.indexedChildrenCount
                        }))))));
                    this._commands.registerApiCommand(n), this._commands.registerApiCommand(a)
                }
                createNotebookController(e, t, i, s, o, n) {
                    for (const i of this._kernelData.values())
                        if (i.controller.id === t && m.kP.equals(e.identifier, i.extensionId)) throw new Error(`notebook controller with id '${t}' ALREADY exist`);
                    const a = this._handlePool++,
                        c = this;
                    this._logService.trace(`NotebookController[${a}], CREATED by ${e.identifier.value}, ${t}`);
                    const d = () => Pi.warn(`NO execute handler from notebook controller '${p.id}' of extension: '${e.identifier}'`);
                    let l = !1;
                    const h = new r.Q5,
                        u = new r.Q5,
                        p = {
                            id: Hi(e.identifier, t),
                            notebookType: i,
                            extensionId: e.identifier,
                            extensionLocation: e.extensionLocation,
                            label: s || e.identifier.value,
                            preloads: n ? n.map(k.xT.from) : []
                        };
                    let g, v, _ = o ? ? d;
                    this._proxy.$addKernel(a, p).catch((e => {
                        Pi.log(e), l = !0
                    }));
                    let f = 0;
                    const y = () => {
                            if (l) return;
                            const e = ++f;
                            Promise.resolve().then((() => {
                                e === f && this._proxy.$updateKernel(a, p)
                            }))
                        },
                        w = new $e.Y9,
                        x = {
                            get id() {
                                return t
                            },
                            get notebookType() {
                                return p.notebookType
                            },
                            onDidChangeSelectedNotebooks: h.event,
                            get label() {
                                return p.label
                            },
                            set label(t) {
                                p.label = t ? ? e.displayName ? ? e.name, y()
                            },
                            get detail() {
                                return p.detail ? ? ""
                            },
                            set detail(e) {
                                p.detail = e, y()
                            },
                            get description() {
                                return p.description ? ? ""
                            },
                            set description(e) {
                                p.description = e, y()
                            },
                            get supportedLanguages() {
                                return p.supportedLanguages
                            },
                            set supportedLanguages(e) {
                                p.supportedLanguages = e, y()
                            },
                            get supportsExecutionOrder() {
                                return p.supportsExecutionOrder ? ? !1
                            },
                            set supportsExecutionOrder(e) {
                                p.supportsExecutionOrder = e, y()
                            },
                            get rendererScripts() {
                                return p.preloads ? p.preloads.map(k.xT.to) : []
                            },
                            get executeHandler() {
                                return _
                            },
                            set executeHandler(e) {
                                _ = e ? ? d
                            },
                            get interruptHandler() {
                                return g
                            },
                            set interruptHandler(e) {
                                g = e, p.supportsInterrupt = Boolean(e), y()
                            },
                            set variableProvider(t) {
                                (0, q.H5)(e, "notebookVariableProvider"), v = t, p.hasVariableProvider = !!t, t ? .onDidChangeVariables((e => c._proxy.$variablesUpdated(e.uri))), y()
                            },
                            get variableProvider() {
                                return v
                            },
                            createNotebookCellExecution(t) {
                                if (l) throw new Error("notebook controller is DISPOSED");
                                if (!w.has(t.notebook.uri)) throw c._logService.trace(`NotebookController[${a}] NOT associated to notebook, associated to THESE notebooks:`, Array.from(w.keys()).map((e => e.toString()))), new Error(`notebook controller is NOT associated to notebook: ${t.notebook.uri.toString()}`);
                                return c._createNotebookCellExecution(t, Hi(e.identifier, this.id))
                            },
                            createNotebookExecution(t) {
                                if ((0, q.H5)(e, "notebookExecution"), l) throw new Error("notebook controller is DISPOSED");
                                if (!w.has(t.uri)) throw c._logService.trace(`NotebookController[${a}] NOT associated to notebook, associated to THESE notebooks:`, Array.from(w.keys()).map((e => e.toString()))), new Error(`notebook controller is NOT associated to notebook: ${t.uri.toString()}`);
                                return c._createNotebookExecution(t, Hi(e.identifier, this.id))
                            },
                            dispose: () => {
                                l || (this._logService.trace(`NotebookController[${a}], DISPOSED`), l = !0, this._kernelData.delete(a), h.dispose(), u.dispose(), this._proxy.$removeKernel(a))
                            },
                            updateNotebookAffinity(t, i) {
                                i === b.Hu0.Hidden && (0, q.H5)(e, "notebookControllerAffinityHidden"), c._proxy.$updateNotebookPriority(a, t.uri, i)
                            },
                            onDidReceiveMessage: u.event,
                            postMessage: (t, i) => ((0, q.H5)(e, "notebookMessaging"), c._proxy.$postMessage(a, i && c._extHostNotebook.getIdByEditor(i), t)),
                            asWebviewUri: t => ((0, q.H5)(e, "notebookMessaging"), oe(t, c._initData.remote))
                        };
                    return this._kernelData.set(a, {
                        extensionId: e.identifier,
                        controller: x,
                        onDidReceiveMessage: u,
                        onDidChangeSelection: h,
                        associatedNotebooks: w
                    }), x
                }
                getIdByController(e) {
                    for (const [t, i] of this._kernelData)
                        if (i.controller === e) return Hi(i.extensionId, e.id);
                    return null
                }
                createNotebookControllerDetectionTask(e, t) {
                    const i = this._kernelDetectionTaskHandlePool++,
                        s = this;
                    this._logService.trace(`NotebookControllerDetectionTask[${i}], CREATED by ${e.identifier.value}`), this._proxy.$addKernelDetectionTask(i, t);
                    const o = {
                        dispose: () => {
                            this._kernelDetectionTask.delete(i), s._proxy.$removeKernelDetectionTask(i)
                        }
                    };
                    return this._kernelDetectionTask.set(i, o), o
                }
                registerKernelSourceActionProvider(e, t, i) {
                    const s = this._kernelSourceActionProviderHandlePool++,
                        o = "function" == typeof i.onDidChangeNotebookKernelSourceActions ? s : void 0,
                        r = this;
                    let n;
                    return this._kernelSourceActionProviders.set(s, i), this._logService.trace(`NotebookKernelSourceActionProvider[${s}], CREATED by ${e.identifier.value}`), this._proxy.$addKernelSourceActionProvider(s, s, t), void 0 !== o && (n = i.onDidChangeNotebookKernelSourceActions((e => this._proxy.$emitNotebookKernelSourceActionsChangeEvent(o)))), {
                        dispose: () => {
                            this._kernelSourceActionProviders.delete(s), r._proxy.$removeKernelSourceActionProvider(s, s), n ? .dispose()
                        }
                    }
                }
                async $provideKernelSourceActions(e, t) {
                    const i = this._kernelSourceActionProviders.get(e);
                    if (i) {
                        const e = new n.SL;
                        return (await i.provideNotebookKernelSourceActions(t) ? ? []).map((t => k.ac.from(t, this._commands.converter, e)))
                    }
                    return []
                }
                $acceptNotebookAssociation(e, t, i) {
                    const s = this._kernelData.get(e);
                    if (s) {
                        const o = this._extHostNotebook.getNotebookDocument(d.ov.revive(t));
                        i ? s.associatedNotebooks.set(o.uri, !0) : s.associatedNotebooks.delete(o.uri), this._logService.trace(`NotebookController[${e}] ASSOCIATE notebook`, o.uri.toString(), i), s.onDidChangeSelection.fire({
                            selected: i,
                            notebook: o.apiNotebook
                        })
                    }
                }
                async $executeCells(e, t, i) {
                    const s = this._kernelData.get(e);
                    if (!s) return;
                    const o = this._extHostNotebook.getNotebookDocument(d.ov.revive(t)),
                        r = [];
                    for (const e of i) {
                        const t = o.getCell(e);
                        t && r.push(t.apiCell)
                    }
                    try {
                        this._logService.trace(`NotebookController[${e}] EXECUTE cells`, o.uri.toString(), r.length), await s.controller.executeHandler.call(s.controller, r, o.apiNotebook, s.controller)
                    } catch (t) {
                        this._logService.error(`NotebookController[${e}] execute cells FAILED`, t), Pi.error(t)
                    }
                }
                async $cancelCells(e, t, i) {
                    const s = this._kernelData.get(e);
                    if (!s) return;
                    const o = this._extHostNotebook.getNotebookDocument(d.ov.revive(t));
                    if (s.controller.interruptHandler) await s.controller.interruptHandler.call(s.controller, o.apiNotebook);
                    else
                        for (const e of i) {
                            const t = o.getCell(e);
                            t && this._activeExecutions.get(t.uri) ? .cancel()
                        }
                    if (s.controller.interruptHandler) {
                        const e = this._activeNotebookExecutions.get(o.uri);
                        this._activeNotebookExecutions.delete(o.uri), i.length && Array.isArray(e) && e.length && e.forEach((e => e.dispose()))
                    }
                }
                async $provideVariables(e, t, i, s, o, r, n) {
                    const a = this._kernelData.get(e);
                    if (!a) return;
                    const c = this._extHostNotebook.getNotebookDocument(d.ov.revive(i)),
                        l = a.controller.variableProvider;
                    if (!l) return;
                    let h;
                    if (void 0 !== s) {
                        if (h = this.variableStore[s], !h) return
                    } else this.variableStore = {};
                    const u = "named" === o ? b.rbC.Named : b.rbC.Indexed,
                        p = l.provideVariables(c.apiNotebook, h, u, r, n);
                    let m = 0;
                    for await (const e of p) {
                        if (n.isCancellationRequested) return;
                        const i = {
                            id: this.id++,
                            name: e.variable.name,
                            value: e.variable.value,
                            type: e.variable.type,
                            interfaces: e.variable.interfaces,
                            language: e.variable.language,
                            expression: e.variable.expression,
                            hasNamedChildren: e.hasNamedChildren,
                            indexedChildrenCount: e.indexedChildrenCount,
                            extensionId: a.extensionId.value
                        };
                        if (this.variableStore[i.id] = e.variable, this._proxy.$receiveVariable(t, i), m++ >= 100) return
                    }
                }
                $acceptKernelMessageFromRenderer(e, t, i) {
                    const s = this._kernelData.get(e);
                    if (!s) return;
                    const o = this._extHostNotebook.getEditorById(t);
                    s.onDidReceiveMessage.fire(Object.freeze({
                        editor: o.apiEditor,
                        message: i
                    }))
                }
                $cellExecutionChanged(e, t, i) {
                    const s = this._extHostNotebook.getNotebookDocument(d.ov.revive(e)).getCell(t);
                    if (s) {
                        const e = i ? k.KP.to(i) : b.KPz.Idle;
                        void 0 !== e && this._onDidChangeCellExecutionState.fire({
                            cell: s.apiCell,
                            state: e
                        })
                    }
                }
                _createNotebookCellExecution(e, t) {
                    if (e.index < 0) throw new Error("CANNOT execute cell that has been REMOVED from notebook");
                    const i = this._extHostNotebook.getNotebookDocument(e.notebook.uri).getCellFromApiCell(e);
                    if (!i) throw new Error("invalid cell");
                    if (this._activeExecutions.has(i.uri)) throw new Error(`duplicate execution for ${i.uri}`);
                    const s = new Ai(t, i, this._proxy);
                    this._activeExecutions.set(i.uri, s);
                    const o = s.onDidChangeState((() => {
                        s.state === ki.Resolved && (s.dispose(), o.dispose(), this._activeExecutions.delete(i.uri))
                    }));
                    return s.asApiObject()
                }
                _createNotebookExecution(e, t) {
                    const i = this._extHostNotebook.getNotebookDocument(e.uri),
                        s = e.getCells().find((e => {
                            const t = i.getCellFromApiCell(e);
                            return t && this._activeExecutions.has(t.uri)
                        }));
                    if (s) throw new Error(`duplicate cell execution for ${s.document.uri}`);
                    if (this._activeNotebookExecutions.has(i.uri)) throw new Error(`duplicate notebook execution for ${i.uri}`);
                    const o = new $i(t, i, this._proxy),
                        r = o.onDidChangeState((() => {
                            o.state === Ii.Resolved && (o.dispose(), r.dispose(), this._activeNotebookExecutions.delete(i.uri))
                        }));
                    return this._activeNotebookExecutions.set(i.uri, [o, r]), o.asApiObject()
                }
            };
            var ki, Ii;
            Ti = (0, N.g)([(0, N.f)(4, _.V)], Ti),
                function(e) {
                    e[e.Init = 0] = "Init", e[e.Started = 1] = "Started", e[e.Resolved = 2] = "Resolved"
                }(ki || (ki = {}));
            class Ai extends n.JT {
                static {
                    this.HANDLE = 0
                }
                get state() {
                    return this._state
                }
                constructor(e, t, i) {
                    super(), this._cell = t, this._proxy = i, this._handle = Ai.HANDLE++, this._onDidChangeState = new r.Q5, this.onDidChangeState = this._onDidChangeState.event, this._state = ki.Init, this._tokenSource = this._register(new s.AU), this._collector = new Ri(10, (e => this.update(e))), this._executionOrder = t.internalMetadata.executionOrder, this._proxy.$createExecution(this._handle, e, this._cell.notebook.uri, this._cell.handle)
                }
                cancel() {
                    this._tokenSource.cancel()
                }
                async updateSoon(e) {
                    await this._collector.addItem(e)
                }
                async update(e) {
                    const t = Array.isArray(e) ? e : [e];
                    return this._proxy.$updateExecution(this._handle, new L.ky(t))
                }
                verifyStateForOutput() {
                    if (this._state === ki.Init) throw new Error("Must call start before modifying cell output");
                    if (this._state === ki.Resolved) throw new Error("Cannot modify cell output after calling resolve")
                }
                cellIndexToHandle(e) {
                    let t = this._cell;
                    if (e && (t = this._cell.notebook.getCellFromApiCell(e)), !t) throw new Error("INVALID cell");
                    return t.handle
                }
                validateAndConvertOutputs(e) {
                    return e.map((e => {
                        const t = b.JOq.ensureUniqueMimeTypes(e.items, !0);
                        return t === e.items ? k.JO.from(e) : k.JO.from({
                            items: t,
                            id: e.id,
                            metadata: e.metadata
                        })
                    }))
                }
                async updateOutputs(e, t, i) {
                    const s = this.cellIndexToHandle(t),
                        o = this.validateAndConvertOutputs((0, C._2)(e));
                    return this.updateSoon({
                        editType: Ei.W.Output,
                        cellHandle: s,
                        append: i,
                        outputs: o
                    })
                }
                async updateOutputItems(e, t, i) {
                    return e = b.JOq.ensureUniqueMimeTypes((0, C._2)(e), !0), this.updateSoon({
                        editType: Ei.W.OutputItems,
                        items: e.map(k.x$.from),
                        outputId: t.id,
                        append: i
                    })
                }
                asApiObject() {
                    const e = this,
                        t = {
                            get token() {
                                return e._tokenSource.token
                            },
                            get cell() {
                                return e._cell.apiCell
                            },
                            get executionOrder() {
                                return e._executionOrder
                            },
                            set executionOrder(t) {
                                e._executionOrder = t, e.update([{
                                    editType: Ei.W.ExecutionState,
                                    executionOrder: e._executionOrder
                                }])
                            },
                            start(t) {
                                if (e._state === ki.Resolved || e._state === ki.Started) throw new Error("Cannot call start again");
                                e._state = ki.Started, e._onDidChangeState.fire(), e.update({
                                    editType: Ei.W.ExecutionState,
                                    runStartTime: t
                                })
                            },
                            end(t, i, s) {
                                if (e._state === ki.Resolved) throw new Error("Cannot call resolve twice");
                                e._state = ki.Resolved, e._onDidChangeState.fire(), e._collector.flush();
                                const o = s ? {
                                    message: s.message,
                                    stack: s.stack,
                                    location: s ? .location ? {
                                        startLineNumber: s.location.start.line,
                                        startColumn: s.location.start.character,
                                        endLineNumber: s.location.end.line,
                                        endColumn: s.location.end.character
                                    } : void 0,
                                    uri: s.uri
                                } : void 0;
                                e._proxy.$completeExecution(e._handle, new L.ky({
                                    runEndTime: i,
                                    lastRunSuccess: t,
                                    error: o
                                }))
                            },
                            clearOutput: t => (e.verifyStateForOutput(), e.updateOutputs([], t, !1)),
                            appendOutput: (t, i) => (e.verifyStateForOutput(), e.updateOutputs(t, i, !0)),
                            replaceOutput: (t, i) => (e.verifyStateForOutput(), e.updateOutputs(t, i, !1)),
                            appendOutputItems: (t, i) => (e.verifyStateForOutput(), e.updateOutputItems(t, i, !0)),
                            replaceOutputItems: (t, i) => (e.verifyStateForOutput(), e.updateOutputItems(t, i, !1))
                        };
                    return Object.freeze(t)
                }
            }! function(e) {
                e[e.Init = 0] = "Init", e[e.Started = 1] = "Started", e[e.Resolved = 2] = "Resolved"
            }(Ii || (Ii = {}));
            class $i extends n.JT {
                static {
                    this.HANDLE = 0
                }
                get state() {
                    return this._state
                }
                constructor(e, t, i) {
                    super(), this._notebook = t, this._proxy = i, this._handle = $i.HANDLE++, this._onDidChangeState = new r.Q5, this.onDidChangeState = this._onDidChangeState.event, this._state = Ii.Init, this._tokenSource = this._register(new s.AU), this._proxy.$createNotebookExecution(this._handle, e, this._notebook.uri)
                }
                cancel() {
                    this._tokenSource.cancel()
                }
                asApiObject() {
                    const e = {
                        start: () => {
                            if (this._state === Ii.Resolved || this._state === Ii.Started) throw new Error("Cannot call start again");
                            this._state = Ii.Started, this._onDidChangeState.fire(), this._proxy.$beginNotebookExecution(this._handle)
                        },
                        end: () => {
                            if (this._state === Ii.Resolved) throw new Error("Cannot call resolve twice");
                            this._state = Ii.Resolved, this._onDidChangeState.fire(), this._proxy.$completeNotebookExecution(this._handle)
                        }
                    };
                    return Object.freeze(e)
                }
            }
            class Ri {
                constructor(e, t) {
                    this.delay = e, this.callback = t, this.batch = [], this.startedTimer = Date.now()
                }
                addItem(e) {
                    return this.batch.push(e), this.currentDeferred || (this.currentDeferred = new U.CR, this.startedTimer = Date.now(), (0, U.Vs)(this.delay).then((() => this.flush()))), Date.now() - this.startedTimer > this.delay ? this.flush() : this.currentDeferred.p
                }
                flush() {
                    if (0 === this.batch.length || !this.currentDeferred) return Promise.resolve();
                    const e = this.currentDeferred;
                    this.currentDeferred = void 0;
                    const t = this.batch;
                    return this.batch = [], this.callback(t).finally((() => e.complete()))
                }
            }

            function Hi(e, t) {
                return `${e.value}/${t}`
            }
            class Fi {
                constructor(e, t) {
                    this._extHostNotebook = t, this._rendererMessageEmitters = new Map, this.proxy = e.getProxy(x.Tr.MainThreadNotebookRenderers)
                }
                $postRendererMessage(e, t, i) {
                    const s = this._extHostNotebook.getEditorById(e);
                    this._rendererMessageEmitters.get(t) ? .fire({
                        editor: s.apiEditor,
                        message: i
                    })
                }
                createRendererMessaging(e, t) {
                    if (!e.contributes ? .notebookRenderer ? .some((e => e.id === t))) throw new Error(`Extensions may only call createRendererMessaging() for renderers they contribute (got ${t})`);
                    return {
                        onDidReceiveMessage: (e, i, s) => this.getOrCreateEmitterFor(t).event(e, i, s),
                        postMessage: (e, i) => {
                            pi.apiEditorsToExtHost.has(e) && ([e, i] = [i, e]);
                            const s = i && pi.apiEditorsToExtHost.get(i);
                            return this.proxy.$postMessage(s ? .id, t, e)
                        }
                    }
                }
                getOrCreateEmitterFor(e) {
                    let t = this._rendererMessageEmitters.get(e);
                    return t || (t = new r.Q5({
                        onDidRemoveLastListener: () => {
                            t ? .dispose(), this._rendererMessageEmitters.delete(e)
                        }
                    }), this._rendererMessageEmitters.set(e, t), t)
                }
            }
            var Ni = i("rqgR");
            class Mi {
                constructor(e) {
                    this.handlers = new Map, this.proxy = e.getProxy(x.Tr.MainThreadProfileContentHandlers)
                }
                registerProfileContentHandler(e, t, i) {
                    if ((0, q.H5)(e, "profileContentHandlers"), this.handlers.has(t)) throw new Error(`Handler with id '${t}' already registered`);
                    return this.handlers.set(t, i), this.proxy.$registerProfileContentHandler(t, i.name, i.description, e.identifier.value), (0, n.OF)((() => {
                        this.handlers.delete(t), this.proxy.$unregisterProfileContentHandler(t)
                    }))
                }
                async $saveProfile(e, t, i, s) {
                    const o = this.handlers.get(e);
                    if (!o) throw new Error(`Unknown handler with id: ${e}`);
                    return o.saveProfile(t, i, s)
                }
                async $readProfile(e, t, i) {
                    const s = this.handlers.get(e);
                    if (!s) throw new Error(`Unknown handler with id: ${e}`);
                    return s.readProfile((0, z.HD)(t) ? t : d.ov.revive(t), i)
                }
            }
            var Li = i("xoT7"),
                Oi = i("H8NC");
            class Ui {
                constructor(e) {
                    this._handles = 0, this._mapHandleToCancellationSource = new Map, this._proxy = e
                }
                async withProgress(e, t, i) {
                    const s = this._handles++,
                        {
                            title: r,
                            location: n,
                            cancellable: a
                        } = t,
                        c = {
                            label: e.displayName || e.name,
                            id: e.identifier.value
                        };
                    return this._proxy.$startProgress(s, {
                        location: k.uT.from(n),
                        title: r,
                        source: c,
                        cancellable: a
                    }, e.isUnderDevelopment ? void 0 : e.identifier.value).catch(o.Cp), this._withProgress(s, i, !!a)
                }
                _withProgress(e, t, i) {
                    let o;
                    i && (o = new s.AU, this._mapHandleToCancellationSource.set(e, o));
                    const r = e => {
                        this._proxy.$progressEnd(e), this._mapHandleToCancellationSource.delete(e), o ? .dispose()
                    };
                    let n;
                    try {
                        n = t(new Vi(this._proxy, e), i && o ? o.token : s.Ts.None)
                    } catch (t) {
                        throw r(e), t
                    }
                    return n.then((t => r(e)), (t => r(e))), n
                }
                $acceptProgressCanceled(e) {
                    const t = this._mapHandleToCancellationSource.get(e);
                    t && (t.cancel(), this._mapHandleToCancellationSource.delete(e))
                }
            }
            class Vi extends Li.Ex {
                constructor(e, t) {
                    super((e => this.throttledReport(e))), this._proxy = e, this._handle = t
                }
                throttledReport(e) {
                    this._proxy.$progressReport(this._handle, e)
                }
            }
            Vi.__decorator = (0, N.g)([(0, Oi.P2)(100, ((e, t) => function(e, t) {
                return e.message = t.message, "number" == typeof t.increment && ("number" == typeof e.increment ? e.increment += t.increment : e.increment = t.increment), e
            }(e, t)), (() => Object.create(null)))], Vi.prototype, "throttledReport", null);
            class Wi {
                static {
                    this.handlePool = 0
                }
                constructor(e, t) {
                    this.uriTransformer = t, this.providers = new Map, this.proxy = e.getProxy(x.Tr.MainThreadQuickDiff)
                }
                $provideOriginalResource(e, t, i) {
                    const s = d.ov.revive(t),
                        o = this.providers.get(e);
                    return o ? (0, U.OH)((() => o.provideOriginalResource(s, i))).then((e => e || null)) : Promise.resolve(null)
                }
                registerQuickDiffProvider(e, t, i, s) {
                    const o = Wi.handlePool++;
                    return this.providers.set(o, t), this.proxy.$registerQuickDiffProvider(o, k.Lq.from(e, this.uriTransformer), i, s), {
                        dispose: () => {
                            this.proxy.$unregisterQuickDiffProvider(o), this.providers.delete(o)
                        }
                    }
                }
            }
            var Bi = i("ziTh");
            var zi, ji = i("iw9n"),
                qi = i("pLPy");

            function Ki(e) {
                return e instanceof d.ov
            }

            function Ji(e, t) {
                return e.scheme === a.lg.file && t.scheme === a.lg.file && qi.IJ ? e.toString() === t.toString() : e.toString().toLowerCase() === t.toString().toLowerCase()
            }

            function Gi(e) {
                return e ? "string" == typeof e.iconPath ? d.ov.file(e.iconPath) : d.ov.isUri(e.iconPath) || Q.kS.isThemeIcon(e.iconPath) ? e.iconPath : void 0 : void 0
            }

            function Qi(e) {
                if (e) {
                    if (d.ov.isUri(e)) return e;
                    if (Q.kS.isThemeIcon(e)) return e; {
                        const t = e;
                        return {
                            light: t.light,
                            dark: t.dark
                        }
                    }
                }
            }

            function Zi(e) {
                const t = Qi(e.icon),
                    i = e.labels ? .map((e => ({
                        title: e.title,
                        icon: Qi(e.icon)
                    })));
                return { ...e,
                    icon: t,
                    labels: i
                }
            }

            function Yi(e, t) {
                if (!e.iconPath && !t.iconPath) return 0;
                if (!e.iconPath) return -1;
                if (!t.iconPath) return 1;
                const i = "string" == typeof e.iconPath ? e.iconPath : d.ov.isUri(e.iconPath) ? e.iconPath.fsPath : e.iconPath.id,
                    s = "string" == typeof t.iconPath ? t.iconPath : d.ov.isUri(t.iconPath) ? t.iconPath.fsPath : t.iconPath.id;
                return (0, ji.W7)(i, s)
            }

            function Xi(e, t) {
                let i = (0, ji.W7)(e.resourceUri.fsPath, t.resourceUri.fsPath, !0);
                if (0 !== i) return i;
                if (e.command && t.command) i = function(e, t) {
                    if (e.command !== t.command) return e.command < t.command ? -1 : 1;
                    if (e.title !== t.title) return e.title < t.title ? -1 : 1;
                    if (e.tooltip !== t.tooltip) {
                        if (void 0 !== e.tooltip && void 0 !== t.tooltip) return e.tooltip < t.tooltip ? -1 : 1;
                        if (void 0 !== e.tooltip) return 1;
                        if (void 0 !== t.tooltip) return -1
                    }
                    if (e.arguments === t.arguments) return 0;
                    if (!e.arguments) return -1;
                    if (!t.arguments) return 1;
                    if (e.arguments.length !== t.arguments.length) return e.arguments.length - t.arguments.length;
                    for (let i = 0; i < e.arguments.length; i++) {
                        const s = e.arguments[i],
                            o = t.arguments[i];
                        if (s !== o && !(Ki(s) && Ki(o) && Ji(s, o))) return s < o ? -1 : 1
                    }
                    return 0
                }(e.command, t.command);
                else {
                    if (e.command) return 1;
                    if (t.command) return -1
                }
                if (0 !== i) return i;
                if (e.decorations && t.decorations) i = function(e, t) {
                    let i = 0;
                    if (e.strikeThrough !== t.strikeThrough) return e.strikeThrough ? 1 : -1;
                    if (e.faded !== t.faded) return e.faded ? 1 : -1;
                    if (e.tooltip !== t.tooltip) return (e.tooltip || "").localeCompare(t.tooltip || "");
                    if (i = Yi(e, t), 0 !== i) return i;
                    if (e.light && t.light) i = Yi(e.light, t.light);
                    else {
                        if (e.light) return 1;
                        if (t.light) return -1
                    }
                    if (0 !== i) return i;
                    if (e.dark && t.dark) i = Yi(e.dark, t.dark);
                    else {
                        if (e.dark) return 1;
                        if (t.dark) return -1
                    }
                    return i
                }(e.decorations, t.decorations);
                else {
                    if (e.decorations) return 1;
                    if (t.decorations) return -1
                }
                if (e.multiFileDiffEditorModifiedUri && t.multiFileDiffEditorModifiedUri) i = (0, ji.W7)(e.multiFileDiffEditorModifiedUri.fsPath, t.multiFileDiffEditorModifiedUri.fsPath, !0);
                else {
                    if (e.multiFileDiffEditorModifiedUri) return 1;
                    if (t.multiFileDiffEditorModifiedUri) return -1
                }
                if (e.multiDiffEditorOriginalUri && t.multiDiffEditorOriginalUri) i = (0, ji.W7)(e.multiDiffEditorOriginalUri.fsPath, t.multiDiffEditorOriginalUri.fsPath, !0);
                else {
                    if (e.multiDiffEditorOriginalUri) return 1;
                    if (t.multiDiffEditorOriginalUri) return -1
                }
                return i
            }

            function es(e, t) {
                return e.command === t.command && e.title === t.title && e.tooltip === t.tooltip && (e.arguments && t.arguments ? function(e, t) {
                    for (let i = 0; i < e.length; i++)
                        if (e[i] !== t[i]) return !1;
                    return !0
                }(e.arguments, t.arguments) : e.arguments === t.arguments)
            }
            class ts {#
                e;#
                E;
                get value() {
                    return this._value
                }
                set value(e) {
                    e = e ? ? "", this.#e.$setInputBoxValue(this._sourceControlHandle, e), this.updateValue(e)
                }
                get onDidChange() {
                    return this._onDidChange.event
                }
                get placeholder() {
                    return this._placeholder
                }
                set placeholder(e) {
                    this.#e.$setInputBoxPlaceholder(this._sourceControlHandle, e), this._placeholder = e
                }
                get validateInput() {
                    return (0, q.H5)(this._extension, "scmValidation"), this._validateInput
                }
                set validateInput(e) {
                    if ((0, q.H5)(this._extension, "scmValidation"), e && "function" != typeof e) throw new Error(`[${this._extension.identifier.value}]: Invalid SCM input box validation function`);
                    this._validateInput = e, this.#e.$setValidationProviderIsEnabled(this._sourceControlHandle, !!e)
                }
                get enabled() {
                    return this._enabled
                }
                set enabled(e) {
                    e = !!e, this._enabled !== e && (this._enabled = e, this.#e.$setInputBoxEnablement(this._sourceControlHandle, e))
                }
                get visible() {
                    return this._visible
                }
                set visible(e) {
                    e = !!e, this._visible !== e && (this._visible = e, this.#e.$setInputBoxVisibility(this._sourceControlHandle, e))
                }
                get document() {
                    return (0, q.H5)(this._extension, "scmTextDocument"), this.#E.getDocument(this._documentUri)
                }
                constructor(e, t, i, s, o) {
                    this._extension = e, this._sourceControlHandle = s, this._documentUri = o, this._value = "", this._onDidChange = new r.Q5, this._placeholder = "", this._enabled = !0, this._visible = !0, this.#E = t, this.#e = i
                }
                showValidationMessage(e, t) {
                    (0, q.H5)(this._extension, "scmValidation"), this.#e.$showValidationMessage(this._sourceControlHandle, e, t)
                }
                $onInputBoxValueChange(e) {
                    this.updateValue(e)
                }
                updateValue(e) {
                    this._value = e, this._onDidChange.fire(e)
                }
            }
            class is {
                static {
                    this._handlePool = 0
                }
                get disposed() {
                    return this._disposed
                }
                get id() {
                    return this._id
                }
                get label() {
                    return this._label
                }
                set label(e) {
                    this._label = e, this._proxy.$updateGroupLabel(this._sourceControlHandle, this.handle, e)
                }
                get hideWhenEmpty() {
                    return this._hideWhenEmpty
                }
                set hideWhenEmpty(e) {
                    this._hideWhenEmpty = e, this._proxy.$updateGroup(this._sourceControlHandle, this.handle, this.features)
                }
                get features() {
                    return {
                        hideWhenEmpty: this.hideWhenEmpty
                    }
                }
                get resourceStates() {
                    return [...this._resourceStates]
                }
                set resourceStates(e) {
                    this._resourceStates = [...e], this._onDidUpdateResourceStates.fire()
                }
                constructor(e, t, i, s, o, n, a) {
                    this._proxy = e, this._commands = t, this._sourceControlHandle = i, this._id = s, this._label = o, this.multiDiffEditorEnableViewChanges = n, this._extension = a, this._resourceHandlePool = 0, this._resourceStates = [], this._resourceStatesMap = new Map, this._resourceStatesCommandsMap = new Map, this._resourceStatesDisposablesMap = new Map, this._onDidUpdateResourceStates = new r.Q5, this.onDidUpdateResourceStates = this._onDidUpdateResourceStates.event, this._disposed = !1, this._onDidDispose = new r.Q5, this.onDidDispose = this._onDidDispose.event, this._handlesSnapshot = [], this._resourceSnapshot = [], this._hideWhenEmpty = void 0, this.handle = is._handlePool++
                }
                getResourceState(e) {
                    return this._resourceStatesMap.get(e)
                }
                $executeResourceCommand(e, t) {
                    const i = this._resourceStatesCommandsMap.get(e);
                    return i ? (0, U.OH)((() => this._commands.executeCommand(i.command, ...i.arguments || [], t))) : Promise.resolve(void 0)
                }
                _takeResourceStateSnapshot() {
                    const e = [...this._resourceStates].sort(Xi),
                        t = (0, C.XZ)(this._resourceSnapshot, e, Xi).map((e => {
                            const t = e.toInsert.map((e => {
                                const t = this._resourceHandlePool++;
                                this._resourceStatesMap.set(t, e);
                                const i = e.resourceUri;
                                let s;
                                if (e.command)
                                    if ("vscode.open" === e.command.command || "vscode.diff" === e.command.command || "vscode.changes" === e.command.command) {
                                        const i = new n.SL;
                                        s = this._commands.converter.toInternal(e.command, i), this._resourceStatesDisposablesMap.set(t, i)
                                    } else this._resourceStatesCommandsMap.set(t, e.command);
                                const o = (0, q.$x)(this._extension, "scmMultiDiffEditor"),
                                    r = o ? e.multiDiffEditorOriginalUri : void 0,
                                    a = o ? e.multiFileDiffEditorModifiedUri : void 0,
                                    c = Gi(e.decorations);
                                return {
                                    rawResource: [t, i, [e.decorations && Gi(e.decorations.light) || c, e.decorations && Gi(e.decorations.dark) || c], e.decorations && e.decorations.tooltip || "", e.decorations && !!e.decorations.strikeThrough, e.decorations && !!e.decorations.faded, e.contextValue || "", s, r, a],
                                    handle: t
                                }
                            }));
                            return {
                                start: e.start,
                                deleteCount: e.deleteCount,
                                toInsert: t
                            }
                        })),
                        i = t.map((({
                            start: e,
                            deleteCount: t,
                            toInsert: i
                        }) => [e, t, i.map((e => e.rawResource))])),
                        s = t.reverse();
                    for (const {
                            start: e,
                            deleteCount: t,
                            toInsert: i
                        } of s) {
                        const s = i.map((e => e.handle)),
                            o = this._handlesSnapshot.splice(e, t, ...s);
                        for (const e of o) this._resourceStatesMap.delete(e), this._resourceStatesCommandsMap.delete(e), this._resourceStatesDisposablesMap.get(e) ? .dispose(), this._resourceStatesDisposablesMap.delete(e)
                    }
                    return this._resourceSnapshot = e, i
                }
                dispose() {
                    this._disposed = !0, this._onDidDispose.fire()
                }
            }
            class ss {
                static {
                    this._handlePool = 0
                }#
                e;
                get id() {
                    return this._id
                }
                get label() {
                    return this._label
                }
                get rootUri() {
                    return this._rootUri
                }
                get inputBox() {
                    return this._inputBox
                }
                get count() {
                    return this._count
                }
                set count(e) {
                    this._count !== e && (this._count = e, this.#e.$updateSourceControl(this.handle, {
                        count: e
                    }))
                }
                get quickDiffProvider() {
                    return this._quickDiffProvider
                }
                set quickDiffProvider(e) {
                    let t;
                    this._quickDiffProvider = e, (0, q.$x)(this._extension, "quickDiffProvider") && (t = e ? .label), this.#e.$updateSourceControl(this.handle, {
                        hasQuickDiffProvider: !!e,
                        quickDiffLabel: t
                    })
                }
                get historyProvider() {
                    return (0, q.H5)(this._extension, "scmHistoryProvider"), this._historyProvider
                }
                set historyProvider(e) {
                    (0, q.H5)(this._extension, "scmHistoryProvider"), this._historyProvider = e, this._historyProviderDisposable.value = new n.SL, this.#e.$updateSourceControl(this.handle, {
                        hasHistoryProvider: !!e
                    }), e && this._historyProviderDisposable.value.add(e.onDidChangeCurrentHistoryItemGroup((() => {
                        this._historyProviderCurrentHistoryItemGroup = e ? .currentHistoryItemGroup, this.#e.$onDidChangeHistoryProviderCurrentHistoryItemGroup(this.handle, this._historyProviderCurrentHistoryItemGroup)
                    })))
                }
                get commitTemplate() {
                    return this._commitTemplate
                }
                set commitTemplate(e) {
                    e !== this._commitTemplate && (this._commitTemplate = e, this.#e.$updateSourceControl(this.handle, {
                        commitTemplate: e
                    }))
                }
                get acceptInputCommand() {
                    return this._acceptInputCommand
                }
                set acceptInputCommand(e) {
                    this._acceptInputDisposables.value = new n.SL, this._acceptInputCommand = e;
                    const t = this._commands.converter.toInternal(e, this._acceptInputDisposables.value);
                    this.#e.$updateSourceControl(this.handle, {
                        acceptInputCommand: t
                    })
                }
                get actionButton() {
                    return (0, q.H5)(this._extension, "scmActionButton"), this._actionButton
                }
                set actionButton(e) {
                    (0, q.H5)(this._extension, "scmActionButton"), this._actionButtonDisposables.value = new n.SL, this._actionButton = e;
                    const t = void 0 !== e ? {
                        command: this._commands.converter.toInternal(e.command, this._actionButtonDisposables.value),
                        secondaryCommands: e.secondaryCommands ? .map((e => e.map((e => this._commands.converter.toInternal(e, this._actionButtonDisposables.value))))),
                        description: e.description,
                        enabled: e.enabled
                    } : void 0;
                    this.#e.$updateSourceControl(this.handle, {
                        actionButton: t ? ? null
                    })
                }
                get statusBarCommands() {
                    return this._statusBarCommands
                }
                set statusBarCommands(e) {
                    if (this.logService.trace("ExtHostSourceControl#statusBarCommands", (e ? ? []).map((e => e.command)).join(", ")), this._statusBarCommands && e && (t = this._statusBarCommands, i = e, (0, C.fS)(t, i, es))) return void this.logService.trace("ExtHostSourceControl#statusBarCommands are equal");
                    var t, i;
                    this._statusBarDisposables.value = new n.SL, this._statusBarCommands = e;
                    const s = (e || []).map((e => this._commands.converter.toInternal(e, this._statusBarDisposables.value)));
                    this.#e.$updateSourceControl(this.handle, {
                        statusBarCommands: s
                    })
                }
                get selected() {
                    return this._selected
                }
                constructor(e, t, i, s, o, c, l, h) {
                    this._extension = e, this._commands = s, this.logService = o, this._id = c, this._label = l, this._rootUri = h, this._groups = new Map, this._count = void 0, this._quickDiffProvider = void 0, this._historyProviderDisposable = new n.XK, this._commitTemplate = void 0, this._acceptInputDisposables = new n.XK, this._acceptInputCommand = void 0, this._actionButtonDisposables = new n.XK, this._statusBarDisposables = new n.XK, this._statusBarCommands = void 0, this._selected = !1, this._onDidChangeSelection = new r.Q5, this.onDidChangeSelection = this._onDidChangeSelection.event, this.handle = ss._handlePool++, this.createdResourceGroups = new Map, this.updatedResourceGroups = new Set, this.#e = i;
                    const u = d.ov.from({
                        scheme: a.lg.vscodeSourceControl,
                        path: `${c}/scm${this.handle}/input`,
                        query: h ? `rootUri=${encodeURIComponent(h.toString())}` : void 0
                    });
                    this._inputBox = new ts(e, t, this.#e, this.handle, u), this.#e.$registerSourceControl(this.handle, c, l, h, u)
                }
                createResourceGroup(e, t, i) {
                    const s = (0, q.$x)(this._extension, "scmMultiDiffEditor") && !0 === i ? .multiDiffEditorEnableViewChanges,
                        o = new is(this.#e, this._commands, this.handle, e, t, s, this._extension),
                        n = r.ju.once(o.onDidDispose)((() => this.createdResourceGroups.delete(o)));
                    return this.createdResourceGroups.set(o, n), this.eventuallyAddResourceGroups(), o
                }
                eventuallyAddResourceGroups() {
                    const e = [],
                        t = [];
                    for (const [i, s] of this.createdResourceGroups) {
                        s.dispose();
                        const o = i.onDidUpdateResourceStates((() => {
                            this.updatedResourceGroups.add(i), this.eventuallyUpdateResourceStates()
                        }));
                        r.ju.once(i.onDidDispose)((() => {
                            this.updatedResourceGroups.delete(i), o.dispose(), this._groups.delete(i.handle), this.#e.$unregisterGroup(this.handle, i.handle)
                        })), e.push([i.handle, i.id, i.label, i.features, i.multiDiffEditorEnableViewChanges]);
                        const n = i._takeResourceStateSnapshot();
                        n.length > 0 && t.push([i.handle, n]), this._groups.set(i.handle, i)
                    }
                    this.#e.$registerGroups(this.handle, e, t), this.createdResourceGroups.clear()
                }
                eventuallyUpdateResourceStates() {
                    const e = [];
                    this.updatedResourceGroups.forEach((t => {
                        const i = t._takeResourceStateSnapshot();
                        0 !== i.length && e.push([t.handle, i])
                    })), e.length > 0 && this.#e.$spliceResourceStates(this.handle, e), this.updatedResourceGroups.clear()
                }
                getResourceGroup(e) {
                    return this._groups.get(e)
                }
                setSelectionState(e) {
                    this._selected = e, this._onDidChangeSelection.fire(e)
                }
                dispose() {
                    this._acceptInputDisposables.dispose(), this._actionButtonDisposables.dispose(), this._statusBarDisposables.dispose(), this._groups.forEach((e => e.dispose())), this.#e.$unregisterSourceControl(this.handle)
                }
            }
            ss.__decorator = (0, N.g)([(0, Oi.Ds)(100)], ss.prototype, "eventuallyAddResourceGroups", null), ss.__decorator = (0, N.g)([(0, Oi.Ds)(100)], ss.prototype, "eventuallyUpdateResourceStates", null);
            let os = class {
                static {
                    zi = this
                }
                static {
                    this._handlePool = 0
                }
                get onDidChangeActiveProvider() {
                    return this._onDidChangeActiveProvider.event
                }
                constructor(e, t, i, s) {
                    this._commands = t, this._extHostDocuments = i, this.logService = s, this._sourceControls = new Map, this._sourceControlsByExtension = new m.C1, this._onDidChangeActiveProvider = new r.Q5, this._proxy = e.getProxy(x.Tr.MainThreadSCM), this._telemetry = e.getProxy(x.Tr.MainThreadTelemetry), t.registerArgumentProcessor({
                        processArgument: e => {
                            if (e && e.$mid === ne.m.ScmResource) {
                                const t = this._sourceControls.get(e.sourceControlHandle);
                                if (!t) return e;
                                const i = t.getResourceGroup(e.groupHandle);
                                return i ? i.getResourceState(e.handle) : e
                            }
                            if (e && e.$mid === ne.m.ScmResourceGroup) {
                                const t = this._sourceControls.get(e.sourceControlHandle);
                                return t ? t.getResourceGroup(e.groupHandle) : e
                            }
                            if (e && e.$mid === ne.m.ScmProvider) {
                                return this._sourceControls.get(e.handle) || e
                            }
                            return e
                        }
                    })
                }
                createSourceControl(e, t, i, s) {
                    this.logService.trace("ExtHostSCM#createSourceControl", e.identifier.value, t, i, s), this._telemetry.$publicLog2("api/scm/createSourceControl", {
                        extensionId: e.identifier.value
                    });
                    const o = zi._handlePool++,
                        r = new ss(e, this._extHostDocuments, this._proxy, this._commands, this.logService, t, i, s);
                    this._sourceControls.set(o, r);
                    const n = this._sourceControlsByExtension.get(e.identifier) || [];
                    return n.push(r), this._sourceControlsByExtension.set(e.identifier, n), r
                }
                getLastInputBox(e) {
                    this.logService.trace("ExtHostSCM#getLastInputBox", e.identifier.value);
                    const t = this._sourceControlsByExtension.get(e.identifier),
                        i = t && t[t.length - 1];
                    return i && i.inputBox
                }
                $provideOriginalResource(e, t, i) {
                    const s = d.ov.revive(t);
                    this.logService.trace("ExtHostSCM#$provideOriginalResource", e, s.toString());
                    const o = this._sourceControls.get(e);
                    return o && o.quickDiffProvider && o.quickDiffProvider.provideOriginalResource ? (0, U.OH)((() => o.quickDiffProvider.provideOriginalResource(s, i))).then((e => e || null)) : Promise.resolve(null)
                }
                $onInputBoxValueChange(e, t) {
                    this.logService.trace("ExtHostSCM#$onInputBoxValueChange", e);
                    const i = this._sourceControls.get(e);
                    return i ? (i.inputBox.$onInputBoxValueChange(t), Promise.resolve(void 0)) : Promise.resolve(void 0)
                }
                $executeResourceCommand(e, t, i, s) {
                    this.logService.trace("ExtHostSCM#$executeResourceCommand", e, t, i);
                    const o = this._sourceControls.get(e);
                    if (!o) return Promise.resolve(void 0);
                    const r = o.getResourceGroup(t);
                    return r ? r.$executeResourceCommand(i, s) : Promise.resolve(void 0)
                }
                $validateInput(e, t, i) {
                    this.logService.trace("ExtHostSCM#$validateInput", e);
                    const s = this._sourceControls.get(e);
                    return s && s.inputBox.validateInput ? (0, U.OH)((() => s.inputBox.validateInput(t, i))).then((e => {
                        if (!e) return Promise.resolve(void 0);
                        const t = k.W5.fromStrict(e.message);
                        return t ? Promise.resolve([t, e.type]) : Promise.resolve(void 0)
                    })) : Promise.resolve(void 0)
                }
                $setSelectedSourceControl(e) {
                    return this.logService.trace("ExtHostSCM#$setSelectedSourceControl", e), void 0 !== e && this._sourceControls.get(e) ? .setSelectionState(!0), void 0 !== this._selectedSourceControlHandle && this._sourceControls.get(this._selectedSourceControlHandle) ? .setSelectionState(!1), this._selectedSourceControlHandle = e, Promise.resolve(void 0)
                }
                async $resolveHistoryItemGroupCommonAncestor(e, t, i, s) {
                    const o = this._sourceControls.get(e) ? .historyProvider;
                    return await (o ? .resolveHistoryItemGroupCommonAncestor(t, i, s)) ? ? void 0
                }
                async $provideHistoryItems(e, t, i, s) {
                    const o = this._sourceControls.get(e) ? .historyProvider,
                        r = await (o ? .provideHistoryItems(t, i, s));
                    return r ? .map((e => Zi(e))) ? ? void 0
                }
                async $provideHistoryItems2(e, t, i) {
                    const s = this._sourceControls.get(e) ? .historyProvider,
                        o = await (s ? .provideHistoryItems2(t, i));
                    return o ? .map((e => Zi(e))) ? ? void 0
                }
                async $provideHistoryItemSummary(e, t, i, s) {
                    const o = this._sourceControls.get(e) ? .historyProvider;
                    if ("function" != typeof o ? .provideHistoryItemSummary) return;
                    const r = await o.provideHistoryItemSummary(t, i, s);
                    return r ? Zi(r) : void 0
                }
                async $provideHistoryItemChanges(e, t, i, s) {
                    const o = this._sourceControls.get(e) ? .historyProvider;
                    return await (o ? .provideHistoryItemChanges(t, i, s)) ? ? void 0
                }
            };
            os = zi = (0, N.g)([(0, N.f)(3, _.V)], os);
            var rs = i("w14f"),
                ns = i("ZuU9");
            class as {
                static {
                    this.handlePool = 0
                }
                constructor(e, t) {
                    this.uriTransformer = t, this.providers = new Map, this.proxy = e.getProxy(x.Tr.MainThreadShare)
                }
                async $provideShare(e, t, i) {
                    const s = this.providers.get(e);
                    return await (s ? .provideShare({
                        selection: k.e6.to(t.selection),
                        resourceUri: d.ov.revive(t.resourceUri)
                    }, i)) ? ? void 0
                }
                registerShareProvider(e, t) {
                    const i = as.handlePool++;
                    return this.providers.set(i, t), this.proxy.$registerShareProvider(i, k.Lq.from(e, this.uriTransformer), t.id, t.label, t.priority), {
                        dispose: () => {
                            this.proxy.$unregisterShareProvider(i), this.providers.delete(i)
                        }
                    }
                }
            }
            class cs {
                static {
                    this.ID_POOL = 1
                }
                constructor(e) {
                    this.providers = new Map, this.sessions = new Map, this.synthesizers = new Map, this.proxy = e.getProxy(x.Tr.MainThreadSpeech)
                }
                async $createSpeechToTextSession(e, t, i) {
                    const o = this.providers.get(e);
                    if (!o) return;
                    const r = new n.SL,
                        a = new s.AU;
                    this.sessions.set(t, a);
                    const c = await o.provideSpeechToTextSession(a.token, i ? {
                        language: i
                    } : void 0);
                    c && (r.add(c.onDidChange((e => {
                        a.token.isCancellationRequested || this.proxy.$emitSpeechToTextEvent(t, e)
                    }))), r.add(a.token.onCancellationRequested((() => r.dispose()))))
                }
                async $cancelSpeechToTextSession(e) {
                    this.sessions.get(e) ? .dispose(!0), this.sessions.delete(e)
                }
                async $createTextToSpeechSession(e, t, i) {
                    const o = this.providers.get(e);
                    if (!o) return;
                    const r = new n.SL,
                        a = new s.AU;
                    this.sessions.set(t, a);
                    const c = await o.provideTextToSpeechSession(a.token, i ? {
                        language: i
                    } : void 0);
                    c && (this.synthesizers.set(t, c), r.add(c.onDidChange((e => {
                        a.token.isCancellationRequested || this.proxy.$emitTextToSpeechEvent(t, e)
                    }))), r.add(a.token.onCancellationRequested((() => r.dispose()))))
                }
                async $synthesizeSpeech(e, t) {
                    this.synthesizers.get(e) ? .synthesize(t)
                }
                async $cancelTextToSpeechSession(e) {
                    this.sessions.get(e) ? .dispose(!0), this.sessions.delete(e), this.synthesizers.delete(e)
                }
                async $createKeywordRecognitionSession(e, t) {
                    const i = this.providers.get(e);
                    if (!i) return;
                    const o = new n.SL,
                        r = new s.AU;
                    this.sessions.set(t, r);
                    const a = await i.provideKeywordRecognitionSession(r.token);
                    a && (o.add(a.onDidChange((e => {
                        r.token.isCancellationRequested || this.proxy.$emitKeywordRecognitionEvent(t, e)
                    }))), o.add(r.token.onCancellationRequested((() => o.dispose()))))
                }
                async $cancelKeywordRecognitionSession(e) {
                    this.sessions.get(e) ? .dispose(!0), this.sessions.delete(e)
                }
                registerProvider(e, t, i) {
                    const s = cs.ID_POOL++;
                    return this.providers.set(s, i), this.proxy.$registerProvider(s, t, {
                        extension: e,
                        displayName: e.value
                    }), (0, n.OF)((() => {
                        this.proxy.$unregisterProvider(s), this.providers.delete(s)
                    }))
                }
            }
            const ds = "vs/workbench/api/common/extHostStatusBar";
            class ls {
                static {
                    this.ID_GEN = 0
                }
                static {
                    this.ALLOWED_BACKGROUND_COLORS = new Map([
                        ["statusBarItem.errorBackground", new b.tPk("statusBarItem.errorForeground")],
                        ["statusBarItem.warningBackground", new b.tPk("statusBarItem.warningForeground")]
                    ])
                }#
                e;#
                P;
                constructor(e, t, i, s, o, r = b.MIn.Left, a) {
                    if (this._disposed = !1, this._text = "", this._staleCommandRegistrations = new n.SL, this.#e = e, this.#P = t, o && s) {
                        this._entryId = (0, b.yHy)(s.identifier, o);
                        const e = i.get(this._entryId);
                        e && (r = e.alignLeft ? b.MIn.Left : b.MIn.Right, a = e.priority, this._visible = !0, this.name = e.name, this.text = e.text, this.tooltip = e.tooltip, this.command = e.command, this.accessibilityInformation = e.accessibilityInformation)
                    } else this._entryId = String(ls.ID_GEN++);
                    this._extension = s, this._id = o, this._alignment = r, this._priority = this.validatePriority(a)
                }
                validatePriority(e) {
                    if ((0, z.hj)(e)) return e === Number.POSITIVE_INFINITY ? Number.MAX_VALUE : e === Number.NEGATIVE_INFINITY ? -Number.MAX_VALUE : e
                }
                get id() {
                    return this._id ? ? this._extension.identifier.value
                }
                get alignment() {
                    return this._alignment
                }
                get priority() {
                    return this._priority
                }
                get text() {
                    return this._text
                }
                get name() {
                    return this._name
                }
                get tooltip() {
                    return this._tooltip
                }
                get color() {
                    return this._color
                }
                get backgroundColor() {
                    return this._backgroundColor
                }
                get command() {
                    return this._command ? .fromApi
                }
                get accessibilityInformation() {
                    return this._accessibilityInformation
                }
                set text(e) {
                    this._text = e, this.update()
                }
                set name(e) {
                    this._name = e, this.update()
                }
                set tooltip(e) {
                    this._tooltip = e, this.update()
                }
                set color(e) {
                    this._color = e, this.update()
                }
                set backgroundColor(e) {
                    e && !ls.ALLOWED_BACKGROUND_COLORS.has(e.id) && (e = void 0), this._backgroundColor = e, this.update()
                }
                set command(e) {
                    this._command ? .fromApi !== e && (this._latestCommandRegistration && this._staleCommandRegistrations.add(this._latestCommandRegistration), this._latestCommandRegistration = new n.SL, this._command = "string" == typeof e ? {
                        fromApi: e,
                        internal: this.#P.toInternal({
                            title: "",
                            command: e
                        }, this._latestCommandRegistration)
                    } : e ? {
                        fromApi: e,
                        internal: this.#P.toInternal(e, this._latestCommandRegistration)
                    } : void 0, this.update())
                }
                set accessibilityInformation(e) {
                    this._accessibilityInformation = e, this.update()
                }
                show() {
                    this._visible = !0, this.update()
                }
                hide() {
                    clearTimeout(this._timeoutHandle), this._visible = !1, this.#e.$disposeEntry(this._entryId)
                }
                update() {
                    !this._disposed && this._visible && (clearTimeout(this._timeoutHandle), this._timeoutHandle = setTimeout((() => {
                        let e, t;
                        this._timeoutHandle = void 0, e = this._extension ? this._id ? `${this._extension.identifier.value}.${this._id}` : this._extension.identifier.value : this._id, t = this._name ? this._name : (0, Ie.C$)(ds, 0, "{0} (Extension)", this._extension.displayName || this._extension.name);
                        let i = this._color;
                        this._backgroundColor && (i = ls.ALLOWED_BACKGROUND_COLORS.get(this._backgroundColor.id));
                        const s = k.W5.fromStrict(this._tooltip);
                        this.#e.$setEntry(this._entryId, e, this._extension ? .identifier.value, t, this._text, s, this._command ? .internal, i, this._backgroundColor, this._alignment === b.MIn.Left, this._priority, this._accessibilityInformation), this._staleCommandRegistrations.clear()
                    }), 0))
                }
                dispose() {
                    this.hide(), this._disposed = !0
                }
            }
            class hs {
                constructor(e) {
                    this._messages = [], this._item = e.createStatusBarEntry(void 0, "status.extensionMessage", b.MIn.Left, Number.MIN_VALUE), this._item.name = (0, Ie.C$)(ds, 1, "Extension Status")
                }
                dispose() {
                    this._messages.length = 0, this._item.dispose()
                }
                setMessage(e) {
                    const t = {
                        message: e
                    };
                    return this._messages.unshift(t), this._update(), new b.JTr((() => {
                        const e = this._messages.indexOf(t);
                        e >= 0 && (this._messages.splice(e, 1), this._update())
                    }))
                }
                _update() {
                    this._messages.length > 0 ? (this._item.text = this._messages[0].message, this._item.show()) : this._item.hide()
                }
            }
            class us {
                constructor(e, t) {
                    this._existingItems = new Map, this._proxy = e.getProxy(x.Tr.MainThreadStatusBar), this._commands = t, this._statusMessage = new hs(this)
                }
                $acceptStaticEntries(e) {
                    for (const t of e) this._existingItems.set(t.entryId, t)
                }
                createStatusBarEntry(e, t, i, s) {
                    return new ls(this._proxy, this._commands, this._existingItems, e, t, i, s)
                }
                setStatusBarMessage(e, t) {
                    const i = this._statusMessage.setMessage(e);
                    let s;
                    return "number" == typeof t ? s = setTimeout((() => i.dispose()), t) : void 0 !== t && t.then((() => i.dispose()), (() => i.dispose())), new b.JTr((() => {
                        i.dispose(), clearTimeout(s)
                    }))
                }
            }
            var ps = i("GZWR"),
                ms = i("PZtK"),
                gs = i("JbH+"),
                vs = i("ofuf"),
                _s = i("DvZ5"),
                fs = i("ocTE"),
                ys = i("3BDB"),
                ws = i("4FWJ");
            class xs extends n.JT {
                constructor(e, t) {
                    super(), this._extHostDocumentsAndEditors = t, this._onDidChangeTextEditorSelection = new r.Q5, this._onDidChangeTextEditorOptions = new r.Q5, this._onDidChangeTextEditorVisibleRanges = new r.Q5, this._onDidChangeTextEditorViewColumn = new r.Q5, this._onDidChangeActiveTextEditor = new r.Q5, this._onDidChangeVisibleTextEditors = new r.Q5, this.onDidChangeTextEditorSelection = this._onDidChangeTextEditorSelection.event, this.onDidChangeTextEditorOptions = this._onDidChangeTextEditorOptions.event, this.onDidChangeTextEditorVisibleRanges = this._onDidChangeTextEditorVisibleRanges.event, this.onDidChangeTextEditorViewColumn = this._onDidChangeTextEditorViewColumn.event, this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event, this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event, this._proxy = e.getProxy(x.Tr.MainThreadTextEditors), this._register(this._extHostDocumentsAndEditors.onDidChangeVisibleTextEditors((e => this._onDidChangeVisibleTextEditors.fire(e)))), this._register(this._extHostDocumentsAndEditors.onDidChangeActiveTextEditor((e => this._onDidChangeActiveTextEditor.fire(e))))
                }
                getActiveTextEditor() {
                    return this._extHostDocumentsAndEditors.activeEditor()
                }
                getVisibleTextEditors(e) {
                    const t = this._extHostDocumentsAndEditors.allEditors();
                    return e ? t : t.map((e => e.value))
                }
                async showTextDocument(e, t, i) {
                    let s;
                    s = "number" == typeof t ? {
                        position: k.eI.from(t),
                        preserveFocus: i
                    } : "object" == typeof t ? {
                        position: k.eI.from(t.viewColumn),
                        preserveFocus: t.preserveFocus,
                        selection: "object" == typeof t.selection ? k.e6.from(t.selection) : void 0,
                        pinned: "boolean" == typeof t.preview ? !t.preview : void 0
                    } : {
                        preserveFocus: !1
                    };
                    const o = await this._proxy.$tryShowTextDocument(e.uri, s),
                        r = o && this._extHostDocumentsAndEditors.getEditor(o);
                    if (r) return r.value;
                    throw o ? new Error(`Could NOT open editor for "${e.uri.toString()}" because another editor opened in the meantime.`) : new Error(`Could NOT open editor for "${e.uri.toString()}".`)
                }
                createTextEditorDecorationType(e, t) {
                    return new ws.TE(this._proxy, e, t).value
                }
                $acceptEditorPropertiesChanged(e, t) {
                    const i = this._extHostDocumentsAndEditors.getEditor(e);
                    if (!i) throw new Error("unknown text editor");
                    if (t.options && i._acceptOptions(t.options), t.selections) {
                        const e = t.selections.selections.map(k.Y1.to);
                        i._acceptSelections(e)
                    }
                    if (t.visibleRanges) {
                        const e = (0, C.kX)(t.visibleRanges.map(k.e6.to));
                        i._acceptVisibleRanges(e)
                    }
                    if (t.options && this._onDidChangeTextEditorOptions.fire({
                            textEditor: i.value,
                            options: { ...t.options,
                                lineNumbers: k.lP.to(t.options.lineNumbers)
                            }
                        }), t.selections) {
                        const e = b.dWA.fromValue(t.selections.source),
                            s = t.selections.selections.map(k.Y1.to);
                        this._onDidChangeTextEditorSelection.fire({
                            textEditor: i.value,
                            selections: s,
                            kind: e
                        })
                    }
                    if (t.visibleRanges) {
                        const e = (0, C.kX)(t.visibleRanges.map(k.e6.to));
                        this._onDidChangeTextEditorVisibleRanges.fire({
                            textEditor: i.value,
                            visibleRanges: e
                        })
                    }
                }
                $acceptEditorPositionData(e) {
                    for (const t in e) {
                        const i = this._extHostDocumentsAndEditors.getEditor(t);
                        if (!i) throw new Error("Unknown text editor");
                        const s = k.eI.to(e[t]);
                        i.value.viewColumn !== s && (i._acceptViewColumn(s), this._onDidChangeTextEditorViewColumn.fire({
                            textEditor: i.value,
                            viewColumn: s
                        }))
                    }
                }
                getDiffInformation(e) {
                    return Promise.resolve(this._proxy.$getDiffInformation(e))
                }
            }
            let bs = class {
                constructor(e) {
                    this._actual = new b.UPf(b.bZY.Dark), this._onDidChangeActiveColorTheme = new r.Q5
                }
                get activeColorTheme() {
                    return this._actual
                }
                $onColorThemeChange(e) {
                    let t;
                    switch (e) {
                        case "light":
                            t = b.bZY.Light;
                            break;
                        case "hcDark":
                            t = b.bZY.HighContrast;
                            break;
                        case "hcLight":
                            t = b.bZY.HighContrastLight;
                            break;
                        default:
                            t = b.bZY.Dark
                    }
                    this._actual = new b.UPf(t), this._onDidChangeActiveColorTheme.fire(this._actual)
                }
                get onDidChangeActiveColorTheme() {
                    return this._onDidChangeActiveColorTheme.event
                }
            };
            bs = (0, N.g)([(0, N.f)(0, M.O)], bs);
            var Ds = i("OYZR"),
                Cs = i("ziTh");
            class Ss {
                constructor(e, t) {
                    this._providers = new Map, this._itemsBySourceAndUriMap = new Map, this._proxy = e.getProxy(x.Tr.MainThreadTimeline), t.registerArgumentProcessor({
                        processArgument: (e, t) => {
                            if (!e || e.$mid !== ne.m.TimelineActionContext) return e;
                            if (this._providers.get(e.source) && m.kP.equals(t, this._providers.get(e.source) ? .extension)) {
                                const t = void 0 === e.uri ? void 0 : d.ov.revive(e.uri);
                                return this._itemsBySourceAndUriMap.get(e.source) ? .get(Es(t)) ? .get(e.handle)
                            }
                        }
                    })
                }
                async $getTimeline(e, t, i, s) {
                    const o = this._providers.get(e);
                    return o ? .provider.provideTimeline(d.ov.revive(t), i, s)
                }
                registerTimelineProvider(e, t, i, s) {
                    const o = new n.SL,
                        r = this.convertTimelineItem(t.id, s, o).bind(this);
                    let a;
                    t.onDidChange && (a = t.onDidChange((e => this._proxy.$emitTimelineChangeEvent({
                        uri: void 0,
                        reset: !0,
                        ...e,
                        id: t.id
                    })), this));
                    const c = this._itemsBySourceAndUriMap;
                    return this.registerTimelineProviderCore({ ...t,
                        scheme: e,
                        onDidChange: void 0,
                        async provideTimeline(e, i, s) {
                            i ? .resetCache && (o.clear(), c.get(t.id) ? .clear());
                            const n = await t.provideTimeline(e, i, s);
                            if (null == n) return;
                            const a = r(e, i);
                            return { ...n,
                                source: t.id,
                                items: n.items.map(a)
                            }
                        },
                        dispose() {
                            for (const e of c.values()) e.get(t.id) ? .clear();
                            a ? .dispose(), o.dispose()
                        }
                    }, i)
                }
                convertTimelineItem(e, t, i) {
                    return (s, o) => {
                        let r;
                        if (o ? .cacheResults) {
                            let t = this._itemsBySourceAndUriMap.get(e);
                            void 0 === t && (t = new Map, this._itemsBySourceAndUriMap.set(e, t));
                            const i = Es(s);
                            r = t.get(i), void 0 === r && (r = new Map, t.set(i, r))
                        }
                        return s => {
                            const {
                                iconPath: o,
                                ...n
                            } = s, a = `${e}|${s.id??s.timestamp}`;
                            let c, l, h, u;
                            return r ? .set(a, s), s.iconPath && (o instanceof b.kS8 ? h = {
                                id: o.id,
                                color: o.color
                            } : d.ov.isUri(o) ? (c = o, l = o) : ({
                                light: c,
                                dark: l
                            } = o)), b.W5C.isMarkdownString(n.tooltip) ? u = k.W5.from(n.tooltip) : (0, z.HD)(n.tooltip) ? u = n.tooltip : b.W5C.isMarkdownString(n.detail) ? (Cs.warn("Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip"), u = k.W5.from(n.detail)) : (0, z.HD)(n.detail) && (Cs.warn("Using deprecated TimelineItem.detail, migrate to TimelineItem.tooltip"), u = n.detail), { ...n,
                                id: n.id ? ? void 0,
                                handle: a,
                                source: e,
                                command: s.command ? t.toInternal(s.command, i) : void 0,
                                icon: c,
                                iconDark: l,
                                themeIcon: h,
                                tooltip: u,
                                accessibilityInformation: s.accessibilityInformation
                            }
                        }
                    }
                }
                registerTimelineProviderCore(e, t) {
                    if (this._providers.get(e.id)) throw new Error(`Timeline Provider ${e.id} already exists.`);
                    return this._proxy.$registerTimelineProvider({
                        id: e.id,
                        label: e.label,
                        scheme: e.scheme
                    }), this._providers.set(e.id, {
                        provider: e,
                        extension: t
                    }), (0, n.OF)((() => {
                        for (const t of this._itemsBySourceAndUriMap.values()) t.get(e.id) ? .clear();
                        this._providers.delete(e.id), this._proxy.$unregisterTimelineProvider(e.id), e.dispose()
                    }))
                }
            }

            function Es(e) {
                return e ? .toString()
            }
            var Ps = i("1Fkz"),
                Ts = i("ZY6M");

            function ks(e, t) {
                if ((0, z.HD)(e)) return {
                    label: e
                };
                if (e && "object" == typeof e && "string" == typeof e.label) {
                    let t;
                    return Array.isArray(e.highlights) && (t = e.highlights.filter((e => 2 === e.length && "number" == typeof e[0] && "number" == typeof e[1])), t = t.length ? t : void 0), {
                        label: e.label,
                        highlights: t
                    }
                }
            }
            class Is extends n.JT {
                constructor(e, t, i) {
                    function s(e) {
                        return e && e.$treeViewId && (e.$treeItemHandle || e.$selectedTreeItems || e.$focusedTreeItem)
                    }
                    super(), this._proxy = e, this.commands = t, this.logService = i, this.treeViews = new Map, this.treeDragAndDropService = new Ts.Y, t.registerArgumentProcessor({
                        processArgument: e => s(e) ? this.convertArgument(e) : Array.isArray(e) && e.length > 0 ? e.map((e => s(e) ? this.convertArgument(e) : e)) : e
                    })
                }
                registerTreeDataProvider(e, t, i) {
                    const s = this.createTreeView(e, {
                        treeDataProvider: t
                    }, i);
                    return {
                        dispose: () => s.dispose()
                    }
                }
                createTreeView(e, t, i) {
                    if (!t || !t.treeDataProvider) throw new Error("Options with treeDataProvider is mandatory");
                    const s = t.dragAndDropController ? .dropMimeTypes ? ? [],
                        o = t.dragAndDropController ? .dragMimeTypes ? ? [],
                        r = !!t.dragAndDropController ? .handleDrag,
                        n = !!t.dragAndDropController ? .handleDrop,
                        a = this.createExtHostTreeView(e, t, i),
                        c = {
                            showCollapseAll: !!t.showCollapseAll,
                            canSelectMany: !!t.canSelectMany,
                            dropMimeTypes: s,
                            dragMimeTypes: o,
                            hasHandleDrag: r,
                            hasHandleDrop: n,
                            manuallyManageCheckboxes: !!t.manageCheckboxStateManually
                        },
                        d = this._proxy.$registerTreeViewDataProvider(e, c),
                        l = {
                            get onDidCollapseElement() {
                                return a.onDidCollapseElement
                            },
                            get onDidExpandElement() {
                                return a.onDidExpandElement
                            },
                            get selection() {
                                return a.selectedElements
                            },
                            get onDidChangeSelection() {
                                return a.onDidChangeSelection
                            },
                            get activeItem() {
                                return (0, q.H5)(i, "treeViewActiveItem"), a.focusedElement
                            },
                            get onDidChangeActiveItem() {
                                return (0, q.H5)(i, "treeViewActiveItem"), a.onDidChangeActiveItem
                            },
                            get visible() {
                                return a.visible
                            },
                            get onDidChangeVisibility() {
                                return a.onDidChangeVisibility
                            },
                            get onDidChangeCheckboxState() {
                                return a.onDidChangeCheckboxState
                            },
                            get message() {
                                return a.message
                            },
                            set message(e) {
                                (0, Qe.Fr)(e) && (0, q.H5)(i, "treeViewMarkdownMessage"), a.message = e
                            },
                            get title() {
                                return a.title
                            },
                            set title(e) {
                                a.title = e
                            },
                            get description() {
                                return a.description
                            },
                            set description(e) {
                                a.description = e
                            },
                            get badge() {
                                return a.badge
                            },
                            set badge(e) {
                                void 0 !== e && b.z0r.isViewBadge(e) ? a.badge = {
                                    value: Math.floor(Math.abs(e.value)),
                                    tooltip: e.tooltip
                                } : void 0 === e && (a.badge = void 0)
                            },
                            reveal: (e, t) => a.reveal(e, t),
                            dispose: async () => {
                                await d, this.treeViews.delete(e), a.dispose()
                            }
                        };
                    return this._register(l), l
                }
                $getChildren(e, t) {
                    const i = this.treeViews.get(e);
                    return i ? i.getChildren(t) : Promise.reject(new Ps.Ki(e))
                }
                async $handleDrop(e, t, i, s, o, r, n, a) {
                    const c = this.treeViews.get(e);
                    if (!c) return Promise.reject(new Ps.Ki(e));
                    const d = k.tn.toDataTransfer(i, (async i => (await this._proxy.$resolveDropFileData(e, t, i)).buffer));
                    return n === e && a && await this.addAdditionalTransferItems(d, c, a, o, r), c.onDrop(d, s, o)
                }
                async addAdditionalTransferItems(e, t, i, s, o) {
                    const r = this.treeDragAndDropService.removeDragOperationTransfer(o);
                    if (r)(await r) ? .forEach(((t, i) => {
                        t && e.set(i, t)
                    }));
                    else if (o && t.handleDrag) {
                        const r = t.handleDrag(i, e, s);
                        this.treeDragAndDropService.addDragOperationTransfer(o, r), await r
                    }
                    return e
                }
                async $handleDrag(e, t, i, s) {
                    const o = this.treeViews.get(e);
                    if (!o) return Promise.reject(new Ps.Ki(e));
                    const r = await this.addAdditionalTransferItems(new b.tnH, o, t, s, i);
                    return r && !s.isCancellationRequested ? k.tn.from(r) : void 0
                }
                async $hasResolve(e) {
                    const t = this.treeViews.get(e);
                    if (!t) throw new Ps.Ki(e);
                    return t.hasResolve
                }
                $resolve(e, t, i) {
                    const s = this.treeViews.get(e);
                    if (!s) throw new Ps.Ki(e);
                    return s.resolveTreeItem(t, i)
                }
                $setExpanded(e, t, i) {
                    const s = this.treeViews.get(e);
                    if (!s) throw new Ps.Ki(e);
                    s.setExpanded(t, i)
                }
                $setSelectionAndFocus(e, t, i) {
                    const s = this.treeViews.get(e);
                    if (!s) throw new Ps.Ki(e);
                    s.setSelectionAndFocus(t, i)
                }
                $setVisible(e, t) {
                    const i = this.treeViews.get(e);
                    if (!i) {
                        if (!t) return;
                        throw new Ps.Ki(e)
                    }
                    i.setVisible(t)
                }
                $changeCheckboxState(e, t) {
                    const i = this.treeViews.get(e);
                    if (!i) throw new Ps.Ki(e);
                    i.setCheckboxState(t)
                }
                createExtHostTreeView(e, t, i) {
                    const s = this._register(new As(e, t, this._proxy, this.commands.converter, this.logService, i));
                    return this.treeViews.set(e, s), s
                }
                convertArgument(e) {
                    const t = this.treeViews.get(e.$treeViewId);
                    return t && "$treeItemHandle" in e ? t.getExtensionElement(e.$treeItemHandle) : t && "$focusedTreeItem" in e && e.$focusedTreeItem ? t.focusedElement : null
                }
            }
            class As extends n.JT {
                static {
                    this.LABEL_HANDLE_PREFIX = "0"
                }
                static {
                    this.ID_HANDLE_PREFIX = "1"
                }
                get visible() {
                    return this._visible
                }
                get selectedElements() {
                    return this._selectedHandles.map((e => this.getExtensionElement(e))).filter((e => !(0, z.Jp)(e)))
                }
                get focusedElement() {
                    return this._focusedHandle ? this.getExtensionElement(this._focusedHandle) : void 0
                }
                constructor(e, t, i, o, n, a) {
                    if (super(), this.viewId = e, this.proxy = i, this.commands = o, this.logService = n, this.extension = a, this.roots = void 0, this.elements = new Map, this.nodes = new Map, this._visible = !1, this._selectedHandles = [], this._focusedHandle = void 0, this._onDidExpandElement = this._register(new r.Q5), this.onDidExpandElement = this._onDidExpandElement.event, this._onDidCollapseElement = this._register(new r.Q5), this.onDidCollapseElement = this._onDidCollapseElement.event, this._onDidChangeSelection = this._register(new r.Q5), this.onDidChangeSelection = this._onDidChangeSelection.event, this._onDidChangeActiveItem = this._register(new r.Q5), this.onDidChangeActiveItem = this._onDidChangeActiveItem.event, this._onDidChangeVisibility = this._register(new r.Q5), this.onDidChangeVisibility = this._onDidChangeVisibility.event, this._onDidChangeCheckboxState = this._register(new r.Q5), this.onDidChangeCheckboxState = this._onDidChangeCheckboxState.event, this._onDidChangeData = this._register(new r.Q5), this.refreshPromise = Promise.resolve(), this.refreshQueue = Promise.resolve(), this._message = "", this._title = "", this._refreshCancellationSource = new s.AU, a.contributes && a.contributes.views)
                        for (const t in a.contributes.views)
                            for (const i of a.contributes.views[t]) i.id === e && (this._title = i.name);
                    let c, d;
                    this.dataProvider = t.treeDataProvider, this.dndController = t.dragAndDropController, this.dataProvider.onDidChangeTreeData && this._register(this.dataProvider.onDidChangeTreeData((e => {
                        Array.isArray(e) && 0 === e.length || this._onDidChangeData.fire({
                            message: !1,
                            element: e
                        })
                    })));
                    const l = r.ju.debounce(this._onDidChangeData.event, ((e, t) => (e || (e = {
                        message: !1,
                        elements: []
                    }), !1 !== t.element && (c || (c = new Promise((e => d = e)), this.refreshPromise = this.refreshPromise.then((() => c))), Array.isArray(t.element) ? e.elements.push(...t.element) : e.elements.push(t.element)), t.message && (e.message = !0), e)), 200, !0);
                    this._register(l((({
                        message: e,
                        elements: t
                    }) => {
                        t.length && (this.refreshQueue = this.refreshQueue.then((() => {
                            const e = d;
                            return c = null, this.refresh(t).then((() => e()))
                        }))), e && this.proxy.$setMessage(this.viewId, k.W5.fromStrict(this._message) ? ? "")
                    })))
                }
                async getChildren(e) {
                    const t = e ? this.getExtensionElement(e) : void 0;
                    if (e && !t) return this.logService.error(`No tree item with id '${e}' found.`), Promise.resolve([]);
                    let i = this.getChildrenNodes(e);
                    return i || (i = await this.fetchChildrenNodes(t)), i ? i.map((e => e.item)) : void 0
                }
                getExtensionElement(e) {
                    return this.elements.get(e)
                }
                reveal(e, t) {
                    t = t || {
                        select: !0,
                        focus: !1
                    };
                    const i = !!(0, z.Jp)(t.select) || t.select,
                        s = !(0, z.Jp)(t.focus) && t.focus,
                        o = !(0, z.Jp)(t.expand) && t.expand;
                    return "function" != typeof this.dataProvider.getParent ? Promise.reject(new Error("Required registered TreeDataProvider to implement 'getParent' method to access 'reveal' method")) : e ? this.refreshPromise.then((() => this.resolveUnknownParentChain(e))).then((t => this.resolveTreeNode(e, t[t.length - 1]).then((e => this.proxy.$reveal(this.viewId, {
                        item: e.item,
                        parentChain: t.map((e => e.item))
                    }, {
                        select: i,
                        focus: s,
                        expand: o
                    })))), (e => this.logService.error(e))) : this.proxy.$reveal(this.viewId, void 0, {
                        select: i,
                        focus: s,
                        expand: o
                    })
                }
                get message() {
                    return this._message
                }
                set message(e) {
                    this._message = e, this._onDidChangeData.fire({
                        message: !0,
                        element: !1
                    })
                }
                get title() {
                    return this._title
                }
                set title(e) {
                    this._title = e, this.proxy.$setTitle(this.viewId, e, this._description)
                }
                get description() {
                    return this._description
                }
                set description(e) {
                    this._description = e, this.proxy.$setTitle(this.viewId, this._title, e)
                }
                get badge() {
                    return this._badge
                }
                set badge(e) {
                    this._badge ? .value === e ? .value && this._badge ? .tooltip === e ? .tooltip || (this._badge = k.z0.from(e), this.proxy.$setBadge(this.viewId, e))
                }
                setExpanded(e, t) {
                    const i = this.getExtensionElement(e);
                    i && (t ? this._onDidExpandElement.fire(Object.freeze({
                        element: i
                    })) : this._onDidCollapseElement.fire(Object.freeze({
                        element: i
                    })))
                }
                setSelectionAndFocus(e, t) {
                    const i = !(0, C.fS)(this._selectedHandles, e);
                    this._selectedHandles = e;
                    const s = this._focusedHandle !== t;
                    this._focusedHandle = t, i && this._onDidChangeSelection.fire(Object.freeze({
                        selection: this.selectedElements
                    })), s && this._onDidChangeActiveItem.fire(Object.freeze({
                        activeItem: this.focusedElement
                    }))
                }
                setVisible(e) {
                    e !== this._visible && (this._visible = e, this._onDidChangeVisibility.fire(Object.freeze({
                        visible: this._visible
                    })))
                }
                async setCheckboxState(e) {
                    const t = (await Promise.all(e.map((async e => {
                        const t = this.getExtensionElement(e.treeItemHandle);
                        return t ? {
                            extensionItem: t,
                            treeItem: await this.dataProvider.getTreeItem(t),
                            newState: e.newState ? b.KHd.Checked : b.KHd.Unchecked
                        } : Promise.resolve(void 0)
                    })))).filter((e => void 0 !== e));
                    t.forEach((e => {
                        e.treeItem.checkboxState = e.newState ? b.KHd.Checked : b.KHd.Unchecked
                    })), this._onDidChangeCheckboxState.fire({
                        items: t.map((e => [e.extensionItem, e.newState]))
                    })
                }
                async handleDrag(e, t, i) {
                    const s = [];
                    for (const t of e) {
                        const e = this.getExtensionElement(t);
                        e && s.push(e)
                    }
                    if (this.dndController ? .handleDrag && 0 !== s.length) return await this.dndController.handleDrag(s, t, i), t
                }
                get hasHandleDrag() {
                    return !!this.dndController ? .handleDrag
                }
                async onDrop(e, t, i) {
                    const s = t ? this.getExtensionElement(t) : void 0;
                    if ((s || !t) && this.dndController ? .handleDrop) return (0, U.OH)((() => this.dndController ? .handleDrop ? this.dndController.handleDrop(s, e, i) : void 0))
                }
                get hasResolve() {
                    return !!this.dataProvider.resolveTreeItem
                }
                async resolveTreeItem(e, t) {
                    if (!this.dataProvider.resolveTreeItem) return;
                    const i = this.elements.get(e);
                    if (i) {
                        const e = this.nodes.get(i);
                        if (e) {
                            const s = await this.dataProvider.resolveTreeItem(e.extensionItem, i, t) ? ? e.extensionItem;
                            return this.validateTreeItem(s), e.item.tooltip = this.getTooltip(s.tooltip), e.item.command = this.getCommand(e.disposableStore, s.command), e.item
                        }
                    }
                }
                resolveUnknownParentChain(e) {
                    return this.resolveParent(e).then((e => e ? this.resolveUnknownParentChain(e).then((t => this.resolveTreeNode(e, t[t.length - 1]).then((e => (t.push(e), t))))) : Promise.resolve([])))
                }
                resolveParent(e) {
                    const t = this.nodes.get(e);
                    return t ? Promise.resolve(t.parent ? this.elements.get(t.parent.item.handle) : void 0) : (0, U.OH)((() => this.dataProvider.getParent(e)))
                }
                resolveTreeNode(e, t) {
                    const i = this.nodes.get(e);
                    return i ? Promise.resolve(i) : (0, U.OH)((() => this.dataProvider.getTreeItem(e))).then((i => this.createHandle(e, i, t, !0))).then((e => this.getChildren(t ? t.item.handle : void 0).then((() => {
                        const t = this.getExtensionElement(e);
                        if (t) {
                            const e = this.nodes.get(t);
                            if (e) return Promise.resolve(e)
                        }
                        throw new Error(`Cannot resolve tree item for element ${e} from extension ${this.extension.identifier.value}`)
                    }))))
                }
                getChildrenNodes(e) {
                    if (e) {
                        let t;
                        if ("string" == typeof e) {
                            const i = this.getExtensionElement(e);
                            t = i ? this.nodes.get(i) : void 0
                        } else t = e;
                        return t && t.children || void 0
                    }
                    return this.roots
                }
                async fetchChildrenNodes(e) {
                    this.clearChildren(e);
                    const t = new s.AU(this._refreshCancellationSource.token);
                    try {
                        const i = e ? this.nodes.get(e) : void 0,
                            s = await this.dataProvider.getChildren(e);
                        if (t.token.isCancellationRequested) return;
                        const o = (0, C.kX)(s || []),
                            r = await Promise.all((0, C.kX)(o).map((e => this.dataProvider.getTreeItem(e))));
                        if (t.token.isCancellationRequested) return;
                        const n = r.map(((e, t) => e ? this.createAndRegisterTreeNode(o[t], e, i) : null));
                        return (0, C.kX)(n)
                    } finally {
                        t.dispose()
                    }
                }
                refresh(e) {
                    if (e.some((e => !e))) return this._refreshCancellationSource.dispose(!0), this._refreshCancellationSource = new s.AU, this.clearAll(), this.proxy.$refresh(this.viewId); {
                        const t = this.getHandlesToRefresh(e);
                        if (t.length) return this.refreshHandles(t)
                    }
                    return Promise.resolve(void 0)
                }
                getHandlesToRefresh(e) {
                    const t = new Set,
                        i = e.map((e => this.nodes.get(e)));
                    for (const e of i)
                        if (e && !t.has(e.item.handle)) {
                            let s = e;
                            for (; s && s.parent && -1 === i.findIndex((e => s && s.parent && e && e.item.handle === s.parent.item.handle));) {
                                const e = this.elements.get(s.parent.item.handle);
                                s = e ? this.nodes.get(e) : void 0
                            }
                            s && !s.parent && t.add(e.item.handle)
                        }
                    const s = [];
                    return t.forEach((e => {
                        const i = this.elements.get(e);
                        if (i) {
                            const o = this.nodes.get(i);
                            !o || o.parent && t.has(o.parent.item.handle) || s.push(e)
                        }
                    })), s
                }
                refreshHandles(e) {
                    const t = {};
                    return Promise.all(e.map((e => this.refreshNode(e).then((i => {
                        i && (t[e] = i.item)
                    }))))).then((() => Object.keys(t).length ? this.proxy.$refresh(this.viewId, t) : void 0))
                }
                refreshNode(e) {
                    const t = this.getExtensionElement(e);
                    if (t) {
                        const e = this.nodes.get(t);
                        if (e) return this.clearChildren(t), (0, U.OH)((() => this.dataProvider.getTreeItem(t))).then((i => {
                            if (i) {
                                const s = this.createTreeNode(t, i, e.parent);
                                return this.updateNodeCache(t, s, e, e.parent), e.dispose(), s
                            }
                            return null
                        }))
                    }
                    return Promise.resolve(null)
                }
                createAndRegisterTreeNode(e, t, i) {
                    const s = this.createTreeNode(e, t, i);
                    if (t.id && this.elements.has(s.item.handle)) throw new Error((0, Ie.C$)("vs/workbench/api/common/extHostTreeViews", 0, "Element with id {0} is already registered", t.id));
                    return this.addNodeToCache(e, s), this.addNodeToParentCache(s, i), s
                }
                getTooltip(e) {
                    return b.W5C.isMarkdownString(e) ? k.W5.from(e) : e
                }
                getCommand(e, t) {
                    return t ? { ...this.commands.toInternal(t, e),
                        originalId: t.command
                    } : void 0
                }
                getCheckbox(e) {
                    if (void 0 === e.checkboxState) return;
                    let t, i, s;
                    return "number" == typeof e.checkboxState ? t = e.checkboxState : (t = e.checkboxState.state, i = e.checkboxState.tooltip, s = e.checkboxState.accessibilityInformation), {
                        isChecked: t === b.KHd.Checked,
                        tooltip: i,
                        accessibilityInformation: s
                    }
                }
                validateTreeItem(e) {
                    if (!b.kfG.isTreeItem(e, this.extension)) throw new Error(`Extension ${this.extension.identifier.value} has provided an invalid tree item.`)
                }
                createTreeNode(e, t, i) {
                    this.validateTreeItem(t);
                    const s = this._register(new n.SL),
                        o = this.createHandle(e, t, i),
                        r = this.getLightIconPath(t);
                    return {
                        item: {
                            handle: o,
                            parentHandle: i ? i.item.handle : void 0,
                            label: ks(t.label),
                            description: t.description,
                            resourceUri: t.resourceUri,
                            tooltip: this.getTooltip(t.tooltip),
                            command: this.getCommand(s, t.command),
                            contextValue: t.contextValue,
                            icon: r,
                            iconDark: this.getDarkIconPath(t) || r,
                            themeIcon: this.getThemeIcon(t),
                            collapsibleState: (0, z.Jp)(t.collapsibleState) ? b.oCf.None : t.collapsibleState,
                            accessibilityInformation: t.accessibilityInformation,
                            checkbox: this.getCheckbox(t)
                        },
                        extensionItem: t,
                        parent: i,
                        children: void 0,
                        disposableStore: s,
                        dispose() {
                            s.dispose()
                        }
                    }
                }
                getThemeIcon(e) {
                    return e.iconPath instanceof b.kS8 ? e.iconPath : void 0
                }
                createHandle(e, {
                    id: t,
                    label: i,
                    resourceUri: s
                }, o, r) {
                    if (t) return `${As.ID_HANDLE_PREFIX}/${t}`;
                    const n = ks(i),
                        a = o ? o.item.handle : As.LABEL_HANDLE_PREFIX;
                    let c = n ? n.label : s ? (0, de.EZ)(s) : "";
                    c = -1 !== c.indexOf("/") ? c.replace("/", "//") : c;
                    const d = this.nodes.has(e) ? this.nodes.get(e).item.handle : void 0,
                        l = this.getChildrenNodes(o) || [];
                    let h, u = 0;
                    do {
                        if (h = `${a}/${u}:${c}`, r || !this.elements.has(h) || d === h) break;
                        u++
                    } while (u <= l.length);
                    return h
                }
                getLightIconPath(e) {
                    if (e.iconPath && !(e.iconPath instanceof b.kS8)) return "string" == typeof e.iconPath || d.ov.isUri(e.iconPath) ? this.getIconPath(e.iconPath) : this.getIconPath(e.iconPath.light)
                }
                getDarkIconPath(e) {
                    if (e.iconPath && !(e.iconPath instanceof b.kS8) && e.iconPath.dark) return this.getIconPath(e.iconPath.dark)
                }
                getIconPath(e) {
                    return d.ov.isUri(e) ? e : d.ov.file(e)
                }
                addNodeToCache(e, t) {
                    this.elements.set(t.item.handle, e), this.nodes.set(e, t)
                }
                updateNodeCache(e, t, i, s) {
                    this.elements.delete(t.item.handle), this.nodes.delete(e), t.item.handle !== i.item.handle && this.elements.delete(i.item.handle), this.addNodeToCache(e, t);
                    const o = this.getChildrenNodes(s) || [],
                        r = o.filter((e => e.item.handle === i.item.handle))[0];
                    r && o.splice(o.indexOf(r), 1, t)
                }
                addNodeToParentCache(e, t) {
                    t ? (t.children || (t.children = []), t.children.push(e)) : (this.roots || (this.roots = []), this.roots.push(e))
                }
                clearChildren(e) {
                    if (e) {
                        const t = this.nodes.get(e);
                        if (t) {
                            if (t.children)
                                for (const e of t.children) {
                                    const t = this.elements.get(e.item.handle);
                                    t && this.clear(t)
                                }
                            t.children = void 0
                        }
                    } else this.clearAll()
                }
                clear(e) {
                    const t = this.nodes.get(e);
                    if (t) {
                        if (t.children)
                            for (const e of t.children) {
                                const t = this.elements.get(e.item.handle);
                                t && this.clear(t)
                            }
                        this.nodes.delete(e), this.elements.delete(t.item.handle), t.dispose()
                    }
                }
                clearAll() {
                    this.roots = void 0, this.elements.clear(), this.nodes.forEach((e => e.dispose())), this.nodes.clear()
                }
                dispose() {
                    super.dispose(), this._refreshCancellationSource.dispose(), this.clearAll(), this.proxy.$disposeTree(this.viewId)
                }
            }
            var $s = i("bQf8");
            class Rs {
                static {
                    this.supportedSchemes = new Set([a.lg.http, a.lg.https])
                }
                constructor(e) {
                    this._openers = new Map, this._proxy = e.getProxy(x.Tr.MainThreadUriOpeners)
                }
                registerExternalUriOpener(e, t, i, s) {
                    if (this._openers.has(t)) throw new Error(`Opener with id '${t}' already registered`);
                    const o = s.schemes.find((e => !Rs.supportedSchemes.has(e)));
                    if (o) throw new Error(`Scheme '${o}' is not supported. Only http and https are currently supported.`);
                    return this._openers.set(t, i), this._proxy.$registerUriOpener(t, s.schemes, e, s.label), (0, n.OF)((() => {
                        this._openers.delete(t), this._proxy.$unregisterUriOpener(t)
                    }))
                }
                async $canOpenUri(e, t, i) {
                    const s = this._openers.get(e);
                    if (!s) throw new Error(`Unknown opener with id: ${e}`);
                    const o = d.ov.revive(t);
                    return s.canOpenExternalUri(o, i)
                }
                async $openUri(e, t, i) {
                    const s = this._openers.get(e);
                    if (!s) throw new Error(`Unknown opener id: '${e}'`);
                    return s.openExternalUri(d.ov.revive(t.resolvedUri), {
                        sourceUri: d.ov.revive(t.sourceUri)
                    }, i)
                }
            }
            var Hs = i("Rtpz");
            class Fs {
                static {
                    this.HandlePool = 0
                }
                constructor(e) {
                    this.handles = new m.o$, this.handlers = new Map, this._proxy = e.getProxy(x.Tr.MainThreadUrls)
                }
                registerUriHandler(e, t) {
                    const i = e.identifier;
                    if (this.handles.has(i)) throw new Error(`Protocol handler already registered for extension ${i}`);
                    const s = Fs.HandlePool++;
                    return this.handles.add(i), this.handlers.set(s, t), this._proxy.$registerUriHandler(s, i, e.displayName || e.name), (0, n.OF)((() => {
                        this.handles.delete(i), this.handlers.delete(s), this._proxy.$unregisterUriHandler(s)
                    }))
                }
                $handleExternalUri(e, t) {
                    const i = this.handlers.get(e);
                    if (!i) return Promise.resolve(void 0);
                    try {
                        i.handleUri(d.ov.revive(t))
                    } catch (e) {
                        (0, o.dL)(e)
                    }
                    return Promise.resolve(void 0)
                }
                async createAppUri(e) {
                    return d.ov.revive(await this._proxy.$createAppUri(e))
                }
            }
            var Ns = i("R7Dl");
            class Ms extends n.JT {#
                u;#
                e;#
                T;#
                k;#
                f;#
                I;#
                A;#
                $;#
                R;#
                H;#
                y;#
                F;#
                N;
                constructor(e, t, i, s) {
                    super(), this.#$ = void 0, this.#R = !0, this.#y = !1, this.#F = this._register(new r.Q5), this.onDidDispose = this.#F.event, this.#N = this._register(new r.Q5), this.onDidChangeViewState = this.#N.event, this.#u = e, this.#e = t, this.#k = i, this.#T = s.viewType, this.#f = s.panelOptions, this.#$ = s.viewColumn, this.#I = s.title, this.#H = s.active
                }
                dispose() {
                    this.#y || (this.#y = !0, this.#F.fire(), this.#e.$disposeWebview(this.#u), this.#k.dispose(), super.dispose())
                }
                get webview() {
                    return this.assertNotDisposed(), this.#k
                }
                get viewType() {
                    return this.assertNotDisposed(), this.#T
                }
                get title() {
                    return this.assertNotDisposed(), this.#I
                }
                set title(e) {
                    this.assertNotDisposed(), this.#I !== e && (this.#I = e, this.#e.$setTitle(this.#u, e))
                }
                get iconPath() {
                    return this.assertNotDisposed(), this.#A
                }
                set iconPath(e) {
                    this.assertNotDisposed(), this.#A !== e && (this.#A = e, this.#e.$setIconPath(this.#u, d.ov.isUri(e) ? {
                        light: e,
                        dark: e
                    } : e))
                }
                get options() {
                    return this.#f
                }
                get viewColumn() {
                    if (this.assertNotDisposed(), !("number" == typeof this.#$ && this.#$ < 0)) return this.#$
                }
                get active() {
                    return this.assertNotDisposed(), this.#H
                }
                get visible() {
                    return this.assertNotDisposed(), this.#R
                }
                _updateViewState(e) {
                    this.#y || this.active === e.active && this.visible === e.visible && this.viewColumn === e.viewColumn || (this.#H = e.active, this.#R = e.visible, this.#$ = e.viewColumn, this.#N.fire({
                        webviewPanel: this
                    }))
                }
                reveal(e, t) {
                    this.assertNotDisposed(), this.#e.$reveal(this.#u, {
                        viewColumn: void 0 === e ? void 0 : k.eI.from(e),
                        preserveFocus: !!t
                    })
                }
                assertNotDisposed() {
                    if (this.#y) throw new Error("Webview is disposed")
                }
            }
            class Ls extends n.JT {
                static newHandle() {
                    return (0, Ns.R)()
                }
                constructor(e, t, i) {
                    super(), this.webviews = t, this.workspace = i, this._webviewPanels = new Map, this._serializers = new Map, this._proxy = e.getProxy(x.Tr.MainThreadWebviewPanels)
                }
                dispose() {
                    super.dispose(), this._webviewPanels.forEach((e => e.dispose())), this._webviewPanels.clear()
                }
                createWebviewPanel(e, t, i, s, o = {}) {
                    const r = "object" == typeof s ? s.viewColumn : s,
                        n = {
                            viewColumn: k.eI.from(r),
                            preserveFocus: "object" == typeof s && !!s.preserveFocus
                        },
                        a = me(e),
                        c = Ls.newHandle();
                    this._proxy.$createWebviewPanel(ve(e), c, t, {
                        title: i,
                        panelOptions: Os(o),
                        webviewOptions: _e(e, this.workspace, o),
                        serializeBuffersForPostMessage: a
                    }, n);
                    const d = this.webviews.createNewWebview(c, o, e);
                    return this.createNewWebviewPanel(c, t, i, r, o, d, !0)
                }
                $onDidChangeWebviewPanelViewStates(e) {
                    const t = Object.keys(e);
                    t.sort(((t, i) => {
                        const s = e[t],
                            o = e[i];
                        return s.active ? 1 : o.active ? -1 : +s.visible - +o.visible
                    }));
                    for (const i of t) {
                        const t = this.getWebviewPanel(i);
                        if (!t) continue;
                        const s = e[i];
                        t._updateViewState({
                            active: s.active,
                            visible: s.visible,
                            viewColumn: k.eI.to(s.position)
                        })
                    }
                }
                async $onDidDisposeWebviewPanel(e) {
                    const t = this.getWebviewPanel(e);
                    t ? .dispose(), this._webviewPanels.delete(e), this.webviews.deleteWebview(e)
                }
                registerWebviewPanelSerializer(e, t, i) {
                    if (this._serializers.has(t)) throw new Error(`Serializer for '${t}' already registered`);
                    return this._serializers.set(t, {
                        serializer: i,
                        extension: e
                    }), this._proxy.$registerSerializer(t, {
                        serializeBuffersForPostMessage: me(e)
                    }), new b.JTr((() => {
                        this._serializers.delete(t), this._proxy.$unregisterSerializer(t)
                    }))
                }
                async $deserializeWebviewPanel(e, t, i, s) {
                    const o = this._serializers.get(t);
                    if (!o) throw new Error(`No serializer found for '${t}'`);
                    const {
                        serializer: r,
                        extension: n
                    } = o, a = this.webviews.createNewWebview(e, i.webviewOptions, n), c = this.createNewWebviewPanel(e, t, i.title, s, i.panelOptions, a, i.active);
                    await r.deserializeWebviewPanel(c, i.state)
                }
                createNewWebviewPanel(e, t, i, s, o, r, n) {
                    const a = new Ms(e, this._proxy, r, {
                        viewType: t,
                        title: i,
                        viewColumn: s,
                        panelOptions: o,
                        active: n
                    });
                    return this._webviewPanels.set(e, a), a
                }
                getWebviewPanel(e) {
                    return this._webviewPanels.get(e)
                }
            }

            function Os(e) {
                return {
                    enableFindWidget: e.enableFindWidget,
                    retainContextWhenHidden: e.retainContextWhenHidden
                }
            }
            class Us extends n.JT {#
                u;#
                e;#
                T;#
                k;#
                y;#
                M;#
                I;#
                L;#
                O;
                constructor(e, t, i, s, o, n) {
                    super(), this.#y = !1, this.#U = this._register(new r.Q5), this.onDidChangeVisibility = this.#U.event, this.#F = this._register(new r.Q5), this.onDidDispose = this.#F.event, this.#T = i, this.#I = s, this.#u = e, this.#e = t, this.#k = o, this.#M = n
                }
                dispose() {
                    this.#y || (this.#y = !0, this.#F.fire(), this.#k.dispose(), super.dispose())
                }#
                U;#
                F;
                get title() {
                    return this.assertNotDisposed(), this.#I
                }
                set title(e) {
                    this.assertNotDisposed(), this.#I !== e && (this.#I = e, this.#e.$setWebviewViewTitle(this.#u, e))
                }
                get description() {
                    return this.assertNotDisposed(), this.#L
                }
                set description(e) {
                    this.assertNotDisposed(), this.#L !== e && (this.#L = e, this.#e.$setWebviewViewDescription(this.#u, e))
                }
                get visible() {
                    return this.#M
                }
                get webview() {
                    return this.#k
                }
                get viewType() {
                    return this.#T
                }
                _setVisible(e) {
                    e === this.#M || this.#y || (this.#M = e, this.#U.fire())
                }
                get badge() {
                    return this.assertNotDisposed(), this.#O
                }
                set badge(e) {
                    this.assertNotDisposed(), e ? .value === this.#O ? .value && e ? .tooltip === this.#O ? .tooltip || (this.#O = k.z0.from(e), this.#e.$setWebviewViewBadge(this.#u, e))
                }
                show(e) {
                    this.assertNotDisposed(), this.#e.$show(this.#u, !!e)
                }
                assertNotDisposed() {
                    if (this.#y) throw new Error("Webview is disposed")
                }
            }
            class Vs {
                constructor(e, t) {
                    this._extHostWebview = t, this._viewProviders = new Map, this._webviewViews = new Map, this._proxy = e.getProxy(x.Tr.MainThreadWebviewViews)
                }
                registerWebviewViewProvider(e, t, i, s) {
                    if (this._viewProviders.has(t)) throw new Error(`View provider for '${t}' already registered`);
                    return this._viewProviders.set(t, {
                        provider: i,
                        extension: e
                    }), this._proxy.$registerWebviewViewProvider(ve(e), t, {
                        retainContextWhenHidden: s ? .retainContextWhenHidden,
                        serializeBuffersForPostMessage: me(e)
                    }), new b.JTr((() => {
                        this._viewProviders.delete(t), this._proxy.$unregisterWebviewViewProvider(t)
                    }))
                }
                async $resolveWebviewView(e, t, i, s, o) {
                    const r = this._viewProviders.get(t);
                    if (!r) throw new Error(`No view provider found for '${t}'`);
                    const {
                        provider: n,
                        extension: a
                    } = r, c = this._extHostWebview.createNewWebview(e, {}, a), d = new Us(e, this._proxy, t, i, c, !0);
                    this._webviewViews.set(e, d), await n.resolveWebviewView(d, {
                        state: s
                    }, o)
                }
                async $onDidChangeWebviewViewVisibility(e, t) {
                    this.getWebviewView(e)._setVisible(t)
                }
                async $disposeWebviewView(e) {
                    const t = this.getWebviewView(e);
                    this._webviewViews.delete(e), t.dispose(), this._extHostWebview.deleteWebview(e)
                }
                getWebviewView(e) {
                    const t = this._webviewViews.get(e);
                    if (!t) throw new Error("No webview found");
                    return t
                }
            }
            var Ws = i("GWyr"),
                Bs = i("n9io"),
                zs = i("xHkz"),
                js = i("MQtx"),
                qs = i("FwF7");

            function Ks(e) {
                const t = e.get(nt.$),
                    i = e.get(Re.G),
                    E = e.get(et.a),
                    P = e.get(Ke.k2),
                    I = e.get(Bs.w),
                    $ = e.get(vs.fv),
                    R = e.get(ae.E1),
                    N = e.get(Hs.F),
                    L = e.get(M.O),
                    V = e.get(ps.W),
                    W = e.get(ms.L),
                    B = e.get(_.y),
                    z = e.get(_.V),
                    j = e.get($s.rd),
                    K = e.get(H.J),
                    G = e.get(Ws.V),
                    Y = e.get(ns.Z),
                    ee = e.get(ze.v),
                    te = e.get(ai.W),
                    ie = e.get(F.E),
                    se = e.get(si.X);
                L.set(x.D.ExtHostFileSystemInfo, i), L.set(x.D.ExtHostLogLevelServiceShape, B), L.set(x.D.ExtHostWorkspace, I), L.set(x.D.ExtHostConfiguration, R), L.set(x.D.ExtHostExtensionService, P), L.set(x.D.ExtHostStorage, V), L.set(x.D.ExtHostTunnelService, j), L.set(x.D.ExtHostWindow, G), L.set(x.D.ExtHostSecretState, Y), L.set(x.D.ExtHostTelemetry, $), L.set(x.D.ExtHostEditorTabs, ee), L.set(x.D.ExtHostManagedSockets, te), L.set(x.D.ExtHostAuthentication, ie), L.set(x.D.ExtHostChatProvider, se);
                const oe = L.set(x.D.ExtHostDecorations, e.get(ke.W)),
                    ce = L.set(x.D.ExtHostDocumentsAndEditors, e.get(Be.T)),
                    de = L.set(x.D.ExtHostCommands, e.get(T.f7)),
                    le = L.set(x.D.ExtHostTerminalService, e.get(_s.$3)),
                    he = L.set(x.D.ExtHostTerminalShellIntegration, e.get(fs.P)),
                    ue = L.set(x.D.ExtHostDebugService, e.get(Te.gM)),
                    pe = L.set(x.D.ExtHostSearch, e.get(rs.FR)),
                    me = L.set(x.D.ExtHostTask, e.get(gs.h2)),
                    ve = L.set(x.D.ExtHostOutputService, e.get(Ni.U)),
                    _e = L.set(x.D.ExtHostLocalization, e.get(ni.O)),
                    fe = L.set(x.D.ExtHostUrls, new Fs(L)),
                    ye = L.set(x.D.ExtHostDocuments, new We(L, ce)),
                    we = L.set(x.D.ExtHostDocumentContentProviders, new Le(L, ce, z)),
                    xe = L.set(x.D.ExtHostDocumentSaveParticipant, new Ue(z, ye, L.getProxy(x.Tr.MainThreadBulkEdits))),
                    be = L.set(x.D.ExtHostNotebook, new bi(L, de, ce, ye, E, pe, z)),
                    De = L.set(x.D.ExtHostNotebookDocuments, new Ci(be)),
                    Ce = L.set(x.D.ExtHostNotebookEditors, new Si(z, be)),
                    Ee = L.set(x.D.ExtHostNotebookKernels, new Ti(L, t, be, de, z)),
                    Pe = L.set(x.D.ExtHostNotebookRenderers, new Fi(L, be)),
                    Ie = L.set(x.D.ExtHostNotebookDocumentSaveParticipant, new Di(z, be, L.getProxy(x.Tr.MainThreadBulkEdits))),
                    Ae = L.set(x.D.ExtHostEditors, new xs(L, ce)),
                    $e = L.set(x.D.ExtHostTreeViews, new Is(L.getProxy(x.Tr.MainThreadTreeViews), de, z)),
                    He = L.set(x.D.ExtHostEditorInsets, new re(L.getProxy(x.Tr.MainThreadEditorInsets), Ae, t.remote)),
                    Me = L.set(x.D.ExtHostDiagnostics, new Fe(L, z, i, ce)),
                    Oe = L.set(x.D.ExtHostLanguages, new ri(L, ye, de.converter, N)),
                    Ve = L.set(x.D.ExtHostLanguageFeatures, new ti(L, N, ye, de, Me, z, K, $)),
                    Je = L.set(x.D.ExtHostFileSystem, new Xe(L, Ve)),
                    Ge = L.set(x.D.ExtHostFileSystemEventService, new rt(L, z, ce)),
                    Qe = L.set(x.D.ExtHostQuickOpen, function(e, t, i) {
                        const a = e.getProxy(x.Tr.MainThreadQuickOpen);
                        class l {
                            static {
                                this._nextId = 1
                            }
                            constructor(e, t) {
                                this._extensionId = e, this._onDidDispose = t, this._id = u._nextId++, this._visible = !1, this._expectingHide = !1, this._enabled = !0, this._busy = !1, this._ignoreFocusOut = !0, this._value = "", this._buttons = [], this._handlesToButtons = new Map, this._onDidAcceptEmitter = new r.Q5, this._onDidChangeValueEmitter = new r.Q5, this._onDidTriggerButtonEmitter = new r.Q5, this._onDidHideEmitter = new r.Q5, this._pendingUpdate = {
                                    id: this._id
                                }, this._disposed = !1, this._disposables = [this._onDidTriggerButtonEmitter, this._onDidHideEmitter, this._onDidAcceptEmitter, this._onDidChangeValueEmitter], this.onDidChangeValue = this._onDidChangeValueEmitter.event, this.onDidAccept = this._onDidAcceptEmitter.event, this.onDidTriggerButton = this._onDidTriggerButtonEmitter.event, this.onDidHide = this._onDidHideEmitter.event
                            }
                            get title() {
                                return this._title
                            }
                            set title(e) {
                                this._title = e, this.update({
                                    title: e
                                })
                            }
                            get step() {
                                return this._steps
                            }
                            set step(e) {
                                this._steps = e, this.update({
                                    step: e
                                })
                            }
                            get totalSteps() {
                                return this._totalSteps
                            }
                            set totalSteps(e) {
                                this._totalSteps = e, this.update({
                                    totalSteps: e
                                })
                            }
                            get enabled() {
                                return this._enabled
                            }
                            set enabled(e) {
                                this._enabled = e, this.update({
                                    enabled: e
                                })
                            }
                            get busy() {
                                return this._busy
                            }
                            set busy(e) {
                                this._busy = e, this.update({
                                    busy: e
                                })
                            }
                            get ignoreFocusOut() {
                                return this._ignoreFocusOut
                            }
                            set ignoreFocusOut(e) {
                                this._ignoreFocusOut = e, this.update({
                                    ignoreFocusOut: e
                                })
                            }
                            get value() {
                                return this._value
                            }
                            set value(e) {
                                this._value = e, this.update({
                                    value: e
                                })
                            }
                            get placeholder() {
                                return this._placeholder
                            }
                            set placeholder(e) {
                                this._placeholder = e, this.update({
                                    placeholder: e
                                })
                            }
                            get buttons() {
                                return this._buttons
                            }
                            set buttons(e) {
                                this._buttons = e.slice(), this._handlesToButtons.clear(), e.forEach(((e, t) => {
                                    const i = e === b.ApZ.Back ? -1 : t;
                                    this._handlesToButtons.set(i, e)
                                })), this.update({
                                    buttons: e.map(((e, t) => ({ ...h(e.iconPath),
                                        tooltip: e.tooltip,
                                        handle: e === b.ApZ.Back ? -1 : t
                                    })))
                                })
                            }
                            show() {
                                this._visible = !0, this._expectingHide = !0, this.update({
                                    visible: !0
                                })
                            }
                            hide() {
                                this._visible = !1, this.update({
                                    visible: !1
                                })
                            }
                            _fireDidAccept() {
                                this._onDidAcceptEmitter.fire()
                            }
                            _fireDidChangeValue(e) {
                                this._value = e, this._onDidChangeValueEmitter.fire(e)
                            }
                            _fireDidTriggerButton(e) {
                                const t = this._handlesToButtons.get(e);
                                t && this._onDidTriggerButtonEmitter.fire(t)
                            }
                            _fireDidHide() {
                                this._expectingHide && (this._expectingHide = this._visible, this._onDidHideEmitter.fire())
                            }
                            dispose() {
                                this._disposed || (this._disposed = !0, this._fireDidHide(), this._disposables = (0, n.B9)(this._disposables), this._updateTimeout && (clearTimeout(this._updateTimeout), this._updateTimeout = void 0), this._onDidDispose(), a.$dispose(this._id))
                            }
                            update(e) {
                                if (!this._disposed) {
                                    for (const t of Object.keys(e)) {
                                        const i = e[t];
                                        this._pendingUpdate[t] = void 0 === i ? null : i
                                    }
                                    "visible" in this._pendingUpdate ? (this._updateTimeout && (clearTimeout(this._updateTimeout), this._updateTimeout = void 0), this.dispatchUpdate()) : this._visible && !this._updateTimeout && (this._updateTimeout = setTimeout((() => {
                                        this._updateTimeout = void 0, this.dispatchUpdate()
                                    }), 0))
                                }
                            }
                            dispatchUpdate() {
                                a.$createOrUpdate(this._pendingUpdate), this._pendingUpdate = {
                                    id: this._id
                                }
                            }
                        }

                        function h(e) {
                            const t = function(e) {
                                if (e instanceof b.kS8) return {
                                    id: e.id
                                };
                                const t = function(e) {
                                        return "object" == typeof e && "dark" in e ? e.dark : e
                                    }(e),
                                    i = function(e) {
                                        return "object" == typeof e && "light" in e ? e.light : e
                                    }(e);
                                return {
                                    dark: "string" == typeof t ? d.ov.file(t) : t,
                                    light: "string" == typeof i ? d.ov.file(i) : i
                                }
                            }(e);
                            let i, s;
                            return "id" in t ? s = Q.kS.asClassName(t) : i = t, {
                                iconPath: i,
                                iconClass: s
                            }
                        }
                        class u extends l {
                            constructor(e, t) {
                                super(e.identifier, t), this.extension = e, this._items = [], this._handlesToItems = new Map, this._itemsToHandles = new Map, this._canSelectMany = !1, this._matchOnDescription = !0, this._matchOnDetail = !0, this._sortByLabel = !0, this._keepScrollPosition = !1, this._activeItems = [], this._onDidChangeActiveEmitter = new r.Q5, this._selectedItems = [], this._onDidChangeSelectionEmitter = new r.Q5, this._onDidTriggerItemButtonEmitter = new r.Q5, this.onDidChangeActive = this._onDidChangeActiveEmitter.event, this.onDidChangeSelection = this._onDidChangeSelectionEmitter.event, this.onDidTriggerItemButton = this._onDidTriggerItemButtonEmitter.event, this._disposables.push(this._onDidChangeActiveEmitter, this._onDidChangeSelectionEmitter, this._onDidTriggerItemButtonEmitter), this.update({
                                    type: "quickPick"
                                })
                            }
                            get items() {
                                return this._items
                            }
                            set items(e) {
                                this._items = e.slice(), this._handlesToItems.clear(), this._itemsToHandles.clear(), e.forEach(((e, t) => {
                                    this._handlesToItems.set(t, e), this._itemsToHandles.set(e, t)
                                }));
                                const t = (0, q.$x)(this.extension, "quickPickItemTooltip"),
                                    i = [];
                                for (let s = 0; s < e.length; s++) {
                                    const o = e[s];
                                    if (o.kind === b.qlg.Separator) i.push({
                                        type: "separator",
                                        label: o.label
                                    });
                                    else {
                                        o.tooltip && !t && Bi.warn(`Extension '${this.extension.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${this.extension.identifier.value}`);
                                        const e = o.iconPath ? h(o.iconPath) : void 0;
                                        i.push({
                                            handle: s,
                                            label: o.label,
                                            iconPath: e ? .iconPath,
                                            iconClass: e ? .iconClass,
                                            description: o.description,
                                            detail: o.detail,
                                            picked: o.picked,
                                            alwaysShow: o.alwaysShow,
                                            tooltip: t ? k.W5.fromStrict(o.tooltip) : void 0,
                                            buttons: o.buttons ? .map(((e, t) => ({ ...h(e.iconPath),
                                                tooltip: e.tooltip,
                                                handle: t
                                            })))
                                        })
                                    }
                                }
                                this.update({
                                    items: i
                                })
                            }
                            get canSelectMany() {
                                return this._canSelectMany
                            }
                            set canSelectMany(e) {
                                this._canSelectMany = e, this.update({
                                    canSelectMany: e
                                })
                            }
                            get matchOnDescription() {
                                return this._matchOnDescription
                            }
                            set matchOnDescription(e) {
                                this._matchOnDescription = e, this.update({
                                    matchOnDescription: e
                                })
                            }
                            get matchOnDetail() {
                                return this._matchOnDetail
                            }
                            set matchOnDetail(e) {
                                this._matchOnDetail = e, this.update({
                                    matchOnDetail: e
                                })
                            }
                            get sortByLabel() {
                                return this._sortByLabel
                            }
                            set sortByLabel(e) {
                                this._sortByLabel = e, this.update({
                                    sortByLabel: e
                                })
                            }
                            get keepScrollPosition() {
                                return this._keepScrollPosition
                            }
                            set keepScrollPosition(e) {
                                this._keepScrollPosition = e, this.update({
                                    keepScrollPosition: e
                                })
                            }
                            get activeItems() {
                                return this._activeItems
                            }
                            set activeItems(e) {
                                this._activeItems = e.filter((e => this._itemsToHandles.has(e))), this.update({
                                    activeItems: this._activeItems.map((e => this._itemsToHandles.get(e)))
                                })
                            }
                            get selectedItems() {
                                return this._selectedItems
                            }
                            set selectedItems(e) {
                                this._selectedItems = e.filter((e => this._itemsToHandles.has(e))), this.update({
                                    selectedItems: this._selectedItems.map((e => this._itemsToHandles.get(e)))
                                })
                            }
                            _fireDidChangeActive(e) {
                                const t = (0, C.kX)(e.map((e => this._handlesToItems.get(e))));
                                this._activeItems = t, this._onDidChangeActiveEmitter.fire(t)
                            }
                            _fireDidChangeSelection(e) {
                                const t = (0, C.kX)(e.map((e => this._handlesToItems.get(e))));
                                this._selectedItems = t, this._onDidChangeSelectionEmitter.fire(t)
                            }
                            _fireDidTriggerItemButton(e, t) {
                                const i = this._handlesToItems.get(e);
                                if (!i || !i.buttons || !i.buttons.length) return;
                                const s = i.buttons[t];
                                s && this._onDidTriggerItemButtonEmitter.fire({
                                    button: s,
                                    item: i
                                })
                            }
                        }
                        class p extends l {
                            constructor(e, t) {
                                super(e.identifier, t), this._password = !1, this.update({
                                    type: "inputBox"
                                })
                            }
                            get password() {
                                return this._password
                            }
                            set password(e) {
                                this._password = e, this.update({
                                    password: e
                                })
                            }
                            get prompt() {
                                return this._prompt
                            }
                            set prompt(e) {
                                this._prompt = e, this.update({
                                    prompt: e
                                })
                            }
                            get valueSelection() {
                                return this._valueSelection
                            }
                            set valueSelection(e) {
                                this._valueSelection = e, this.update({
                                    valueSelection: e
                                })
                            }
                            get validationMessage() {
                                return this._validationMessage
                            }
                            set validationMessage(e) {
                                this._validationMessage = e, e ? "string" == typeof e ? this.update({
                                    validationMessage: e,
                                    severity: c.Z.Error
                                }) : this.update({
                                    validationMessage: e.message,
                                    severity: e.severity ? ? c.Z.Error
                                }) : this.update({
                                    validationMessage: void 0,
                                    severity: c.Z.Ignore
                                })
                            }
                        }
                        return new class {
                            constructor(e, t) {
                                this._sessions = new Map, this._instances = 0, this._workspace = e, this._commands = t
                            }
                            showQuickPick(e, t, i, r = s.Ts.None) {
                                this._onDidSelectItem = void 0;
                                const n = Promise.resolve(t),
                                    c = ++this._instances,
                                    d = a.$show(c, {
                                        title: i ? .title,
                                        placeHolder: i ? .placeHolder,
                                        matchOnDescription: i ? .matchOnDescription,
                                        matchOnDetail: i ? .matchOnDetail,
                                        ignoreFocusLost: i ? .ignoreFocusOut,
                                        canPickMany: i ? .canPickMany
                                    }, r),
                                    l = {},
                                    u = d.then((() => l));
                                return Promise.race([u, n]).then((t => {
                                    if (t === l) return;
                                    const s = (0, q.$x)(e, "quickPickItemTooltip");
                                    return n.then((t => {
                                        const o = [];
                                        for (let i = 0; i < t.length; i++) {
                                            const r = t[i];
                                            if ("string" == typeof r) o.push({
                                                label: r,
                                                handle: i
                                            });
                                            else if (r.kind === b.qlg.Separator) o.push({
                                                type: "separator",
                                                label: r.label
                                            });
                                            else {
                                                r.tooltip && !s && Bi.warn(`Extension '${e.identifier.value}' uses a tooltip which is proposed API that is only available when running out of dev or with the following command line switch: --enable-proposed-api ${e.identifier.value}`);
                                                const t = r.iconPath ? h(r.iconPath) : void 0;
                                                o.push({
                                                    label: r.label,
                                                    iconPath: t ? .iconPath,
                                                    iconClass: t ? .iconClass,
                                                    description: r.description,
                                                    detail: r.detail,
                                                    picked: r.picked,
                                                    alwaysShow: r.alwaysShow,
                                                    tooltip: s ? k.W5.fromStrict(r.tooltip) : void 0,
                                                    handle: i
                                                })
                                            }
                                        }
                                        return i && "function" == typeof i.onDidSelectItem && (this._onDidSelectItem = e => {
                                            i.onDidSelectItem(t[e])
                                        }), a.$setItems(c, o), d.then((e => "number" == typeof e ? t[e] : Array.isArray(e) ? e.map((e => t[e])) : void 0))
                                    }))
                                })).then(void 0, (e => {
                                    if (!(0, o.n2)(e)) return a.$setError(c, e), Promise.reject(e)
                                }))
                            }
                            $onItemSelected(e) {
                                this._onDidSelectItem ? .(e)
                            }
                            showInput(e, t = s.Ts.None) {
                                return this._validateInput = e ? .validateInput, a.$input(e, "function" == typeof this._validateInput, t).then(void 0, (e => {
                                    if (!(0, o.n2)(e)) return Promise.reject(e)
                                }))
                            }
                            async $validateInput(e) {
                                if (!this._validateInput) return;
                                const t = await this._validateInput(e);
                                if (!t || "string" == typeof t) return t;
                                let i;
                                switch (t.severity) {
                                    case b.S$x.Info:
                                        i = c.Z.Info;
                                        break;
                                    case b.S$x.Warning:
                                        i = c.Z.Warning;
                                        break;
                                    case b.S$x.Error:
                                        i = c.Z.Error;
                                        break;
                                    default:
                                        i = t.message ? c.Z.Error : c.Z.Ignore
                                }
                                return {
                                    content: t.message,
                                    severity: i
                                }
                            }
                            async showWorkspaceFolderPick(e, t = s.Ts.None) {
                                const i = await this._commands.executeCommand("_workbench.pickWorkspaceFolder", [e]);
                                if (!i) return;
                                const o = await this._workspace.getWorkspaceFolders2();
                                return o ? o.find((e => e.uri.toString() === i.uri.toString())) : void 0
                            }
                            createQuickPick(e) {
                                const t = new u(e, (() => this._sessions.delete(t._id)));
                                return this._sessions.set(t._id, t), t
                            }
                            createInputBox(e) {
                                const t = new p(e, (() => this._sessions.delete(t._id)));
                                return this._sessions.set(t._id, t), t
                            }
                            $onDidChangeValue(e, t) {
                                const i = this._sessions.get(e);
                                i ? ._fireDidChangeValue(t)
                            }
                            $onDidAccept(e) {
                                const t = this._sessions.get(e);
                                t ? ._fireDidAccept()
                            }
                            $onDidChangeActive(e, t) {
                                const i = this._sessions.get(e);
                                i instanceof u && i._fireDidChangeActive(t)
                            }
                            $onDidChangeSelection(e, t) {
                                const i = this._sessions.get(e);
                                i instanceof u && i._fireDidChangeSelection(t)
                            }
                            $onDidTriggerButton(e, t) {
                                const i = this._sessions.get(e);
                                i ? ._fireDidTriggerButton(t)
                            }
                            $onDidTriggerItemButton(e, t, i) {
                                const s = this._sessions.get(e);
                                s instanceof u && s._fireDidTriggerItemButton(t, i)
                            }
                            $onDidHide(e) {
                                const t = this._sessions.get(e);
                                t ? ._fireDidHide()
                            }
                        }(t, i)
                    }(L, I, de)),
                    Ze = L.set(x.D.ExtHostSCM, new os(L, de, ye, z)),
                    Ye = L.set(x.D.ExtHostQuickDiff, new Wi(L, N)),
                    tt = L.set(x.D.ExtHostShare, new as(L, N)),
                    it = L.set(x.D.ExtHostComments, function(e, t, i) {
                        const s = e.getProxy(x.Tr.MainThreadComments);
                        class o {
                            static {
                                this.handlePool = 0
                            }
                            constructor() {
                                this._commentControllers = new Map, this._commentControllersByExtension = new m.C1, t.registerArgumentProcessor({
                                    processArgument: e => {
                                        if (e && e.$mid === ne.m.CommentController) {
                                            const t = this._commentControllers.get(e.handle);
                                            return t ? t.value : e
                                        }
                                        if (e && e.$mid === ne.m.CommentThread) {
                                            const t = e,
                                                i = this._commentControllers.get(t.commentControlHandle);
                                            if (!i) return t;
                                            const s = i.getCommentThread(t.commentThreadHandle);
                                            return s ? s.value : t
                                        }
                                        if (e && (e.$mid === ne.m.CommentThreadReply || e.$mid === ne.m.CommentThreadInstance)) {
                                            const t = this._commentControllers.get(e.thread.commentControlHandle);
                                            if (!t) return e;
                                            const i = t.getCommentThread(e.thread.commentThreadHandle);
                                            return i ? e.$mid === ne.m.CommentThreadInstance ? i.value : {
                                                thread: i.value,
                                                text: e.text
                                            } : e
                                        }
                                        if (e && e.$mid === ne.m.CommentNode) {
                                            const t = this._commentControllers.get(e.thread.commentControlHandle);
                                            if (!t) return e;
                                            const i = t.getCommentThread(e.thread.commentThreadHandle);
                                            if (!i) return e;
                                            const s = e.commentUniqueId;
                                            return i.getCommentByUniqueId(s) || e
                                        }
                                        if (e && e.$mid === ne.m.CommentThreadNode) {
                                            const t = this._commentControllers.get(e.thread.commentControlHandle);
                                            if (!t) return e;
                                            const i = t.getCommentThread(e.thread.commentThreadHandle);
                                            if (!i) return e;
                                            const s = e.text,
                                                o = e.commentUniqueId,
                                                r = i.getCommentByUniqueId(o);
                                            return r ? ("string" == typeof r.body ? r.body = s : r.body = new b.W5C(s), r) : e
                                        }
                                        return e
                                    }
                                })
                            }
                            createCommentController(e, t, i) {
                                const s = o.handlePool++,
                                    r = new c(e, s, t, i);
                                this._commentControllers.set(r.handle, r);
                                const n = this._commentControllersByExtension.get(e.identifier) || [];
                                return n.push(r), this._commentControllersByExtension.set(e.identifier, n), r.value
                            }
                            async $createCommentThreadTemplate(e, t, i, s) {
                                const o = this._commentControllers.get(e);
                                o && o.$createCommentThreadTemplate(t, i, s)
                            }
                            async $setActiveComment(e, t) {
                                const i = this._commentControllers.get(e);
                                i && i.$setActiveComment(t ? ? void 0)
                            }
                            async $updateCommentThreadTemplate(e, t, i) {
                                const s = this._commentControllers.get(e);
                                s && s.$updateCommentThreadTemplate(t, i)
                            }
                            $deleteCommentThread(e, t) {
                                const i = this._commentControllers.get(e);
                                i ? .$deleteCommentThread(t)
                            }
                            async $provideCommentingRanges(e, t, s) {
                                const o = this._commentControllers.get(e);
                                if (!o || !o.commentingRangeProvider) return Promise.resolve(void 0);
                                const r = await i.ensureDocumentData(d.ov.revive(t));
                                return (0, U.OH)((async () => {
                                    const e = await o.commentingRangeProvider.provideCommentingRanges(r.document, s);
                                    let t;
                                    return t = Array.isArray(e) ? {
                                        ranges: e,
                                        fileComments: !1
                                    } : e ? {
                                        ranges: e.ranges || [],
                                        fileComments: e.enableFileComments || !1
                                    } : e ? ? void 0, t
                                })).then((e => {
                                    let t;
                                    return e && (t = {
                                        ranges: e.ranges.map((e => k.e6.from(e))),
                                        fileComments: e.fileComments
                                    }), t
                                }))
                            }
                            $toggleReaction(e, t, i, s, o) {
                                const r = this._commentControllers.get(e);
                                return r && r.reactionHandler ? (0, U.OH)((() => {
                                    const e = r.getCommentThread(t);
                                    if (e) {
                                        const t = e.getCommentByUniqueId(s.uniqueIdInThread);
                                        if (void 0 !== r && t && r.reactionHandler) return r.reactionHandler(t, function(e) {
                                            return {
                                                label: e.label || "",
                                                count: e.count || 0,
                                                iconPath: e.iconPath ? d.ov.revive(e.iconPath) : "",
                                                authorHasReacted: e.hasReacted || !1,
                                                reactors: e.reactors ? .map((e => ({
                                                    name: e
                                                })))
                                            }
                                        }(o))
                                    }
                                    return Promise.resolve(void 0)
                                })) : Promise.resolve(void 0)
                            }
                        }
                        class a {
                            static {
                                this._handlePool = 0
                            }
                            set threadId(e) {
                                this._id = e
                            }
                            get threadId() {
                                return this._id
                            }
                            get id() {
                                return this._id
                            }
                            get resource() {
                                return this._uri
                            }
                            get uri() {
                                return this._uri
                            }
                            set range(e) {
                                void 0 === e == (void 0 === this._range) && e && this._range && e.isEqual(this._range) || (this._range = e, this.modifications.range = e, this._onDidUpdateCommentThread.fire())
                            }
                            get range() {
                                return this._range
                            }
                            set canReply(e) {
                                this._canReply !== e && (this._canReply = e, this.modifications.canReply = e, this._onDidUpdateCommentThread.fire())
                            }
                            get canReply() {
                                return this._canReply
                            }
                            get label() {
                                return this._label
                            }
                            set label(e) {
                                this._label = e, this.modifications.label = e, this._onDidUpdateCommentThread.fire()
                            }
                            get contextValue() {
                                return this._contextValue
                            }
                            set contextValue(e) {
                                this._contextValue = e, this.modifications.contextValue = e, this._onDidUpdateCommentThread.fire()
                            }
                            get comments() {
                                return this._comments
                            }
                            set comments(e) {
                                this._comments = e, this.modifications.comments = e, this._onDidUpdateCommentThread.fire()
                            }
                            get collapsibleState() {
                                return this._collapseState
                            }
                            set collapsibleState(e) {
                                this._collapseState = e, this.modifications.collapsibleState = e, this._onDidUpdateCommentThread.fire()
                            }
                            get state() {
                                return this._state
                            }
                            set state(e) {
                                this._state = e, "object" == typeof e ? ((0, q.H5)(this.extensionDescription, "commentThreadApplicability"), this.modifications.state = e.resolved, this.modifications.applicability = e.applicability) : this.modifications.state = e, this._onDidUpdateCommentThread.fire()
                            }
                            get isDisposed() {
                                return this._isDiposed
                            }
                            constructor(e, t, i, o, c, d, h, u, p) {
                                this._commentControllerHandle = t, this._id = i, this._uri = o, this._range = c, this._comments = d, this.extensionDescription = h, this._isTemplate = u, this.handle = a._handlePool++, this.commentHandle = 0, this.modifications = Object.create(null), this._onDidUpdateCommentThread = new r.Q5, this.onDidUpdateCommentThread = this._onDidUpdateCommentThread.event, this._canReply = !0, this._commentsMap = new Map, this._acceptInputDisposables = new n.XK, this._acceptInputDisposables.value = new n.SL, void 0 === this._id && (this._id = `${e}.${this.handle}`), s.$createCommentThread(t, this.handle, this._id, this._uri, k.e6.from(this._range), this._comments.map((e => l(this, e, this._commentsMap, this.extensionDescription))), h.identifier, this._isTemplate, p), this._localDisposables = [], this._isDiposed = !1, this._localDisposables.push(this.onDidUpdateCommentThread((() => {
                                    this.eventuallyUpdateCommentThread()
                                }))), this._localDisposables.push({
                                    dispose: () => {
                                        s.$deleteCommentThread(t, this.handle)
                                    }
                                });
                                const m = this;
                                this.value = {
                                    get uri() {
                                        return m.uri
                                    },
                                    get range() {
                                        return m.range
                                    },
                                    set range(e) {
                                        m.range = e
                                    },
                                    get comments() {
                                        return m.comments
                                    },
                                    set comments(e) {
                                        m.comments = e
                                    },
                                    get collapsibleState() {
                                        return m.collapsibleState
                                    },
                                    set collapsibleState(e) {
                                        m.collapsibleState = e
                                    },
                                    get canReply() {
                                        return m.canReply
                                    },
                                    set canReply(e) {
                                        m.canReply = e
                                    },
                                    get contextValue() {
                                        return m.contextValue
                                    },
                                    set contextValue(e) {
                                        m.contextValue = e
                                    },
                                    get label() {
                                        return m.label
                                    },
                                    set label(e) {
                                        m.label = e
                                    },
                                    get state() {
                                        return m.state
                                    },
                                    set state(e) {
                                        m.state = e
                                    },
                                    reveal: e => m.reveal(e),
                                    dispose: () => {
                                        m.dispose()
                                    }
                                }
                            }
                            updateIsTemplate() {
                                this._isTemplate && (this._isTemplate = !1, this.modifications.isTemplate = !1)
                            }
                            eventuallyUpdateCommentThread() {
                                if (this._isDiposed) return;
                                this.updateIsTemplate(), this._acceptInputDisposables.value || (this._acceptInputDisposables.value = new n.SL);
                                const e = e => Object.prototype.hasOwnProperty.call(this.modifications, e),
                                    t = {};
                                e("range") && (t.range = k.e6.from(this._range)), e("label") && (t.label = this.label), e("contextValue") && (t.contextValue = this.contextValue ? ? null), e("comments") && (t.comments = this._comments.map((e => l(this, e, this._commentsMap, this.extensionDescription)))), e("collapsibleState") && (t.collapseState = function(e) {
                                    if (void 0 !== e) switch (e) {
                                        case b.xKz.Expanded:
                                            return S.xK.Expanded;
                                        case b.xKz.Collapsed:
                                            return S.xK.Collapsed
                                    }
                                    return S.xK.Collapsed
                                }(this._collapseState)), e("canReply") && (t.canReply = this.canReply), e("state") && (t.state = function(e) {
                                    let t;
                                    if (t = "object" == typeof e ? e.resolved : e, void 0 !== t) switch (t) {
                                        case b.OTk.Unresolved:
                                            return S.OT.Unresolved;
                                        case b.OTk.Resolved:
                                            return S.OT.Resolved
                                    }
                                    return S.OT.Unresolved
                                }(this._state)), e("applicability") && (t.applicability = function(e) {
                                    let t;
                                    if ("object" == typeof e && (t = e.applicability), void 0 !== t) switch (t) {
                                        case b.dql.Current:
                                            return S.dq.Current;
                                        case b.dql.Outdated:
                                            return S.dq.Outdated
                                    }
                                    return S.dq.Current
                                }(this._state)), e("isTemplate") && (t.isTemplate = this._isTemplate), this.modifications = {}, s.$updateCommentThread(this._commentControllerHandle, this.handle, this._id, this._uri, t)
                            }
                            getCommentByUniqueId(e) {
                                for (const t of this._commentsMap) {
                                    const i = t[0];
                                    if (e === t[1]) return i
                                }
                            }
                            async reveal(e) {
                                return (0, q.H5)(this.extensionDescription, "commentReveal"), s.$revealCommentThread(this._commentControllerHandle, this.handle, {
                                    preserveFocus: !1,
                                    focusReply: !1,
                                    ...e
                                })
                            }
                            dispose() {
                                this._isDiposed = !0, this._acceptInputDisposables.dispose(), this._localDisposables.forEach((e => e.dispose()))
                            }
                        }
                        class c {
                            get id() {
                                return this._id
                            }
                            get label() {
                                return this._label
                            }
                            get handle() {
                                return this._handle
                            }
                            get commentingRangeProvider() {
                                return this._commentingRangeProvider
                            }
                            set commentingRangeProvider(e) {
                                this._commentingRangeProvider = e, e ? .resourceHints && (0, q.H5)(this._extension, "commentingRangeHint"), s.$updateCommentingRanges(this.handle, e ? .resourceHints)
                            }
                            get reactionHandler() {
                                return this._reactionHandler
                            }
                            set reactionHandler(e) {
                                this._reactionHandler = e, s.$updateCommentControllerFeatures(this.handle, {
                                    reactionHandler: !!e
                                })
                            }
                            get options() {
                                return this._options
                            }
                            set options(e) {
                                this._options = e, s.$updateCommentControllerFeatures(this.handle, {
                                    options: this._options
                                })
                            }
                            get activeComment() {
                                return (0, q.H5)(this._extension, "activeComment"), this._activeComment
                            }
                            get activeCommentThread() {
                                return (0, q.H5)(this._extension, "activeComment"), this._activeThread
                            }
                            constructor(e, t, i, o) {
                                this._extension = e, this._handle = t, this._id = i, this._label = o, this._threads = new Map, s.$registerCommentController(this.handle, i, o, this._extension.identifier.value);
                                const r = this;
                                this.value = Object.freeze({
                                    id: r.id,
                                    label: r.label,
                                    get options() {
                                        return r.options
                                    },
                                    set options(e) {
                                        r.options = e
                                    },
                                    get commentingRangeProvider() {
                                        return r.commentingRangeProvider
                                    },
                                    set commentingRangeProvider(e) {
                                        r.commentingRangeProvider = e
                                    },
                                    get reactionHandler() {
                                        return r.reactionHandler
                                    },
                                    set reactionHandler(e) {
                                        r.reactionHandler = e
                                    },
                                    get activeCommentThread() {
                                        return r.activeCommentThread
                                    },
                                    createCommentThread: (e, t, i) => r.createCommentThread(e, t, i).value,
                                    dispose: () => {
                                        r.dispose()
                                    }
                                }), this._localDisposables = [], this._localDisposables.push({
                                    dispose: () => {
                                        s.$unregisterCommentController(this.handle)
                                    }
                                })
                            }
                            createCommentThread(e, t, i) {
                                void 0 === t && (0, q.H5)(this._extension, "fileComments");
                                const s = new a(this.id, this.handle, void 0, e, t, i, this._extension, !1);
                                return this._threads.set(s.handle, s), s
                            }
                            $setActiveComment(e) {
                                if (!e) return this._activeComment = void 0, void(this._activeThread = void 0);
                                const t = this._threads.get(e.commentThreadHandle);
                                t && (this._activeComment = e.uniqueIdInThread ? t.getCommentByUniqueId(e.uniqueIdInThread) : void 0, this._activeThread = t)
                            }
                            $createCommentThreadTemplate(e, t, i) {
                                const s = new a(this.id, this.handle, void 0, d.ov.revive(e), k.e6.to(t), [], this._extension, !0, i);
                                return s.collapsibleState = S.xK.Expanded, this._threads.set(s.handle, s), s
                            }
                            $updateCommentThreadTemplate(e, t) {
                                const i = this._threads.get(e);
                                i && (i.range = k.e6.to(t))
                            }
                            $deleteCommentThread(e) {
                                const t = this._threads.get(e);
                                t ? .dispose(), this._threads.delete(e)
                            }
                            getCommentThread(e) {
                                return this._threads.get(e)
                            }
                            dispose() {
                                this._threads.forEach((e => {
                                    e.dispose()
                                })), this._localDisposables.forEach((e => e.dispose()))
                            }
                        }

                        function l(e, t, i, s) {
                            let o = i.get(t);
                            return o || (o = ++e.commentHandle, i.set(t, o)), void 0 !== t.state && (0, q.H5)(s, "commentsDraftState"), t.reactions ? .some((e => void 0 !== e.reactors)) && (0, q.H5)(s, "commentReactor"), {
                                mode: t.mode,
                                contextValue: t.contextValue,
                                uniqueIdInThread: o,
                                body: "string" == typeof t.body ? t.body : k.W5.from(t.body),
                                userName: t.author.name,
                                userIconPath: t.author.iconPath,
                                label: t.label,
                                commentReactions: t.reactions ? t.reactions.map((e => function(e) {
                                    return {
                                        label: e.label,
                                        iconPath: e.iconPath ? (0, k.Ru)(e.iconPath) : void 0,
                                        count: e.count,
                                        hasReacted: e.authorHasReacted,
                                        reactors: e.reactors && e.reactors.length > 0 && "string" != typeof e.reactors[0] ? e.reactors.map((e => e.name)) : e.reactors
                                    }
                                }(e))) : void 0,
                                state: t.state,
                                timestamp: t.timestamp ? .toJSON()
                            }
                        }
                        return new o
                    }(L, de, ye)),
                    st = L.set(x.D.ExtHostProgress, new Ui(L.getProxy(x.Tr.MainThreadProgress))),
                    ot = L.set(x.D.ExtHostLabelService, new ct(L)),
                    dt = L.set(x.D.ExtHostTheming, new bs(L)),
                    lt = L.set(x.D.ExtHostTimeline, new Ss(L, de)),
                    ht = L.set(x.D.ExtHostWebviews, new ge(L, t.remote, I, z, K)),
                    ut = L.set(x.D.ExtHostWebviewPanels, new Ls(L, ht, I)),
                    pt = L.set(x.D.ExtHostCustomEditors, new Se(L, ye, W, ht, ut)),
                    mt = L.set(x.D.ExtHostWebviewViews, new Vs(L, ht)),
                    gt = L.set(x.D.ExtHostTesting, e.get(ys.s7)),
                    vt = L.set(x.D.ExtHostUriOpeners, new Rs(L)),
                    _t = L.set(x.D.ExtHostProfileContentHandlers, new Mi(L));
                L.set(x.D.ExtHostInteractive, new at(L, be, ce, de, z));
                const ft = L.set(x.D.ExtHostChatAgents2, new J(L, z, de)),
                    yt = L.set(x.D.ExtHostChatVariables, new Z(L)),
                    wt = L.set(x.D.ExtHostLanguageModelTools, new ii(L)),
                    xt = L.set(x.D.ExtHostAiRelatedInformation, new D(L)),
                    bt = L.set(x.D.ExtHostAiEmbeddingVector, new qe(L)),
                    Dt = L.set(x.D.ExtHostStatusBar, new us(L, de.converter)),
                    Ct = L.set(x.D.ExtHostSpeech, new cs(L)),
                    St = L.set(x.D.ExtHostEmbeddings, new je(L)),
                    Et = Object.values(x.D);
                L.assertRegistered(Et);
                const Pt = new O(L, ce),
                    Tt = new X(L),
                    kt = new ci(L, z),
                    It = new Ne(L);
                return A.register(de),
                    function(e, i, _) {
                        function D(t) {
                            return (i, s, r) => {
                                const n = t((t => {
                                    try {
                                        i.call(s, t)
                                    } catch (t) {
                                        (0, o.Cp)(new Error(`[ExtensionListenerError] Extension '${e.identifier.value}' FAILED to handle event: ${t.toString()}`, {
                                            cause: t
                                        })), $.onExtensionError(e.identifier, t)
                                    }
                                }));
                                return r ? .push(n), n
                            }
                        }
                        const C = function() {
                                let t = !e.isUnderDevelopment;

                                function i() {
                                    t || (z.info(`Extension '${e.identifier.value}' uses a document selector without scheme. Learn more about this: https://go.microsoft.com/fwlink/?linkid=872305`), t = !0)
                                }
                                return function t(s) {
                                    if (Array.isArray(s)) s.forEach(t);
                                    else if ("string" == typeof s) i();
                                    else {
                                        const t = s;
                                        void 0 === t.scheme && i(), "boolean" == typeof t.exclusive && (0, q.H5)(e, "documentFiltersExclusive")
                                    }
                                    return s
                                }
                            }(),
                            S = {
                                getSession: (t, i, s) => ("object" == typeof s ? .forceNewSession && s.forceNewSession.learnMore && (0, q.H5)(e, "authLearnMore"), s ? .account && (0, q.H5)(e, "authGetSessions"), ie.getSession(e, t, i, s)),
                                getAccounts: t => ((0, q.H5)(e, "authGetSessions"), ie.getAccounts(t)),
                                hasSession: async (t, i) => ((0, q.H5)(e, "authSession"), !!await ie.getSession(e, t, i, {
                                    silent: !0
                                })),
                                get onDidChangeSessions() {
                                    return D(ie.onDidChangeSessions)
                                },
                                registerAuthenticationProvider: (e, t, i, s) => ie.registerAuthenticationProvider(e, t, i, s)
                            },
                            T = {
                                registerCommand: (t, i, s) => de.registerCommand(!0, t, i, s, void 0, e),
                                registerTextEditorCommand: (t, i, s) => de.registerCommand(!0, t, ((...e) => {
                                    const o = Ae.getActiveTextEditor();
                                    if (o) return o.edit((t => {
                                        i.apply(s, [o, t, ...e])
                                    })).then((e => {
                                        e || z.warn("Edits from command " + t + " were not applied.")
                                    }), (e => {
                                        z.warn("An error occurred while running command " + t, e)
                                    }));
                                    z.warn("Cannot execute " + t + " because there is no active text editor.")
                                }), void 0, void 0, e),
                                registerDiffInformationCommand: (t, i, s) => ((0, q.H5)(e, "diffCommand"), de.registerCommand(!0, t, (async (...e) => {
                                    const o = ce.activeEditor(!0);
                                    if (!o) return void z.warn("Cannot execute " + t + " because there is no active text editor.");
                                    const r = await Ae.getDiffInformation(o.id);
                                    i.apply(s, [r, ...e])
                                }), void 0, void 0, e)),
                                executeCommand: (e, ...t) => de.executeCommand(e, ...t),
                                getCommands: (e = !1) => de.getCommands(e)
                            },
                            A = {
                                get machineId() {
                                    return t.telemetryInfo.machineId
                                },
                                get sessionId() {
                                    return t.telemetryInfo.sessionId
                                },
                                get language() {
                                    return t.environment.appLanguage
                                },
                                get appName() {
                                    return t.environment.appName
                                },
                                get appRoot() {
                                    return t.environment.appRoot ? .fsPath ? ? ""
                                },
                                get appHost() {
                                    return t.environment.appHost
                                },
                                get uriScheme() {
                                    return t.environment.appUriScheme
                                },
                                get clipboard() {
                                    return Tt.value
                                },
                                get shell() {
                                    return le.getDefaultShell(!1)
                                },
                                get onDidChangeShell() {
                                    return D(le.onDidChangeShell)
                                },
                                get isTelemetryEnabled() {
                                    return $.getTelemetryConfiguration()
                                },
                                get onDidChangeTelemetryEnabled() {
                                    return D($.onDidChangeTelemetryEnabled)
                                },
                                get telemetryConfiguration() {
                                    return (0, q.H5)(e, "telemetry"), $.getTelemetryDetails()
                                },
                                get onDidChangeTelemetryConfiguration() {
                                    return (0, q.H5)(e, "telemetry"), D($.onDidChangeTelemetryConfiguration)
                                },
                                get isNewAppInstall() {
                                    return (0, vs.oI)(t.telemetryInfo.firstSessionDate)
                                },
                                createTelemetryLogger: (t, i) => (vs.jQ.validateSender(t), $.instantiateLogger(e, t, i)),
                                openExternal: (e, i) => G.openUri(e, {
                                    allowTunneling: !!t.remote.authority,
                                    allowContributedOpeners: i ? .allowContributedOpeners
                                }),
                                async asExternalUri(e) {
                                    if (e.scheme === t.environment.appUriScheme) return fe.createAppUri(e);
                                    try {
                                        return await G.asExternalUri(e, {
                                            allowTunneling: !!t.remote.authority
                                        })
                                    } catch (t) {
                                        if ((0, a.xn)(e, a.lg.http) || (0, a.xn)(e, a.lg.https)) return e;
                                        throw t
                                    }
                                },
                                get remoteName() {
                                    return (0, f.WX)(t.remote.authority)
                                },
                                get remoteAuthority() {
                                    return (0, q.H5)(e, "resolvers"), t.remote.authority
                                },
                                get uiKind() {
                                    return t.uiKind
                                },
                                get logLevel() {
                                    return z.getLevel()
                                },
                                get onDidChangeLogLevel() {
                                    return D(z.onDidChangeLogLevel)
                                },
                                get appQuality() {
                                    return (0, q.H5)(e, "resolvers"), t.quality
                                },
                                get appCommit() {
                                    return (0, q.H5)(e, "resolvers"), t.commit
                                }
                            },
                            R = {
                                createTestController: (t, i, s) => gt.createTestController(e, t, i, s),
                                createTestObserver: () => ((0, q.H5)(e, "testObserver"), gt.createTestObserver()),
                                runTests: t => ((0, q.H5)(e, "testObserver"), gt.runTests(t)),
                                registerTestFollowupProvider: t => ((0, q.H5)(e, "testObserver"), gt.registerTestFollowupProvider(t)),
                                get onDidChangeTestResults() {
                                    return (0, q.H5)(e, "testObserver"), D(gt.onResultsChanged)
                                },
                                get testResults() {
                                    return (0, q.H5)(e, "testObserver"), gt.results
                                }
                            },
                            H = t.remote.isRemote ? b.TPH.Workspace : b.TPH.UI,
                            F = {
                                getExtension(t, s) {
                                    (0, q.$x)(e, "extensionsAny") || (s = !1);
                                    const o = i.mine.getExtensionDescription(t);
                                    if (o) return new Ke.hj(P, e.identifier, o, H, !1);
                                    if (s) {
                                        const s = i.all.getExtensionDescription(t);
                                        if (s) return new Ke.hj(P, e.identifier, s, H, !0)
                                    }
                                },
                                get all() {
                                    const t = [];
                                    for (const s of i.mine.getAllExtensionDescriptions()) t.push(new Ke.hj(P, e.identifier, s, H, !1));
                                    return t
                                },
                                get allAcrossExtensionHosts() {
                                    (0, q.H5)(e, "extensionsAny");
                                    const t = new m.o$(i.mine.getAllExtensionDescriptions().map((e => e.identifier))),
                                        s = [];
                                    for (const o of i.all.getAllExtensionDescriptions()) {
                                        const i = !t.has(o.identifier);
                                        s.push(new Ke.hj(P, e.identifier, o, H, i))
                                    }
                                    return s
                                },
                                get onDidChange() {
                                    return (0, q.$x)(e, "extensionsAny") ? D(r.ju.any(i.mine.onDidChange, i.all.onDidChange)) : D(i.mine.onDidChange)
                                }
                            },
                            N = {
                                createDiagnosticCollection: t => Me.createDiagnosticCollection(e.identifier, t),
                                get onDidChangeDiagnostics() {
                                    return D(Me.onDidChangeDiagnostics)
                                },
                                getDiagnostics: e => Me.getDiagnostics(e),
                                getLanguages: () => Oe.getLanguages(),
                                setTextDocumentLanguage: (e, t) => Oe.changeLanguage(e.uri, t),
                                match(e, t) {
                                    const i = k.$z.from(e);
                                    let s;
                                    return (0, h.J)(i) && (s = be.notebookDocuments.find((e => e.apiNotebook.getCells().find((e => e.document === t)))) ? .apiNotebook), (0, h.G)(i, t.uri, t.languageId, !0, s ? .uri, s ? .notebookType)
                                },
                                registerCodeActionsProvider: (t, i, s) => Ve.registerCodeActionProvider(e, C(t), i, s),
                                registerDocumentPasteEditProvider: (t, i, s) => ((0, q.H5)(e, "documentPaste"), Ve.registerDocumentPasteEditProvider(e, C(t), i, s)),
                                registerCodeLensProvider: (t, i) => Ve.registerCodeLensProvider(e, C(t), i),
                                registerDefinitionProvider: (t, i) => Ve.registerDefinitionProvider(e, C(t), i),
                                registerDeclarationProvider: (t, i) => Ve.registerDeclarationProvider(e, C(t), i),
                                registerImplementationProvider: (t, i) => Ve.registerImplementationProvider(e, C(t), i),
                                registerTypeDefinitionProvider: (t, i) => Ve.registerTypeDefinitionProvider(e, C(t), i),
                                registerHoverProvider: (t, i) => Ve.registerHoverProvider(e, C(t), i, e.identifier),
                                registerEvaluatableExpressionProvider: (t, i) => Ve.registerEvaluatableExpressionProvider(e, C(t), i, e.identifier),
                                registerInlineValuesProvider: (t, i) => Ve.registerInlineValuesProvider(e, C(t), i, e.identifier),
                                registerDocumentHighlightProvider: (t, i) => Ve.registerDocumentHighlightProvider(e, C(t), i),
                                registerMultiDocumentHighlightProvider: (t, i) => Ve.registerMultiDocumentHighlightProvider(e, C(t), i),
                                registerLinkedEditingRangeProvider: (t, i) => Ve.registerLinkedEditingRangeProvider(e, C(t), i),
                                registerReferenceProvider: (t, i) => Ve.registerReferenceProvider(e, C(t), i),
                                registerRenameProvider: (t, i) => Ve.registerRenameProvider(e, C(t), i),
                                registerNewSymbolNamesProvider: (t, i) => ((0, q.H5)(e, "newSymbolNamesProvider"), Ve.registerNewSymbolNamesProvider(e, C(t), i)),
                                registerDocumentSymbolProvider: (t, i, s) => Ve.registerDocumentSymbolProvider(e, C(t), i, s),
                                registerWorkspaceSymbolProvider: t => Ve.registerWorkspaceSymbolProvider(e, t),
                                registerDocumentFormattingEditProvider: (t, i) => Ve.registerDocumentFormattingEditProvider(e, C(t), i),
                                registerDocumentRangeFormattingEditProvider: (t, i) => Ve.registerDocumentRangeFormattingEditProvider(e, C(t), i),
                                registerOnTypeFormattingEditProvider: (t, i, s, ...o) => Ve.registerOnTypeFormattingEditProvider(e, C(t), i, [s].concat(o)),
                                registerDocumentSemanticTokensProvider: (t, i, s) => Ve.registerDocumentSemanticTokensProvider(e, C(t), i, s),
                                registerDocumentRangeSemanticTokensProvider: (t, i, s) => Ve.registerDocumentRangeSemanticTokensProvider(e, C(t), i, s),
                                registerSignatureHelpProvider: (t, i, s, ...o) => "object" == typeof s ? Ve.registerSignatureHelpProvider(e, C(t), i, s) : Ve.registerSignatureHelpProvider(e, C(t), i, void 0 === s ? [] : [s, ...o]),
                                registerCompletionItemProvider: (t, i, ...s) => Ve.registerCompletionItemProvider(e, C(t), i, s),
                                registerInlineCompletionItemProvider: (t, i, s) => (i.handleDidShowCompletionItem && (0, q.H5)(e, "inlineCompletionsAdditions"), i.handleDidPartiallyAcceptCompletionItem && (0, q.H5)(e, "inlineCompletionsAdditions"), s && (0, q.H5)(e, "inlineCompletionsAdditions"), Ve.registerInlineCompletionsProvider(e, C(t), i, s)),
                                registerInlineEditProvider: (t, i) => ((0, q.H5)(e, "inlineEdit"), Ve.registerInlineEditProvider(e, C(t), i)),
                                registerDocumentLinkProvider: (t, i) => Ve.registerDocumentLinkProvider(e, C(t), i),
                                registerColorProvider: (t, i) => Ve.registerColorProvider(e, C(t), i),
                                registerFoldingRangeProvider: (t, i) => Ve.registerFoldingRangeProvider(e, C(t), i),
                                registerSelectionRangeProvider: (t, i) => Ve.registerSelectionRangeProvider(e, t, i),
                                registerCallHierarchyProvider: (t, i) => Ve.registerCallHierarchyProvider(e, t, i),
                                registerTypeHierarchyProvider: (t, i) => Ve.registerTypeHierarchyProvider(e, t, i),
                                setLanguageConfiguration: (t, i) => Ve.setLanguageConfiguration(e, t, i),
                                getTokenInformationAtPosition: (t, i) => ((0, q.H5)(e, "tokenInformation"), Oe.tokenAtPosition(t, i)),
                                registerInlayHintsProvider: (t, i) => Ve.registerInlayHintsProvider(e, t, i),
                                createLanguageStatusItem: (t, i) => Oe.createLanguageStatusItem(e, t, i),
                                registerDocumentDropEditProvider: (t, i, s) => Ve.registerDocumentOnDropEditProvider(e, t, i, (0, q.$x)(e, "documentPaste") ? s : void 0)
                            },
                            M = {
                                get activeTextEditor() {
                                    return Ae.getActiveTextEditor()
                                },
                                get visibleTextEditors() {
                                    return Ae.getVisibleTextEditors()
                                },
                                get activeTerminal() {
                                    return le.activeTerminal
                                },
                                get terminals() {
                                    return le.terminals
                                },
                                async showTextDocument(t, i, s) {
                                    d.ov.isUri(t) && t.scheme === a.lg.vscodeRemote && !t.authority && K.report("workspace.showTextDocument", e, "A URI of 'vscode-remote' scheme requires an authority.");
                                    const o = await (d.ov.isUri(t) ? Promise.resolve(L.openTextDocument(t)) : Promise.resolve(t));
                                    return Ae.showTextDocument(o, i, s)
                                },
                                createTextEditorDecorationType: t => Ae.createTextEditorDecorationType(e, t),
                                onDidChangeActiveTextEditor: (e, t, i) => D(Ae.onDidChangeActiveTextEditor)(e, t, i),
                                onDidChangeVisibleTextEditors: (e, t, i) => D(Ae.onDidChangeVisibleTextEditors)(e, t, i),
                                onDidChangeTextEditorSelection: (e, t, i) => D(Ae.onDidChangeTextEditorSelection)(e, t, i),
                                onDidChangeTextEditorOptions: (e, t, i) => D(Ae.onDidChangeTextEditorOptions)(e, t, i),
                                onDidChangeTextEditorVisibleRanges: (e, t, i) => D(Ae.onDidChangeTextEditorVisibleRanges)(e, t, i),
                                onDidChangeTextEditorViewColumn: (e, t, i) => D(Ae.onDidChangeTextEditorViewColumn)(e, t, i),
                                onDidCloseTerminal: (e, t, i) => D(le.onDidCloseTerminal)(e, t, i),
                                onDidOpenTerminal: (e, t, i) => D(le.onDidOpenTerminal)(e, t, i),
                                onDidChangeActiveTerminal: (e, t, i) => D(le.onDidChangeActiveTerminal)(e, t, i),
                                onDidChangeTerminalDimensions: (t, i, s) => ((0, q.H5)(e, "terminalDimensions"), D(le.onDidChangeTerminalDimensions)(t, i, s)),
                                onDidChangeTerminalState: (e, t, i) => D(le.onDidChangeTerminalState)(e, t, i),
                                onDidWriteTerminalData: (t, i, s) => ((0, q.H5)(e, "terminalDataWriteEvent"), D(le.onDidWriteTerminalData)(t, i, s)),
                                onDidExecuteTerminalCommand: (t, i, s) => ((0, q.H5)(e, "terminalExecuteCommandEvent"), D(le.onDidExecuteTerminalCommand)(t, i, s)),
                                onDidChangeTerminalShellIntegration: (t, i, s) => ((0, q.H5)(e, "terminalShellIntegration"), D(he.onDidChangeTerminalShellIntegration)(t, i, s)),
                                onDidStartTerminalShellExecution: (t, i, s) => ((0, q.H5)(e, "terminalShellIntegration"), D(he.onDidStartTerminalShellExecution)(t, i, s)),
                                onDidEndTerminalShellExecution: (t, i, s) => ((0, q.H5)(e, "terminalShellIntegration"), D(he.onDidEndTerminalShellExecution)(t, i, s)),
                                get state() {
                                    return G.getState()
                                },
                                onDidChangeWindowState: (e, t, i) => D(G.onDidChangeWindowState)(e, t, i),
                                showInformationMessage: (t, ...i) => kt.showMessage(e, c.Z.Info, t, i[0], i.slice(1)),
                                showWarningMessage: (t, ...i) => kt.showMessage(e, c.Z.Warning, t, i[0], i.slice(1)),
                                showErrorMessage: (t, ...i) => kt.showMessage(e, c.Z.Error, t, i[0], i.slice(1)),
                                showQuickPick: (t, i, s) => Qe.showQuickPick(e, t, i, s),
                                showWorkspaceFolderPick: e => Qe.showWorkspaceFolderPick(e),
                                showInputBox: (e, t) => Qe.showInput(e, t),
                                showOpenDialog: t => It.showOpenDialog(e, t),
                                showSaveDialog: e => It.showSaveDialog(e),
                                createStatusBarItem(t, i, s) {
                                    let o, r, n;
                                    return "string" == typeof t ? (o = t, r = i, n = s) : (r = t, n = i), Dt.createStatusBarEntry(e, o, r, n)
                                },
                                setStatusBarMessage: (e, t) => Dt.setStatusBarMessage(e, t),
                                withScmProgress: t => (K.report("window.withScmProgress", e, "Use 'withProgress' instead."), st.withProgress(e, {
                                    location: b.uTI.SourceControl
                                }, ((e, i) => t({
                                    report(e) {}
                                })))),
                                withProgress: (t, i) => st.withProgress(e, t, i),
                                createOutputChannel: (t, i) => ve.createOutputChannel(t, i, e),
                                createWebviewPanel: (t, i, s, o) => ut.createWebviewPanel(e, t, i, s, o),
                                createWebviewTextEditorInset: (t, i, s, o) => ((0, q.H5)(e, "editorInsets"), He.createWebviewEditorInset(t, i, s, o, e)),
                                createTerminal: (e, t, i) => "object" == typeof e ? "pty" in e ? le.createExtensionTerminal(e) : le.createTerminalFromOptions(e) : le.createTerminal(e, t, i),
                                registerTerminalLinkProvider: e => le.registerLinkProvider(e),
                                registerTerminalProfileProvider: (t, i) => le.registerProfileProvider(e, t, i),
                                registerTerminalQuickFixProvider: (t, i) => ((0, q.H5)(e, "terminalQuickFixProvider"), le.registerTerminalQuickFixProvider(t, e.identifier.value, i)),
                                registerTreeDataProvider: (t, i) => $e.registerTreeDataProvider(t, i, e),
                                createTreeView: (t, i) => $e.createTreeView(t, i, e),
                                registerWebviewPanelSerializer: (t, i) => ut.registerWebviewPanelSerializer(e, t, i),
                                registerCustomEditorProvider: (t, i, s = {}) => pt.registerCustomEditorProvider(e, t, i, s),
                                registerFileDecorationProvider: t => oe.registerFileDecorationProvider(t, e),
                                registerUriHandler: t => fe.registerUriHandler(e, t),
                                createQuickPick: () => Qe.createQuickPick(e),
                                createInputBox: () => Qe.createInputBox(e),
                                get activeColorTheme() {
                                    return dt.activeColorTheme
                                },
                                onDidChangeActiveColorTheme: (e, t, i) => D(dt.onDidChangeActiveColorTheme)(e, t, i),
                                registerWebviewViewProvider: (t, i, s) => mt.registerWebviewViewProvider(e, t, i, s ? .webviewOptions),
                                get activeNotebookEditor() {
                                    return be.activeNotebookEditor
                                },
                                onDidChangeActiveNotebookEditor: (e, t, i) => D(be.onDidChangeActiveNotebookEditor)(e, t, i),
                                get visibleNotebookEditors() {
                                    return be.visibleNotebookEditors
                                },
                                get onDidChangeVisibleNotebookEditors() {
                                    return D(be.onDidChangeVisibleNotebookEditors)
                                },
                                onDidChangeNotebookEditorSelection: (e, t, i) => D(Ce.onDidChangeNotebookEditorSelection)(e, t, i),
                                onDidChangeNotebookEditorVisibleRanges: (e, t, i) => D(Ce.onDidChangeNotebookEditorVisibleRanges)(e, t, i),
                                showNotebookDocument: (e, t) => be.showNotebookDocument(e, t),
                                registerExternalUriOpener: (t, i, s) => ((0, q.H5)(e, "externalUriOpener"), vt.registerExternalUriOpener(e.identifier, t, i, s)),
                                registerProfileContentHandler: (t, i) => ((0, q.H5)(e, "profileContentHandlers"), _t.registerProfileContentHandler(e, t, i)),
                                registerQuickDiffProvider: (t, i, s, o) => ((0, q.H5)(e, "quickDiffProvider"), Ye.registerQuickDiffProvider(C(t), i, s, o)),
                                get tabGroups() {
                                    return ee.tabGroups
                                },
                                registerShareProvider: (t, i) => ((0, q.H5)(e, "shareProvider"), tt.registerShareProvider(C(t), i))
                            },
                            L = {
                                get rootPath() {
                                    return K.report("workspace.rootPath", e, "Please use 'workspace.workspaceFolders' instead. More details: https://aka.ms/vscode-eliminating-rootpath"), I.getPath()
                                },
                                set rootPath(e) {
                                    throw new o.Tu("rootPath")
                                },
                                getWorkspaceFolder: e => I.getWorkspaceFolder(e),
                                get workspaceFolders() {
                                    return I.getWorkspaceFolders()
                                },
                                get name() {
                                    return I.name
                                },
                                set name(e) {
                                    throw new o.Tu("name")
                                },
                                get workspaceFile() {
                                    return I.workspaceFile
                                },
                                set workspaceFile(e) {
                                    throw new o.Tu("workspaceFile")
                                },
                                updateWorkspaceFolders: (t, i, ...s) => I.updateWorkspaceFolders(e, t, i || 0, ...s),
                                onDidChangeWorkspaceFolders: function(e, t, i) {
                                    return D(I.onDidChangeWorkspace)(e, t, i)
                                },
                                asRelativePath: (e, t) => I.getRelativePath(e, t),
                                findFiles: (t, i, s, o) => I.findFiles(t, i, s, e.identifier, o),
                                findFiles2: (t, i, s) => ((0, q.H5)(e, "findFiles2"), I.findFiles2(t, i, e.identifier, s)),
                                findTextInFiles: (t, i, s, o) => {
                                    let r, n;
                                    return (0, q.H5)(e, "findTextInFiles"), "object" == typeof i ? (r = i, n = s) : (r = {}, n = i, o = s), I.findTextInFiles(t, r || {}, n, e.identifier, o)
                                },
                                save: e => I.save(e),
                                saveAs: e => I.saveAs(e),
                                saveAll: e => I.saveAll(e),
                                applyEdit: (t, i) => Pt.applyWorkspaceEdit(t, e, i),
                                createFileSystemWatcher: (t, i, s, o) => {
                                    let r;
                                    return "boolean" == typeof i ? r = {
                                        ignoreCreateEvents: Boolean(i),
                                        ignoreChangeEvents: Boolean(s),
                                        ignoreDeleteEvents: Boolean(o),
                                        correlate: !1
                                    } : i && ((0, q.H5)(e, "createFileSystemWatcher"), r = { ...i,
                                        correlate: !0
                                    }), Ge.createFileSystemWatcher(I, e, t, r)
                                },
                                get textDocuments() {
                                    return ye.getAllDocumentData().map((e => e.document))
                                },
                                set textDocuments(e) {
                                    throw new o.Tu("textDocuments")
                                },
                                openTextDocument(t) {
                                    let i;
                                    const s = t;
                                    if ("string" == typeof t) i = Promise.resolve(d.ov.file(t));
                                    else if (d.ov.isUri(t)) i = Promise.resolve(t);
                                    else {
                                        if (s && "object" != typeof s) throw new Error("illegal argument - uriOrFileNameOrOptions");
                                        i = ye.createDocumentData(s)
                                    }
                                    return i.then((t => (t.scheme !== a.lg.vscodeRemote || t.authority || K.report("workspace.openTextDocument", e, "A URI of 'vscode-remote' scheme requires an authority."), ye.ensureDocumentData(t).then((e => e.document)))))
                                },
                                onDidOpenTextDocument: (e, t, i) => D(ye.onDidAddDocument)(e, t, i),
                                onDidCloseTextDocument: (e, t, i) => D(ye.onDidRemoveDocument)(e, t, i),
                                onDidChangeTextDocument: (e, t, i) => D(ye.onDidChangeDocument)(e, t, i),
                                onDidSaveTextDocument: (e, t, i) => D(ye.onDidSaveDocument)(e, t, i),
                                onWillSaveTextDocument: (t, i, s) => D(xe.getOnWillSaveTextDocumentEvent(e))(t, i, s),
                                get notebookDocuments() {
                                    return be.notebookDocuments.map((e => e.apiNotebook))
                                },
                                async openNotebookDocument(e, t) {
                                    let i;
                                    if (d.ov.isUri(e)) i = e, await be.openNotebookDocument(e);
                                    else {
                                        if ("string" != typeof e) throw new Error("Invalid arguments");
                                        i = d.ov.revive(await be.createNotebookDocument({
                                            viewType: e,
                                            content: t
                                        }))
                                    }
                                    return be.getNotebookDocument(i).apiNotebook
                                },
                                onDidSaveNotebookDocument: (e, t, i) => D(De.onDidSaveNotebookDocument)(e, t, i),
                                onDidChangeNotebookDocument: (e, t, i) => D(De.onDidChangeNotebookDocument)(e, t, i),
                                onWillSaveNotebookDocument: (t, i, s) => D(Ie.getOnWillSaveNotebookDocumentEvent(e))(t, i, s),
                                get onDidOpenNotebookDocument() {
                                    return D(be.onDidOpenNotebookDocument)
                                },
                                get onDidCloseNotebookDocument() {
                                    return D(be.onDidCloseNotebookDocument)
                                },
                                registerNotebookSerializer: (t, i, s, o) => be.registerNotebookSerializer(e, t, i, s, (0, q.$x)(e, "notebookLiveShare") ? o : void 0),
                                onDidChangeConfiguration: (e, t, i) => D(_.onDidChangeConfiguration)(e, t, i),
                                getConfiguration(t, i) {
                                    return i = 1 === arguments.length ? void 0 : i, _.getConfiguration(t, i, e)
                                },
                                registerTextDocumentContentProvider: (e, t) => we.registerTextDocumentContentProvider(e, t),
                                registerTaskProvider: (t, i) => (K.report("window.registerTaskProvider", e, "Use the corresponding function on the 'tasks' namespace instead"), me.registerTaskProvider(e, t, i)),
                                registerFileSystemProvider: (t, i, s) => (0, n.F8)(Je.registerFileSystemProvider(e, t, i, s), E.addFileSystemProvider(t, i, s)),
                                get fs() {
                                    return E.value
                                },
                                registerFileSearchProvider: (t, i) => ((0, q.H5)(e, "fileSearchProvider"), pe.registerFileSearchProvider(t, i)),
                                registerTextSearchProvider: (t, i) => ((0, q.H5)(e, "textSearchProvider"), pe.registerTextSearchProvider(t, i)),
                                registerAITextSearchProvider: (t, i) => ((0, q.H5)(e, "aiTextSearchProvider"), (0, q.H5)(e, "textSearchProvider"), pe.registerAITextSearchProvider(t, i)),
                                registerRemoteAuthorityResolver: (t, i) => ((0, q.H5)(e, "resolvers"), P.registerRemoteAuthorityResolver(t, i)),
                                registerResourceLabelFormatter: t => ((0, q.H5)(e, "resolvers"), ot.$registerResourceLabelFormatter(t)),
                                getRemoteExecServer: t => ((0, q.H5)(e, "resolvers"), P.getRemoteExecServer(t)),
                                onDidCreateFiles: (e, t, i) => D(Ge.onDidCreateFile)(e, t, i),
                                onDidDeleteFiles: (e, t, i) => D(Ge.onDidDeleteFile)(e, t, i),
                                onDidRenameFiles: (e, t, i) => D(Ge.onDidRenameFile)(e, t, i),
                                onWillCreateFiles: (t, i, s) => D(Ge.getOnWillCreateFileEvent(e))(t, i, s),
                                onWillDeleteFiles: (t, i, s) => D(Ge.getOnWillDeleteFileEvent(e))(t, i, s),
                                onWillRenameFiles: (t, i, s) => D(Ge.getOnWillRenameFileEvent(e))(t, i, s),
                                openTunnel: t => ((0, q.H5)(e, "tunnels"), j.openTunnel(e, t).then((e => {
                                    if (!e) throw new Error("cannot open tunnel");
                                    return e
                                }))),
                                get tunnels() {
                                    return (0, q.H5)(e, "tunnels"), j.getTunnels()
                                },
                                onDidChangeTunnels: (t, i, s) => ((0, q.H5)(e, "tunnels"), D(j.onDidChangeTunnels)(t, i, s)),
                                registerPortAttributesProvider: (t, i) => ((0, q.H5)(e, "portsAttributes"), j.registerPortsAttributesProvider(t, i)),
                                registerTunnelProvider: (t, i) => ((0, q.H5)(e, "tunnelFactory"), j.registerTunnelProvider(t, i)),
                                registerTimelineProvider: (t, i) => ((0, q.H5)(e, "timeline"), lt.registerTimelineProvider(t, i, e.identifier, de.converter)),
                                get isTrusted() {
                                    return I.trusted
                                },
                                requestWorkspaceTrust: t => ((0, q.H5)(e, "workspaceTrust"), I.requestWorkspaceTrust(t)),
                                onDidGrantWorkspaceTrust: (e, t, i) => D(I.onDidGrantWorkspaceTrust)(e, t, i),
                                registerEditSessionIdentityProvider: (t, i) => ((0, q.H5)(e, "editSessionIdentityProvider"), I.registerEditSessionIdentityProvider(t, i)),
                                onWillCreateEditSessionIdentity: (t, i, s) => ((0, q.H5)(e, "editSessionIdentityProvider"), D(I.getOnWillCreateEditSessionIdentityEvent(e))(t, i, s)),
                                registerCanonicalUriProvider: (t, i) => ((0, q.H5)(e, "canonicalUriProvider"), I.registerCanonicalUriProvider(t, i)),
                                getCanonicalUri: (t, i, s) => ((0, q.H5)(e, "canonicalUriProvider"), I.provideCanonicalUri(t, i, s))
                            },
                            O = {
                                get inputBox() {
                                    return K.report("scm.inputBox", e, "Use 'SourceControl.inputBox' instead"), Ze.getLastInputBox(e)
                                },
                                createSourceControl: (t, i, s) => Ze.createSourceControl(e, t, i, s)
                            },
                            U = {
                                createCommentController: (t, i) => it.createCommentController(e, t, i)
                            },
                            V = {
                                get activeDebugSession() {
                                    return ue.activeDebugSession
                                },
                                get activeDebugConsole() {
                                    return ue.activeDebugConsole
                                },
                                get breakpoints() {
                                    return ue.breakpoints
                                },
                                get activeStackItem() {
                                    return ue.activeStackItem
                                },
                                registerDebugVisualizationProvider: (t, i) => ((0, q.H5)(e, "debugVisualization"), ue.registerDebugVisualizationProvider(e, t, i)),
                                registerDebugVisualizationTreeProvider: (t, i) => ((0, q.H5)(e, "debugVisualization"), ue.registerDebugVisualizationTree(e, t, i)),
                                onDidStartDebugSession: (e, t, i) => D(ue.onDidStartDebugSession)(e, t, i),
                                onDidTerminateDebugSession: (e, t, i) => D(ue.onDidTerminateDebugSession)(e, t, i),
                                onDidChangeActiveDebugSession: (e, t, i) => D(ue.onDidChangeActiveDebugSession)(e, t, i),
                                onDidReceiveDebugSessionCustomEvent: (e, t, i) => D(ue.onDidReceiveDebugSessionCustomEvent)(e, t, i),
                                onDidChangeBreakpoints: (e, t, i) => D(ue.onDidChangeBreakpoints)(e, t, i),
                                onDidChangeActiveStackItem: (e, t, i) => D(ue.onDidChangeActiveStackItem)(e, t, i),
                                registerDebugConfigurationProvider: (e, t, i) => ue.registerDebugConfigurationProvider(e, t, i || zs.j4.Initial),
                                registerDebugAdapterDescriptorFactory: (t, i) => ue.registerDebugAdapterDescriptorFactory(e, t, i),
                                registerDebugAdapterTrackerFactory: (e, t) => ue.registerDebugAdapterTrackerFactory(e, t),
                                startDebugging: (e, t, i) => !i || "object" == typeof i && "configuration" in i ? ue.startDebugging(e, t, {
                                    parentSession: i
                                }) : ue.startDebugging(e, t, i || {}),
                                stopDebugging: e => ue.stopDebugging(e),
                                addBreakpoints: e => ue.addBreakpoints(e),
                                removeBreakpoints: e => ue.removeBreakpoints(e),
                                asDebugSourceUri: (e, t) => ue.asDebugSourceUri(e, t)
                            },
                            W = {
                                registerTaskProvider: (t, i) => me.registerTaskProvider(e, t, i),
                                fetchTasks: e => me.fetchTasks(e),
                                executeTask: t => me.executeTask(e, t),
                                get taskExecutions() {
                                    return me.taskExecutions
                                },
                                onDidStartTask: (e, t, i) => D(me.onDidStartTask)(e, t, i),
                                onDidEndTask: (e, t, i) => D(me.onDidEndTask)(e, t, i),
                                onDidStartTaskProcess: (e, t, i) => D(me.onDidStartTaskProcess)(e, t, i),
                                onDidEndTaskProcess: (e, t, i) => D(me.onDidEndTaskProcess)(e, t, i)
                            },
                            B = {
                                createNotebookController: (t, i, s, o, r) => Ee.createNotebookController(e, t, i, s, o, (0, q.$x)(e, "notebookMessaging") ? r : void 0),
                                registerNotebookCellStatusBarItemProvider: (t, i) => be.registerNotebookCellStatusBarItemProvider(e, t, i),
                                createRendererMessaging: t => Pe.createRendererMessaging(e, t),
                                createNotebookControllerDetectionTask: t => ((0, q.H5)(e, "notebookKernelSource"), Ee.createNotebookControllerDetectionTask(e, t)),
                                registerKernelSourceActionProvider: (t, i) => ((0, q.H5)(e, "notebookKernelSource"), Ee.registerKernelSourceActionProvider(e, t, i)),
                                onDidChangeNotebookCellExecutionState: (t, i, s) => ((0, q.H5)(e, "notebookCellExecutionState"), D(Ee.onDidChangeNotebookCellExecutionState)(t, i, s))
                            },
                            J = {
                                t(...t) {
                                    if ("string" == typeof t[0]) {
                                        const i = t.shift(),
                                            s = t && "object" == typeof t[0] ? t[0] : t;
                                        return _e.getMessage(e.identifier.value, {
                                            message: i,
                                            args: s
                                        })
                                    }
                                    return _e.getMessage(e.identifier.value, t[0])
                                },
                                get bundle() {
                                    return _e.getBundle(e.identifier.value)
                                },
                                get uri() {
                                    return _e.getBundleUri(e.identifier.value)
                                }
                            },
                            Q = {
                                _version: 1,
                                transferActiveChat: t => ((0, q.H5)(e, "interactive"), ft.transferActiveChat(t))
                            },
                            Z = {
                                getRelatedInformation: (t, i) => ((0, q.H5)(e, "aiRelatedInformation"), xt.getRelatedInformation(e, t, i)),
                                registerRelatedInformationProvider: (t, i) => ((0, q.H5)(e, "aiRelatedInformation"), xt.registerRelatedInformationProvider(e, t, i)),
                                registerEmbeddingVectorProvider: (t, i) => ((0, q.H5)(e, "aiRelatedInformation"), bt.registerEmbeddingVectorProvider(e, t, i))
                            },
                            Y = {
                                _version: 1,
                                registerChatResponseProvider: (t, i, s) => ((0, q.H5)(e, "chatProvider"), se.registerLanguageModel(e, t, i, s)),
                                registerChatVariableResolver: (t, i, s, o, r, n, a, c) => ((0, q.H5)(e, "chatVariableResolver"), yt.registerVariableResolver(e, t, i, s, o, r, n, a, c ? .id)),
                                registerMappedEditsProvider: (t, i) => ((0, q.H5)(e, "mappedEditsProvider"), Ve.registerMappedEditsProvider(e, t, i)),
                                createChatParticipant: (t, i) => ft.createChatAgent(e, t, i),
                                createDynamicChatParticipant: (t, i, s) => ((0, q.H5)(e, "chatParticipantPrivate"), ft.createDynamicChatAgent(e, t, i, s))
                            },
                            X = {
                                selectChatModels: t => se.selectLanguageModels(e, t ? ? {}),
                                onDidChangeChatModels: (e, t, i) => se.onDidChangeProviders(e, t, i),
                                registerChatModelProvider: (t, i, s) => ((0, q.H5)(e, "chatProvider"), se.registerLanguageModel(e, t, i, s)),
                                get embeddingModels() {
                                    return (0, q.H5)(e, "embeddings"), St.embeddingsModels
                                },
                                onDidChangeEmbeddingModels: (t, i, s) => ((0, q.H5)(e, "embeddings"), St.onDidChange(t, i, s)),
                                registerEmbeddingsProvider: (t, i) => ((0, q.H5)(e, "embeddings"), St.registerEmbeddingsProvider(e, t, i)),
                                computeEmbeddings: async (t, i, s) => ((0, q.H5)(e, "embeddings"), St.computeEmbeddings(t, i, s)),
                                registerTool: (t, i) => ((0, q.H5)(e, "lmTools"), wt.registerTool(e, t, i)),
                                invokeTool: (t, i, s) => ((0, q.H5)(e, "lmTools"), wt.invokeTool(t, i, s)),
                                get tools() {
                                    return (0, q.H5)(e, "lmTools"), wt.tools
                                }
                            },
                            te = {
                                registerSpeechProvider: (t, i) => ((0, q.H5)(e, "speech"), Ct.registerProvider(e.identifier, t, i))
                            };
                        return {
                            version: t.version,
                            ai: Z,
                            authentication: S,
                            commands: T,
                            comments: U,
                            chat: Y,
                            debug: V,
                            env: A,
                            extensions: F,
                            interactive: Q,
                            l10n: J,
                            languages: N,
                            lm: X,
                            notebooks: B,
                            scm: O,
                            speech: te,
                            tasks: W,
                            tests: R,
                            window: M,
                            workspace: L,
                            Breakpoint: b.UoH,
                            TerminalOutputAnchor: b.vvd,
                            ChatResultFeedbackKind: b.u8m,
                            ChatVariableLevel: b.Xfu,
                            ChatCompletionItem: b.uOQ,
                            CallHierarchyIncomingCall: b.MPI,
                            CallHierarchyItem: b.llk,
                            CallHierarchyOutgoingCall: b.RVV,
                            CancellationError: o.FU,
                            CancellationTokenSource: s.AU,
                            CandidatePortSource: x.H_,
                            CodeAction: b.B2n,
                            CodeActionKind: b.yNd,
                            CodeActionTriggerKind: b.CDv,
                            CodeLens: b.JFR,
                            Color: b.Ilk,
                            ColorInformation: b.pr0,
                            ColorPresentation: b.oi2,
                            ColorThemeKind: b.bZY,
                            CommentMode: b._AT,
                            CommentState: b.N$N,
                            CommentThreadCollapsibleState: b.xKz,
                            CommentThreadState: b.OTk,
                            CommentThreadApplicability: b.dql,
                            CompletionItem: b.FGT,
                            CompletionItemKind: b.cmM,
                            CompletionItemTag: b.weh,
                            CompletionList: b.Ub$,
                            CompletionTriggerKind: b.IjA,
                            ConfigurationTarget: b.JDx,
                            CustomExecution: b.mgN,
                            DebugAdapterExecutable: b.FLm,
                            DebugAdapterInlineImplementation: b.yr7,
                            DebugAdapterNamedPipeServer: b.HGt,
                            DebugAdapterServer: b.cZI,
                            DebugConfigurationProviderTriggerKind: zs.j4,
                            DebugConsoleMode: b.lZM,
                            DebugVisualization: b.yzl,
                            DecorationRangeBehavior: b.TED,
                            Diagnostic: b.R9_,
                            DiagnosticRelatedInformation: b.va0,
                            DiagnosticSeverity: b.H_B,
                            DiagnosticTag: b.$uQ,
                            Disposable: b.JTr,
                            DocumentHighlight: b.ehQ,
                            DocumentHighlightKind: b.MYA,
                            MultiDocumentHighlight: b.lMH,
                            DocumentLink: b.jWy,
                            DocumentSymbol: b.w6Q,
                            EndOfLine: b.b6q,
                            EnvironmentVariableMutatorType: b.vGG,
                            EvaluatableExpression: b.hfl,
                            InlineValueText: b.$KE,
                            InlineValueVariableLookup: b.wJF,
                            InlineValueEvaluatableExpression: b.rLr,
                            InlineCompletionTriggerKind: b.bwv,
                            EventEmitter: r.Q5,
                            ExtensionKind: b.TPH,
                            ExtensionMode: b.UCC,
                            ExternalUriOpenerPriority: b.cYW,
                            FileChangeType: b.zR2,
                            FileDecoration: b.unW,
                            FileDecoration2: b.unW,
                            FileSystemError: b.yNx,
                            FileType: g.Tv,
                            FilePermission: g.rM,
                            FoldingRange: b.sof,
                            FoldingRangeKind: b.ADb,
                            FunctionBreakpoint: b.TpX,
                            InlineCompletionItem: b.Coj,
                            InlineCompletionList: b.tfP,
                            Hover: b.TMw,
                            VerboseHover: b.GLX,
                            HoverVerbosityAction: b.bqK,
                            IndentAction: u.wU,
                            Location: b.YeX,
                            MarkdownString: b.W5C,
                            OverviewRulerLane: p.sh,
                            ParameterInformation: b.M$5,
                            PortAutoForwardAction: b.pdQ,
                            Position: b.Lyo,
                            ProcessExecution: b.OLe,
                            ProgressLocation: b.uTI,
                            QuickInputButtons: b.ApZ,
                            Range: b.e6w,
                            RelativePattern: b.sUC,
                            Selection: b.Y19,
                            SelectionRange: b.xm7,
                            SemanticTokens: b.Uzh,
                            SemanticTokensBuilder: b.n2H,
                            SemanticTokensEdit: b.FR$,
                            SemanticTokensEdits: b.JQb,
                            SemanticTokensLegend: b.Pts,
                            ShellExecution: b.yGk,
                            ShellQuoting: b.WBl,
                            SignatureHelp: b.vyX,
                            SignatureHelpTriggerKind: b.WW0,
                            SignatureInformation: b.qIz,
                            SnippetString: b.EG5,
                            SourceBreakpoint: b.TGJ,
                            StandardTokenType: b.xJH,
                            StatusBarAlignment: b.MIn,
                            SymbolInformation: b.JNW,
                            SymbolKind: b.cRn,
                            SymbolTag: b.r4c,
                            Task: b.iQE,
                            TaskGroup: b.p5U,
                            TaskPanelKind: b.e2j,
                            TaskRevealKind: b.FZl,
                            TaskScope: b.qNe,
                            TerminalLink: b.TWf,
                            TerminalQuickFixTerminalCommand: b.t5,
                            TerminalQuickFixOpener: b.QII,
                            TerminalLocation: b.i23,
                            TerminalProfile: b.JCu,
                            TerminalExitReason: b._x0,
                            TerminalShellExecutionCommandLineConfidence: b.I82,
                            TextDocumentSaveReason: b.wDJ,
                            TextEdit: b.PYv,
                            SnippetTextEdit: b.M0$,
                            TextEditorCursorStyle: l.d2,
                            TextEditorLineNumbersStyle: b.lP6,
                            TextEditorRevealType: b._VK,
                            TextEditorSelectionChangeKind: b.dWA,
                            SyntaxTokenType: b.wxO,
                            TextDocumentChangeReason: b.bur,
                            ThemeColor: b.tPk,
                            ThemeIcon: b.kS8,
                            TreeItem: b.kfG,
                            TreeItemCheckboxState: b.KHd,
                            TreeItemCollapsibleState: b.oCf,
                            TypeHierarchyItem: b.fQK,
                            UIKind: js.D$,
                            Uri: d.ov,
                            ViewColumn: b.eIC,
                            WorkspaceEdit: b.DbP,
                            DocumentPasteTriggerKind: b.NqL,
                            DocumentDropEdit: b.DKv,
                            DocumentDropOrPasteEditKind: b.MXZ,
                            DocumentPasteEdit: b.xwm,
                            InlayHint: b.t7_,
                            InlayHintLabelPart: b.qR,
                            InlayHintKind: b.gl,
                            RemoteAuthorityResolverError: b.qaI,
                            ResolvedAuthority: b.sz_,
                            ManagedResolvedAuthority: b.ryi,
                            SourceControlInputBoxValidationType: b.TMt,
                            ExtensionRuntime: b.Usx,
                            TimelineItem: b.jqr,
                            NotebookRange: b.XsU,
                            NotebookCellKind: b.wUy,
                            NotebookCellExecutionState: b.KPz,
                            NotebookCellData: b.Ul,
                            NotebookData: b.c4G,
                            NotebookRendererScript: b.xTW,
                            NotebookCellStatusBarAlignment: b.F3Y,
                            NotebookEditorRevealType: b.Ay,
                            NotebookCellOutput: b.JOq,
                            NotebookCellOutputItem: b.x$B,
                            NotebookCellStatusBarItem: b.sfZ,
                            NotebookControllerAffinity: b.YjK,
                            NotebookControllerAffinity2: b.Hu0,
                            NotebookEdit: b.HCM,
                            NotebookKernelSourceAction: b.acJ,
                            NotebookVariablesRequestKind: b.rbC,
                            PortAttributes: b.AIo,
                            LinkedEditingRanges: b.YED,
                            TestResultState: b.ZMD,
                            TestRunRequest: b.$hL,
                            TestMessage: b.ltp,
                            TestTag: b.LdD,
                            TestRunProfileKind: b.InX,
                            TextSearchCompleteMessageType: qs.a,
                            DataTransfer: b.tnH,
                            DataTransferItem: b.lSh,
                            TestCoverageCount: b.qRu,
                            FileCoverage: b.XuI,
                            FileCoverage2: b.XuI,
                            StatementCoverage: b.xmj,
                            BranchCoverage: b.fyj,
                            DeclarationCoverage: b.dEe,
                            WorkspaceTrustState: b.Y0F,
                            LanguageStatusSeverity: b.Rxm,
                            QuickPickItemKind: b.qlg,
                            InputBoxValidationSeverity: b.S$x,
                            TabInputText: b.Y_o,
                            TabInputTextDiff: b.lF4,
                            TabInputTextMerge: b.kiP,
                            TabInputCustom: b.zwE,
                            TabInputNotebook: b.IAb,
                            TabInputNotebookDiff: b.ogl,
                            TabInputWebview: b.kU2,
                            TabInputTerminal: b.UyC,
                            TabInputInteractiveWindow: b.Ngc,
                            TabInputChat: b.XgO,
                            TabInputTextMultiDiff: b.UwW,
                            TelemetryTrustedValue: y.NE,
                            LogLevel: v.in,
                            EditSessionIdentityMatch: w.i,
                            InteractiveSessionVoteDirection: b.IAe,
                            ChatCopyKind: b.EU7,
                            InteractiveEditorResponseFeedbackKind: b.ySx,
                            DebugStackFrame: b.U07,
                            DebugThread: b.hNq,
                            RelatedInformationType: b.azK,
                            SpeechToTextStatus: b.xJu,
                            TextToSpeechStatus: b.V8w,
                            PartialAcceptTriggerKind: b.NAb,
                            KeywordRecognitionStatus: b.$R,
                            ChatResponseMarkdownPart: b.HYr,
                            ChatResponseFileTreePart: b.Y08,
                            ChatResponseAnchorPart: b.trJ,
                            ChatResponseProgressPart: b.Gli,
                            ChatResponseProgressPart2: b.meY,
                            ChatResponseReferencePart: b.Ht3,
                            ChatResponseWarningPart: b.fkf,
                            ChatResponseTextEditPart: b.cGf,
                            ChatResponseMarkdownWithVulnerabilitiesPart: b.Zgy,
                            ChatResponseCommandButtonPart: b.WTw,
                            ChatResponseDetectedParticipantPart: b.s8P,
                            ChatResponseConfirmationPart: b.Ik8,
                            ChatRequestTurn: b.eg0,
                            ChatResponseTurn: b.IQN,
                            ChatLocation: b.oYl,
                            LanguageModelChatMessageRole: b.grl,
                            LanguageModelChatMessage: b.xf$,
                            LanguageModelChatMessageFunctionResultPart: b.DHf,
                            LanguageModelChatResponseTextPart: b.NEU,
                            LanguageModelChatResponseFunctionUsePart: b._n6,
                            LanguageModelChatMessage2: b.xf$,
                            LanguageModelChatSystemMessage: b.ORh,
                            LanguageModelChatUserMessage: b.Tax,
                            LanguageModelChatAssistantMessage: b.I01,
                            LanguageModelError: b.tHl,
                            NewSymbolName: b.Xdk,
                            NewSymbolNameTag: b.wa0,
                            NewSymbolNameTriggerKind: b.Llw,
                            InlineEdit: b.Cgf,
                            InlineEditTriggerKind: b.rnR
                        }
                    }
            }
            var Js, Gs = i("JKRA"),
                Qs = i("ziTh");
            let Zs = class {
                constructor(e, t, i, s, o, r, n) {
                    this._apiFactory = e, this._extensionRegistry = t, this._instaService = i, this._extHostConfiguration = s, this._extHostExtensionService = o, this._initData = r, this._logService = n, this._factories = new Map, this._alternatives = []
                }
                async install() {
                    this._installInterceptor(), (0, Gs.B)("code/extHost/willWaitForConfig");
                    const e = await this._extHostConfiguration.getConfigProvider();
                    (0, Gs.B)("code/extHost/didWaitForConfig");
                    const t = await this._extHostExtensionService.getExtensionPathIndex();
                    this.register(new Xs(this._apiFactory, t, this._extensionRegistry, e, this._logService)), this.register(this._instaService.createInstance(Ys)), this._initData.remote.isRemote && this.register(this._instaService.createInstance(eo, t, this._initData.environment.appUriScheme))
                }
                register(e) {
                    if ("nodeModuleName" in e)
                        if (Array.isArray(e.nodeModuleName))
                            for (const t of e.nodeModuleName) this._factories.set(t, e);
                        else this._factories.set(e.nodeModuleName, e);
                    "function" == typeof e.alternativeModuleName && this._alternatives.push((t => e.alternativeModuleName(t)))
                }
            };
            Zs = (0, N.g)([(0, N.f)(2, Ds.TG), (0, N.f)(3, ae.E1), (0, N.f)(4, Ke.k2), (0, N.f)(5, nt.$), (0, N.f)(6, _.V)], Zs);
            let Ys = class {
                static {
                    Js = this
                }
                static {
                    this.aliased = new Map([
                        ["vscode-ripgrep", "@vscode/ripgrep"],
                        ["vscode-windows-registry", "@vscode/windows-registry"]
                    ])
                }
                constructor(e) {
                    if (e.environment.appRoot && Js.aliased.size) {
                        const t = (0, Me.ec)(this.forceForwardSlashes(e.environment.appRoot.fsPath)),
                            i = "[a-z0-9_.-]",
                            s = `@${i}+\\/${i}+|${i}+`,
                            o = "node_modules|node_modules\\.asar(?:\\.unpacked)?";
                        this.re = new RegExp(`^(${t}/${o}\\/)(${s})(.*)$`, "i")
                    }
                }
                alternativeModuleName(e) {
                    if (!this.re) return;
                    const t = this.re.exec(this.forceForwardSlashes(e));
                    if (!t) return;
                    const [, i, s, o] = t, r = Js.aliased.get(s);
                    return void 0 !== r ? (Qs.warn(`${s} as been renamed to ${r}, please update your imports`), i + r + o) : void 0
                }
                forceForwardSlashes(e) {
                    return e.replace(/\\/g, "/")
                }
            };
            Ys = Js = (0, N.g)([(0, N.f)(0, nt.$)], Ys);
            class Xs {
                constructor(e, t, i, s, o) {
                    this._apiFactory = e, this._extensionPaths = t, this._extensionRegistry = i, this._configProvider = s, this._logService = o, this.nodeModuleName = "vscode", this._extApiImpl = new m.C1
                }
                load(e, t) {
                    const i = this._extensionPaths.findSubstr(t);
                    if (i) {
                        let e = this._extApiImpl.get(i.identifier);
                        return e || (e = this._apiFactory(i, this._extensionRegistry, this._configProvider), this._extApiImpl.set(i.identifier, e)), e
                    }
                    if (!this._defaultApiImpl) {
                        let e = "";
                        this._extensionPaths.forEach(((t, i) => e += `\t${i} -> ${t.identifier.value}\n`)), this._logService.warn(`Could not identify extension for 'vscode' require call from ${t}. These are the extension path mappings: \n${e}`), this._defaultApiImpl = this._apiFactory(q.nF, this._extensionRegistry, this._configProvider)
                    }
                    return this._defaultApiImpl
                }
            }
            let eo = class {
                constructor(e, t, i) {
                    this._extensionPaths = e, this._appUriScheme = t, this.nodeModuleName = ["open", "opn"], this._mainThreadTelemetry = i.getProxy(x.Tr.MainThreadTelemetry);
                    const s = i.getProxy(x.Tr.MainThreadWindow);
                    this._impl = (e, t) => {
                        const i = d.ov.parse(e);
                        return t ? this.callOriginal(e, t) : "http" === i.scheme || "https" === i.scheme ? s.$openUri(i, e, {
                            allowTunneling: !0
                        }) : "mailto" === i.scheme || i.scheme === this._appUriScheme ? s.$openUri(i, e, {}) : this.callOriginal(e, t)
                    }
                }
                load(e, t, i) {
                    const s = this._extensionPaths.findSubstr(t);
                    return s && (this._extensionId = s.identifier.value, this.sendShimmingTelemetry()), this._original = i(e), this._impl
                }
                callOriginal(e, t) {
                    return this.sendNoForwardTelemetry(), this._original(e, t)
                }
                sendShimmingTelemetry() {
                    this._extensionId && this._mainThreadTelemetry.$publicLog2("shimming.open", {
                        extension: this._extensionId
                    })
                }
                sendNoForwardTelemetry() {
                    this._extensionId && this._mainThreadTelemetry.$publicLog2("shimming.open.call.noForward", {
                        extension: this._extensionId
                    })
                }
            };
            eo = (0, N.g)([(0, N.f)(2, M.O)], eo);
            var to = i("ziTh");
            let io = class {
                constructor(e, t) {
                    this._mainThreadConsole = e.getProxy(x.Tr.MainThreadConsole), this._includeStack = t.consoleForward.includeStack, this._logNative = t.consoleForward.logNative, this._wrapConsoleMethod("info", "log"), this._wrapConsoleMethod("log", "log"), this._wrapConsoleMethod("warn", "warn"), this._wrapConsoleMethod("debug", "debug"), this._wrapConsoleMethod("error", "error")
                }
                _wrapConsoleMethod(e, t) {
                    const i = this,
                        s = to[e];
                    Object.defineProperty(to, e, {
                        set: () => {},
                        get: () => function() {
                            i._handleConsoleCall(e, t, s, arguments)
                        }
                    })
                }
                _handleConsoleCall(e, t, i, s) {
                    this._mainThreadConsole.$logExtensionHostMessage({
                        type: "__$console",
                        severity: t,
                        arguments: oo(s, this._includeStack)
                    }), this._logNative && this._nativeConsoleLogMessage(e, i, s)
                }
            };
            io = (0, N.g)([(0, N.f)(0, M.O), (0, N.f)(1, nt.$)], io);
            const so = 1e5;

            function oo(e, t) {
                const i = [];
                if (e.length)
                    for (let t = 0; t < e.length; t++) {
                        let s = e[t];
                        if (void 0 === s) s = "undefined";
                        else if (s instanceof Error) {
                            const e = s;
                            s = e.stack ? e.stack : e.toString()
                        }
                        i.push(s)
                    }
                if (t) {
                    const e = (new Error).stack;
                    e && i.push({
                        __$stack: e.split("\n").slice(3).join("\n")
                    })
                }
                try {
                    const e = (0, le.or)(i);
                    return e.length > so ? "Output omitted for a large object that exceeds the limits" : e
                } catch (e) {
                    return `Output omitted for an object that cannot be inspected ('${e.toString()}')`
                }
            }
            var ro = i("ziTh");
            let no = class extends io {
                constructor(e, t) {
                    super(e, t)
                }
                _nativeConsoleLogMessage(e, t, i) {
                    t.apply(ro, i)
                }
            };
            no = (0, N.g)([(0, N.f)(0, M.O), (0, N.f)(1, nt.$)], no);
            var ao = i("ziTh");
            class co extends Zs {
                _installInterceptor() {}
                getModule(e, t) {
                    for (const t of this._alternatives) {
                        const i = t(e);
                        if (i) {
                            e = i;
                            break
                        }
                    }
                    if (this._factories.has(e)) return this._factories.get(e).load(e, t, (() => {
                        throw new Error("CANNOT LOAD MODULE from here.")
                    }))
                }
            }
            class lo extends Ke.Qx {
                constructor() {
                    super(...arguments), this.extensionRuntime = b.Usx.Webworker
                }
                async _beforeAlmostReadyToRunExtensions() {
                    qi.n2 && this._instaService.createInstance(no), this._apiFactory = this._instaService.invokeFunction(Ks), this._fakeModules = this._instaService.createInstance(co, this._apiFactory, {
                        mine: this._myRegistry,
                        all: this._globalRegistry
                    }), await this._fakeModules.install(), performance.mark("code/extHost/didInitAPI"), await this._waitForDebuggerAttachment()
                }
                _getEntryPoint(e) {
                    return e.browser
                }
                async _loadCommonJSModule(e, t, i) {
                    var s;
                    t = t.with({
                        path: (s = t.path, ".js", s.endsWith(".js") ? s : s + ".js")
                    });
                    const o = e ? .identifier.value;
                    o && performance.mark(`code/extHost/willFetchExtensionCode/${o}`);
                    const r = d.ov.revive(await this._mainThreadExtensionsProxy.$asBrowserUri(t)),
                        n = await fetch(r.toString(!0));
                    if (o && performance.mark(`code/extHost/didFetchExtensionCode/${o}`), 200 !== n.status) throw new Error(n.statusText);
                    const a = `${await n.text()}\n//# sourceURL=${t.toString(!0)}#vscode-extension`;
                    let c;
                    try {
                        c = new Function("module", "exports", "require", a)
                    } catch (e) {
                        throw o ? ao.error(`Loading code for extension ${o} failed: ${e.message}`) : ao.error(`Loading code failed: ${e.message}`), ao.error(`${t.toString(!0)}${"number"==typeof e.line?` line ${e.line}`:""}${"number"==typeof e.column?` column ${e.column}`:""}`), ao.error(e), e
                    }
                    e && await this._extHostLocalizationService.initializeLocalizedMessages(e);
                    const l = {},
                        h = {
                            exports: l
                        },
                        u = e => {
                            const i = this._fakeModules.getModule(e, t);
                            if (void 0 === i) throw new Error(`Cannot load module '${e}'`);
                            return i
                        };
                    try {
                        return i.codeLoadingStart(), o && performance.mark(`code/extHost/willLoadExtensionCode/${o}`), c(h, l, u), h.exports !== l ? h.exports : l
                    } finally {
                        o && performance.mark(`code/extHost/didLoadExtensionCode/${o}`), i.codeLoadingStop()
                    }
                }
                async $setRemoteEnvironment(e) {}
                async _waitForDebuggerAttachment(e = 5e3) {
                    if (!this._initData.environment.isExtensionDevelopmentDebug) return;
                    const t = Date.now() + e;
                    for (; Date.now() < t && !("__jsDebugIsReady" in globalThis);) await (0, U.Vs)(10)
                }
            }
        }
    }
]);
//# sourceMappingURL=https://hrcdn.net/fcore/assets/sourcemaps/defaultVendors-node_modules_vscode_vscode_src_vs_workbench_api_common_extHost_common_services-6032ab-5673b876.js.map