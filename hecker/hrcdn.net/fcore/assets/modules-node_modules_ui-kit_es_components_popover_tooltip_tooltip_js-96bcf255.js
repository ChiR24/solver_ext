"use strict";
(self.webpackChunkhackerrank_lib = self.webpackChunkhackerrank_lib || []).push([
    ["modules-node_modules_ui-kit_es_components_popover_tooltip_tooltip_js"], {
        pAcs: (e, t, o) => {
            o.d(t, {
                ZP: () => T
            });
            var i = o("+9dH"),
                r = o("PRvr"),
                s = o("L5+t"),
                n = o("DTvD"),
                p = o.n(n),
                a = o("TSYQ"),
                l = o.n(a),
                h = o("dvg7"),
                c = o("37OS"),
                v = o.n(c),
                d = o("N4dn"),
                u = o("sLMI"),
                m = ["target", "coordinate", "align", "showTip", "open", "className", "onClose", "popoverSpace"],
                f = parseInt(10, 10) + parseInt(25, 10) / 2;
            class g extends n.Component {
                constructor(e) {
                    super(e), (0, s.Z)(this, "popoverElement", void 0), (0, s.Z)(this, "popoverWrap", void 0), (0, s.Z)(this, "popoverTip", void 0), (0, s.Z)(this, "getNewAlignment", ((e, t, o) => {
                        var i = ["top", "top-right", "top-left", "right", "left", "bottom", "bottom-right", "bottom-left"],
                            r = 0,
                            s = e,
                            n = i.indexOf(e);
                        0 !== n && (e.indexOf("-right") > 0 || e.indexOf("-left") > 0) ? n -= 1 : n += 1;
                        do {
                            if (++r === i.length) break;
                            s = i[n %= i.length]
                        } while (!this.checkPopoverOverflow(i[n++], t, o));
                        return s
                    })), (0, s.Z)(this, "checkPopoverOverflow", ((e, t, o) => {
                        var {
                            popoverWrapHeight: i,
                            popoverWrapWidth: r
                        } = this.getPopoverDimension(), {
                            left: s,
                            top: n
                        } = this.getPopupCoordinates(e);
                        return s + r > t || n + i > o || n < 0 || s < 0
                    })), (0, s.Z)(this, "getPopupCoordinates", (e => {
                        var t, o, {
                                popoverWrapHeight: i,
                                popoverWrapWidth: r
                            } = this.getPopoverDimension(),
                            {
                                offsetTop: s,
                                offsetLeft: n,
                                offsetWidth: p,
                                offsetHeight: a
                            } = this.getTargetOffsets(),
                            {
                                popoverSpace: l,
                                showTip: h
                            } = this.props,
                            c = h && p < 2 * f ? f - p / 2 : 0;
                        switch (e) {
                            case "top":
                                t = n + p / 2 - r / 2, o = s - i - l;
                                break;
                            case "top-right":
                                t = n + p - r + c, o = s - i - l;
                                break;
                            case "top-left":
                                t = n - c, o = s - i - l;
                                break;
                            case "right":
                                t = n + p + l, o = s + a / 2 - i / 2;
                                break;
                            case "bottom":
                                t = n + p / 2 - r / 2, o = s + a + l;
                                break;
                            case "bottom-right":
                                t = n + p - r + c, o = s + a + l;
                                break;
                            case "bottom-left":
                                t = n - c, o = s + a + l;
                                break;
                            case "left":
                                t = n - r - l, o = s + a / 2 - i / 2;
                                break;
                            default:
                                t = 0, o = 0
                        }
                        return {
                            left: t,
                            top: o
                        }
                    })), (0, s.Z)(this, "positionPopover", (() => {
                        var {
                            popoverWrap: e,
                            popoverTip: t,
                            props: o
                        } = this, {
                            open: i,
                            target: r,
                            align: s,
                            coordinate: n,
                            showTip: p
                        } = o;
                        if (i) {
                            var a, l, {
                                containmentWidth: h,
                                containmentHeight: c
                            } = this.getContainmentDimension();
                            n ? (0, d.BH)(e, n) : r && (this.checkPopoverOverflow(s, h, c) ? (a = this.getNewAlignment(s, h, c), l = this.getPopupCoordinates(a), p && (t.classList.remove("align-tip-".concat(s)), t.classList.add("align-tip-".concat(a))), e.classList.remove("align-popover-".concat(s)), e.classList.add("align-popover-".concat(a))) : l = this.getPopupCoordinates(s), (0, d.BH)(e, {
                                left: "".concat(l.left, "px"),
                                top: "".concat(l.top, "px")
                            }))
                        }
                    })), (0, s.Z)(this, "closePopupOverIframe", (() => {
                        setTimeout((() => {
                            var e;
                            (null === (e = document) || void 0 === e ? void 0 : e.activeElement) instanceof HTMLIFrameElement && this.props.onCloseOverIframeHandler()
                        }), 0)
                    })), this.closePopupOverIframe = this.closePopupOverIframe.bind(this)
                }
                componentDidMount() {
                    this.positionPopover(), window.addEventListener("resize", this.positionPopover), this.props.shouldCloseOverIframes && window.addEventListener("blur", this.closePopupOverIframe)
                }
                shouldComponentUpdate(e) {
                    var {
                        props: t
                    } = this;
                    return e.open !== t.open || e.children !== t.children
                }
                componentDidUpdate() {
                    this.positionPopover()
                }
                componentWillUnmount() {
                    window.removeEventListener("resize", this.positionPopover), this.props.shouldCloseOverIframes && window.removeEventListener("blur", this.closePopupOverIframe)
                }
                getPopoverDimension() {
                    var {
                        offsetWidth: e,
                        offsetHeight: t
                    } = this.popoverWrap;
                    return {
                        popoverWrapHeight: t,
                        popoverWrapWidth: e
                    }
                }
                getContainmentDimension() {
                    return {
                        containmentWidth: window.innerWidth,
                        containmentHeight: document.documentElement.scrollHeight
                    }
                }
                getTargetOffsets() {
                    var {
                        target: e
                    } = this.props, {
                        top: t,
                        left: o
                    } = (0, d.pW)(e), {
                        width: i,
                        height: r
                    } = e.getBoundingClientRect();
                    return {
                        offsetTop: t,
                        offsetLeft: o,
                        offsetWidth: i,
                        offsetHeight: r
                    }
                }
                render() {
                    var e = this.props,
                        {
                            target: t,
                            coordinate: o,
                            align: s,
                            showTip: n,
                            open: a,
                            className: c,
                            onClose: v,
                            popoverSpace: d
                        } = e,
                        f = (0, r.Z)(e, m);
                    return a && (t || o) ? p().createElement(u.Z, null, p().createElement(h.Z, {
                        onClickOutside: v
                    }, p().createElement("div", {
                        className: l()("custom-popover", c),
                        ref: e => {
                            this.popoverElement = e
                        }
                    }, p().createElement("div", (0, i.Z)({
                        ref: e => {
                            this.popoverWrap = e
                        },
                        className: l()("popover-wrap", "align-popover-".concat(s), {
                            "has-tip": n
                        })
                    }, f), p().createElement("div", {
                        className: "content"
                    }, this.props.children), n && p().createElement("div", {
                        ref: e => {
                            this.popoverTip = e
                        },
                        className: l()("tip", "align-tip-".concat(s))
                    }))))) : null
                }
            }(0, s.Z)(g, "defaultProps", {
                align: "top",
                showTip: !0,
                open: !1,
                popoverSpace: 15,
                onClose: v(),
                onCloseOverIframeHandler: v()
            });
            const T = g
        },
        "+XdK": (e, t, o) => {
            o.d(t, {
                ZP: () => T
            }), o("yt8O"), o("rGqo"), o("KKXr");
            var i = o("+9dH"),
                r = o("PRvr"),
                s = o("L5+t"),
                n = o("DTvD"),
                p = o.n(n),
                a = o("TSYQ"),
                l = o.n(a),
                h = o("37OS"),
                c = o.n(h),
                v = o("pAcs"),
                d = o("FLdU"),
                u = o("4zxa"),
                m = ["className", "onTooltipOpen", "onTooltipClose", "delay", "disabled", "id", "aliveTime", "variant", "content"],
                f = (0, d.Z)();
            class g extends n.Component {
                constructor() {
                    var e;
                    super(), e = this, (0, s.Z)(this, "popoverTimeout", void 0), (0, s.Z)(this, "delayTimeout", void 0), (0, s.Z)(this, "clearTimeouts", (() => {
                        this.popoverTimeout && clearTimeout(this.popoverTimeout), this.delayTimeout && clearTimeout(this.delayTimeout)
                    })), (0, s.Z)(this, "setAriaDescribedBy", (() => {
                        var e, t = this.wrapperRef.current.firstChild,
                            o = null !== (e = t.getAttribute("aria-describedby")) && void 0 !== e ? e : "",
                            i = "".concat(o, " ").concat(this.props.id),
                            r = [...new Set(i.split(" "))].join(" ");
                        t.setAttribute("aria-describedby", r)
                    })), (0, s.Z)(this, "onKeydown", (e => {
                        "Escape" === e.key && (this.props.enableKeyEventPropagation || (e.preventDefault(), e.stopPropagation()), this.closePopover(e, !0))
                    })), (0, s.Z)(this, "onAnyPopupOpen", (e => {
                        this.state.target && e !== this.state.target && (this.clearTimeouts(), this.setState({
                            popoverOpen: !1,
                            target: void 0
                        }))
                    })), (0, s.Z)(this, "setPopoverOpen", (e => {
                        var {
                            onTooltipOpen: t
                        } = this.props;
                        this.setState(e, (() => {
                            f.emit("onUITooltipOpen", this.state.target), t()
                        }))
                    })), (0, s.Z)(this, "openPopover", ((e, t) => {
                        var {
                            disabled: o,
                            delay: i
                        } = this.props, {
                            popoverOpen: r
                        } = this.state;
                        if (this.clearTimeouts(), !r && !o) {
                            var s = {
                                popoverOpen: !0
                            };
                            t && (s.target = e.currentTarget), this.delayTimeout = setTimeout((() => this.setPopoverOpen(s)), i)
                        }
                    })), (0, s.Z)(this, "closePopover", (function(t) {
                        var o = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            {
                                onTooltipClose: i,
                                aliveTime: r
                            } = e.props;
                        e.clearTimeouts();
                        var s = o ? 0 : r;
                        e.popoverTimeout = setTimeout((() => {
                            e.setState({
                                popoverOpen: !1,
                                target: void 0
                            }, (() => i()))
                        }), s)
                    })), (0, s.Z)(this, "bindTriggerEvents", (e => {
                        var t = p().Children.only(e),
                            o = e => {
                                var o = "focus" === e.type;
                                this.openPopover(e, !0), o ? t.props.onFocus && t.props.onFocus(e) : t.props.onMouseEnter && t.props.onMouseEnter(e)
                            },
                            i = e => {
                                var o = "blur" === e.type;
                                this.closePopover(e), o ? t.props.onBlur && t.props.onBlur(e) : t.props.onMouseLeave && t.props.onMouseLeave(e)
                            };
                        return p().cloneElement(t, {
                            onFocus: o,
                            onMouseEnter: o,
                            onMouseLeave: i,
                            onBlur: i
                        })
                    })), this.state = {
                        popoverOpen: !1
                    }, this.onMouseEnter = this.openPopover.bind(this, !1), this.wrapperRef = (0, n.createRef)()
                }
                componentDidMount() {
                    f.on("onUITooltipOpen", this.onAnyPopupOpen), document.addEventListener("keydown", this.onKeydown), this.setAriaDescribedBy()
                }
                componentDidUpdate(e) {
                    e.children !== this.props.children && this.setAriaDescribedBy()
                }
                componentWillUnmount() {
                    f.off("onUITooltipOpen", this.onAnyPopupOpen), document.removeEventListener("keydown", this.onKeydown), this.clearTimeouts()
                }
                getTooltipContent() {
                    var {
                        content: e
                    } = this.props;
                    return "function" == typeof e ? e() : e
                }
                renderPopover() {
                    var {
                        props: e,
                        state: t
                    } = this, {
                        className: o,
                        onTooltipOpen: s,
                        onTooltipClose: n,
                        delay: a,
                        disabled: h,
                        id: c,
                        aliveTime: d,
                        variant: u,
                        content: f
                    } = e, g = (0, r.Z)(e, m), {
                        target: T
                    } = t;
                    if (!h) return p().createElement(v.ZP, (0, i.Z)({}, g, {
                        id: c,
                        role: "tooltip",
                        className: l()("ui-tooltip", o, {
                            light: "light" === u
                        }),
                        open: !0,
                        onMouseEnter: this.onMouseEnter,
                        onMouseLeave: this.closePopover,
                        target: T
                    }), this.getTooltipContent())
                }
                render() {
                    var {
                        popoverOpen: e
                    } = this.state, {
                        children: t
                    } = this.props, o = this.bindTriggerEvents(t);
                    return p().createElement(n.Fragment, null, p().createElement("div", {
                        className: "ui-tooltip-wrapper",
                        ref: this.wrapperRef
                    }, o), e && this.renderPopover())
                }
            }(0, s.Z)(g, "defaultProps", {
                aliveTime: 300,
                onTooltipOpen: c(),
                onTooltipClose: c(),
                disabled: !1,
                variant: "dark",
                delay: 0,
                enableKeyEventPropagation: !1
            });
            const T = (0, u.xD)("tooltip")(g)
        }
    }
]);
//# sourceMappingURL=https://hrcdn.net/fcore/assets/sourcemaps/modules-node_modules_ui-kit_es_components_popover_tooltip_tooltip_js-96bcf255.js.map